<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编译原理: 语法分析</title>
    <url>/blogs/2025/12/03/compilers-syntax/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="语法分析">语法分析</h1>
<h2 id="文法分类">文法分类</h2>
<ul>
<li><code>0</code>型文法：又称短语文法</li>
<li><code>1</code>型文法：又称上下文有关文法</li>
<li><code>2</code>型文法：又称上下文无关文法</li>
<li><code>3</code>型文法：又称正则表达式</li>
</ul>
<h2 id="上下文无关文法">上下文无关文法</h2>
<ul>
<li><p>结构：<span
class="math inline">(<em>V</em><sub><em>T</em></sub>,<em>V</em><sub><em>N</em></sub>,<em>S</em>,<em>P</em>)</span>，其中<span
class="math inline"><em>V</em><sub><em>T</em></sub></span>是终结符集合，<span
class="math inline"><em>V</em><sub><em>N</em></sub></span>是非终结符集合，<span
class="math inline"><em>S</em></span>是开始符号，<span
class="math inline"><em>P</em></span>是产生式集合</p></li>
<li><p>上下文无关文法允许产生式右部出现所有在产生式左部出现的非终结符</p></li>
<li><p>推导：</p>
<ul>
<li>最左推导：每次展开都展开最左边的非终结符</li>
<li>最右推导(规范推导)：每次展开都展开最右边的非终结符</li>
</ul></li>
<li><p>分析树：推导的树型表示</p></li>
<li><p>二义性：存在多种推导的可能结果，例如产生式集合<span
class="math inline"><em>E</em> → <em>E</em> + <em>E</em>|<em>E</em> × <em>E</em></span></p>
<ul>
<li><p>消除二义性：通过引入中间非终结符解决：</p>
<p><span class="math display">$$
\begin{align}
&amp;E\rightarrow E+T
\\&amp;T\rightarrow T\times T
\end{align}
$$</span></p></li>
<li><p>一般，优先级高的运算，其产生式应该离根更远</p></li>
</ul></li>
<li><p>消除左递归：在递归下降分析程序里，由于程序无法看到后续的记号，因此如果存在左递归会存在一个函数递归调用自身而不继续解析的问题</p>
<ul>
<li><p>消除直接左递归：<span
class="math inline"><em>A</em> → <em>A</em><em>α</em>|<em>β</em></span></p>
<p><span class="math display">$$
\begin{align}
&amp;A\rightarrow \beta A'
\\&amp;A'\rightarrow \alpha A'|\epsilon
\end{align}
$$</span></p></li>
<li><p>消除间接左递归：<span
class="math inline">$\begin{cases}A\rightarrow
B\alpha|\beta\\B\rightarrow A\gamma|\epsilon\end{cases}$</span></p>
<p>实际上可以先转化为直接左递归：</p>
<p><span class="math display">$$
\begin{cases}A\rightarrow B\alpha|\beta\\B\rightarrow
B\alpha\gamma|\beta\gamma|\epsilon\end{cases}
$$</span></p></li>
</ul></li>
<li><p>提取公共左因子：存在公共左因子会使程序不知道应该选择哪个，如果定死顺序则很可能出现错误分析</p>
<p>提取公共左因子非常简单，只需要添加中间的非终结符即可：</p>
<p><span class="math display">$$
\begin{align}
&amp;A\rightarrow \alpha A|\alpha B
\\\\&amp;A\rightarrow \alpha C
\\&amp;C\rightarrow A|B
\end{align}
$$</span></p></li>
</ul>
<h2 id="分析法">分析法</h2>
<h3 id="自上而下分析ll1">自上而下分析<code>LL(1)</code></h3>
<ul>
<li><code>LL(1)</code>要求产生式集合没有二义性、没有左递归、没有公共左因子</li>
<li>求<code>first</code>集合：
<ul>
<li>终结符的<code>first</code>集合只有一个元素：它本身</li>
<li>非终结符的<code>first</code>集合：
<ul>
<li>先找到所有形如<span
class="math inline"><em>S</em> → <em>a</em><em>α</em>…</span>的产生式，其右部的开始符号是终结符</li>
<li>再找到所有形如<span
class="math inline"><em>S</em> → <em>A</em><em>α</em>…</span>的产生式，其右部的开始符号是非终结符，将<span
class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>A</em>) − <em>ϵ</em></span>加入<span
class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>S</em>)</span></li>
<li>如果在第二步，<span
class="math inline"><em>ϵ</em> ∈ <em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>A</em>)</span>，那么使<span
class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>α</em>) − <em>ϵ</em></span>加入<span
class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>S</em>)</span>，继续本步骤</li>
<li>如果在第三步，遍历到最后的符号且最后的符号的<code>first</code>集包含<span
class="math inline"><em>ϵ</em></span>，那么将<span
class="math inline"><em>ϵ</em></span>加入<span
class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>S</em>)</span></li>
</ul></li>
</ul></li>
<li>求<code>follow</code>集合：<code>follow</code>集合不包含<span
class="math inline"><em>ϵ</em></span>
<ul>
<li>将<code>$</code>加入开始符号的<code>follow</code>集合里</li>
<li>对所有<span
class="math inline"><em>A</em> → <em>α</em><em>B</em><em>β</em></span>，将<span
class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>β</em>) − <em>ϵ</em></span>加入<span
class="math inline"><em>f</em><em>o</em><em>l</em><em>l</em><em>o</em><em>w</em>(<em>B</em>)</span></li>
<li>对所有<span
class="math inline"><em>A</em> → <em>α</em><em>B</em></span>或<span
class="math inline"><em>A</em> → <em>α</em><em>B</em><em>β</em></span>且<span
class="math inline"><em>ϵ</em> ∈ <em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>β</em>)</span>，则将<span
class="math inline"><em>f</em><em>o</em><em>l</em><em>l</em><em>o</em><em>w</em>(<em>A</em>)</span>加入<span
class="math inline"><em>f</em><em>o</em><em>l</em><em>l</em><em>o</em><em>w</em>(<em>B</em>)</span></li>
</ul></li>
<li>非递归的下降分析：要求构建分析表，则程序分析时不递归而是查找分析表找到对应的产生式
<ul>
<li>行名为(栈顶的)非终结符，列名为输入符号，表格项为产生式</li>
<li>对每个<span
class="math inline"><em>A</em> → <em>α</em></span>，对<span
class="math inline">∀<em>a</em> ∈ <em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>α</em>)</span>且<span
class="math inline"><em>a</em> ≠ <em>ϵ</em></span>，使<span
class="math inline"><em>M</em>(<em>A</em>,<em>a</em>)</span>为这个产生式</li>
<li>对每个<span
class="math inline"><em>A</em> → <em>α</em></span>，若<span
class="math inline"><em>ϵ</em> ∈ <em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>α</em>)</span>，则对<span
class="math inline">∀<em>a</em> ∈ <em>f</em><em>o</em><em>l</em><em>l</em><em>o</em><em>w</em>(<em>A</em>)</span>使<span
class="math inline"><em>M</em>(<em>A</em>,<em>a</em>)</span>为这个产生式</li>
<li>若运行时遇到表格项为空，说明程序分析出错</li>
<li>若遇到一个表格项包含多个产生式，说明不是<code>LL(1)</code>文法</li>
</ul></li>
<li>错误恢复：
<ul>
<li>词法错误</li>
<li>语法错误</li>
<li>语义错误</li>
<li>逻辑错误</li>
</ul></li>
<li>同步选择集合：</li>
</ul>
<h3 id="自下而上分析">自下而上分析</h3>
<ul>
<li>句柄：和某个产生式右部一致的串</li>
<li>移进归约分析：
<ul>
<li>移进：将下一个符号入栈</li>
<li>归约：将栈顶的整个句柄用对应的产生式归约，用产生式的左部替换这个句柄</li>
<li>接受：到达目标串的结尾且分析表未出错</li>
<li>错误：分析表到达了空表项</li>
</ul></li>
<li>移进归约冲突：栈顶的句柄可以继续移进，也可以归约的时候</li>
<li>归约归约冲突：栈顶可以有多种归约可能情况</li>
<li><code>LR(0)</code>(<code>Left-to-right, Rightmost derivation, 0 lookahead</code>)：非常容易产生移进归约冲突和归约归约冲突
<ul>
<li>项目：一个产生式的右部的符号中间添加<code>·</code>符号</li>
<li>项目集规范族：
<ul>
<li>引入增广文法（添加产生式<span
class="math inline"><em>E</em>′ → <em>E</em></span>指向开始符号）</li>
<li>对扩展文法新增的产生式求<span
class="math inline"><em>E</em>′ →  · <em>E</em></span>闭包，即只要<code>·</code>后是非终结符则要把这个非终结符为左部的所有产生式加入闭包，递归进行此步骤</li>
<li>对上述闭包可以移进的所有符号，进行移进得到新的项目集</li>
<li>重复第二步和第三步直到构建出<code>DFA</code></li>
</ul></li>
<li>从<code>DFA</code>构建<code>LR(0)</code>分析表：
<ul>
<li>对<code>Ix-&gt;Iy</code>出边为终结符<code>a</code>的情况：<code>ACTION[Ix, a]=sy</code></li>
<li>对<code>Ix-&gt;Iy</code>出边为非终结符<code>A</code>的情况：<code>GOTO[Ix, A]=y</code></li>
<li>对<code>Ix</code>能够归约的项目(产生式编号为<code>y</code>，产生式左部为<code>A</code>)：对所有终结符<code>a</code>，使<code>ACTION[Ix, a]=ry</code></li>
<li>对归约项目为增广文法新增的产生式，使表项为<code>acc</code></li>
<li>使其余所有表项为<code>error</code></li>
</ul></li>
<li>使用<code>LR(0)</code>分析表对输入进行语法分析：
<ul>
<li>初始状态栈只有一个元素：<code>I0</code></li>
<li>设当前状态为<code>Ix</code>，输入符号为<code>a</code>，查询<code>ACTION[Ix, a]</code>：
<ul>
<li>若为<code>sy</code>，则状态变为<code>Iy</code>，输入后移，<code>Iy</code>入栈</li>
<li>若为<code>ry</code>，第<code>y</code>个产生式为<span
class="math inline"><em>A</em> → <em>α</em></span>，则从状态栈出栈，设出栈后栈顶状态为<code>Iz</code>则状态变为<code>GOTO[Iz, A]</code></li>
<li>若为<code>error</code>，则进入错误恢复程序</li>
<li>若为<code>acc</code>，表示接受输入，语法分析成功</li>
</ul></li>
</ul></li>
</ul></li>
<li><code>SLR</code>分析表(<code>SLR(1)</code>)：与<code>LR(0)</code>对比，引入了<code>follow</code>集合，对<code>Ix</code>能够归约的项目(产生式编号为<code>y</code>，产生式左部为<code>A</code>)：对所有<code>a</code>属于<code>follow(A)</code>，使<code>ACTION[x, a]=ry</code></li>
<li><code>LR(1)</code>分析表：
<ul>
<li><code>SLR(1)</code>分析仍然会出现移进归约冲突</li>
<li><code>LR(1)</code>分析对项目进行修改：使其带搜索符，例如<span
class="math inline"><em>A</em> →  · <em>α</em>, <em>a</em></span></li>
<li>项目集规范族：
<ul>
<li>增广文法产生的项目为<span
class="math inline"><em>E</em>′ →  · <em>α</em>, $</span></li>
<li>同样对扩展文法新增的产生式求<span
class="math inline"><em>A</em>′ →  · <em>B</em><em>α</em>, <em>a</em></span>闭包，即只要<code>·</code>后是非终结符则要把这个非终结符为左部的所有产生式加入闭包，递归进行此步骤，其中它们的搜索符是<span
class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em>(<em>α</em><em>a</em>)</span></li>
</ul></li>
<li>生成分析表的过程和<code>LR(0)</code>的区别是：只对搜索符对应的表项设置为可归约项</li>
</ul></li>
<li><code>LALR</code>分析表：<code>LALR</code>在<code>LR(1)</code>的基础上，将略去搜索符后一致的项目族合并，因此和<code>SLR</code>拥有相似数量的项目族，但<code>LALR</code>可能出现归约归约冲突</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Compilers</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理: 词法分析</title>
    <url>/blogs/2025/12/02/compilers-lexical/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="词法分析">词法分析</h1>
<h2 id="编译过程">编译过程</h2>
<ul>
<li>编译器分为前端和后端，前端包括词法分析、语法分析、语义分析、生成中间代码，后端包括代码优化、最终代码生成，在过程中借助符号表管理器和错误管理器</li>
<li>通过中间代码划分前端和后端，不需要针对每一门语言都完整设计一个编译器</li>
<li>遍：</li>
<li>翻译器：将一门语言翻译成另一门语言的软件</li>
<li>编译器：将一门高级语言翻译成一门低级语言的软件</li>
<li>解释器：</li>
<li>即时编译：</li>
</ul>
<h2 id="词法分析过程">词法分析过程</h2>
<ul>
<li>词法分析的目标是把源文件这一串符号流转换成记号流</li>
<li>词法单元：源文件这一串字符串</li>
<li>词法记号：满足一定规则的词法单元</li>
<li>字母表：符号的集合</li>
<li>串：符号组成的序列</li>
<li>语言：字母表上某些串的集合，包括空串、空集</li>
<li>句子：语言的一个元素</li>
<li>语言的运算及正则表达式：详见<a href="./regex.md">Regex</a></li>
</ul>
<h2 id="自动机">自动机</h2>
<h3 id="不确定的有限自动机nfa">不确定的有限自动机(<code>NFA</code>)</h3>
<ul>
<li>允许出边的条件为空串</li>
<li>允许有具有相同条件的出边</li>
<li>由正则表达式生成<code>NFA</code>：
<ul>
<li>或运算<code>x s|t y</code>：在<code>x</code>后添加两条空串的出边，在<code>y</code>前添加两条空串的入边，分别指向<code>s</code>和<code>t</code></li>
<li>与运算<code>x st y</code>：使<code>s</code>的出节点和<code>t</code>的入节点重合</li>
<li>闭包<span
class="math inline"><em>x</em><em>s</em><sup>*</sup><em>y</em></span>：使<code>x</code>通过空串既指向<code>s</code>又指向<code>y</code>，使<code>s</code>的出节点通过空串指向入节点</li>
</ul></li>
<li>由语言生成<code>NFA</code>：脑补所有可能结束的状态，由初始状态遍历字母表迭代计算</li>
</ul>
<h3 id="确定的有限自动机dfa">确定的有限自动机(<code>DFA</code>)</h3>
<ul>
<li>由<code>NFA</code>生成`：子集构造法
<ul>
<li>从初始状态开始，求出闭包（经过空串能得到的所有状态）</li>
<li>遍历每一个字母表的元素，计算上述闭包经过该元素能得到的集合，并求出新集合的闭包</li>
<li>重复第二个步骤，直到没有任何新增的闭包</li>
</ul></li>
<li>化简<code>DFA</code>：
<ul>
<li>死状态：如果存在一个字母表中的元素，有一个状态没有对应的出边，那么需要使他指向死状态，死状态的所有出边都指向它自己，相当于出错时直接跳过当前词法单元</li>
<li>执行类似由<code>NFA</code>转化的步骤，但是将不可区分的状态合成为一个状态</li>
</ul></li>
</ul>
<h3 id="词法分析器的生成器">词法分析器的生成器</h3>
<ul>
<li><code>lex</code>和<code>flex</code>：使用嵌入了<code>c/cpp</code>的脚本语言，将脚本语言翻译成一般<code>c</code>程序</li>
<li>语法：
<ul>
<li><p>声明语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%</span><br><span class="line">int cnt = 0; </span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分隔符：<code>%%</code></p></li>
<li><p>入口：<code>yylex()</code>，每次调用都会解析直到在匹配规则里<code>return</code>或分析到字符串结尾，若中途返回则下次调用从返回处继续分析</p></li>
<li><p><code>yytext</code>：匹配成功，得到的完整的词法单元</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Compilers</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: 无监督学习</title>
    <url>/blogs/2025/11/28/stat-unsupervise-learning/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="无监督学习">无监督学习</h1>
<h2 id="主成分分析">主成分分析</h2>
<ul>
<li>主成分分析和主成分回归的第一步很像，使样本矩阵乘上载荷矩阵，载荷矩阵是<span
class="math inline"><em>p</em> × <em>M</em></span>的矩阵，使共<span
class="math inline"><em>p</em></span>个特征降维为<span
class="math inline"><em>M</em></span>个特征，只不过无法通过交叉验证估计测试误差，也无法选择<span
class="math inline"><em>M</em></span></li>
<li>主成分分析必须<strong>对载荷矩阵进行对标准化</strong>，中心化可选</li>
</ul>
<h2 id="聚类分析">聚类分析</h2>
<h3 id="k均值聚类"><code>K</code>均值聚类</h3>
<ul>
<li><code>PCA</code>的本质是降维，保留使得方差大的方向(数据投影到该方向上，能占据较宽的范围)，证明这个方向很接近数据分布的方向，从而实现去噪声</li>
<li>而<code>K</code>均值聚类则是在<code>PCA</code>的基础上做聚类任务，<code>K</code>均值聚类事先规定了<code>K</code>，而系统聚类通过人工分析得到最终的类别数</li>
<li><code>K</code>均值聚类希望<strong>类内差异尽可能小</strong>，度量类内差异通常有：
<ul>
<li>平方欧氏距离：<em>{i,jC_k}||x</em>{i}x_j||^2</li>
</ul></li>
<li><code>K</code>均值聚类的步骤：事先定义<code>K</code>个类中心，每次迭代使一个样本分类到距离其最近的类中心所代表的类里，然后重新根据类内差异计算类中心，直到所有点所属的类都不再变化</li>
</ul>
<h3 id="系统聚类">系统聚类</h3>
<ul>
<li>凝聚法(自下而上)：每次迭代选出两类合并为一类(初始每个样本独自为一类)</li>
<li>选择合并双方的评判方法有：
<ul>
<li>最长距离法：选取最大差异度最小的两类</li>
<li>最短距离法：选取最小差异度最小的两类</li>
<li>重心法：选取两类的重心(所有样本点各个特征的平均值为重心的各个特征值)距离最小的两类(会发生颠倒现象)</li>
<li>类平均法：选取平均差异度最小的两类</li>
</ul></li>
<li>差异度的评判方法：
<ul>
<li>欧氏距离</li>
<li>基于相关性的距离</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: SVM（支持向量机）</title>
    <url>/blogs/2025/11/27/stat-svm/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="支持向量机">支持向量机</h1>
<h2 id="超平面">超平面</h2>
<ul>
<li>超平面就是一个式子，<span
class="math inline"><em>β</em><sub>0</sub> + <em>β</em><sub>1</sub><em>x</em><sub>1</sub> + … + <em>β</em><sub><em>p</em></sub><em>x</em><sub><em>p</em></sub> = 0</span></li>
<li>分割超平面：如果超平面两边(<span
class="math inline"> &gt; 0<em>或</em> &lt; 0</span>)刚好划分了两类样本，则为分割超平面</li>
<li>最大间隔分类器：
<ul>
<li>间隔：所有样本点到分割超平面的距离的<strong>最小值</strong></li>
<li>最大间隔分类器：使所有样本点的间隔最大的分割超平面</li>
</ul></li>
</ul>
<h2 id="支持向量分类器">支持向量分类器</h2>
<ul>
<li>支持向量分类器：又称软间隔分类器，它和分割超平面不同，允许有间隔错误和超平面错误
<ul>
<li>间隔错误：在间隔内部以及分类错误的样本点</li>
<li>超平面错误：分类错误的样本点，是间隔错误的子集</li>
<li>支持向量：落在间隔上或者间隔错误的样本点个数就是支持向量的个数</li>
</ul></li>
</ul>
<h2 id="核函数和支持向量机">核函数和支持向量机</h2>
<ul>
<li>事实上，超平面可以改写成<span
class="math inline"><em>f</em>(<em>x</em>) = <em>β</em><sub>0</sub> + ∑<sub><em>i</em> ∈ <em>S</em></sub><em>α̂</em><sub><em>i</em></sub> &lt; <em>x</em>, <em>x</em><sub><em>i</em></sub>&gt;</span>，其中<span
class="math inline"> &lt; <em>x</em>, <em>x</em><sub><em>i</em></sub>&gt;</span>为它们的内积</li>
<li>而这个内积可以改为其它函数，称为核函数，基于不同核函数的分类器统称为支持向量机
<ul>
<li>线性核函数：支持向量分类器所用的核函数</li>
<li>多项式核函数：可以生成光滑决策边界</li>
<li>径向基核函数：</li>
</ul></li>
<li>当类别可分时，支持向量机和<code>LDA</code>做的比逻辑斯蒂回归更好</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>Rlang: 虽然不知道为什么要学</title>
    <url>/blogs/2025/11/26/Rlang-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="统计学习">统计学习</h1>
<h2 id="线性回归">线性回归</h2>
<h3 id="stats包"><code>stats</code>包</h3>
<ul>
<li><code>c(...)</code>：使参数拼接为一个向量</li>
<li><code>sample(tot, sz)</code>：生成一组索引，从<code>tot</code>个样本中随机采样<code>sz</code>个样本</li>
<li><code>poly(x, k, raw, ...)</code>：生成关于<code>x</code>的<code>k</code>阶多项式，<code>raw</code>布尔值表示<code>TRUE</code>(正交多项式)、<code>FALSE</code>(原始多项式)，正交多项式的每一项是原始多项式(<span
class="math inline"><em>x</em><sup><em>i</em></sup></span>)的线性组合</li>
<li><code>lm()</code>：
<ul>
<li><code>formula</code>：模型公式，例如<code>y ~ x1 + x2</code>
<ul>
<li><code>+</code>：线性相加</li>
<li><code>.</code>：通配符，包括所有变量的<code>+</code></li>
<li><code>-</code>：去除变量，通常配合<code>.</code></li>
<li><code>:</code>：交互项</li>
<li><code>*</code>：表示包含两者以及两者的交互项，例如<code>x1*x2</code>等价于<code>x1+x2+x1:x2</code></li>
<li><code>0</code>或<code>-1</code>：表示去除截距项</li>
<li><code>I(x^k)</code>：多项式项(<code>k</code>次幂)</li>
</ul></li>
<li><code>data</code>：所用的数据，必须包含<code>formula</code>中使用的变量</li>
<li><code>subset</code>：逻辑表达式或者索引，在训练前先作用于<code>data</code></li>
</ul></li>
<li><code>glm()</code>：广义线性模型，相比<code>lm()</code>添加了<code>family</code>参数
<ul>
<li><code>gaussian</code>：默认值，进行线性拟合</li>
<li><code>binomial</code>：逻辑回归</li>
</ul></li>
<li><code>summary(model)</code>：获取模型的总结，包括系数、标准差、<span
class="math inline"><em>t</em></span>值、<span
class="math inline"><em>t</em></span>假设检验的<code>p</code>值、<span
class="math inline"><em>R</em><em>S</em><em>E</em></span>、<span
class="math inline"><em>R</em><sup>2</sup></span>(<code>adj</code>表示加了惩罚项)、<span
class="math inline"><em>F</em></span>统计量、<span
class="math inline"><em>F</em></span>假设检验的<code>p</code>值
<ul>
<li>逻辑回归的总结还包括零模型偏差和完整模型偏差，以及<code>AIC</code>估计</li>
</ul></li>
<li><code>coef(model)</code>：返回更少的内容，只返回系数的估计值</li>
<li><code>anova(models...)</code>：通过方差分析，判断更复杂的模型新增的变量是否有显著影响</li>
<li><code>predict(model, data, interval, level, type)</code>：使用模型进行预测
<ul>
<li><code>data</code>：待预测的数据</li>
<li><code>interval</code>：指定预测区间还是置信区间，可选<code>confidence</code>、<code>prediction</code>，默认为<code>none</code>(点估计)</li>
<li><code>level</code>：指定置信水平，默认<code>0.95</code></li>
<li><code>type</code>：指定预测类型，可选<code>response</code>、<code>link</code>，指定为<code>response</code>来获得响应值，因为默认的<code>link</code>难以解释</li>
</ul></li>
<li><code>which.min(vec)</code>：求出最小值对应的下标，<code>max()</code>类似</li>
</ul>
<h2 id="可视化">可视化</h2>
<ul>
<li><code>plot(x, y)</code>：绘制散点图</li>
<li><code>abline(model)</code>：绘制模型的最小二乘线</li>
</ul>
<h2 id="mass现代应用统计学"><code>MASS</code>(现代应用统计学)</h2>
<ul>
<li><code>lda()</code>：线性判别分析</li>
<li><code>qda()</code>：二次判别分析</li>
</ul>
<h2 id="boot"><code>boot</code></h2>
<ul>
<li><code>cv.glm(data, glmfit, K, cost)</code>：对<code>glm()</code>的模型进行<code>k</code>折交叉验证，返回值的<code>delta</code>列的第一项是标准的交叉验证估计值(<code>res$delta[1]</code>)</li>
<li><code>boot(data, statistic, R, ...)</code>：自助法估计指定<code>statistic</code>统计量的某个指标
<ul>
<li><p><code>data</code>：原始数据集</p></li>
<li><p><code>statistic(data, indices)</code>：自定义函数，在里面指定模型、返回感兴趣的统计指标，例如：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span><span class="punctuation">(</span>data<span class="punctuation">,</span> indices<span class="punctuation">)</span></span><br><span class="line">   d <span class="operator">&lt;-</span> data<span class="punctuation">[</span><span class="punctuation">,</span> indices<span class="punctuation">]</span>        <span class="comment"># indices是boot()提供的索引组</span></span><br><span class="line">   model <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> data<span class="operator">=</span>d<span class="punctuation">)</span></span><br><span class="line">   pred <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>model<span class="punctuation">,</span> d<span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br><span class="line">   <span class="built_in">return</span> mean<span class="punctuation">(</span>pred <span class="operator">==</span> d<span class="operator">$</span>Y<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="leaps"><code>leaps</code></h2>
<ul>
<li><code>regsubsets(y ~ ., data, method, nvmax, ...)</code>：默认为最优子集法，<code>method</code>可选<code>forward</code>和<code>backward</code>
<ul>
<li><code>summary()</code>可返回<code>rsq, rss, bic, adjr2, cp</code>统计量</li>
</ul></li>
</ul>
<h2 id="glmnet"><code>glmnet</code></h2>
<ul>
<li><code>glmnet()</code>相比<code>glm()</code>新增了<code>alpha</code>和<code>lambda</code>参数，<code>alpha=0</code>表示岭回归(默认值)，<code>alpha=1</code>表示<code>Lasso</code>回归，<code>lambda</code>为惩罚系数，可以通过交叉验证求得</li>
<li>一般通过<code>predict()</code>使<code>type="coeficcients"</code>获取系数，因为使用压缩估计的目的是变量选择，所以不使用<code>summary()</code></li>
<li>使用<code>cv.glmnet()</code>来选择超参数<code>lambda</code>，它会在内部自动调用<code>glmnet()</code></li>
</ul>
<h2 id="pls"><code>pls</code></h2>
<ul>
<li><code>pcr()</code>：<code>scale</code>参数</li>
<li><code>validationplot()</code></li>
<li><code>plsr()</code>：偏最小二乘回归</li>
<li><code>scale=TRUE</code>参数表示标准化，<code>validation="cv"</code>表示使用交叉验证来估计测试误差</li>
</ul>
<h2 id="非线性模型">非线性模型</h2>
<ul>
<li>通过<code>cut(x, sz)</code>划分变量范围，来拟合阶梯函数</li>
</ul>
<h2 id="splines"><code>splines</code></h2>
<ul>
<li><code>bs()</code>表示样条函数，默认为三次样条</li>
<li><code>smooth.spline()</code>：光滑样条</li>
<li><code>loess()</code>：局部回归</li>
</ul>
<h2 id="gam"><code>gam</code></h2>
<ul>
<li><code>gam()</code>：广义可加模型</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Rlang</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>stat</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch: 使用torch.utils.data封装数据</title>
    <url>/blogs/2025/11/26/pytorch-dataprocess/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="数据集集成框架">数据集集成框架</h3>
<ul>
<li><p>数据的流向：先将数据交给自定义的数据集类(其任务为对源数据预处理，包装成数据加载器能够访问的数据集)，通常转化为张量
通过数据加载类进行采样并送给模型计算并优化(其任务为根据默认或自定义的采样器<code>Sampler</code>进行真正的采样)</p></li>
<li><p><code>map-style</code>和<code>iterable-style</code>：索引式数据集和迭代式数据集</p>
<ul>
<li>索引式数据集的做法是将整个数据集读取到内存，采样的时候通过<code>[]</code>访问即可
适用于批量读取、小数据集，由于数据均在内存中，往往更快</li>
<li>迭代式数据集的做法是事先定义迭代的行为，采样的时候从硬盘中取出数据并作为迭代器返回
适用于各种数据无法事先全部读入内存的情况(例如训练过程中会产生新样本、或内存过小)，当然是比较慢的</li>
</ul></li>
<li><p><code>torch.utils.data.Dataset</code>(简称<code>Dataset</code>)是所有<strong>数据集类型的基类</strong>，用户如果需要构建自己的索引式数据集，必须直接继承该类并重载以下方法(其实就是封装成一个索引式数据集)：</p>
<ul>
<li><code>__len__()</code>：应返回数据集的长度，以便可以用<code>len(obj)</code>访问数据集长度</li>
<li><code>__getitem__(idx)</code>：应返回该索引指向的数据，以便可以用<code>[]</code>访问数据</li>
</ul></li>
<li><p><code>torch.utils.data.IterableDataset</code>(简称<code>IterableDataset</code>)是所有<strong>迭代式数据集的基类</strong>，继承该类后必须重载：</p>
<ul>
<li><code>__iter__()</code>：<code>yield</code>一个迭代器，一般是在方法内临时读取文件并返回一条数据</li>
</ul></li>
<li><p><code>torch.utils.data.DataLoader</code>(简称<code>DataLoader</code>)是<strong>数据集对象的迭代器</strong>，相比诸多语言的内置迭代器封装了很多功能，不需要手动实现乱序、分批读取等，加载数据集十分方便，其构造方法<code>__init__()</code>参数用法为：</p>
<ul>
<li><code>dataset</code>：<code>Dataset</code>(或子类)对象，表示要遍历的数据集</li>
<li><strong><code>batch_size</code></strong>：批数据的大小，即通过该迭代器遍历时返回的<strong>样本个数</strong>；将其设置为<code>None</code>以关闭自动批处理</li>
<li><code>sampler</code>：可以<strong>指定采样器进行更多样的采样行为</strong></li>
<li><code>batch_sampler</code>：类似<code>sampler</code>，但要求用户提供的采样器必须<strong>返回一批张量的索引</strong>而不是一个张量的索引，这一批张量均用用户提供的<code>Sampler</code>对象来采样，它和<code>sampler、batch_size</code>是冲突的(因为认为用户已经在<code>sampler</code>里定义了批量大小)</li>
<li><strong><code>shuffle</code></strong>：布尔值，决定<strong>是否乱序采样</strong>，和<code>sampler、batch_sampler</code>冲突(因为要使用默认的<code>RandomSampler</code>)，没有更高需求的采样行为而懒得自定义采样器时，使<code>shuffle=True</code>就足够了</li>
</ul>
<p>只提供<code>dataset</code>，其它参数保持默认下，迭代器会顺序地进行批量为一的自动批处理采样
<img src="DataLoader_init.png" alt="DataLoader_init" style="zoom:40%;" />
其它不常用的参数：</p>
<ul>
<li><code>num_workers</code>：将数据分给多个子进程加载，默认只用主进程加载</li>
<li><code>collate_fn</code>：是一个可调用对象，表示对数据集采样后，返回给用户前进行的行为
默认的<code>collate_fn</code>常在一个开启了自动批处理的索引式数据集中用到，会<strong>将采样的数据合并为一批</strong>
因为迭代式数据集的批量采样等行为通常是由用户在<code>__iter__()</code>中实现的，所以对迭代式数据集不会提供默认的<code>collate_fn</code>
用户可以自定义<code>collate_fn</code></li>
<li><code>pin_memory</code>：由于<code>GPU</code>中的内存全是锁页内存，但<code>CPU</code>中一般只是不锁页内存(即会被交换到虚存中)，设置<code>pin_memory=True</code>，将使读入的样本变成锁页内存，通过<strong>消耗<code>CPU</code>内存的方式加快其载入<code>GPU</code>的过程</strong></li>
<li><code>drop_last</code>：布尔值，表示是否丢弃最后一个不完整的批次</li>
<li><code>timeout</code>：表示数据加载的时限</li>
</ul></li>
<li><p><code>torch.utils.data.Sampler</code>(简称<code>Sampler</code>)是采样器类，表示采样的策略，具体为提供一个索引序列
内置的<code>Sampler</code>有：</p>
<ul>
<li><code>SequentialSampler</code>：顺序采样，每次返回一个索引，是未提供<code>sampler</code>且<code>shuffle=False</code>时的默认采样器</li>
<li><code>RandomSampler</code>：全集的随机采样，是未提供<code>sampler</code>且<code>shuffle=True</code>时的默认采样器</li>
<li><code>WeightedRandomSampler</code>：根据权重的随机采样</li>
<li><code>SubsetRandomSampler</code>：对数据集子集的随机采样</li>
<li><code>BatchSampler</code>：对其它<code>Sampler</code>产生的索引序列分批，顺序地提供的各个批次的索引序列(一次返回整个批次的所有索引)
开启自动批处理时，最终会经过这个采样器进行分批</li>
</ul>
<p>用户可以继承<code>Sampler</code>或以上这些特化的采样器类，来自定义一个<code>Sampler</code>
不过大多数情况下，上述采样器已经足够了</p></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>big data</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: 树型模型</title>
    <url>/blogs/2025/11/25/stat-tree-models/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="树模型">树模型</h1>
<h2 id="决策树">决策树</h2>
<h3 id="树方法的特点">树方法的特点</h3>
<ul>
<li>解释性强，方法简单</li>
<li>准确性不如之前介绍的方法</li>
</ul>
<h3 id="回归树">回归树</h3>
<ul>
<li><p>回归树的损失函数是将<span
class="math inline"><em>R</em><em>S</em><em>S</em></span>划分为多个区域<span
class="math inline"><em>R</em><sub><em>j</em></sub></span>，形式为：</p>
<p><span class="math display">$$
RSS=\sum_{j=1}^J\sum_{i\in R_j}(y_i-\hat y_{R_j})^2
$$</span></p></li>
<li><p>建树方法：递归二叉分裂：</p>
<ul>
<li>自上而下：从顶端开始，选择预测变量和分割点(每一个预测变量都可以分段，所有分割点就是所有变量的分割点的集合)</li>
<li>贪婪：选择能使树的<span
class="math inline"><em>R</em><em>S</em><em>S</em></span>最小的那个分割点<span
class="math inline"><em>s</em></span></li>
</ul></li>
<li><p>剪枝：递归二叉分裂的过拟合较为严重，需要剪枝防止预测结果进一步分裂</p>
<ul>
<li><p>代价复杂性剪枝(最弱联系剪枝)：对<span
class="math inline"><em>R</em><em>S</em><em>S</em></span>添加惩罚项：</p>
<p><span class="math display">$$
RSS=\sum_{j=1}^J\sum_{i\in R_j}(y_i-\hat y_{R_j})^2+\alpha|T|
$$</span></p>
<p>其中<span
class="math inline"><em>α</em></span>对应一棵子树，是非负的超参数，<span
class="math inline">|<em>T</em>|</span>为该子树的叶子节点数，<span
class="math inline"><em>α</em></span>同样通过交叉验证选择</p>
<p>即叶子结点数越多，惩罚越大</p></li>
</ul></li>
</ul>
<h3 id="分类树">分类树</h3>
<ul>
<li><p>分类树和回归树类似，只不过损失函数需要变化</p></li>
<li><p>效果较差的分类错误率：</p>
<p><span
class="math display"><em>E</em> = 1 − max<sub><em>k</em></sub>(<em>p̂</em><sub><em>m</em><em>k</em></sub>)</span></p>
<p><span
class="math inline"><em>p̂</em><sub><em>m</em><em>k</em></sub></span>是在第<span
class="math inline"><em>m</em></span>个区域第<span
class="math inline"><em>k</em></span>类所占比例，即所有非最常见类的预测比例</p></li>
<li><p>基尼系数：</p>
<p><span class="math display">$$
G=\sum_{k=1}^K\hat p_{mk}(1-\hat p_{mk})
$$</span></p></li>
<li><p>交叉熵：</p>
<p><span class="math display">$$
D=-\sum_{k=1}^K\hat p_{mk}\log \hat p_{mk}
$$</span></p></li>
</ul>
<h2 id="装袋法">装袋法</h2>
<ul>
<li>装袋法又称自助法聚集，学习自助法可以知道，通过有放回重复采样可以平均方差，使预测结果的<strong>方差减小</strong></li>
<li>装袋法通过生成<span
class="math inline"><em>B</em></span>棵树，分别进行预测，求平均得到最终的预测结果</li>
<li>针对分类树，采用多数投票的方法，取最多投票的分类作为最终的预测结果</li>
<li>由自助法，每个自助样本包含原始样本大约<span
class="math inline">$\frac23$</span>的样本点，那么一颗自助树的袋外样本就有<span
class="math inline">$\frac13$</span>，那么不使用这<span
class="math inline">$\frac13$</span>袋外样本作为训练集的自助树有<span
class="math inline">$\frac B3$</span>棵，通过这<span
class="math inline">$\frac B3$</span>个袋外预测值就能估计测试误差了</li>
<li>它的估计过程和自助法估计不同，自助法针对每个模型计算袋外样本的测试误差，然后平均(共<code>模型数</code>个)，装袋法针对每个袋外样本先算测试误差，然后平均(共<code>袋外样本数</code>个)</li>
</ul>
<h2 id="随机森林">随机森林</h2>
<ul>
<li>随机森林本质是变量数更少的装袋法，在每个分裂点都选出<span
class="math inline"><em>m</em> ≤ <em>p</em></span>个变量来训练，通常<span
class="math inline"><em>m</em></span>取<span class="math inline">$\sqrt
p$</span></li>
</ul>
<h2 id="提升法">提升法</h2>
<ul>
<li>提升法适用于多个回归方法，针对回归树，它先训练多个弱学习器，不过是顺序训练的，后面的学习器会采用前面学习器的残差作为<span
class="math inline"><em>y</em></span></li>
<li>提升法的目标是降低偏差</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: 非线性模型</title>
    <url>/blogs/2025/11/24/stat-nlinear-models/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="非线性模型">非线性模型</h1>
<h2 id="基函数">基函数</h2>
<h3 id="多项式回归">多项式回归</h3>
<ul>
<li>多项式回归通过添加变量的幂来实现非线性的拟合</li>
</ul>
<h3 id="阶梯函数">阶梯函数</h3>
<ul>
<li>阶梯函数通过将预测变量的取值划分为<span
class="math inline"><em>K</em></span>个区间，来得到<span
class="math inline"><em>K</em> + 1</span>个新的定性的变量</li>
</ul>
<h3 id="基函数推广">基函数推广</h3>
<ul>
<li><p>基函数本质是针对一个预测变量<span
class="math inline"><em>X</em></span>做许多变换，来增加模型的复杂度，其基本形式是：</p>
<p><span
class="math display"><em>y</em> = <em>β</em><sub>0</sub> + <em>β</em><sub>1</sub><em>b</em><sub>1</sub>(<em>X</em>) + … + <em>β</em><sub><em>k</em></sub><em>b</em><sub><em>k</em></sub>(<em>X</em>) + <em>ϵ</em></span></p></li>
<li><p>多项式回归和阶梯函数都是基函数的特例</p></li>
</ul>
<h2 id="回归样条">回归样条</h2>
<ul>
<li>回归样条在分段多项式回归的基础上添加限制条件，使不同区间在分段点上连接，称为<code>spline</code>(样条)</li>
<li><code>d</code>阶样条是<code>d</code>阶多项式在每个分段点的零阶到<code>d-1</code>阶的导数都是连续的</li>
<li>样条基函数：通过将<code>d</code>阶多项式改写为<span
class="math inline"><em>y</em> = <em>β</em><sub>0</sub> + <em>β</em><sub>1</sub><em>b</em><sub>1</sub>(<em>x</em>) + … + <em>β</em><sub><em>k</em></sub><em>b</em><sub><em>k</em></sub>(<em>x</em>) + <em>ϵ</em></span>的基函数的形式，能减小使其<code>k</code>阶导数连续的难度</li>
<li>线性样条：</li>
<li>三次样条：有<code>K</code>个节点的三次样条的自由度为<code>K+4</code></li>
<li>自然样条：有<code>K</code>个节点的自然样条的自由度为<code>K</code></li>
<li>结点选择：通过交叉验证选择</li>
</ul>
<h2 id="光滑样条">光滑样条</h2>
<ul>
<li>光滑样条不同于回归样条，通过在最小二乘损失函数<span
class="math inline"><em>R</em><em>S</em><em>S</em></span>的基础上添加光滑惩罚项(波动性惩罚)<span
class="math inline">$\begin{align}\lambda\int g''(t)^2\mathrm
dt\end{align}$</span></li>
<li>这个对二阶导求和的惩罚项要求模型在节点处限制其粗糙程度，样条越光滑二阶导的积分越小</li>
<li>最终结果是自然三次样条的收缩版本，<span
class="math inline"><em>λ</em></span>是收缩程度，<span
class="math inline"><em>λ</em></span>同样通过交叉验证选择</li>
<li>其自由度随<span class="math inline"><em>λ</em></span>增大从<span
class="math inline"><em>n</em></span>降低到<span
class="math inline">2</span></li>
</ul>
<h2 id="局部回归">局部回归</h2>
<ul>
<li>局部回归在训练时只使用一个点附近的数据来拟合</li>
</ul>
<h2 id="广义可加模型">广义可加模型</h2>
<ul>
<li>广义可加模型在多项式回归函数的基础上，将<span
class="math inline"><em>β</em><sub><em>j</em></sub><em>x</em><sub><em>j</em></sub></span>改为<span
class="math inline"><em>f</em><sub><em>j</em></sub>(<em>x</em><sub><em>j</em></sub>)</span>非线性函数(例如上面的阶梯函数和样条函数)，称为可加模型</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: 估计方法</title>
    <url>/blogs/2025/11/20/stat-estimate/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="估计方法">估计方法</h1>
<h2 id="简介">简介</h2>
<ul>
<li>此前我们所说的<code>RSE</code>、置信区间等指标都需要测试误差，而测试误差是不可知的，因为没有标签</li>
<li>因此需要用一定的方法<strong>估计</strong>测试误差，除了测试误差，各种统计量的不确定性也需要估计，这有利于我们分析估计出来的统计量的浮动程度</li>
<li>在真正处于没有标签的环境之前，可以通过切出小部分数据集不让模型训练，从而预估模型的效果，分割出来给模型训练的是训练集，其余的为测试集，有时希望人工调整一些参数，会继续分割为验证集和测试集，验证集用于中期人工调整、测试集用于最终效果评估和展示(不再调整)</li>
<li>验证集的思路是好的，但是验证集通常是远小于训练集的数据量，且具有偶然性，测试误差被高估(有偏的)(不同的分割方式对误差影响大)</li>
</ul>
<h2 id="交叉验证法">交叉验证法</h2>
<h3 id="k折交叉验证"><code>K</code>折交叉验证</h3>
<ul>
<li><code>K</code>折交叉验证就是用于估计测试误差的被广泛使用的方法</li>
<li>其原理是将数据集分为<code>K</code>折大小一致的组，进行<code>K</code>次训练-测试，其中第<code>i</code>次的测试集为第<code>i</code>组，其余组为训练集，交叉验证最终的<code>MSE</code>为<code>K</code>次测试<code>MSE</code>的均值</li>
<li>通过划分来进行交叉验证，解决了验证集方法因训练次数只有一次而因划分方案导致的随机性，<code>K</code>折交叉验证本身也会因<code>K</code>的变大而变得更加稳定</li>
<li>当<code>K</code>不那么小时，可将交叉验证估计出来的误差为对某<span
class="math inline">$\frac
nk$</span>个未知样本的误差的渐进无偏估计，当<code>K</code>变大其训练集的样本数自然变少，从而和验证集方法一样变得有偏</li>
</ul>
<h3 id="留一法">留一法</h3>
<ul>
<li><p><code>LOOCV</code>(留一法)是特殊的<code>K</code>折交叉验证，它把数据集分为<code>n</code>(样本数)组，即验证集只有一个样本，因此会进行完整<code>n</code>次训练-测试拟合</p></li>
<li><p><code>LOOCV</code>是对某一个未知样本的误差的渐进无偏估计，渐进指<code>N</code>十分大时，估计出的误差和真实的泛化误差差不多</p>
<p>由于留一法测试时选取的是一个样本，所以说是对某<strong>一个</strong>未知样本的无偏估计，又因为训练集几乎等同于整个数据集，留一法的偏差会更小</p></li>
<li><p>留一法的划分是固定的，因为每一折只有一个样本，划分方案只有一种，对同一个数据集，留一法的估计结果是确定的</p></li>
<li><p>在采用最小二乘法拟合线性模型时，<code>LOOCV</code>估计的误差可以近似于只进行一次拟合：</p>
<p><span class="math display">$$
CV_(n)=\frac1n\sum_{i=1}^n\left(\frac{y_i-\hat y_i}{1-h_i}\right)
$$</span></p></li>
</ul>
<h2 id="自助法">自助法</h2>
<ul>
<li><p>自助法专注于估计一个统计量的<strong>不确定性</strong>，比如泛化误差的标准差和置信区间，而不是估计泛化误差</p></li>
<li><p>估计不确定性需要大量的数据和大量的重复试验来估计统计量的总体分布，因此交叉验证不适合</p></li>
<li><p>自助法的原理是对数据集进行多次<strong>有放回重复简单随机抽样</strong>，从而获得近似总体的若干数据集，一次简单随机抽样获得的数据集和原始数据集大小一致，称为一个自助样本</p>
<p>然后，对于每个自助样本，可以证明<strong>当<code>n</code>较大</strong>时有大概<strong>三分之二的重复</strong>的样本点，自助法使用自助样本来训练，使用袋外样本来测试，得到对应的统计量，这个<strong>统计量(例如泛化误差)一般是被低估</strong>的，虽然测试集和训练集没有重叠，但是训练集本身因为有重复样本已经和总体分布偏离了</p>
<p>虽然统计量的偏差较大，但是其方差、置信区间等却能很好地代表总体的方差</p></li>
<li><p>三分之二重复的证明：抽样符合<span
class="math inline">$P(x未被抽中)=\left(1-\frac{1}{n}\right)^n$</span>，<code>n</code>取极大后取极限为<span
class="math inline">$\frac1e$</span>约等于三分之一</p></li>
<li><p>蒙特卡洛模拟对该方法进行了压力测试，即使统计量的估计分布和其总体分布偏差较大，但统计量的估计分布的不确定性却十分准确</p></li>
</ul>
<h2 id="间接估计测试误差">间接估计测试误差</h2>
<h3 id="c_p"><span
class="math inline"><em>C</em><sub><em>p</em></sub></span></h3>
<ul>
<li><p>交叉验证是用于直接估计测试误差的方法，而有些方法通过对训练误差进行数学调整来间接地估计测试误差</p></li>
<li><p><span
class="math inline"><em>C</em><sub><em>p</em></sub></span>统计量：其中<span
class="math inline"><em>p</em></span>为预测变量个数、<span
class="math inline"><em>σ̂</em><sup>2</sup></span>为<strong>测试误差的方差的估计值</strong></p>
<p><span class="math display">$$
C_p=\frac1n(RSS+2p\hat\sigma^2)
$$</span></p></li>
<li><p>因为训练误差通常小于测试误差，因此需要加上惩罚项来估计被低估的测试误差，其中参数个数越大惩罚越大</p></li>
<li><p>直观上来看，<span
class="math inline"><em>C</em><sub><em>p</em></sub></span>统计量肯定越小越好，如果<span
class="math inline"><em>σ̂</em><sup>2</sup></span>是<span
class="math inline"><em>σ</em><sup>2</sup></span>的无偏估计，那么<span
class="math inline"><em>C</em><sub><em>p</em></sub></span>也就是测试误差的无偏估计了</p></li>
<li><p><span
class="math inline"><em>σ̂</em><sup>2</sup></span>一般用包含全部变量的模型通过自助法估计</p></li>
</ul>
<h3 id="bic"><span
class="math inline"><em>B</em><em>I</em><em>C</em></span></h3>
<ul>
<li><p><code>BIC</code>(贝叶斯信息准则)统计量，对于最小二乘法拟合得到的模型，其形式为：</p>
<p><span class="math display">$$
BIC=\frac1nRSS+\log(n)p\hat\sigma^2
$$</span></p></li>
<li><p>相比<span
class="math inline"><em>C</em><sub><em>p</em></sub></span>，在<span
class="math inline"><em>n</em> &gt; 100</span>时其惩罚更大</p></li>
</ul>
<h3 id="aic"><span
class="math inline"><em>A</em><em>I</em><em>C</em></span></h3>
<ul>
<li><p><code>AIC</code>(赤池信息准则)统计量不仅适用于最小二乘法，适用于大部分极大似然法拟合得到的模型(其中<span
class="math inline"><em>L</em></span>为似然函数的极大值)：</p>
<p><span class="math display">$$
AIC=-2\logL+2p
$$</span></p></li>
<li><p><code>AIC</code>针对最小二乘法的形式为：</p>
<p><span class="math display">$$
AIC=\frac1{n\hat\sigma^2}(RSS+2p\hat\sigma^2)
$$</span></p></li>
</ul>
<h3 id="调整r2">调整<span
class="math inline"><em>R</em><sup>2</sup></span></h3>
<ul>
<li><p>调整<span
class="math inline"><em>R</em><sup>2</sup></span>肯定是让它变小：</p>
<p><span class="math display">$$
R^2=1-\frac{RSS(n-1)}{TSS(n-p-1)}
$$</span></p></li>
<li><p>调整<span
class="math inline"><em>R</em><sup>2</sup></span>没有理论证明，但是广泛适用，是对多余变量数<span
class="math inline"><em>p</em></span>的惩罚</p></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: 变量选择</title>
    <url>/blogs/2025/11/20/stat-var-selection/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="变量选择">变量选择</h1>
<h2 id="子集选择法">子集选择法</h2>
<ul>
<li><p>最优子集选择法：对<code>p</code>个预测变量，进行总共<span
class="math inline">$\sum_{i=1}^pC_{p}^i=2^p-1$</span>次拟合，即会拟合所有可能的模型</p>
<p>具体做法是先对每一个<code>i</code>，求出包含<code>i</code>个变量的最优模型(训练误差最小)，然后在剩下的<code>p</code>个最优模型里再选择最优(真正进行交叉验证，选择泛化误差最小)</p>
<p>但效率极低，当<code>p</code>较大时<span
class="math inline">2<sup><em>p</em></sup></span>级别的复杂度就会使拟合无法完成</p></li>
<li><p>逐步选择：</p>
<ul>
<li><p>逐步向前选择：从不包含任何变量的模型开始，遍历没有加入模型的预测变量，选择使得下一模型的训练误差最小的变量加入，直到所有变量全部加入</p>
<p>模型仍然能获得<code>p</code>个“最优”模型，在其中估计泛化误差选择最小者</p>
<p>其拟合次数为<span
class="math inline">$\sum_{i=1}^p=\frac{p(p+1)}{2}$</span>，约为<span
class="math inline"><em>p</em><sup>2</sup></span></p></li>
<li><p>逐步向后选择：从包含全部变量的模型开始，遍历所有已经加入模型的预测变量，选择使得下一模型的训练误差最小的变量删除，直到所有变量全部删除</p>
<p>模型仍然能获得<code>p</code>个“最优”模型，在其中估计泛化误差选择最小者</p>
<p>其拟合次数为<span
class="math inline">$\sum_{i=1}^p=\frac{p(p+1)}{2}$</span>，约为<span
class="math inline"><em>p</em><sup>2</sup></span></p>
<p>向后选择在<span
class="math inline"><em>p</em> &gt; <em>n</em></span>时无法进行，因为方程组无解(方程数小于未知变量数)</p></li>
</ul></li>
<li><p>最优模型的选择依据</p>
<ul>
<li>模型选择依赖于交叉验证估计的较为准确的泛化误差</li>
</ul></li>
</ul>
<h2 id="压缩估计">压缩估计</h2>
<ul>
<li>压缩估计是一种针对训练过程的变量选择方法，通过影响损失函数来间接影响拟合函数，让某些多余变量的系数接近零或变成零，因此也可作为变量选择的一节</li>
<li>压缩估计不是通过对训练误差直接增加惩罚项或直接估计测试误差，而是试图在训练时就对最小化函数增加惩罚项，一般是针对系数加惩罚，来减小系数的方差以测试误差的方差最终有效地防止过拟合</li>
<li>前面介绍的方法都没有影响基于最小二乘法的训练过程，而是通过各种手段估计测试误差，以其作为依据选择最优模型，而压缩估计则是直接修改了损失函数的形式，从而在选择最优模型之前的那一步减弱模型的过拟合</li>
</ul>
<h3
id="lasso回归l1回归"><code>Lasso</code>回归(<code>L1</code>回归)</h3>
<ul>
<li><p><code>Lasso</code>回归是在最小二乘法的基础上，将最小化函数<span
class="math inline"><em>R</em><em>S</em><em>S</em></span>改造为：</p>
<p><span class="math display">$$
Lasso=\sum_{i=1}^n\left(y_i-\hat
y_i\right)^2+\lambda\sum_{j=1}^p|\beta_j|
$$</span></p></li>
<li><p>最小化|_j|，它的解在解空间里将有“尖角”特性，其和<span
class="math inline"><em>R</em><em>S</em><em>S</em></span>最小化的解的交集将有很大概率落在坐标轴上，因此<span
class="math inline"><em>β</em><sub><em>j</em></sub></span>系数更容易被压缩到零，从而更能实现变量选择的效果</p></li>
<li><p>与第一节的权衡一致，增加惩罚项使偏差增大，方差减小，能减小模型的过拟合现象</p></li>
<li><p>它的另一个形式是作为一个约束(其中<span
class="math inline"><em>s</em></span>为无穷大时等价于最小二乘法)：</p>
<p><span class="math display">$$
\sum_{j=1}^p|\beta_j|\le s
$$</span></p></li>
</ul>
<h3
id="ridge回归l2回归"><code>Ridge</code>回归(<code>L2</code>回归)</h3>
<ul>
<li><p>岭回归是在最小二乘法的基础上添加惩罚项<span
class="math inline">$\lambda\sum_{j=1}^p\beta_j^2$</span>，它的效果并没有<code>Lasso</code>回归那么好，因为其解是圆滑的，随着系数会接近零但不会为零，这减小了可解释性</p></li>
<li><p>与<code>Lasso</code>回归类似，它的另一个形式是作为一个约束：</p>
<p><span class="math display">$$
\sum_{j=1}^p\beta_j^2\le s
$$</span></p></li>
</ul>
<h3 id="选择lamdba或s">选择<span
class="math inline">$\lamdba$</span>或<span
class="math inline"><em>s</em></span></h3>
<ul>
<li>和子集选择法类似，最终仍然通过交叉验证来估计测试误差，只不过针对的是不同<span
class="math inline"><em>λ</em></span>下的最优模型，即不是直接比较不同变量组合的模型，而是比较不同正则化强度的模型</li>
</ul>
<h2 id="降维选择法">降维选择法</h2>
<ul>
<li>此前的子集选择法会完全不使用部分变量，而压缩估计则是通过压缩系数来间接地选择变量，而降维选择法则是通过将原始<span
class="math inline"><em>p</em></span>个变量<strong>变换</strong>为更少的<span
class="math inline"><em>M</em></span>个变量(并不是将一些变量合为一组来进行训练)</li>
<li>降维选择法直接影响拟合函数的形式，也是一种针对训练过程的变量选择</li>
<li>变量个数<span
class="math inline"><em>M</em></span>也通过交叉验证来选择</li>
</ul>
<h4 id="主成分回归">主成分回归</h4>
<ul>
<li><code>PCR</code>回归通过投影方法，把<span
class="math inline"><em>p</em></span>个变量投影到<span
class="math inline"><em>M</em></span>个变量，通过乘投影矩阵得到主成分</li>
</ul>
<h4 id="偏最小二乘">偏最小二乘</h4>
<ul>
<li><code>PLS</code>偏最小二乘可以视作有指导的主成分回归，响应变量<span
class="math inline"><em>Y</em></span>会参与降维的过程</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: 分类任务</title>
    <url>/blogs/2025/11/18/stat-classification/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="分类任务">分类任务</h1>
<h2 id="逻辑回归">逻辑回归</h2>
<h3 id="二分类逻辑回归">二分类逻辑回归</h3>
<ul>
<li><p>针对分类任务，通常可用概率值估计类别，例如二分类求出一个<code>0~1</code>之间的概率，若概率大于某个阈值则取其中一类</p>
<p>而一般的线性回归会求出超出<code>0~1</code>范围的数，这是一种不合理</p></li>
<li><p>如同之前分析的线性回归问题“数据非线性”的解决方法那样，逻辑回归通过对预测变量作变换来解决分类任务</p>
<p>一元逻辑回归的形式是：</p>
<p><span class="math display">$$
p(X)=\frac{e^{\beta_0+\beta_1X}}{1+e^{\beta_0+\beta_1X}}=\frac{1}{1+e^{-\beta_0-\beta_1X}}
$$</span></p>
<p>这在人工智能里称为激活函数<code>Sigmoid</code>，其中可将<span
class="math inline"><em>β</em><sub>0</sub> + <em>β</em><sub>1</sub><em>X</em></span>替换为多元线性回归的形式来拟合多元分类任务</p></li>
<li><p>逻辑回归的想法就是将分类任务转换为回归任务</p>
<p>计算估计参数的方法自然是极大似然估计法，处理定性变量和一般线性回归相同，通过设计哑变量来表示</p>
<p>预测变量和响应变量的相关性通过<code>Z</code>统计量及其假设检验计算</p></li>
<li><p>和线性回归一样，如果预测变量之间高相关，那么容易产生混淆现象</p></li>
</ul>
<h3 id="多分类逻辑回归">多分类逻辑回归</h3>
<ul>
<li><p>和线性回归不同，针对逻辑回归，“多元”一般指多分类，即输出是多个类别</p></li>
<li><p>使用的激活函数是<code>Softmax</code>，<code>Sigmoid</code>是<code>Softmax</code>的特例：假设输出类别数为<code>K</code>，那么第<code>i</code>个输出是</p>
<p><span class="math display">$$
Softmax(X_i)=\frac{e^{z_i}}{\sum_{k=1}^Ke^{z_k}}
$$</span></p></li>
</ul>
<h2 id="线性判别分析">线性判别分析</h2>
<ul>
<li><p><code>LDA</code>（线性判别分析）是另一种间接估计<span
class="math inline"><em>P</em><em>r</em>(<em>Y</em>=<em>k</em>|<em>X</em>=<em>x</em>)</span>的方法，通过建立预测变量的分布模型，根据贝叶斯定理估计后验概率，最后分类</p></li>
<li><p>贝叶斯定理：</p>
<p><span class="math display">$$
Pr(Y=y|X=x)=\frac{\pi_yf_y(x)}{\sum_(l=1)^K\pi_lf_l(x)}
其中\pi_y=Pr(Y=y),f_y(x)=Pr(X=x|Y=y)
$$</span></p></li>
<li><p>估计<span
class="math inline"><em>P</em><em>r</em>(<em>X</em>=<em>x</em>|<em>Y</em>=<em>y</em>)</span>是难题，假设它服从正态分布，那么代入可得贝叶斯分类器，经过推导得到观测的最终分类将是使下式得到最大值的第<span
class="math inline"><em>k</em></span>类：</p>
<p><span class="math display">$$
\delta_y(x)=x\frac{\mu_y}{\sigma^2}-\frac{\mu_y^2}{2\sigma^2}+\log(\pi_y)
$$</span></p></li>
<li><p>线性判别分析和逻辑回归的区别：</p>
<ul>
<li>逻辑回归是参数模型，假设这个条件分布是变换后的线性模型，通过拟合<span
class="math inline"><em>P</em><em>r</em>(<em>Y</em>=<em>y</em>|<em>X</em>=<em>x</em>)</span>的模型并计算参数得到计算式子</li>
<li><code>LDA</code>是非参数模型，假设这个条件分布服从正态分布，通过贝叶斯估计直接推导得出的计算式子，然后求解决定性因子<span
class="math inline"><em>δ</em><sub><em>y</em></sub>(<em>x</em>)</span>得到<span
class="math inline"><em>y</em></span></li>
</ul></li>
<li><p>何时使用<code>LDA</code></p>
<ul>
<li>不同类别区分度较大时</li>
<li>样本量较少无法计算参数时</li>
<li>响应分类类别数较大</li>
<li>通用：假设服从正态分布时和逻辑回归类似，但可以假设服从其它各种分布</li>
</ul></li>
<li><p>决策边界：<code>LDA</code>会出现对于不同的<code>y</code>其<code>\delta_y(x)</code>相同的情况，即：</p>
<p><span class="math display">$$
\delta_{y_1}(x)=\frac{\mu_{y_1}}{\sigma^2}-\frac{\mu_{y_1}^2}{2\sigma^2}+\log(\pi_{y_1})=\delta_{y_2}(x)=\frac{\mu_{y_2}}{\sigma^2}-\frac{\mu_{y_2}^2}{2\sigma^2}+\log(\pi_{y_2})
$$</span></p>
<p>由等式计算得到的<span
class="math inline"><em>x</em></span>，就是决策边界</p></li>
<li><p>先验概率对决策边界的影响：</p>
<p>根据等式，先验概率<span
class="math inline"><em>π</em><sub><em>y</em></sub></span>越大的类别，其覆盖的<code>x</code>范围越大，即决策边界会“远离”该类别</p></li>
<li><p><span
class="math inline"><em>p</em> = 1</span>时<code>LDA</code>的假设：不同类别的<code>x</code>服从方差<span
class="math inline"><em>σ</em><sub><em>y</em></sub><sup>2</sup></span>相同的正态分布</p>
<p><span
class="math inline"><em>p</em> &gt; 1</span>时<code>LDA</code>的假设：不同类别的<code>x</code>服从协方差矩阵相同的多元正态分布，允许不同预测变量之间有相关性（协方差可非零）</p></li>
</ul>
<h2 id="混淆矩阵">混淆矩阵</h2>
<ul>
<li><p>横坐标为预测分类、纵坐标为真实分类</p>
<p><span class="math display">$$
\begin{align}&amp;(真|假)(阳|阴)性率=\frac{预测成功|预测失败\times预测阳性|预测阴性}{真实阳性|真实阴性}\\&amp;真阳性率=\frac{预测阳且真实阳}{真实阳}\\&amp;预测(阳|阴)性率=\frac{预测成功(阳|阴)}{预测(阳|阴)}\end{align}
$$</span></p></li>
</ul>
<h2 id="二次判别分析">二次判别分析</h2>
<ul>
<li><p><code>QDA</code>(二次判别分析)假设每一类别的预测变量仍服从多元高斯分布，但允许不同类的预测变量的协方差矩阵不同，在这样的假设下估计出来的<span
class="math inline">∑<sub><em>k</em></sub></span>不同，代入后得到：</p>
<p><span class="math display">$$
\delta_y(x)=-\frac12(x-\mu_y)^T\sum_y^{-1}(x-\mu_y)+\log\pi_y-\frac12\log|\sum_y|
$$</span></p></li>
<li><p><code>QDA</code>要求计算等同于类别数个的协方差矩阵，带给他更高的光滑度</p></li>
<li><p>由于判别函数是二次的，<code>QDA</code>的光滑度更高，因此偏差更小方差更大，当<strong>数据量非常大</strong>时，<code>LDA</code>的假设十分远离实际，因此偏差异常的大，而<code>QDA</code>带来的方差变大并不那么重要，反而能减小偏差，此时<code>QDA</code>更适合</p></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习: 线性回归</title>
    <url>/blogs/2025/11/17/stat-linear-regression/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="线性回归">线性回归</h1>
<h2 id="简单线性回归">简单线性回归</h2>
<h3 id="最小二乘法">最小二乘法</h3>
<ul>
<li>线性回归是监督学习模型，假设所有预测变量和响应变量具有线性关系</li>
<li>最小二乘回归(<code>OLS</code>)是最常用的简单线性回归方法，它采用的损失函数是残差平方和，其中残差是预测值与真实值的差值，残差平方和(<code>RSS</code>)为<span
class="math inline">$\begin{align}\sum_{i=1}^n(\hat
y_i-y_i)^2\end{align}$</span></li>
<li>最小化损失函数是几乎所有方法使用的估计系数方法，对于<code>OLS</code>而言则是最小化<code>RSS</code>，即求导使导数为零然后解方程</li>
</ul>
<h3 id="模型参数估计值指标">模型参数估计值指标</h3>
<ul>
<li>随机误差：随机误差是线性回归本就假设进去的一项，它的方差<code>$\sigma^2$</code>是不可约误差，是未知的常数</li>
<li>标准差<code>SE</code>：表示参数估计结果偏离真实值的平均值，用到了随机误差的方差以及<code>RSS</code></li>
<li>残差标准差(<code>RSE</code>)：虽然不可知，但可以估计，一般用<code>t(n-2)</code>统计量来估计</li>
<li>置信区间：xx%置信区间通过参数的估计值加上一定比例的标准差来得到，例如95%置信区间的范围是<span
class="math inline"><em>参</em><em>数</em><em>估</em><em>计</em><em>值</em> ± 2<em>S</em><em>E</em>(<em>参</em><em>数</em><em>估</em><em>计</em><em>值</em>)</span></li>
<li>预测区间</li>
<li>参数估计值是否为零：通过对<code>t</code>统计量进行假设检验，若<code>p</code>值接近零，认为有显著影响，因此否定估计值为零的原假设</li>
</ul>
<h3 id="模型预测值评价指标">模型预测值评价指标</h3>
<ul>
<li><p>残差标准差表示模型预测值偏离真实值的平均值</p></li>
<li><p><code>$R^2$</code>统计量通过总平方和以及残差平方和来计算，总平方和是真实值与平均值的差的平方和，该统计量越接近<code>1</code>，说明模型能更好的解释变异</p></li>
<li><p>偏差-方差权衡：模型的光滑度代表了它的复杂程度，光滑度越高，模型的非线性拟合能力越强，方差越小，但偏差也会越大</p>
<p>随光滑度增高，训练误差单调递减，但测试误差随之呈<code>U</code>型变化，左侧呈现出欠拟合问题(模型复杂程度太低)，右侧呈现出过拟合问题(训练误差小于不可约误差，但测试误差较大)</p></li>
</ul>
<h2 id="多元线性回归">多元线性回归</h2>
<ul>
<li>多元线性回归假设各个预测变量不相关</li>
<li>多元线性回归同样使用最小二乘法估计系数</li>
<li>多元线性回归同样通过<code>t</code>统计量的<code>p</code>值判断某个特定系数是否为零，此外还通过<code>F</code>统计量的<code>p</code>值判断是否所有预测变量的系数均为零</li>
</ul>
<h2 id="处理定性的预测变量">处理定性的预测变量</h2>
<ul>
<li>二值变量使用一个哑变量即可，即是某类时赋值为<code>1</code>，否则为零</li>
<li><code>n</code>值变量使用<code>n-1</code>个哑变量，所有哑变量均为零时表示剩下那个状态</li>
</ul>
<h2 id="处理线性回归的假设">处理线性回归的假设</h2>
<ul>
<li>多元线性回归假设各个预测变量不相关，但现实中几乎不可能，为了减小相关性影响，引入交互项(乘积项)，和一般的预测变量相同地参与模型评价</li>
<li>实验分层原则：若交互项存在，那么参与交互项的预测变量(称为主效应项)都应在模型中</li>
</ul>
<h2 id="线性回归的问题">线性回归的问题</h2>
<ul>
<li><p>数据的非线性：画出残差-拟合值图像，对于每一个拟合值，求出的残差的均值应是零，若存在若干点残差均值远离零，那么很有可能有数据的非线性问题</p>
<p>解决办法是观察图像并猜测有可能的线性关系，添加对<strong>预测变量作一定变换</strong>的非线性项</p></li>
<li><p>随机误差项自相关：原本假设是<span
class="math inline"><em>n</em></span>个<span
class="math inline"><em>ε</em></span>之间互不相关(且假设服从正态分布)，如果相关会导致估计标准差低于真实标准差，链式导致置信区间变窄</p>
<p>此问题常出现在时间序列数据上，解决办法是增加采样时间或注重随机采样</p></li>
<li><p>随机误差项方差非恒定：画出残差-拟合值图像，随拟合值变化，残差的均值虽然接近零，但上下范围随之变化</p>
<p>解决办法是对<strong>响应变量作一定变换</strong></p></li>
<li><p>离群点：响应值标签是异常的，针对一元或二元线性回归，可以画出真实值-输入值图像或<strong>学生化残差图</strong>来发现离群点</p>
<p>学生化残差指残差和残差标准差的比值，提供一个易于分析的评估范围(绝对值大于<code>3</code>视为离群点)</p>
<p>离群点不会过多影响最小二乘计算出的参数估计值，但会影响评价指标(因为<code>RSE</code>会被影响)，如<code>p</code>值、置信区间</p></li>
<li><p>高杠杆点：输入数据(预测变量)的值是异常的(简单理解为附近没有其它样本点)，可以通过计算杠杆统计量值量化寻找</p>
<p>高杠杆点和离群点不同，它会极大影响最小二乘计算出的参数估计值，必须找出它</p></li>
<li><p>数据的共线性：预测变量之间高度相关，难以猜测哪些变量是真正相关的，若两个高度相关的变量放在一起，参数的标准差增大、<code>t</code>统计量值减小、假设检验的<code>p</code>值增大，导致无法看出哪个变量是真正和响应变量相关的，且难以解释系数</p>
<p>可通过计算协方差矩阵或计算方差膨胀因子(<code>VIF</code>)发现共线性数据</p>
<p>可通过其它回归方法或去除某些变量解决该问题</p></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>stat</category>
      </categories>
      <tags>
        <tag>stat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux: 内核</title>
    <url>/blogs/2025/08/20/linux-kernel/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="linux内核"><code>Linux</code>内核</h1>
<p><code>Linux</code>内核主要负责四个功能：系统内存管理、软件程序管理、硬件设备管理、文件系统管理</p>
<h2 id="系统内存管理">系统内存管理</h2>
<p><code>Linux</code>内核可以管理硬盘上的<strong>交换区域</strong>，这片区域被称为虚拟内存，它扩大了系统可使用的内存</p>
<p>内核会自动把长时间未访问的资源从物理内存<strong>换出</strong>到交换区域里，需要访问时又把它<strong>换入</strong>到物理内存中</p>
<h2 id="软件程序管理">软件程序管理</h2>
<p>运行中的程序称为进程，第一个进程称为<strong>init进程</strong>，</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习: 卷积层</title>
    <url>/blogs/2025/07/18/deeplearning-convlayer/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="卷积层">卷积层</h3>
<ul>
<li><p>卷积层(<code>Convolutional Layer</code>)专门用于处理网格状数据或具有多维度特征信息的数据，例如时间序列(一维)、图像(二维)等</p>
<p>在全连接层中图像数据的预处理方法：将所有像素均视为特征，一个图像的所有像素的<code>RGB</code>值等排成一列作为一条样本</p>
<p>因此，全连接层极其不适合处理网格数据，原因是：</p>
<ul>
<li>网格数据的特征量极多，导致使用全连接层处理时，参数量爆炸导致计算效率低下</li>
<li>网格数据具有局部相关性，相邻数据相关程度远大于不相邻数据的相关程度，而全连接层使结点和全局数据关联起来，忽略了网格数据的“形状”</li>
<li>平移不变性：网格数据的部分目标平移时，应该将平移前后的数据看作类似的输入，但显然全连接层做不到</li>
</ul>
<p>卷积层解决了上述问题，并总结为三个特性：</p>
<ul>
<li><p>稀疏交互/稀疏连接/稀疏权重：使权重远小于输入，使模型只需要检测一些小的有意义的局部特征，减少存储需求的同时提高统计效率</p></li>
<li><p>参数共享：在同一层卷积层中，计算不同结点的输出所用的参数(权重、偏置)是一致的</p></li>
<li><p>平移等变：假设平移函数是使原输入的部分数据向某个方向平移的函数，那么原输入在经过平移函数后的输出和原输出将是等价的</p>
<p>卷积层中的卷积运算对平移变换函数是天然等变的，对于放缩、旋转等变换，则需要额外的处理</p></li>
</ul></li>
<li><p>卷积层一般作为<strong>特征提取</strong>的核心，靠近输入层的卷积层能够提取低级特征、越深的卷积层越能理解更高级别的语义特征</p></li>
<li><p>卷积层在不同深度学习框架中的命名较为统一，均为<code>ConvXd</code>的形式，表示<code>X</code>维卷积层</p></li>
<li><p>具体结构：</p>
<ul>
<li><p>卷积层的维度：卷积层允许接受维度不同的输入数据，卷积层的维度和输入数据的维度一致</p>
<p>无论数据维度如何，卷积层始终进行局部特征提取，下面以二维卷积层<code>Conv2d</code>为例，一维或三维的卷积层可举一反三地理解</p></li>
<li><p>输入、输出均为三维的<strong>特征图</strong><span
class="math inline"><em>X</em>(<em>c</em>,<em>h</em>,<em>w</em>)</span>，其中<span
class="math inline"><em>c</em></span>为通道数、<span
class="math inline"><em>h</em></span>为特征高度、<span
class="math inline"><em>w</em></span>为特征宽度</p>
<p><strong>通道(<code>Channel</code>)数</strong>是描述<strong>特征种类数</strong>的整数，例如<code>RGB</code>图像就是三通道的特征图</p>
<p>卷积层不是通过展平，而是将数据的结构用通道数、高度、宽度表示出来，强调了数据的“形状”特性</p></li>
<li><p>权重为四维的<strong>滤波器集合</strong><span
class="math inline"><em>W</em>(<em>c</em><sub><em>o</em><em>u</em><em>t</em></sub>,<em>c</em><sub><em>i</em><em>n</em></sub>,<em>h</em><sub><em>W</em></sub>,<em>w</em><sub><em>W</em></sub>)</span>，在每个输出通道上的<strong>三维张量</strong>称为滤波器，又称<strong>卷积核</strong>，其中<span
class="math inline"><em>c</em><sub><em>o</em><em>u</em><em>t</em>/<em>i</em><em>n</em></sub></span>为输出/输入通道数、<span
class="math inline"><em>h</em><sub><em>W</em></sub></span>为核高度、<span
class="math inline"><em>w</em><sub><em>W</em></sub></span>为核宽度</p>
<p>某一层卷积核的数量，等同于输出通道数，和输入通道数无关</p>
<p>一般来说，<span
class="math inline"><em>h</em><sub><em>W</em></sub> = <em>w</em><sub><em>W</em></sub></span>且为奇数，此后统一用<span
class="math inline"><em>K</em></span>表示</p></li>
<li><p>偏置为向量<span
class="math inline"><strong>b</strong>(<em>c</em><sub><em>o</em><em>u</em><em>t</em></sub>)</span>，同一输出通道的所有元素共享一个偏置值</p></li>
<li><p>输入与权重的运算为<strong>卷积运算</strong>，实际上并非数学上的卷积，而是<strong>互相关运算</strong>，用<span
class="math inline">*</span>表示</p>
<p>在数学上的卷积运算中，核是进行了翻转的，即运算的双方在一方索引增大的同时另一方索引减小</p>
<p>这种翻转的唯一目的是为卷积运算赋予<strong>可交换性</strong>，但对于神经网络而言它并不重要</p>
<p>因为传统原因，许多实现把这种互相关运算称为卷积，所以本文也将其称为卷积，并默认其是不带翻转的卷积运算</p></li>
</ul></li>
<li><p>卷积层的卷积运算定义为(设输入特征图为<span
class="math inline"><em>X</em></span>，过滤器为<span
class="math inline"><em>W</em></span>)： <span class="math display">$$
\begin{align}&amp;(X\ast
W)_{c_{out},i,j}=\sum_{k=1}^{c_{in}}\sum_{m=1}^{K}\sum_{n=1}^{K}X_{k,m+i-1,n+j-1}·W_{c_{out},k,m,n}\end{align}
$$</span> 简单来说，输出特征图在通道为<span
class="math inline"><em>c</em><sub>1</sub></span>上的第<span
class="math inline"><em>i</em></span>行第<span
class="math inline"><em>j</em></span>列元素的初步加权求和值，等同于计算：</p>
<ul>
<li>对输入特征图的<strong>每个输入通道</strong><span
class="math inline"><em>c</em><sub>2</sub></span>，取出以第<span
class="math inline"><em>i</em></span>行第<span
class="math inline"><em>j</em></span>列个元素为左上角的、和卷积核结构相同的子矩阵，求出这个子矩阵和输出通道为<span
class="math inline"><em>c</em><sub>1</sub></span>、输入通道为<span
class="math inline"><em>c</em><sub>2</sub></span>的卷积核的<strong>逐元素相乘之和</strong></li>
<li>将上述值求和，得到结果</li>
</ul>
<p>因此在这种情况下，<span
class="math inline"><em>h</em><sub><em>o</em><em>u</em><em>t</em></sub> = <em>h</em><sub><em>i</em><em>n</em></sub> − <em>K</em> + 1</span>，<span
class="math inline"><em>w</em><sub><em>o</em><em>u</em><em>t</em></sub></span>同理，即输入特征图的高度、宽度必须不小于卷积核的高度、宽度</p></li>
<li><p>卷积层相比于全连接层，有一些独有的超参数：</p>
<ul>
<li><p>卷积核的输出通道数、宽高：宽高一般相等，且为奇数</p></li>
<li><p><strong>步长</strong>(<code>Stride</code>)：步长指卷积核移动的步长，上述公式中步长为<span
class="math inline"><em>s</em> = 1</span>，通过增大步长，可达成压缩数据、增大感受野的效果，有时正需要损失部分信息而快速地减少数据规模，例如使<span
class="math inline"><em>s</em> = 2</span></p>
<p>添加步长这个概念后，上述公式可表示为：</p>
<p><span class="math display">$$
\begin{align}&amp;(X\ast
W)_{c_{out},i,j}=\sum_{k=1}^{c_{in}}\sum_{m=1}^{K}\sum_{n=1}^{K}X_{k,\
m+(i-1)s,\
n+(j-1)s}·W_{c_{out},k,m,n}\\&amp;h_{out}=\left\lfloor\frac{h_{in}-K}s\right\rfloor+1\end{align}
$$</span></p></li>
<li><p>卷积层的<strong>填充</strong>(<code>Padding</code>)：如上述所示，经过卷积核运算后，输出特征图的高度、宽度必然缩小，在后续的卷积层中会无法继续运算，上述这种方式也称为<strong>有效填充</strong>(<code>Valid</code>)，即对原输入不进行任何的填充</p>
<p>这种缩小本质是一种数据丢失，边缘的信息从来无法位于子矩阵的中心，导致丢失边缘信息</p>
<p>为了保留信息、扩大输出特征图的结构，会在原输入的四周填充预设值，最常见的两种是：若<span
class="math inline"><em>s</em> = 1</span>则使输出和原输入结构相同、若<span
class="math inline"><em>s</em> &gt; 1</span>则使输出为原输入的一半</p>
<p>有如下经典的填充方式：</p>
<ul>
<li>全零填充(<code>Same</code>)：对四周填充零</li>
<li>反射填充(<code>Reflection</code>)：以四个边缘为对称轴，对称地填充四周的数值，顺序是左右上下</li>
</ul>
<p>填充后新增的圈数称为填充量，记为<span
class="math inline"><em>p</em></span>，可以这样计算： <span
class="math display">$$
\begin{align}&amp;\because
h_{out}=\left\lfloor\frac{h_{in}-K+2p}s\right\rfloor+1\\&amp;\therefore\left\lfloor\frac{(h_{out}-1)s+K-h_{in}}2\right\rfloor\le
p\lt\left\lfloor\frac{h_{out}s+K-h_{in}}2\right\rfloor\end{align}
$$</span> 因此，取<span
class="math inline">$\begin{align}p=\left\lfloor\frac{(h_{out}-1)s+K-h_{in}}2\right\rfloor\end{align}$</span>即可</p>
<p>当输出结构与原输入一致且步长<span
class="math inline"><em>s</em> = 1</span>时，<span
class="math inline">$\begin{align}p=\left\lfloor\frac{K-1}2\right\rfloor\end{align}$</span></p></li>
</ul></li>
<li><p>感受野(<code>Receptive Field</code>，或译为<strong>接受域</strong>)：指在某一层特征图上的某一个元素，对应原始数据输入的区域大小</p>
<p>输入层的每一个神经元结点的感受野<span
class="math inline"><em>R</em><em>F</em></span>都是<span
class="math inline">1</span>，表示该层的每一个结点都只能看到<span
class="math inline">$1\cross1$</span>的区域</p>
<p>卷积程度越深，感受野将越大，直到最后某层的卷积结点的感受野等于全局感受野时，意味着一个结点掌握了完整输入的全局特征</p>
<p>感受野可以迭代地计算：<span
class="math inline">$\begin{align}RF_{l+1}=RF_{l}+(K_{l+1}-1)\prod_{i=1}^{l}s_i\end{align}$</span></p>
<p>可以通过计算感受野大小，帮助我们调整上述超参数，但感受野实际上<strong>与填充无关</strong></p></li>
<li><p>卷积层的前向传播： <span class="math display">$$
\begin{align}&amp;X_{c_{in}}^{(l+1)}=Z^{(l)}_{c_{out}}=g^{(l)}\left((X^{(l)}\ast
W^{(l)})_{c_{out}}+b^{(l)}_{c_{out}}\right)\end{align}
$$</span></p></li>
<li><p>卷积层的反向传播梯度计算，以计算输出通道为<span
class="math inline"><em>c</em><sub><em>o</em><em>u</em><em>t</em></sub></span>的参数梯度为例：</p>
<p>为了便于理解，先从<span
class="math inline"><em>s</em> = 1</span>、<code>Same</code>填充开始推导：
<span class="math display">$$
\begin{align}&amp;\frac{\part Y^{(l)}_{c_{out}}}{\part
X^{(l)}_{c_{in},i,j}}=\sum_{m=1}^K\sum_{n=1}^KW_{c_{out},c_{in},m,n},&amp;(和i,j无关,是标量,记为SW)\\&amp;\boldsymbol\delta^{(l)}_{c_{out}}=\begin{cases}{\Large\frac{\part
L}{\part\hat y}\frac{\part g^{(l)}}{\part
Y^{(l)}}},&amp;l为输出层\\\boldsymbol\delta^{(l+1)}_{c_{out}}SW{\Large\frac{\part
g^{(l)}}{\part Y^{(l)}}},&amp;l为隐藏层\end{cases}\\&amp;\frac{\part
Y^{(l)}}{\part
W^{(l)}_{c_{out},c_{in},i,j}}=\sum_{m=1}^{K}\sum_{n=1}^KX_{c_{in},\
i+(m-1)s,\ j+(n-1)s}\\&amp;\frac{\part L}{\part
W^{(l)}_{c_{out},c_{in},i,j}}=\boldsymbol\delta^{(l)}_{c_{out},i,j}\frac{\part
Y^{(l)}}{\part W^{(l)}_{c_{out},c_{in},i,j}}\end{align}
$$</span></p></li>
</ul>
<h3 id="池化层">池化层</h3>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: Mybatis</title>
    <url>/blogs/2025/07/16/java-mybatis/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="mybatis"><code>MyBatis</code></h1>
<h2 id="sqlsessionfactory"><code>SqlSessionFactory</code></h2>
<ul>
<li><code>SqlSessionFactory</code>通常是单例模式，它的实例用于获取<code>SqlSession</code>，并与其他事务控制</li>
</ul>
<h2 id="sqlsession接口"><code>SqlSession</code>接口</h2>
<ul>
<li><code>SqlSession</code>包含所有执行<code>Sql</code>的方法，类似<code>JDBC</code>的<code>Connection</code>，但它是后者的进一步封装，它将一些繁琐的错误处理，结果处理，参数绑定简化了</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Common Tools</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>Java</tag>
        <tag>ORM</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习: 全连接层</title>
    <url>/blogs/2025/07/15/deeplearning-fclayer/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="全连接层">全连接层</h3>
<ul>
<li><p>全连接层指本层的<strong>每一个结点</strong>都和上一层的<strong>所有结点相连接</strong></p></li>
<li><p>全连接层适合处理<strong>特征数量较少</strong>的<strong>全局特征数据</strong>，要求各条样本之间<strong>不含空间或时间上的相关性</strong></p></li>
<li><p>全连接层通常作为<strong>任务头</strong>，用于<strong>生成输出</strong>而不是中间计算，例如作为输出层</p></li>
<li><p>全连接层在不同深度学习框架中的命名有所不同，例如：</p>
<ul>
<li><code>Affine</code>层(仿射变换层)：根据其数学本质(线性变换与偏移)命名</li>
<li><code>Linear</code>层(线性层)</li>
<li><code>Dense</code>层(密集层)</li>
</ul></li>
<li><p>具体结构：</p>
<ul>
<li><p>全连接层的输入和输出均为<strong>特征展平的列向量</strong><span
class="math inline"><strong>x</strong></span>，本层输入的元素个数和上一层结点数相同、本层输出的元素个数和本层结点数相同</p></li>
<li><p>权重为<strong>二维矩阵</strong><span
class="math inline"><em>W</em></span>，<span
class="math inline"><em>W</em><sub><em>i</em>, <em>j</em></sub><sup>(<em>l</em>)</sup></span>表示第<span
class="math inline"><em>l</em> − 1</span>层第<span
class="math inline"><em>i</em></span>个结点到第<span
class="math inline"><em>l</em></span>层的第<span
class="math inline"><em>j</em></span>个结点的权重</p>
<p>因此若第<span class="math inline"><em>k</em></span>层结点数为<span
class="math inline"><em>c</em><sup>(<em>k</em>)</sup></span>，则<span
class="math inline"><em>W</em><sup>(<em>l</em>)</sup></span>是一个<span
class="math inline"><em>c</em><sup>(<em>l</em>−1)</sup></span>行<span
class="math inline"><em>c</em><sup>(<em>l</em>)</sup></span>列的矩阵</p></li>
<li><p>偏置则为列向量<span
class="math inline"><strong>b</strong></span>，它的元素个数与所在层的结点数相同</p></li>
</ul></li>
<li><p>全连接层的<code>FP</code>(此后假设同一层的激活函数相同)： <span
class="math display">$$
\begin{align}&amp;x_{j}^{(l+1)}=g_j^{(l)}\left(\left(W_{:,j}^{(l)}\right)^T\boldsymbol
x^{(l)}+\boldsymbol b^{(l)}\right)\\&amp;\boldsymbol
x^{(l+1)}=g^{(l)}\left(\left(W^{(l)}\right)^T\boldsymbol
x^{(l)}+\boldsymbol b^{(l)}\right)\end{align}
$$</span></p></li>
<li><p>全连接层的<code>BP</code>梯度计算： <span class="math display">$$
\begin{align}&amp;\boldsymbol\delta^{(l)}=\begin{cases}{\Large\frac{\part
L(\hat y)}{\part\hat y}\frac{\part g^{(l)}(Y^{(l)})}{\part
Y^{(l)}}},&amp;l为输出层\\W^{(l+1)}\boldsymbol\delta^{(l+1)}{\Large\frac{\part
g^{(l)}(Y^{(l)})}{\part
Y^{(l)}}},&amp;l为隐藏层\end{cases}\\&amp;\frac{\part L}{\part
W^{(l)}}=\boldsymbol
x^{(l)}(\boldsymbol\delta^{(l)})^T\\&amp;\frac{\part L}{\part\boldsymbol
b^{(l)}}=\boldsymbol\delta^{(l)}\end{align}
$$</span></p></li>
</ul>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习: 简单神经网络（前馈神经网络）的原理</title>
    <url>/blogs/2025/07/14/deeplearning-simpleNN/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="前馈神经网络基本原理">前馈神经网络基本原理</h2>
<h3 id="基本结构">基本结构</h3>
<ul>
<li><p>神经网络是深度学习最主要的实现手段，它包含<strong>多个神经网络层</strong>，每一层包含若干<strong>神经元</strong></p></li>
<li><p>神经网络根据数据流动的特点不同，分为前馈神经网络(<code>FeedForward NN</code>，<code>FNN</code>)、反馈神经网络(<code>FeedBack NN</code>，但不简称为<code>FNN</code>)、图神经网络(<code>GNN</code>)</p>
<p>前馈神经网络更简单，这种模型的每次计算结果是独立的、数据单向流通，其典型如全连接神经网络<code>FCN</code>、卷积神经网络<code>CNN</code></p>
<p>反馈神经网络的结点不仅接受来自前方结点的数据，还接受来自本身或后方的结点的数据，数据流动存在环的形式，因此其每次计算会受到过去的计算结果的影响，其典型如循环神经网络<code>RNN</code></p>
<p>图神经网络则没有“前后”的概念，它的结构是树或者图，可以处理结构更复杂的数据，例如一句话</p>
<p>以下我们介绍<code>FNN</code>的基本原理</p></li>
<li><p>神经网络层根据位置不同分为<strong>输入层</strong>、<strong>隐藏层</strong>(除首层和尾层的所有层)、<strong>输出层</strong></p></li>
<li><p>虽然神经网络层种类众多，但输入经过每层，基本地需要进行<strong>加权求和、添加偏置、激活函数</strong>三步得到输出，同时作为下一层的输入</p>
<ul>
<li><p>加权求和：每个输入对应一组权重，分别记为<span
class="math inline"><em>X</em></span>和<span
class="math inline"><em>W</em></span></p>
<p>到某个结点的加权求和是一种运算，记为<span
class="math inline"><em>W</em> ∘ <em>X</em></span>，这个中间结果记为<span
class="math inline"><em>Y</em></span></p></li>
<li><p>添加偏置(<code>bias</code>)：在<strong>经过激活函数前</strong>加上偏置，可以<strong>控制</strong>激活神经元的<strong>阈值</strong>，加速模型的拟合</p>
<p>偏置表示为<span class="math inline"><em>b</em></span></p>
<p>你可以想象它为本层的一个隐藏结点，该结点的输出固定为<span
class="math inline">1</span>，偏置则是其到下一层结点的权重</p></li>
<li><p>激活函数记为<span
class="math inline"><em>g</em>(<em>x</em>)</span>，同一层的激活函数一般相同，激活后的非线性输出为本层的最终输出，记为<span
class="math inline"><em>Z</em></span></p>
<p>激活函数有时候会被单独作为一层来说明，称为探测层</p></li>
</ul></li>
<li><p><strong>前向传播过程</strong>(<code>FP</code>)：向前递推计算所有层的输入，直至得到输出层的输出即为模型的预测值</p>
<ul>
<li><span
class="math inline">$\begin{align}&amp;X^{(l+1)}=Z^{(l)}=g^{(l)}(Y^{(l)})=g^{(l)}\left(W^{(l)}\circ
X^{(l)}+b^{(l)}\right)\end{align}$</span></li>
<li>为了方便，称参数、激活函数属于第<span
class="math inline"><em>l</em></span>层，为在第<span
class="math inline"><em>l</em></span>层“向前看”的参数、激活函数</li>
</ul></li>
<li><p><strong>反向传播过程</strong>(<code>BP</code>)：反向递推计算所有参数(指所有隐藏层及输入层的权重、偏置)的误差项</p>
<p>通常通过梯度下降法计算，其一般结论为：</p>
<ul>
<li><p><span
class="math inline">$\begin{align}参数新值=参数旧值-\eta\frac{\part
L}{\part{参数}}\end{align}$</span>，其中：</p>
<p><span
class="math inline"><em>η</em></span>为<strong>学习率</strong>，用于控制更新参数的步长，不至于使每次训练过度调整导致在最优点周围徘徊</p>
<p><span class="math inline"><em>L</em></span>为损失函数，<span
class="math inline">$\begin{align}\frac{\part L}{\part
参数}\end{align}$</span>为<strong>参数梯度</strong>，其基本原理为使参数向梯度的反方向调整，即可使模型的损失值沿最小值方向变化</p></li>
<li><p>每层的参数梯度可通过迭代的方式计算(<span
class="math inline"><em>Y</em></span>为未经过激活函数的中间输出)：</p>
<p><span class="math inline">$\begin{align}&amp;\frac{\part L}{\part
参数^{(l)}}=\frac{\part L}{\part Y^{(l)}}\frac{\part Y^{(l)}}{\part
参数^{(l)}}\\&amp;\frac{\part L}{\part Y^{(l)}}=\frac{\part L}{\part
Y^{(l+1)}}\frac{\part Y^{(l+1)}}{\part Y^{(l)}}=\frac{\part L}{\part
Y^{(l+1)}}\frac{\part Y^{(l+1)}}{\part X^{(l+1)}}\end{align}$</span></p>
<p>记<span class="math inline">$\begin{align}\frac{\part L}{\part
Y^{(l)}}\end{align}$</span>为<span
class="math inline"><em>δ</em><sup>(<em>l</em>)</sup></span>，其结构与第<span
class="math inline"><em>l</em></span>层输出一致，对于具体的神经网络层，我们只需要计算<span
class="math inline">$\begin{align}\frac{\part Y^{(l)}}{\part
参数^{(l)}}\end{align}$</span>以及<span
class="math inline">$\begin{align}\frac{\part Y^{(l)}}{\part
X^{(l)}}\end{align}$</span>即可得出梯度的具体数学表示</p>
<p>由于参数、<span class="math inline"><em>X</em></span>、<span
class="math inline"><em>Y</em></span>一般是向量或矩阵形式，需要学习矩阵求导相关知识才能理解其数学形式推导，有时也有这种形式：求标量分量的偏导、组合出对整个向量或矩阵的偏导</p></li>
</ul></li>
<li><p><strong>计算图</strong>：为了用正式的图形语言表示上述通过一系列运算将输入变为输出的过程，使用计算图语言，它是一个有向无环图，描述了不同层参数、输入之间的计算关系，称为计算图</p></li>
</ul>
<h3 id="梯度下降法的优化">梯度下降法的优化</h3>
<ul>
<li><p>梯度下降法(<code>Gradient Descent</code>，<code>GD</code>)是神经网络训练中最基本的优化算法</p>
<p>为了达成损失最小化，需要<strong>使损失函数对所有参数的偏导为零</strong>(达到极值)</p>
<p>为了使该极值为极小值，需要向函数值减小的方向调整</p>
<p>根据梯度的数学意义，<strong>沿梯度的反方向调整</strong>即可满足<strong>导数下降</strong>、<strong>函数值下降</strong>、<strong>调整效果最大化</strong>三个要求，故称梯度下降</p></li>
<li><p>参数更新：使原本的参数减去算出的梯度值即可(即沿梯度的反方向更新)</p>
<p>为了控制每次更新的步长<strong>不至于过大</strong>而导致模型永远在最优点四周徘徊，一般会给每一层添加学习率<span
class="math inline"><em>η</em></span>(一般为<span
class="math inline">0.001</span>)，即： <span class="math display">$$
\begin{align}P_{new}^{(l)}=P_{old}^{(l)}-\eta^{(l)}\frac{\part L}{\part
P_{old}^{(l)}}\end{align}
$$</span></p></li>
<li><p>衍生算法：</p>
<ul>
<li>随机梯度下降法(<code>Stochastic GD</code>)/增量梯度下降法(<code>Increment GD</code>)：随机选择一个样本点训练，每处理一个样本点，立刻根据梯度更新参数
<ul>
<li>训练很快，能确保在局部最优解附近</li>
<li>像一个醉鬼一样下山，走到哪算哪，可能无法走到全局最优解(损失函数有多个极小值点，可能只能走到较大的极小值点而无法走到最小值点)</li>
</ul></li>
<li>批量梯度下降法(<code>Batch GD</code>)：批量即每次求损失值时，计算所有样本的梯度并存储(暂时不更新)
在处理完整个样本集后，对梯度求平均后更新
<ul>
<li>每次迭代时能稳定地指向最准确的极值方向，结果是全局最优的</li>
<li>当一个数据集的样本特别多时，一次的训练时间过长</li>
</ul></li>
<li>小批量梯度下降(<code>Mini-Batch GD</code>)：小批量如其名，将样本集再划分为多个小样本集，一次训练对小样本集进行上述操作
是一种折中的方法，兼顾训练效率、模型准确度</li>
</ul></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>FNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring framework: Security</title>
    <url>/blogs/2025/07/14/spring-security/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Spring framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>security</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring framework: Validation API</title>
    <url>/blogs/2025/07/14/spring-validation/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="spring-validation"><code>Spring Validation</code></h1>
<h2
id="org.springframework.validation"><code>org.springframework.validation</code></h2>
<h3 id="介绍">介绍</h3>
<ul>
<li><code>Spring Validation</code>是原生的<code>API</code>，不依赖任何外部框架或规范</li>
</ul>
<h3
id="org.springframework.validation.validator接口"><code>org.springframework.validation.Validator</code>接口</h3>
<ul>
<li>这里的<code>Validator</code>不是<code>jakarta.validation.Validator</code></li>
<li>仅包含两个方法：
<ul>
<li><code>boolean supports(Class&lt;?&gt;)</code>：检验该验证器是否支持指定的类</li>
<li><code>void validate(T obj, Errors)</code>：检验<code>obj</code>，将错误信息交给<code>Errors</code>引用
对比<code>jakarta.validation.Validator</code>的<code>validate()</code>方法，它将错误信息交给返回值<code>Set&lt;ConstraintViolation&lt;T&gt;&gt;</code></li>
</ul></li>
</ul>
<h3 id="errors接口"><code>Errors</code>接口</h3>
<ul>
<li><p><code>Errors</code>接口包含一系列方法用于获取错误信息</p></li>
<li><p><code>reject(String errorCode)</code>：注册一个全局的错误，<code>errorCode</code>若要分层，风格可使用<code>.</code>符号分隔不同层</p>
<p><code>reject(String errorCode, String message)</code>：使用自定义错误信息</p></li>
<li><p><code>rejectValue(String field, String errorCode, String message)</code>：对特定字段<code>field</code>注册一个错误</p></li>
<li><p><code>hasErrors()</code>：判断是否有错误</p>
<p><code>hasGlobalErrors()</code>：判断是否有全局错误</p>
<p><code>hasFieldErrors(String Field)</code>：判断是否有特定字段错误</p></li>
<li><p><code>List&lt;ObjectError&gt; getGlobalErrors()</code>：获取所有全局错误</p>
<p><code>FieldError getFieldError(String field)</code>：获取指定的字段错误</p>
<p><code>List&lt;FieldError&gt; getFieldErrors()</code>：获取所有字段错误</p></li>
</ul>
<h3 id="bindingresult接口"><code>BindingResult</code>接口</h3>
<ul>
<li><code>BindingResult</code>继承了<code>Errors</code>接口</li>
<li><code>Object getTarget()</code>：获取发生错误的目标对象</li>
</ul>
<h2
id="集成bean-validation-api">集成<code>Bean Validation API</code></h2>
<ul>
<li><p><code>Spring</code>使用适配器模式将<code>Spring Validation</code>与<code>Bean Validation API</code>集成起来</p>
<p><code>LocalValidatorFactoryBean</code>是一个<code>org.springframework.validation.Validator</code>，内部使用一个<code>jakarta.validation.Validator</code>的实现(一般是<code>Hibernate</code>)从而支持注解形式的验证<code>API</code>，它同时也是一个<code>FactoryBean</code>，因此可以通过<code>IoC</code>容器管理</p></li>
<li><p><code>@Validated</code>是一个<code>Spring</code>额外提供的注解，比起<code>@Valid</code>，它提供分组功能，分组使用方法和<code>Bean Validation API</code>里的<code>groups</code>属性类似</p></li>
<li><p>和<code>Spring MVC</code>的联动：在方法参数中使用<code>@Valid</code>或<code>@Validated</code>或其它的注解约束，由容器会自动进行校验，并将抛出的异常赋给<code>BindingResult</code>对象自动注入</p>
<p>也可定义<code>@ExceptionHandler</code>方法处理</p></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Spring framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>validation</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring framework: MVC</title>
    <url>/blogs/2025/07/12/spring-mvc/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="spring-web-mvc"><code>Spring Web MVC</code></h1>
<h2
id="mvc架构模式与前端控制器设计模式"><code>MVC</code>架构模式与前端控制器设计模式</h2>
<ul>
<li><code>MVC</code>(<code>Model-View-Controller</code>，模型-视图-控制器)是网页应用中最常见的架构
<ul>
<li>模型用于存储数据与负责业务逻辑</li>
<li>视图用于显示与渲染数据</li>
<li>控制器是模型与视图的中介，用于接收并过滤来自视图的输入、格式化并输出来自模型的数据</li>
</ul></li>
<li>在传统的应用中，视图渲染同时也在服务器端进行，即是一个前后端不分离的应用，此时控制器处理请求的返回值是一个视图，在<code>Spring</code>中由<code>ViewResolver</code>解析器保证开发者只需要返回<code>String</code>而不是具体的<code>View</code></li>
<li>在前后端分离的现代<code>Web</code>应用中，前端交给一个前端框架开发，也许你已经听说过，此时后端应该提供<code>RESTful</code>的<code>API</code>，控制器返回的不再是<code>View</code>，而是数据</li>
<li>前端控制器设计模式旨在将<code>Controller</code>部分再次拆分，用一个单一的处理程序(前端控制器)来处理所有的请求，包括过滤、认证与授权、处理、记录日志等
这个<strong>前端控制器</strong>可以根据请求的类型不同，通过一个调度器/<strong>分发器</strong>，将请求分发到下属的<strong>不同的处理程序</strong>
不同的处理程序会有对应的响应数据，<strong>视图</strong>用于呈现这些响应数据</li>
<li>传统的<code>Servlet</code>开发有如下问题：
<ul>
<li><code>Servlet</code>的单个<code>doXxx()</code>处理多个不同<code>URL</code>的请求，管理映射困难，需要用分支判断
而如果对每一个<code>URL</code>都写一个单独的<code>Servlet</code>服务，虽然能解决上述问题，但相似业务逻辑的代码就会被分散在不同的文件中</li>
<li>需要手动地通过分支判断决定重定向以及内部转发，视图和服务紧耦合，难以扩展</li>
<li>需要通过<code>getParameter()</code>获取参数以及手动类型转换和校验</li>
</ul></li>
<li><code>Spring Web MVC</code>是基于<code>Jakarta EE Servlet API</code>的<code>Web</code>框架，通常简称<code>Spring MVC</code></li>
</ul>
<h2 id="配置相关">配置相关</h2>
<h3
id="dispatcherservlet的配置"><code>DispatcherServlet</code>的配置</h3>
<ul>
<li><p><code>Spring MVC</code>提供了大部分实现，以使开发者只需要专心于编写控制器或处理器程序，然而稍微了解其内部构造仍是有用的</p></li>
<li><p><code>DispatcherServlet</code>是一个前端控制器，它实现了<code>jakarta.servlet.http.HttpServlet</code>
它的作用就是识别项目里被<code>@Controller</code>等注解的处理器以及内部的方法映射，将来自不同<code>URL</code>的请求分发给它们</p></li>
<li><p>这个前端控制器同时应该作为一个<code>Bean</code>被纳入<code>IoC</code>容器管理，而作为一个<code>Servlet</code>应用，应用启动的流程是：由<code>Servlet</code>容器创建并注册所有的<code>Servlet</code>服务类，然后启动，最后创建<code>ApplicationContext</code>实例，因此无法使用自动注入</p></li>
<li><p>为了解决这个问题，<code>DispatcherServlet</code>的构造方法有两种：默认构造方法会查询<code>ServletConfig</code>的<code>InitParameter</code>，使用<code>contextConfigLocation</code>配置；另一个构造方法要求一个<code>WebApplicationContext</code>参数，从而引导<code>Servlet</code>容器去创建<code>IoC</code>容器的上下文
这两种方法对应两种配置：
使用<code>web.xml</code>以及<code>IoC</code>容器所需的<code>XML</code>文件注册，部署在外部<code>Servlet</code>容器中
<code>Servlet</code>容器在创建<code>DispatcherServlet</code>时，检测到<code>&lt;init-param/&gt;</code>标签，转而读取对应的<code>IoC</code>容器的<code>XML</code>文件，在创建<code>DispatcherServlet</code>之前创建<code>ClassPathXmlWebApplication</code>实例</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 参数名需要记 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ctx_path<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- IoC容器的XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>使用<code>WebApplicationInitializer</code>接口，覆写<code>onStartup(ServletContext)</code>方法来编程式地创建<code>DispatcherServlet</code>，实际上等价于用<code>Java</code>代码替代<code>XML</code>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>(...);</span><br><span class="line">    </span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">dispatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(ctx);</span><br><span class="line">        <span class="type">var</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addServlet(<span class="string">&quot;dispatcher&quot;</span>, dispatcher);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/api/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果使用基于<code>Java</code>的注解，更建议继承<code>AbstractAnnotationConfigDispatcherServletInitializer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; RootConfig.class &#125;; <span class="comment">// 返回null可能不是最佳实践</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/api/**&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><code>DispatcherServlet</code>默认有若干内置的对象，重要的接口如下：</p>
<ul>
<li><code>HandlerMapping</code>接口：将处理器对应的类映射到某个具体的<code>URL</code>上
不需要调用或实现它，它的默认实现是<code>RequestMappingHandlerMapping</code>，它会自动解析<code>@RequestMapping</code>、<code>@GetMapping</code>等注解映射</li>
<li><code>HandlerAdapter</code>接口：(适配器)将处理器的不同方法统一为一个方法，使前端控制器不需要关注其细节
不需要调用或实现它，它的默认实现是<code>ResquestMappingHandlerAdapter</code>，它替代前端控制器来执行<code>HandlerMapping</code>找到的方法</li>
<li><code>HandlerExceptionResolver</code>接口：将不同地方的各种异常映射到统一的异常处理器类上
不需要调用或实现它，它有若干实现类用于处理不同类别的异常源</li>
<li><code>ViewResolver</code>接口：负责解析后端处理器返回的字符串，变为<code>View</code>对象，如<code>JSP</code>或<code>Thymeleaf</code>模板
不需要调用或实现它，它的默认实现是<code>InternalResourceViewResolver</code>
因为现代<code>Web</code>应用一般使用前后端分离，所以<code>ViewResolver</code>也不常用了</li>
<li><code>LocaleResolver</code>接口：负责<code>i18n</code>
不需要调用或实现它，它有若干实现类</li>
<li><code>ThemeResolver</code>接口：负责解析<code>UI</code>主题，即前端的工作
前端的工作一般不用<code>Java</code>来做，所以一般不需要使用它</li>
<li><code>MultipartResolver</code>接口：负责解析<code>multipart</code>类型的数据
没有默认配置，需要自己配置，有现成的实现类</li>
</ul></li>
</ul>
<h3 id="拦截链">拦截链</h3>
<ul>
<li><p>就像<code>Jakarta EE</code>的<code>Filter</code>那样，<code>DispatcherServlet</code>在找到对应的处理器后，调用之前会先调用拦截器链</p></li>
<li><p>拦截器需要实现<code>HandlerInterceptor</code>接口，包含三个方法，它们会作为回调函数被观察者调用</p>
<ul>
<li><code>preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler)</code>：调用处理器之前的拦截点，通常进行日志记录、身份验证</li>
<li><code>postHandle(HttpServletRequest req, HttpServletResponse resp, Object handler, ModelAndView modelAndView)</code>：成功调用处理器之后，视图渲染之前的拦截点，通常用于添加视图的全局配置</li>
<li><code>afterCompletion(HttpServletRequest req, HttpServletResponse resp, Object handler, Exception ex))</code>：完成整个请求后的回调，通常用于资源关闭、性能统计等，就像<code>finally</code>块那样，即使之前的处理链有异常发生，也会调用该方法</li>
</ul></li>
<li><p>注册拦截器：</p>
<ul>
<li><p>基于<code>Java</code>的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需实现WebMvcConfigurer接口(全部都有default实现, 因此可按需实现)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyHandlerInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebMvcConfig</span><span class="params">(MyHandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptor = interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 注册interceptor, 作用于/api/**, 忽略/api/noIntercept</span></span><br><span class="line">        <span class="comment">// 执行顺序为最高(0为最高优先级)</span></span><br><span class="line">        <span class="comment">// addInterceptor()返回InterceptorRegistration, 然后允许链式调用配置方法</span></span><br><span class="line">        registry.addInterceptor(interceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .exludePathPatterns(<span class="string">&quot;/api/noIntercept&quot;</span>)</span><br><span class="line">                .order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>基于<code>XML</code>配置：待补</p></li>
</ul></li>
<li><p><code>CORS</code>配置：<code>Spring MVC</code>的默认<code>CORS</code>策略是同源策略，即默认情况下，不允许被不同域访问(包括<code>localhost</code>的不同端口)，浏览器确认的具体做法是先发送预请求获取对方的<code>CORS</code>配置，然后限定只能发送或不能发送特定的请求</p></li>
<li><p><code>@CrossOrigin</code>类/方法级注解就是用于配置<code>CORS</code>的，针对一个类，它会作用于该类的所有方法</p>
<ul>
<li><code>origin</code>属性包括它允许的来源域</li>
<li><code>originPatterns</code>属性包括它允许被获取的<code>URI</code></li>
<li><code>methods</code>属性包括它允许的请求方法</li>
<li><code>allowedHeaders</code>和<code>exposedHeaders</code>：允许/不允许请求所包含的请求头</li>
<li><code>maxAge</code>：秒为单位的<code>CORS</code>配置有效时间</li>
</ul></li>
<li><p>除了注解配置，还可以基于<code>Java</code>配置，仍然是<code>WebMvcConfigurer</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">      registry.allowedOrigins(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">              .addMappings(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">              .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>)</span><br><span class="line">              .allowedHeaders(HttpHeaders.LOCATION)</span><br><span class="line">              .exposedHeaders(HttpHeaders.ACCEPT)</span><br><span class="line">              .maxAge(<span class="number">3600</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模型与视图">模型与视图</h2>
<h3 id="model接口"><code>Model</code>接口</h3>
<ul>
<li><code>Model</code>类似<code>ServletRequest</code>的属性在<code>Servlet</code>应用中的作用，用于管理单个请求范围内的由后端程序设置的属性</li>
<li><code>Model</code>提供<code>addAttribute(String, Object)</code>和<code>getAttribute(String, Object)</code>和<code>containsAttribute(String)</code>三个常用的属性相关方法
它不像<code>ServletRequest</code>那样提供删除属性的方法，因为<code>Model</code>的生命周期较短，设计者认为不需要删除属性</li>
<li><code>Model</code>实例通常不需要开发者自己创建，而是由<code>Spring</code>容器自动创建并注入为参数</li>
</ul>
<h3 id="modelandview类"><code>ModelAndView</code>类</h3>
<ul>
<li><code>ModelAndView</code>类通常作为一个返回视图的方法的返回值，需要开发者自己创建，是<code>Model</code>结合返回值<code>String</code>的一个替代选择，它包揽了<code>Model</code>以及返回视图的功能，算是一种风格上的不同
即使在前后端结合的应用中，它也不常用，因为它不止返回视图，还返回其中添加的属性</li>
<li>它提供<code>addObject(String, Object)</code>、<code>setViewName(String)</code></li>
</ul>
<h2 id="注解式声明">注解式声明</h2>
<h3 id="controller声明"><code>Controller</code>声明</h3>
<ul>
<li><code>@ResponseBody</code>类/方法级注解，注解类时表示该类的所有方法的返回值不应经过<code>ViewResolver</code>，而是作为响应体返回；注解方法时只表示该特定方法的返回值不经过<code>ViewResolver</code></li>
<li><code>@Controller</code>类级注解：标识该类是传统的控制器类，通常作为页面控制器而存在，虽然返回值允许多个类型，但期望返回<code>String</code>，表示视图类型，然后<code>ViewResolver</code>会解析它为视图</li>
<li><code>@RestController</code>类级注解：标识该类是现代的前后端分离的控制器类，通常作为数据接口，即<code>API</code>控制器而存在，期望返回<code>ResponseEntity&lt;T&gt;</code>或其它类型，表示数据
<code>@RestController</code>本质是<code>@Controller</code>加上<code>@ResponseBody</code>注解，后者表示该类的方法返回的是数据本身而不是一个视图，不应经过<code>ViewResolver</code>解析</li>
<li><code>@ControllerAdvice</code>类级注解：表示该类中定义的<code>ExceptionHandler</code>方法会应用于全局的<code>Controller</code>类</li>
<li><code>@RestControllerAdvice</code>类级注解：等价于<code>@ControllerAdvice</code>加上<code>@ResponseBody</code>注解</li>
</ul>
<h3 id="url映射"><code>URL</code>映射</h3>
<ul>
<li><p><code>@RequestMapping</code>：通常作为类级注解，<code>value</code>表示映射到的<code>URL</code>路径，<code>method</code>表示请求方法</p></li>
<li><p>针对方法，在<code>@RequestMapping</code>的基础上有若干的扩展注解，即<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>等，它们规定了<code>@RequestMapping</code>的<code>method</code>属性，会继承来自类级<code>@RequestMapping</code>的映射路径，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">  <span class="comment">// 访问/api/obj时会重定向到此</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/obj&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>@RequestMapping</code>除<code>value</code>(<code>URL</code>路径)以外，还有若干属性用于缩小一个方法对应的<code>URL</code>范围</p>
<ul>
<li><code>consumes</code>属性：指定该方法能处理的请求的数据类型，例如<code>consumes={"application/json"}</code>，它会自动解析<code>Content-Type</code>请求头</li>
<li><code>produces</code>属性：指定该方法响应的数据类型，例如<code>produces={"application/json"}</code>，它会自动解析<code>Accept</code>请求头</li>
<li><code>params</code>属性：限定该方法接受请求所带的参数，例如<code>params={"a", "!a", "a=b"}</code>，<code>"a"</code>表示检测请求是否带<code>a</code>参数，<code>!a</code>表示检测请求是否不带<code>a</code>参数，<code>a=b</code>表示检测请求里的<code>a</code>参数是否等于<code>b</code></li>
<li><code>headers</code>属性：限定该方法接受请求所带的请求头，格式和<code>params</code>类似</li>
</ul></li>
<li><p>除了<code>*</code>以及<code>**</code>通配符以外，<code>Spring</code>提供<code>?</code>以及<code>{}</code>捕获功能</p>
<ul>
<li><code>?</code>匹配任意单个字符</li>
<li><code>{variable}</code>：将该部分路径信息捕获，赋给<code>variable</code>模板参数，可以通过<code>@PathVariable</code>获取</li>
<li><code>{variable:regex}</code>：仅将能成功匹配<code>regex</code>正则表达式的<code>URL</code>交给该方法处理，并将该部分路径赋给<code>variable</code>
因为在<code>java</code>中，使用<code>regex</code>与<code>PCRE</code>不同，例如<code>\</code>需要<code>\\</code>转义</li>
<li>类型转换由<code>Spring</code>提供，需要目标参数的类型能通过单个<code>String</code>对象构造</li>
</ul></li>
</ul>
<h3 id="允许自动注入的方法参数">允许自动注入的方法参数</h3>
<ul>
<li>虽然允许直接注入<code>ServletRequest</code>、<code>ServletResponse</code>等<code>Servlet API</code>，但通常没有必要</li>
<li><code>InputStream</code>、<code>Reader</code>、<code>OutputStream</code>、<code>Writer</code>：从<code>Servlet API</code>获取的流对象</li>
<li><code>Model</code>：获取当前请求的整个模型实例</li>
<li><code>Spring</code>核心提供的类型转换十分强大，以下注解获取的数据只要能进行转换(包括<code>json</code>数据)，就能自动注入为各种非<code>String</code>类型的参数值
甚至可以自定义<code>Converter</code>并注册，以实现自定义转换的功能</li>
<li><strong><code>@PathVariable</code></strong>：获取对应的从<code>URL</code>中捕获的参数</li>
<li><code>@MatrixVariable</code>：获取从<code>URL</code>最后由<code>;</code>分割的名值对
例如<code>/api/a;name1=value1,value2;name2=value3</code>，不同名值对由<code>;</code>分割、同一名值对的多个值由<code>,</code>分割</li>
<li><strong><code>@RequestParam("paramName")</code></strong>：获取对应的请求参数，若为<code>POST</code>则只能获取表单或<code>multipart</code>参数</li>
<li><strong><code>@RequestHeader("headerName")</code></strong>：获取对应的请求头的值</li>
<li><strong><code>@CookieValue("cookieName")</code></strong>：获取对应的<code>Cookie</code>值</li>
<li><strong><code>@RequestBody</code></strong>：获取对应的请求体</li>
<li><code>@RequestPart</code>：获取<code>multipart</code>请求体的一个<code>part</code></li>
<li><strong><code>@ModelAttribute("attr")</code></strong>：获取模型中，属性名为<code>attr</code>的值</li>
<li><code>@SessionAttribute("attr")</code>：获取当前会话的属性<code>attr</code>的值</li>
<li><code>@RequestAttribute("attr")</code>：获取当前请求中存的属性<code>attr</code>的值</li>
<li>其它方法参数，若不带任意注解且不是上述的任意类型，若为简单类型则解析为<code>@RequestParam</code>，否则解析为<code>@ModelAttribute</code></li>
</ul>
<h3 id="返回值类型">返回值类型</h3>
<ul>
<li><code>ResponseEntity&lt;T&gt;</code>：完整的由开发者决定的响应体
<ul>
<li>调用一个指定了状态码的静态方法，创建一个<code>ResponseEntity.BodyBuilder</code>或<code>ResponseEntity.HeadersBuilder</code>创建者：
<code>status(HttpStatusCode)</code>：指定任意状态码，创建一个响应报文
<code>ok()</code>：等价于<code>status(200)</code>，服务器成功返回网页
<code>accept()</code>：等价于<code>status(202)</code>，服务器接受但尚未处理
<code>basRequest()</code>：等价于<code>status(400)</code>
<code>notFound()</code>：创建一个仅含响应头的响应报文<code>Builder</code>
<code>internalServerError()</code>：等价于<code>status(500)</code></li>
<li><code>HeadersBuilder</code>接口包含以下方法：
<code>build()</code>：创建<code>ResponseEntity</code>
<code>header(String, String)</code>以及<code>headers(HttpHeaders)</code>：添加响应头</li>
<li><code>BodyBuilder</code>继承<code>HeaderBuilder</code>接口，此外包含以下方法：
<code>contentType(String)</code>：设置响应体数据类型
<code>contentLength(long)</code>：设置响应体大小
<code>body(T)</code>：设置响应体，会自动由<code>Converter</code>序列化</li>
</ul></li>
<li><code>void</code>：方法参数必须包含输出流或<code>ServletResponse</code>，此时表示<code>Spring</code>认为请求在该方法内部完成了处理，返回值为<code>void</code></li>
<li><code>@ModelAttribute</code>：它在修饰参数时表示获取，而在修饰方法时表示方法的返回值会添加到该请求的<code>Model</code>里而不是返回</li>
<li><code>String</code>、<code>View</code>、<code>ModelAndView</code>：返回字符串表示的视图、自己创建的视图、绑定了一些属性的视图</li>
</ul>
<h3 id="异常处理">异常处理</h3>
<ul>
<li>由<code>@ExceptionHandler</code>注解修饰的方法用于处理来自<code>Controller</code>类的异常，它不需要<code>@RequestMapping</code></li>
<li>其接受的方法参数在大多数情况应该是某一个异常类型</li>
<li>其方法的返回值类型规则与一般的<code>@RequestMapping</code>方法一致</li>
<li><code>@ExceptionHandler</code>允许设置一系列异常类的<code>class</code>属性，表示只会接受这些类型的异常</li>
<li>在<code>@Controller</code>类、<code>@RestController</code>类中定义的异常处理器只作用于其所在类的其它方法抛出的异常</li>
<li>在<code>@ControllerAdvice</code>类、<code>@RestControllerAdvice</code>类中定义的异常处理器作用于所有的<code>Controller</code>类</li>
</ul>
<h2 id="其它工具类">其它工具类</h2>
<ul>
<li><code>org.springframework.http.HttpStatus</code>：包含一系列状态码的枚举</li>
<li><code>org.springframework.http.MediaType</code>：包含一系列数据类型常量，包括可以用<code>parseMediaType(String)</code>将其中没有提供的数据类型显式转换为<code>MediaType</code></li>
<li><code>org.springframework.http.HttpHeaders</code>：包含一系列请求头、响应头的常量以及设置方法</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Spring framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>webapp</tag>
        <tag>Spring</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java EE: Bean Validation</title>
    <url>/blogs/2025/07/11/java-bean-validation/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1
id="jakarta-ee-validation-api"><code>Jakarta EE Validation API</code></h1>
<h2 id="简介">简介</h2>
<ul>
<li><p><code>Bean Validation</code>有多套标准，最早是<code>JSR 303</code>的<code>Bean Validation 1.0</code>，现今流行的是<code>Java EE 8</code>的<code>Bean Validation 2.0</code>，即<code>JSR 380</code>标准</p></li>
<li><p><code>Bean Validation</code>通过注解作用于属性字段上，在运行时进行验证</p>
<p>需要说明的是，<code>JPA</code>规范的<code>@Id</code>、<code>@UniqueConstraint</code>等是在生成<code>SQL</code>时额外添加约束，这个约束是数据库层面上的，因此只有在保存、更新、删除时会检查值的有效性</p>
<p>而<code>Bean Validation</code>作用于<code>Java</code>内存中，<strong>给标识符赋值</strong>的时候，例如<code>@NotNull</code>注解规定该标识符不能被赋予<code>null</code>，这种约束的检查是在<code>JVM</code>内部进行的，没有用到外部的软件</p>
<p>添加<code>Bean Validation</code>，有助于在更早的时候发现问题，而对于没有问题的操作，<code>Validation</code>的开销并不大，对于<code>Validation</code>无法发现的问题，数据库的约束则是最后一层保障</p></li>
<li><p>接口依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>hibernate</code>实现(包含接口依赖)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>可能使用到<code>el</code>表达式</p></li>
</ul>
<h2 id="验证注解">验证注解</h2>
<h3 id="验证的通用属性">验证的通用属性</h3>
<ul>
<li><p><code>message</code>：验证失败时，将自动抛出<code>ConstraintViolationException</code>或<code>MethodArgumentNotValidException</code>异常，它们会包含该<code>message</code></p>
<p><code>message</code>支持有限的<code>EL</code>表达式，默认会是<code>{jakarta.validation.constraints.ConstrantName.message}</code>这个<code>EL</code>表达式，是配置文件里设置的</p></li>
<li><p><code>groups</code>：指定<code>Class&lt;?&gt;[]</code>，表示这个验证注解所属的分组类(可有多组)</p>
<p>在验证时，使用<code>validate(bean, Class...)</code>，只会检验<code>bean</code>中属于<code>Class</code>的验证注解的字段</p>
<p>默认为<code>jakarta.validation.groups.Default</code>，<code>validate()</code>若不指定组则默认检验属于<code>Default</code>组的验证</p></li>
<li><p><code>payload</code>：指定<code>Class&lt;? extends Payload&gt;[]</code>，定义<code>payload</code>后，发生异常时可从异常中通过<code>getPayload()</code>获取<code>payload</code>信息</p>
<p>通常用于定义一些元数据，例如便于分类地处理异常，例如按严重程度、按业务逻辑</p></li>
<li><p><code>@Xxx.List</code>子注解：指定<code>@Xxx</code>(同类型验证注解)数组，便于对同一类注解但不同的验证条件赋予不同的<code>message</code></p></li>
</ul>
<h3 id="空值安全">空值安全</h3>
<ul>
<li><strong>只有以下注解会针对<code>null</code>，其它注解将始终视<code>null</code>为合法的</strong></li>
<li><code>@NotNull/@Null</code>：针对任意<code>Object</code>，不允许/必须为<code>null</code></li>
<li><code>@NotBlank</code>：针对任意<code>CharSequence</code>，必须不为<code>null</code>且必须包含非空白字符，即不为空、不含<code>Unicode</code>空白字符(空格、制表符、换行符、回车符、换页符)</li>
<li><code>@NotEmpty</code>：针对任意<code>CharSequence</code>、<code>Collection</code>、<code>Map</code>、<code>Array</code>，必须不为<code>null</code>且不为空</li>
</ul>
<h3 id="数值检查">数值检查</h3>
<ul>
<li><p><code>@AssertTrue/@AssertFalse</code>：针对<code>boolean</code>或<code>Boolean</code>，必须为<code>True/False</code></p></li>
<li><p><code>@Min(value)/@Max(value)</code>：针对<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>以及它们的包装类，检查其最小值/最大值，<code>value</code>值是<code>long</code></p>
<p><code>double</code>和<code>float</code>因为取整误差，不被支持设置<code>@Min</code>和<code>@Max</code></p></li>
<li><p><code>@DecimalMin(value)/@DecimalMax(value)</code>：类似<code>@Min(value)/@Max(value)</code>，但是<code>value</code>是<code>String</code>，会被转化为<code>BigDecimal</code>表示</p>
<p>此外，额外含有一个<code>inclusive</code>布尔属性，表示是否包含边界</p></li>
<li><p><code>@Negative/@NegativeOrZero/@Positive/@PositiveOrZero</code>：针对<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>以及它们的包装类，检查其是否为负/非正/正/非负数，因为只需要判零以及符号，所以支持<code>float</code>和<code>double</code></p></li>
<li><p><code>@Digits(integer, fraction)</code>：针对<code>BigDecimal</code>，<code>BigInteger</code>，<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>以及它们的包装类，以及任意的<code>CharSequence</code>，检查整数位数<code>&lt;= integer</code>，小数位数<code>&lt;= fraction</code></p></li>
<li><p><code>@Size(min = 0, max = Integer.MAX_VALUE)</code>：针对任意<code>CharSequence</code>、<code>Collection</code>、<code>Map</code>、<code>Array</code>，其元素个数必须在<code>[min, max]</code>内，允许为<code>null</code></p></li>
</ul>
<h3 id="特殊类型">特殊类型</h3>
<ul>
<li><p><code>@Pattern(regexp, flags = {})</code>：针对任意<code>CharSequence</code>，检查其是否符合<code>java.util.regex.Pattern</code>的检查</p>
<p><code>regexp</code>与<code>java.util.regex.Pattern</code>的规则一致，<code>flags</code>则是<code>@Flag[]</code>，表示检查模式，与<code>java.util.regex.Pattern</code>内部定义的标志位一致，以注解形式成为元数据的一部分</p></li>
<li><p><code>@Email(regexp = ".*", flags = {})</code>：提供一个默认的邮箱正则表达式规则，可以使用自定义的<code>regexp</code>覆盖原有表达式</p></li>
<li><p><code>@URL(protocal="", host="", port=-1, regexp=".*", flags={})</code>：针对任意<code>CharSequence</code>，检查其是否符合<code>java.net.URL</code>的构造方法的验证，可自定义协议名称、主机名称、端口号，以及可以覆盖<code>@Pattern</code>提供的<code>regexp</code>和<code>flags</code>来自定义匹配规则</p></li>
<li><p><code>@Future/@FutureOrPresent/@Past/@PastOrPresent</code>：针对任意<code>java.time</code>以及<code>java.time.chrono</code>的日期/时间类对象，检查是否是未来/未来或现在/过去/过去或现在的时间，<code>Now</code>这个对象基于<code>JVM</code>以及现在的时区来获取，具体到时间</p>
<p>这里的<code>Present</code>的含义会因为针对的类型而变化，例如针对<code>Year</code>对象，<code>Present</code>视整一年为合法的“现在”，而不需要完全和<code>Now</code>一致</p></li>
<li><p><strong><code>@Valid</code></strong>：空注解，针对任意类型的对象，可以注解一个方法、一个方法的参数、一个类的属性，表示对返回值、参数值、属性值进行级联验证，即检查到这个对象时，会同时检查该对象的所有属性，但只会级联一层，不会深入到属性的属性(除非又有<code>@Valid</code>)，例如<code>@Valid List&lt;@Valid ElementType&gt;</code>，这样才会级联到<code>ElementType</code>的属性</p></li>
</ul>
<h2 id="验证器">验证器</h2>
<ul>
<li><p>所有注解在针对<strong>方法参数以及方法</strong>时，必须依赖<code>Spring</code>的<code>IoC</code>容器或其它<code>CDI</code>框架的实现，才是有用的(能自动校验)</p>
<p>否则，在一般的<code>Hibernate</code>或其它实现中，必须依靠验证器，由开发者在代码中显式地校验</p></li>
<li><p><code>Validator</code>接口：</p>
<ul>
<li><code>validate(T obj, Class&lt;?&gt;... groups)</code>：验证<code>obj</code>的所有属性</li>
<li><code>validateProperty(T obj, String pName, Class&lt;?&gt;...)</code>：验证其特定属性</li>
<li><code>validateValue(T obj, String pName, Object value, Class&lt;?&gt;...)</code>：验证<code>value</code>是否符合其某个字段的约束</li>
</ul></li>
<li><p><code>ConstraintViolation&lt;T&gt;</code>接口：所有上述验证方法的返回值是<code>Set&lt;ConstraintViolation&gt;</code>，表示出现冲突的约束信息</p>
<ul>
<li><code>getMessage()</code>：获取错误信息</li>
<li><code>getRootBean()</code>：获取根对象</li>
<li><code>getLeafBean()</code>：获取出错的对象</li>
<li><code>getConstraintDescriptor()</code>：获取约束描述符</li>
</ul></li>
<li><p><code>ConstraintDescriptor</code>：约束描述符</p>
<ul>
<li><code>getPayload()</code>：获取<code>payload</code></li>
</ul></li>
</ul>
<h2 id="hibernate实现下的扩展"><code>Hibernate</code>实现下的扩展</h2>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>validation</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习: 激活函数</title>
    <url>/blogs/2025/07/09/deeplearning-activeFuncs/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="激活函数">激活函数</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>激活函数是神经网络中十分重要的一部分，用于对线性叠加后的输出添加非线性因素，增大模型容量，实现对非线性问题的拟合</li>
<li>通常激活函数会<strong>限制</strong>输出的<strong>值域</strong>，控制均值
如果一个结点的激活值为零(或接近零)，则它对下一层所有结点的贡献均为零(或很小)，形象地称该神经元死亡</li>
<li>激活函数应该满足：<strong>非线性</strong>、连续<strong>可导</strong>、部署在隐藏层和输出层中</li>
</ul>
<h3 id="常见激活函数">常见激活函数</h3>
<ul>
<li><code>Sigmoid</code>(又称<code>Logistic</code>)：<span
class="math inline">$\begin{align}\sigma(x)=\frac1{1+e^{-x}}、\sigma'(x)=\frac{e^{-x}}{(1+e^{-x})^2}=\sigma(x)(1-\sigma(x))\end{align}$</span>
<ul>
<li>定义域为<span class="math inline">(−∞,+∞)</span>，值域为<span
class="math inline">(0,1)</span>，是一种二分类函数</li>
<li>性质：严格单调递增、输出范围有界且狭小</li>
<li>缺点：
<ul>
<li>输入的绝对值较大时，输出达到饱和，对输入变化不敏感，容易丢失这部分的梯度信息</li>
<li>输出恒大于零，意味着均值不为零，将导致后续神经元的输入也是非零均值的</li>
</ul></li>
</ul></li>
<li><code>Tanh</code>(双曲正切)：<span
class="math inline">$\begin{align}\tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}=2\sigma(x)-1\end{align}$</span>
<ul>
<li>定义域为<span class="math inline">(−∞,+∞)</span>，值域为<span
class="math inline">(−1,1)</span></li>
<li>解决了<code>Sigmoid</code>函数非零均值的问题</li>
</ul></li>
<li><code>ReLU</code>(<code>Rectified linear unit</code>，整流线性单元)：<span
class="math inline">$f(x)=\max(0,x)、f'(x)=\begin{cases}1,&amp;x&gt;0\\0,&amp;x\le0\end{cases}$</span>
<ul>
<li>是最常用的激活函数</li>
<li>性质：计算简单、求导简单、正输入的输出不会饱和</li>
<li>缺点：
<ul>
<li>非零均值</li>
<li><code>Dead ReLU</code>(神经元坏死)：负输入的输出为零，容易导致死一大片神经元</li>
</ul></li>
</ul></li>
<li><code>Leaky ReLU</code>：<span
class="math inline">$\begin{align}&amp;f(x)=\max(\alpha
x,x),&amp;\alpha\text{为十分小的固定正数}\end{align}$</span>
<code>PReLU</code>：<span
class="math inline">$\begin{align}&amp;f(x)=\max(\alpha
x,x),&amp;\alpha\text{为十分小的正数,可在学习过程中改变}\end{align}$</span>
<ul>
<li>负输入的输出将向下渗漏，不恒为零</li>
<li>前者的参数是固定的，使函数近似线性，后者的<span
class="math inline"><em>α</em></span>则为超参数</li>
</ul></li>
<li><code>ELU</code>：<span
class="math inline">$f(x)=\begin{cases}x,&amp;x&gt;0\\\alpha(e^x-1),&amp;x\le0\end{cases}$</span></li>
<li><code>Softmax</code>：</li>
</ul>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java EE: JPA</title>
    <url>/blogs/2025/07/09/java-jpa/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1
id="jakarta-persistence-api"><code>Jakarta Persistence API</code></h1>
<h2 id="介绍">介绍</h2>
<ul>
<li><p><code>JPA</code>是一套<code>API</code>规范，从<code>EJB</code>中分离出来，是持久层的流行<code>API</code></p></li>
<li><p>单纯引入<code>JPA</code>是没用的，其著名实现有<code>Hibernate</code>等，</p></li>
<li><p><code>Spring Data JPA</code>不是<code>JPA</code>的实现，而是基于<code>JPA</code>的一套<code>Repository</code>接口</p></li>
<li><p><code>JPA</code>定义了一套<code>ORM</code>框架，使<code>POJO</code>得以和关系联系起来</p></li>
<li><p>接口依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.persistence-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>hibernate</code>实现依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.4.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="核心组件">核心组件</h2>
<h3 id="persistence"><code>Persistence</code></h3>
<ul>
<li><code>Persistence</code>用于获取<code>EntityManagerFactory</code></li>
<li>配置：</li>
</ul>
<h3
id="entitymanager与entitymanagerfactory"><code>EntityManager</code>与<code>EntityManagerFactory</code></h3>
<ul>
<li><code>EntityManagerFactory</code>全局单例且线程安全，用于获取<code>EntityManager</code></li>
<li><code>EntityManager</code>接口管理对象的持久化操作，定义了四种实体状态：
<ul>
<li><code>Transient</code>：新建状态</li>
<li><code>Managed</code>：托管状态</li>
<li><code>Detached</code>：分离状态</li>
<li><code>Removed</code>：移除状态</li>
</ul></li>
<li><code>EntityManager</code>实例包含以下方法：
<ul>
<li><code>persist(T)</code>：准备保存实体，会生成实体的主键，但可能直到<code>flush</code>才保存</li>
<li><code>find(Class&lt;T&gt;, Object pk)</code>：立即加载获取指定主键(第二个参数)的对象</li>
<li><code>getReference(Class&lt;T&gt;, Object pk)</code>：获取一个实体代理，只有在访问时才查询</li>
<li><code>merge(T)</code>：合并分离出去的实体，返回托管实体(传进去的实体仍是分离状态)</li>
<li><code>remove(T)</code>：删除实体</li>
</ul></li>
</ul>
<h3 id="entitytransaction"><code>EntityTransaction</code></h3>
<ul>
<li>用于事务管理</li>
</ul>
<h2 id="基于注解的orm配置">基于注解的<code>ORM</code>配置</h2>
<h3 id="单表注解">单表注解</h3>
<ul>
<li><p><code>@Entity</code>注解一个<code>POJO</code>类是实体类</p></li>
<li><p><code>@Table</code>注解一个实体类所对应的关系，若不使用，则<code>@Entity</code>注解类的默认表名为类名的全大写</p>
<p>在该注解内定义约束等类似<code>SQL</code>中在属性外的表内定义约束</p>
<ul>
<li><code>name</code>：指定表名</li>
<li><code>schema</code>：指定模式</li>
<li><code>catalog</code>：指定表所属的目录</li>
<li><code>uniqueConstraints</code>：指定表的唯一性约束</li>
<li><code>indexes</code>：指定表的索引</li>
<li><code>check</code>：指定表的检查约束</li>
</ul></li>
<li><p><code>@UniqueConstraint</code>注解表示一个唯一性约束，在<code>@Table</code>的<code>uniqueConstraints</code>中起作用</p>
<ul>
<li><code>name</code>：约束名</li>
<li><code>columns</code>：受约束的属性组</li>
</ul></li>
<li><p><code>@Index</code>注解表示一个索引，在<code>@Table</code>的<code>indexes</code>中起作用</p>
<ul>
<li><code>name</code>：索引名</li>
<li><code>columnList</code>：属性组，是一个字符串，不同属性由<code>,</code>连接</li>
</ul></li>
<li><p><code>@CheckConstraint</code>注解表示一个检查约束，在<code>@Table</code>的<code>check</code>中起作用</p>
<ul>
<li><code>name</code>：约束名</li>
<li><code>constraint</code>：一个本地<code>SQL</code>约束</li>
</ul></li>
<li><p><code>@Id</code>注解作用于属性，标明一个主键</p></li>
<li><p><code>@GeneratedValue</code>：作用于被<code>@Id</code>注解的属性，标明如何初始化主键值，<code>strategy</code>属性有以下选择</p>
<ul>
<li><code>GenerationType.AUTO</code>(默认)策略：根据具体的数据库，自适应策略</li>
<li><code>GenerationType.IDENTITY</code>(常用)策略：依赖数据库的<code>AUTO_INCREMENT</code>(或其他)自增</li>
<li><code>GenerationType.SEQUENCE</code>(可能高性能)策略：依赖数据库的序列，需要配置<code>@GeneratedValue</code>的<code>generator</code>属性</li>
<li><code>GenerationType.UUID</code>(特殊场景)策略：依赖<code>UUID</code>生成器</li>
</ul>
<p>定义<code>@GeneratedValue</code>后，允许使用不带主键参数的构造方法</p></li>
<li><p><code>@Transient</code>注解作用于属性，标明这个属性永远不会被持久化</p></li>
<li><p><code>@Column</code>注解作用于属性，是数据库的列映射</p>
<ul>
<li><code>name</code>：指定属性映射的列名，默认为属性名</li>
<li><code>unique</code>：布尔值，标识是否唯一</li>
<li><code>nullable</code>：布尔值，标识是否允许为<code>null</code></li>
<li><code>columnDefinition</code>：指定本地<code>SQL</code>为该列的定义，而不是使用<code>JPA</code>生成</li>
<li><code>length</code>：指定长度</li>
<li><code>check</code>：同<code>@Table</code>的<code>check</code></li>
</ul></li>
<li><p><code>@Version</code>：表示该对象应使用乐观锁来查询/更新，若在事务中发现冲突则会抛出<code>OptimisticLockException</code></p></li>
</ul>
<h3 id="属性组主键注解">属性组主键注解</h3>
<ul>
<li><p>大部分约束，例如唯一性约束、检查约束、非空约束，由之前介绍的注解可以覆盖大部分场景(包括属性组的约束)</p>
<p>但依靠上述注解无法使一个属性组作为主键</p></li>
<li><p><code>@Embeddable</code>注解标明一个类是可嵌入的</p>
<p>该类的所有属性不需要<code>@Column</code>注解，且该类不需要<code>@Table</code>以及<code>@Entity</code>注解，应该作为一个普通的<code>POJO</code>，只是多了一个<code>@Embeddable</code></p>
<p>为了方便作为主键，需要<strong>覆写<code>equals()</code>与<code>hashCode()</code>方法，且实现<code>Serializable</code>空接口</strong></p></li>
<li><p><code>@EmbeddedId</code>注解标明一个属性是主键，且类型是一个<code>@Embeddable</code>类，可用于属性组为主键的场景</p>
<p>默认不支持<code>AUTO</code>、<code>IDENTITY</code>的策略生成嵌入主键，可以使用<code>SEQUENCE</code>策略</p></li>
<li><p><code>@Embedded</code>注解标明一个属性的类型是一个<code>@Embeddable</code>类</p>
<p><code>JPA</code>转化为<code>DDL</code>语句时，会检测所有的<code>Embedded</code>属性，将该类的每个属性就像一般属性那样写成<code>SQL</code></p></li>
<li><p>默认情况下，<code>@Embeddable</code>类中的所有属性对应的列名就是属性名，就像没有添加<code>@Column</code>注解的一般属性那样</p>
<p>在作为实体类的属性时，建议用<code>@AttributeOverride</code>注解清晰地决定映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;embed_demo&quot;, schema = &quot;demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmbedEntity</span> &#123;</span><br><span class="line">    <span class="meta">@Embeddable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbedId</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Long uid;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="comment">// 重写 equals() hashCode() ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EmbeddedId</span></span><br><span class="line">    <span class="meta">@AttributeOverrides(&#123;</span></span><br><span class="line"><span class="meta">        @AttributeOverride(name = &quot;uid&quot;, column = @Column(name = &quot;uid&quot; /** 其它约束 */</span></span><br><span class="line"><span class="meta">        )),</span></span><br><span class="line"><span class="meta">        @AttributeOverride(name = &quot;username&quot;, column = @Column(name = &quot;username&quot;))</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">private</span> EmbedId id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="meta">@AttributeOverrides(&#123;</span></span><br><span class="line"><span class="meta">        @AttributeOverride(name = &quot;uid&quot;, column = @Column(name = &quot;parent_uid&quot; /** 其它约束 */</span></span><br><span class="line"><span class="meta">        )),</span></span><br><span class="line"><span class="meta">        @AttributeOverride(name = &quot;username&quot;, column = @Column(name = &quot;parent_username&quot;))</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">private</span> EmbedId pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多表关联注解">多表关联注解</h3>
<ul>
<li><p><code>@JoinColumns</code>注解包含多个<code>@JoinColumn</code>，表示一个属性有多个外键依赖</p></li>
<li><p><code>@JoinColumn</code>注解表示一个属性是外键，这样的属性其类型应是一个<code>@Entity</code>类(或是一个列表包含<code>@Entity</code>类)而不应该是引用的属性的类型，<code>JPA</code>会将这个实体类视为外表，在其中查找外键</p>
<ul>
<li><code>name</code>：该属性在本表的列名</li>
<li><code>referencedColumnName</code>：该属性所引用的其它表的列名</li>
<li><code>foreignKey</code>：具体的外键细节</li>
<li><code>unique</code>：一般来说，外键是和其它表的主键相关联的，因此不需要设置<code>unique</code>属性，只需要知道遇到其它情况时记得设置<code>unique=true</code>即可</li>
</ul></li>
<li><p><code>@ForeignKey</code>注解在<code>@JoinColumn</code>的<code>foreignKey</code>中起作用</p>
<ul>
<li><code>name</code>：外键约束名</li>
<li><code>foreignKeyDefinition</code>：使用本地<code>DDL</code>定义外键</li>
</ul></li>
<li><p><code>@JoinTable</code>是用于生成中间表的注解，通常配合<code>@ManyToMany</code>一起使用，它包括<code>@Table</code>的所有属性，同时多出若干属性用于拆解多对多关系</p>
<ul>
<li><code>joinColumns</code>：指向己方实体的外键列，由若干<code>@JoinColumn</code>组成<code>@JoinColumn</code>里的<code>name</code>定义中间表的列名，<code>referencedColumnName</code>指向己方表的列名</li>
<li><code>inverseJoinColumns</code>：指向对方实体的外键列，类似<code>joinColumns</code>，只不过<code>referencedColumnName</code>指向对方表的列名</li>
<li><code>foreignKey</code>与<code>inverseForeignKey</code>：类似<code>@JoinColumn</code>的<code>foreignKey</code></li>
</ul></li>
<li><p><code>@MapsId</code>、<code>@PrimaryKeyJoinColumns</code>、<code>@PrimaryKeyJoinColumn</code>：</p>
<p>有时，一个实体的外键不仅是被引用表的主键，而且是引用表的主键(例如为了满足范式要求而拆表)，即它们共享主键</p>
<p><code>@MapsId</code>支持使用共享主键，<code>value</code>属性默认是被引用表的主键列名，使用<code>@MapsId</code>后，本实体类的<code>@Id</code>属性自动关联到被引用表的主键上，因此不需要<code>@GeneratedValue</code>注解也能使用不含主键参数的构造方法</p>
<p>我们知道<code>@JoinColumn</code>等注解是会体现在<code>JPA</code>生成的<code>DDL</code>中的，但在共享主键的场景下，<code>@Id</code>属性就是外键，此时如果希望通过对象引用导航到主实体的实例上，就可以使用<code>@PrimaryKeyJoinColumn</code>和<code>@PrimaryKeyJoinColumns</code>注解，它们和一般的<code>@JoinColumn</code>注解的唯一区别是：<code>DDL</code>不会带有多余的外键列</p></li>
<li><p>数据库的映射基数有四种：一对一、一对多、多对一、多对多，其中只有多对多需要使用中间表，其它在由<code>ER</code>图转化为关系模式时都可变作“多”那方的外键引用“一”那方的主键</p>
<p>在<code>JPA</code>中，有点反直觉的是，外键是整个被引用实体的引用而不是这个实体的主键类型</p>
<p>特别是在双向关联的场景下，如果仅靠<code>@JoinColumn</code>或<code>@JoinTable</code>注解，<code>JPA</code>将只知道有关联，但不知道返回值的数量，无法使<code>JPA</code>知道对方是多方还是一方，己方是多方还是一方，那么对象导航(绑定)就无法进展下去(无法知道返回的是<code>List&lt;T&gt;</code>还是单纯作为一个实体类来解析)</p>
<p>综上，联系类型的注解是很有必要的，且多对多<code>@ManyToMany</code>需要配合<code>@JoinTable</code>，而<code>@ManyToOne</code>、<code>@OneToOne</code>需要配合<code>@JoinColumn</code>，<code>@OneToMany</code>通常不和任何列映射注解配合使用</p></li>
<li><p><code>@OneToOne</code>注解：表示一对一注解</p>
<p>两个<code>@OneToOne</code>可配对实现双向关联，其中一方为<code>@JoinColumn+@OneToOne(optional=...)</code>、另一方为<code>@OneToOne(mappedBy=...)</code></p>
<ul>
<li><p><code>cascade</code>：设置级联的操作</p></li>
<li><p><code>fetch</code>：设置级联操作的时机</p></li>
<li><p><code>optional</code>：设置参与度约束，默认为<code>true</code>，即允许为<code>null</code></p>
<p>在数据库中，设置参与度约束是通过将外键设置为<code>NOT NULL</code>限制的</p></li>
<li><p><code>orphanRemoval</code>：设置关系断开的级联操作，即在主控方断开关联后后是否级联地删除关系另一方的相应记录</p></li>
<li><p><code>mappedBy</code>：通常用于双向关联的场景，主控方若想要维护一个反向的对象导航，不需要(也不应该)像外键持有方那样使用<code>@JoinColumn</code>，而是使用<code>mappedBy</code>属性</p>
<p>在这种场景下，反向导航不会被数据库存储，即这个属性不是一个<code>@Column</code>或<code>@JoinColumn</code>属性，而是一个仅由<code>JPA</code>根据<code>mappedBy</code>获取的反向引用</p>
<p><code>mappedBy</code>属性的值是对方实体的属性名，而不是对方表的列名</p></li>
</ul></li>
<li><p><code>@OneToOne</code>注解包含所有映射基数注解的所有属性，因为外键方可以是任意一方，所以有<code>optional</code>属性，又因为被引用的那方可以是任意一方，所以有<code>mappedBy</code>属性</p>
<p>在一对多或多对一的映射基数上，多方一般是持有外键的那方，所以<code>@OneToMany</code>只有<code>mappedBy</code>(因为一方不持有外键)、<code>@ManyToOne</code>只有<code>optional</code>(因为多方持有外键，外键可选)</p>
<p>此外，<code>@OneToMany</code>注解属性的类型应该是一个集合，例如<code>List</code></p>
<p><code>@OneToMany(mappedBy=...)</code>和<code>@JoinColumn+@ManyToOne(optional=...)</code>配对实现双向关联</p></li>
<li><p><code>@ManyToMany</code>是一个特殊的映射基数，它只有<code>mappedBy</code>属性，因为在数据库中，多对多的映射基数需要<strong>借助中间表</strong>，这个中间表持有两个外键，从而将<code>@ManyToMany</code>拆成两个<code>@OneToMany</code></p>
<ul>
<li><p>单向关联：如果不使用<code>@JoinTable</code>也会加上一个默认的<code>@JoinTable</code>，所以建议显式定义<code>@JoinTable</code>便于管理</p></li>
<li><p>双向关联：像<code>@OneToOne</code>那样，需要一方使用<code>mappedBy</code>属性，避免生成两个中间表</p>
<p>即<code>@JoinTable+@ManyToMany</code>和<code>@ManyToManay(mappedBy=...)</code>配对实现多对多的双向关联</p></li>
</ul></li>
<li><p><code>CascadeType</code>：作用于映射基数注解里的<code>cascade</code>属性，<code>JPA</code>在实体中的一大优点是实体含有整个的引用而不只是其它实体的主键，因此也可以实现对实体进行持久化操作的同时对其含有的外键进行相同的操作</p>
<ul>
<li><p><code>PERSIST</code>：主体保存时，同时保存其关联的实体</p></li>
<li><p><code>MERGE</code>：主体更新时，同时更新其关联的实体</p></li>
<li><p><code>REMOVE</code>：主体删除时，同时删除其关联的实体</p>
<p><code>orphanRemoval</code>在关系断开时就会级联删除(包括将关联属性替换、设<code>null</code>)，而<code>REMOVE</code>策略只是在主体删除时才进行级联删除</p></li>
<li><p><code>REFRESH</code>：主体刷新时，同时获取其关联的实体</p></li>
<li><p><code>DETACH</code>：实例被分离出持久层管理时，同时将其关联的实例也分离出去</p></li>
<li><p><code>ALL</code>：包括以上所有策略</p></li>
</ul></li>
<li><p><code>FetchType</code>：作用于映射基数注解里的<code>fetch</code>属性，表示加载的策略</p>
<ul>
<li><p><code>LAZY</code>：懒加载，只在真正访问时加载</p>
<p><code>LAZY</code>是一对多、多对多注解的默认值，因为是<code>List</code>通常需要很长的时间加载，许多时候是没必要的</p></li>
<li><p><code>EAGER</code>：急加载，查询到主实体后立刻加载该引用</p>
<p><code>EAGER</code>是一对一、多对一注解的默认值，因为仅加载一个关联实体的实例并不花多久</p></li>
</ul></li>
</ul>
<h3 id="继承注解">继承注解</h3>
<h3 id="例子">例子</h3>
<ul>
<li><p>自关联的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(&quot;employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;eid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer eid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;manager&quot;, referencedColumnName = &quot;eid&quot;, foreignKey = @ForeignKey(name = &quot;fk_EmpManager_EmpEid&quot;))</span></span><br><span class="line">    <span class="meta">@ManyToOne(optional = true)</span></span><br><span class="line">    <span class="keyword">private</span> Employee manager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;manager&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; emps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>共享主键例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@Column(name = &quot;uid&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Long uid;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column(name = &quot;username&quot;, nullable = false, length = 50)</span></span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OneToOne(mappedBy = &quot;user&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> UserDetail userDetail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(&quot;user_detail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetail</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrimaryKeyJoinColumn(referencedColumnName = &quot;uid&quot;)</span></span><br><span class="line">    <span class="meta">@MapsId</span></span><br><span class="line">    <span class="meta">@OneToOne(optional = false)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它信息</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;password&quot;, check = @CheckConstraint(&quot;password ~ ^[0-9a-zA-Z]&#123;8,20&#125;$&quot;))</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jpql"><code>JPQL</code></h2>
<h3 id="参数化查询">参数化查询</h3>
<ul>
<li>为了防止<code>SQL</code>注入，参数化查询提供了类型检查，避免了<code>SQL</code>语句的拼接</li>
<li>命名参数：使用方法中形参的名字引用值，如<code>:paramName</code>表示取<code>paramName</code>这个形参的值</li>
<li>位置参数：使用<code>1-idx</code>的位置来索引形参，如<code>?1</code>表示取第一个参数的值</li>
</ul>
<h3 id="查询细节">查询细节</h3>
<ul>
<li><p><code>JPQL</code>(<code>Java Persistence Query Language</code>)，是<code>JPA</code>规范提供的查询语言，它和<code>SQL</code>的语法类似，但是<strong>操作对象是实体类</strong>，而不是关系</p>
<p>也因此，<code>JPQL</code>是编译时检查的，类型检查能防止很多查询错误</p></li>
<li><p>由于有映射基数的注解，在<code>FROM</code>子句使用<code>JOIN</code>时，可以不用<code>ON</code>关键字，除非需要复杂的查询条件</p></li>
<li><p>推荐使用面向对象的思想编写<code>JPQL</code>，即要多表查询时，使用<code>A JOIN A.B</code>而不是<code>A JOIN B</code>，用<code>.</code>运算符使用对象导航</p></li>
<li><p>对于列表类型，允许使用<code>[0-idx]</code>访问其中的实体实例</p></li>
<li><p>一对多的关系(列表类型)的懒加载会导致<code>N+1</code>查询问题，如果大部分场景需要懒加载，但在特定场景需要获取多方的所有实体时，可以使用<code>JOIN FETCH</code>，能优化为两次查询</p></li>
<li><p>多态查询：</p></li>
<li><p>在不使用<code>Spring Data JPA</code>的场景下，查询结果无法自动转化成返回类型的对象，需要使用<code>NEW ObjClass(...)</code></p></li>
</ul>
<h3 id="面向对象的便捷函数">面向对象的便捷函数</h3>
<ul>
<li><code>TYPE(obj)</code>：获取其类型</li>
<li><code>TREAT(obj AS Type)</code>：向下转型</li>
<li><code>SIZE(collection)</code>：获取集合的大小，是<code>COUNT()</code>加子查询的便捷版</li>
<li><code>obj MEMBER OF collection</code>：类似<code>IN</code></li>
<li><code>collection IS EMPTY</code>：等价于<code>SIZE(collection) = 0</code></li>
</ul>
<h2 id="criteria-api"><code>Criteria API</code></h2>
<h2 id="jpa生命周期"><code>JPA</code>生命周期</h2>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ORM</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java EE: Tomcat</title>
    <url>/blogs/2025/07/08/java-tomcat/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="tomcat"><code>Tomcat</code></h2>
<h3 id="依赖">依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 若用到jsp技术 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="结构介绍">结构介绍</h3>
<ul>
<li><p><code>Tomcat</code>是<code>Apache</code>开发的开源<code>Servlet</code>容器</p></li>
<li><p>其中，<code>WEB-INF</code>目录是受保护的，客户端无法访问这个目录下的资源，保存应用的信息</p>
<p>这个目录下面还有<code>classes/</code>、<code>lib/</code>以及<code>web.xml</code></p>
<p><code>classes/</code>存放<code>Java</code>程序的编译结果、<code>lib/</code>存放一系列第三方<code>jar</code>包</p>
<p>其余应是一系列静态资源，例如<code>js/</code>、<code>css/</code>、<code>views/</code>等常见的命名</p>
<p>使用<code>maven</code>管理项目的情况下，<code>lib/</code>不需要手动寻找、配置</p></li>
<li><p>传统部署：指<code>Tomcat</code>服务器包含开发者开发的<code>.war</code>包这样的<code>Web</code>应用，<code>Servlet</code>应用开发好后打包成<code>.war</code>包并复制到<code>Tomcat</code>服务器中，然后启动服务器</p>
<p>传统部署中，<code>classes/</code>与<code>lib/</code>由<code>Tomcat</code>解包<code>.war</code>文件得到</p></li>
<li><p>内嵌<code>tomcat</code>：指<code>Tomcat API</code>作为<code>java</code>程序的一部分而存在，若使用<code>maven</code>的情况下调用<code>Tomcat</code>实例的<code>addWebapp()</code>方法，实例会从指定的路径中找到<code>WEB-INF/web.xml</code>文件并解析，然后生成<code>classes/</code>与<code>lib/</code>等在<code>target/</code>下</p></li>
</ul>
<h3 id="web.xml映射"><code>web.xml</code>映射</h3>
<ul>
<li><p>这是一种比较传统的映射方式，仅了解即可</p></li>
<li><p><code>web.xml</code>应位于<code>webapp/WEB-INF</code>目录下，其中<code>webapp</code>为自定义的网页应用的名字，<code>web.xml</code>里的所有的配置会<strong>覆盖注解形式的映射</strong></p></li>
<li><p>声明为<code>webapp</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>声明一个<code>Servlet</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Servlet_name<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>类路径<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将<code>Servlet</code>映射到某个路径上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Servlet_name<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/路径<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化某个<code>Servlet</code>或某个<code>Filter</code>的参数(<code>ServletConfig</code>)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>param_name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>xml文件、字符串等<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置<code>ServletContext</code>的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置欢迎文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置<code>session</code>的生效时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注解映射">注解映射</h3>
<ul>
<li><p><code>@WebServlet</code>注解：在<code>Servlet 3.0</code>前，需要在<code>web.xml</code>中配置大量信息，在<code>WebServlet</code>注解出现后，所有的配置被分散到各个服务类上，最重要且必要的属性是<code>urlPatterns</code>，是<code>String</code>集合，表示这些<code>URI</code>均映射到这个<code>Servlet</code>类上</p>
<p>在传统部署时，它们的解析是全自动的</p></li>
</ul>
<h3 id="内嵌tomcat">内嵌<code>Tomcat</code></h3>
<ul>
<li><p>内嵌部署<code>Tomcat</code>显得更加灵活，由开发者完全控制<code>Tomcat</code>的配置，但因此<strong>注解映射、静态资源需要由开发者亲自解析、引入</strong>，因此在不借用<code>Spring boot</code>框架的情况下，直接配置<code>web.xml</code>并调用<code>addWebapp()</code>或手动通过<code>Tomcat</code>对象注册服务以及配置映射是更常用的</p></li>
<li><p>可以理解为：通过<code>web.xml</code>配置的底层实现就是让<code>addWebapp()</code>解析该<code>xml</code>文件，并间接地在内部调用<code>addServlet()</code>、<code>addMapping()</code>等方法</p></li>
<li><p>由<code>new Tomcat()</code>直接构造一个<code>Tomcat</code>实例，调用<code>start()</code>启动该服务器(会抛出<code>LifecycleException</code>受检异常)，调用<code>getServer().await()</code>使该服务器不断地等待请求</p></li>
<li><p><code>Tomcat</code>实例方法：</p>
<ul>
<li><p><code>setHostname(String)</code>：设置服务器地址</p></li>
<li><p><code>setPort(int)</code>：设置服务器端口</p></li>
<li><p><code>setBaseDir(String)</code>：设置基准目录，表示<code>Tomcat</code>实例工作时，临时文件等存放的根目录，这里的临时文件不是<code>classes/</code>与<code>lib/</code>等，而是运行时生成的文件，例如<code>jsp</code>翻译后生成的文件</p>
<p>推荐设置为<code>target/</code>下的某个目录</p></li>
<li><p><code>getConnector()</code>：获取其绑定的连接器，这个方法在首次调用时会进行一系列的初始化操作，包括应用在<strong>此前</strong>设置的<code>baseDir</code>等参数</p>
<p>这个方法应尽量晚些调用</p></li>
<li><p><strong><code>Context addWebapp(String contextPath, String docBase)</code></strong>：添加<code>Web</code>应用并获取它的上下文实例</p>
<p><code>contextPath</code>指上下文的根所<strong>映射的<code>URL</code>路径</strong>，例如传入<code>""</code>则该上下文会映射到<code>"/"</code></p>
<p><code>docBase</code>指要引入的<strong>资源的本地路径</strong>，提供的路径下必须含有<code>WEB-INF</code>目录及<code>web.xml</code>文件</p>
<p>等价于将整个<code>Web</code>应用加载到服务器上，使用<code>addWebapp()</code>会自动生成并注册一个默认的<code>Servlet</code>服务，当客户端访问那些在用户自定义<code>Servlet</code>服务中找不到的服务时，会转向这个默认服务</p>
<p>默认服务会试图在<code>docBase</code>下的静态资源中查询是否有对应的资源，若找到则返回，否则返回<code>404</code>响应</p></li>
<li><p><code>Context addContext(String contextPath, String docBase)</code>：添加一个<strong>空白的上下文</strong>实例，参数意义同上</p></li>
<li><p><strong><code>addServlet(String contextPath, String servletName, Servlet serv)</code></strong>：登记一个名为<code>servletName</code>的微服务，对应到路径为<code>contextPath</code>的上下文</p>
<p>有静态方法的版本，其中<code>contextPath</code>应替换为<code>Context</code>对象</p>
<p>同时需要使用<code>Context</code>实例的<code>addServletMappingDecoded(String pattern, String name)</code>将微服务映射到<code>URL</code>的某个路径上</p>
<p>这两步等价于在<code>web.xml</code>中声明<code>Servlet</code>服务和映射</p>
<p>该方法返回的<code>Wrapper</code>对象可链式调用<code>addMapping(String pattern)</code>，它等价于使用<code>Context</code>实例的<code>addServletMappingDecoded()</code>方法</p></li>
</ul></li>
<li><p>上下文类<code>Context</code>抽象的是整个<code>Web</code>容器，和<code>ServletContext</code>不同，一般作用于容器启动前，而后者作用于<code>Web</code>应用运行中处理业务，<code>Context</code>常用的实例方法有：</p>
<ul>
<li><p><code>addWelcomeFile(String)</code>：设置当客户端访问根路径时，返回的资源文件</p>
<p>即将<code>String</code>指向的资源文件映射到<code>"/"</code></p></li>
<li><p><strong><code>addServletMappingDecoded(String pattern, String name)</code></strong>：将微服务映射到某个<code>URL</code>上</p></li>
<li><p><code>addFilterDef(FilterDef)</code>：登记一个<code>Filter</code>，由<code>FilterDef</code>封装其信息</p>
<p><code>FilterDef</code>常用方法：<code>setFilter(Filter)</code>、<code>setFilterName(String)</code>、<code>addInitParameter(String, Object)</code></p>
<p>分别为登记<code>Filter</code>对象、登记<code>Filter</code>服务名、初始化<code>Filter</code>参数</p></li>
<li><p><code>addFilterMap(FilterMap)</code>：登记从<code>Filter</code>到<code>URL</code>的映射，由<code>FilterMap</code>封装映射信息</p>
<p><code>FilterMap</code>常用方法：<code>addURLPatternDecoded(String)</code>、<code>addServletName(String)</code>、<code>setFilterName(String)</code></p>
<p>分别为登记其应用的<code>URL</code>、登记其应用的<code>Servlet</code>、设置其绑定的<code>Filter</code>服务名</p></li>
</ul></li>
</ul>
<h3 id="例子">例子</h3>
<ul>
<li><p>基本配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line"></span><br><span class="line">tomcat.setHostname(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">tomcat.setPort(<span class="number">8080</span>);</span><br><span class="line">tomcat.setBaseDir(<span class="string">&quot;/target/tomcat/&quot;</span>);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ...其它配置...</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">tomcat.getConnector();</span><br><span class="line">tomcat.init();</span><br><span class="line">tomcat.start();</span><br><span class="line">tomcat.getServer().await();</span><br></pre></td></tr></table></figure></li>
<li><p><code>Servlet</code>等配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> <span class="string">&quot;/api&quot;</span>;</span><br><span class="line"><span class="comment">// String docBase = new File(&quot;/src/main/webapp&quot;).getAbsolutePath();</span></span><br><span class="line"><span class="type">String</span> <span class="variable">docBase</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/src/main/webapp&quot;</span>).toAbsolutePath().toString();</span><br><span class="line"><span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addContext(contextPath, docBase);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> <span class="string">&quot;ServletDemo&quot;</span>;</span><br><span class="line">tomcat.addServlet(contextPath, servletName, <span class="keyword">new</span> <span class="title class_">ServletDemo</span>()).addMapping(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line"><span class="comment">// context.addServletMappingDecoded(&quot;/*&quot;, servletName);</span></span><br><span class="line"></span><br><span class="line"><span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">filterDef.setFilter((req, resp, chain) -&gt; &#123;</span><br><span class="line"><span class="comment">// 过滤 ...</span></span><br><span class="line"><span class="comment">// 链式处理</span></span><br><span class="line">    chain.doFilter(req, resp);</span><br><span class="line">&#125;);</span><br><span class="line">filterDef.setFilterName(<span class="string">&quot;FilterDemo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">filterMap.addURLPatternDecoded(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">filterMap.addServletName(servletName);</span><br><span class="line">filterMap.setFilterName(<span class="string">&quot;FilterDemo&quot;</span>);</span><br><span class="line"></span><br><span class="line">context.addFilterDef(filterDef);</span><br><span class="line">context.addFilterMap(filterMap);</span><br></pre></td></tr></table></figure></li>
<li><p>上述配置与以下配置是近乎等价的，只是以下配置会有多出一个默认的<code>Servlet</code>服务，用于检索静态资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tomcat.addWebapp(<span class="string">&quot;/api&quot;</span>, <span class="string">&quot;src/main/webapp/&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>demo.servlet.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>无法用lambda表达式声明的接口实现<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 针对/*这个URL路径设置Filter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 针对ServletDemo这个服务单独设置Filter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>webapp</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习: 损失函数与正则化</title>
    <url>/blogs/2025/07/06/deeplearning-lossAregular/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="损失函数及正则化">损失函数及正则化</h2>
<h3 id="损失函数概念及约定">损失函数概念及约定</h3>
<ul>
<li><p>损失：表示模型预测值与真实值之间差距的实数，越接近零表示误差越小</p>
<p>代价：是整个数据集上<strong>所有样本的损失的平均值</strong>，即损失的期望，但事实上代价通常也被称作损失，大多数教材并不明确地区分它们</p>
<p>实际训练中，求和并除以<span
class="math inline"><em>n</em></span>使损失变为代价，使其可比较样本数量不同的数据集，并根据整个样本集的代价进行更优秀的调整</p></li>
<li><p>损失函数：输入为模型的预测值，输出为损失的一种函数</p></li>
<li><p>在一次训练以后，模型会通过损失函数估计出损失，并通过某种提前设定好的优化方法调整参数(如权重、偏置等)</p>
<p>无论使用的优化方法是否为梯度下降法，损失函数都是机器学习算法中很重要的一部分</p></li>
<li><p>约定<span class="math inline"><em>y</em></span>为真实值、<span
class="math inline"><em>ŷ</em></span>为模型的预测值</p></li>
<li><p>一个损失函数适用于某种问题总是可以由<strong>最大似然估计</strong>推导</p></li>
</ul>
<h3 id="回归任务">回归任务</h3>
<ul>
<li><p>回归任务：输出为一系列<strong>确切的数值</strong>，目标是预测某个<strong>连续型变量</strong>的分布</p></li>
<li><p>均方误差(<code>Mean Squared Error</code>，<code>MSE</code>)，又称<code>L2 Loss</code>：<span
class="math inline">$\begin{align}L_{MSE}=\frac1n\sum_{i=1}^n(y_i-\hat
y_i)^2\end{align}$</span></p>
<ul>
<li><p>将真实值和预测值的差表示出来：<span
class="math inline"><em>z</em> = <em>y</em> − <em>ŷ</em></span>，且假设误差<span
class="math inline"><em>z</em> ∼ <em>N</em>(0,<em>σ</em><sup>2</sup>)</span></p>
<p>则真实值在已知输入的条件下，<span
class="math inline"><em>y</em> | <em>X</em> ∼ <em>N</em>(<em>ŷ</em>,<em>σ</em><sup>2</sup>)</span></p>
<p>根据极大似然估计法，多条样本的极大似然函数为<span
class="math inline">$\begin{align}L=\prod_{i=1}^n\frac1{\sqrt{2\pi\sigma^2}}e^{\Large-\frac{(y_i-\hat
y_i)^2}{2\sigma^2}}\end{align}$</span></p>
<p>取对数后为<span class="math inline">$\begin{align}-\frac
n2\ln(2\pi\sigma^2)-\frac1{2\sigma^2}\sum_{i=1}^n(y_i-\hat
y_i)^2\end{align}$</span>，而极大化似然函数等价于极小化均方误差</p></li>
<li><p>均方误差的性质：连续光滑、处处可导，是凸函数可最小化，梯度简单且稳定(与误差线性相关)，因此能够快速收敛但对离群点较敏感</p></li>
</ul></li>
<li><p>平均绝对误差(<code>Mean Absolute Error</code>，<code>MAE</code>)，又称<code>L1 Loss</code>：<span
class="math inline">$\begin{align}L_{MSE}=\frac1n\sum_{i=1}^n|y_i-\hat
y_i|\end{align}$</span></p>
<ul>
<li>平均绝对误差的性质：连续、仅在<span
class="math inline"><em>y</em> = 0</span>处不可导，所有点的梯度相同，因此收敛速度较稳定，对离群点具有更强的鲁棒性</li>
</ul></li>
<li><p>均方根误差(<code>Root MSE</code>，<code>RMSE</code>)：<span
class="math inline">$L_{RMSE}=\sqrt{L_{MSE}}$</span></p></li>
</ul>
<h3 id="分类任务">分类任务</h3>
<ul>
<li><p>分类任务：输出为一系列<strong>离散的值</strong>(表示不同的类别，可编号)，目标是预测某个<strong>离散型变量</strong>的分布</p>
<ul>
<li><p>二分类任务：将输入分为两个类别，一个输入仅属于一个类别</p>
<p>真实值标签为<strong>非零即一的值</strong></p>
<p>模型输出一个<span
class="math inline">(0,1)</span>的实数，若大于一定程度则认为属于正类，否则属于反类</p></li>
<li><p>单标签多分类任务：将输入分为<span
class="math inline"><em>k</em></span>个类别，一个输入仅属于一个类别</p>
<p>真实值标签为<strong>一次性向量</strong>(<code>one-hot</code>向量)，仅有一个分量为<span
class="math inline">1</span>，其余均为<span
class="math inline">0</span></p>
<p>模型输出多个<span
class="math inline">(0,1)</span>的实数，取最大者为预测的类别</p></li>
<li><p>多标签多分类任务：将输入分为<span
class="math inline"><em>k</em></span>个类别，一个输入可属于多个类别</p>
<p>真实值标签为<strong>多热向量</strong>，允许多个分量为<span
class="math inline">1</span></p>
<p>模型输出多个<span
class="math inline">(0,1)</span>的实数，根据不同策略预测出多个类别</p></li>
</ul></li>
<li><p>交叉熵损失(<code>Cross-Entropy Loss</code>)：基础为信息论中的交叉熵，在不同任务中由于真实值所遵循的分布不尽相同，其具体式子有所不同</p>
<ul>
<li><p>信息论中的交叉熵：<span
class="math inline">$\begin{align}-\sum_iP(y_i)\ln
Q(y_i)\end{align}$</span></p>
<p>信息熵表示某个概率分布的不确定性，越小其分布越稳定，离散随机变量的真实分布<span
class="math inline"><em>P</em></span>的熵为<span
class="math inline">$\begin{align}H(P)=-\sum_iP(y_i)\ln
P(y_i)\end{align}$</span></p>
<p>交叉熵则是估计分布<span
class="math inline"><em>Q</em></span>在近似真实分布<span
class="math inline"><em>P</em></span>时的平均信息量，<span
class="math inline">$\begin{align}H(P,Q)=-\sum_iP(y_i)\ln
Q(y_i)\end{align}$</span></p>
<p>交叉熵总大于信息熵，因为<span
class="math inline"><em>Q</em></span>总是不能完美近似<span
class="math inline"><em>P</em></span>，交叉熵和信息熵的差值被称为<strong>相对熵</strong>，也称<span
class="math inline"><em>K</em><em>L</em></span>散度，记为<span
class="math inline">$\begin{align}D_{KL}(P\ ||\
Q)=\sum_iP(y_i)\ln(\frac{P(y_i)}{Q(y_i)})\end{align}$</span></p>
<p>在机器学习中将<span
class="math inline"><em>P</em></span>视为固定分布，即<span
class="math inline"><em>H</em>(<em>P</em>)</span>为常量，因此最小化<span
class="math inline"><em>D</em><sub><em>K</em><em>L</em></sub></span>等价于<strong>最小化交叉熵</strong></p></li>
<li><p>二分类任务：真实分布<span
class="math inline"><em>P</em></span>服从<span
class="math inline">01</span>分布</p>
<p>因此最大化似然函数等价于最小化<span
class="math inline">$\begin{align}L_{CE}=-\frac1n\sum_{i=1}^n[y_i\ln\hat
y_i+(1-y_i)\ln(1-\hat y_i)]\end{align}$</span></p>
<p>此交叉熵又称二进制交叉熵，即<code>BCE</code>损失函数</p></li>
<li><p>单标签多分类任务：真实分布<span
class="math inline"><em>P</em></span>服从<strong>分类分布</strong></p>
<p>最大化似然函数等价于最小化<span
class="math inline">$\begin{align}L_{CE}=-\frac1n\sum_{i=1}^n\sum_ky_{ik}\ln\hat
y_{ik}\end{align}$</span></p>
<p>若已知真实值为第<span
class="math inline"><em>j</em></span>项，则<span
class="math inline">$\begin{align}L_{CE}=-\frac1n\sum_{i=1}^n\ln\hat
y_{ij}\end{align}$</span></p></li>
<li><p>多标签多分类任务：真实分布<span
class="math inline"><em>P</em></span>服从二项分布，等价于对每个类别进行二分类交叉熵的求和</p>
<p><span
class="math inline">$\begin{align}L_{CE}=-\frac1n\sum_{i=1}^n\sum_k[y_{ik}\ln\hat
y_{ik}+(1-y_{ik})\ln(1-\hat y_{ik})]\end{align}$</span></p></li>
</ul></li>
<li><p><code>Hinge</code>损失函数：</p></li>
<li><p>余弦相似度损失函数：</p></li>
<li><p>指数损失函数：</p></li>
</ul>
<h3 id="聚类任务">聚类任务</h3>
<ul>
<li>聚类任务：与分类任务相似，但聚类任务依据分析数据本身特点而非标签来分组，实际是将整个样本集分为多个具有相似特征的样本的集合</li>
<li><code>SSE</code>损失函数：</li>
</ul>
<h3 id="其它损失函数">其它损失函数</h3>
<ul>
<li><p>一些更复杂的任务：</p>
<ul>
<li>结构化输出：
<ul>
<li>转录任务：输入为一系列<strong>非结构化</strong>的数据，输出为离散的<strong>有结构的文本标签</strong></li>
<li>机器翻译任务：输入和输出均为有结构的<strong>符号序列</strong>，两种序列使用的语言不同</li>
</ul></li>
<li>异常检测：从输入中标记出异常、非典型的个体</li>
<li>缺失值填补：补充样本中的已知缺失，其输出通常作为某种机器学习算法的输入</li>
<li>去噪：去除样本中损坏的部分，这些损坏通常是非预期发生的</li>
</ul></li>
<li><p><code>KL</code>散度损失函数：</p></li>
</ul>
<h3 id="正则化技术">正则化技术</h3>
<ul>
<li><p>正则化(<code>Regularization</code>)：是为了<strong>防止过拟合</strong>的一系列技术，其原理是主动限制模型的复杂度</p>
<p>传统的正则化通过对损失值添加正则项的方式限制模型的复杂度，其原理是<strong>最大后验估计</strong></p>
<p>限制模型复杂度，一般是故意地让某些神经元结点“死亡”，即它们的权重为零</p></li>
<li><p>常见的正则化：</p>
<ul>
<li><p><code>L1</code>正则化(例如<code>Lasso</code>回归)：正则项为<span
class="math inline">$\begin{align}\lambda\sum_i|w_i|\end{align}$</span>，能使得部分过小的权重为零，只有少数的权重显著不为零</p></li>
<li><p><code>L2</code>正则化(例如<code>Ridge</code>回归)：正则项为<span
class="math inline">$\begin{align}\lambda\sum_iw_i^2\end{align}$</span>，使权重均匀减小，但不至于减小至零</p></li>
<li><p><code>Dropout</code>：在训练过程中<code>dropout</code>会<strong>随机</strong>关闭部分神经元结点，这被实践证明是一种有效的<code>trick</code></p>
<p>直观的理解是：这种<code>dropout</code>使每次训练涉及的部分是在所有的可能子网络中的一个，相当于每次训练的神经网络结构均不同，使得模型不会依赖某个局部特征</p>
<p>其具体做法是：在一次训练中，每次经过一个神经元前，以<span
class="math inline"><em>p</em></span>概率使该神经元<strong>临时死亡</strong>(由伯努利分布提供采样)，为了使输出期望与原来一致，使有效输出乘以<span
class="math inline">$\begin{align}\frac{1}{1-p}\end{align}$</span></p>
<p>因此，反向传播时，只会更新那些未死亡神经元的参数</p>
<p>测试时，保留所有神经元，正常地进行前向传播</p>
<p>在实现中，通常会把<code>Dropout</code>视为和一般神经网络层同等级别的“层”，称为<code>Dropout</code>层</p></li>
<li><p>早停(<code>Early Stopping</code>)：在验证集性能无法提升时，提前结束训练</p>
<p>模型如果在一定次数内(称为耐心值)，验证指标改进幅度均小于最小改进阈值，则提前结束训练，并恢复到效果最优的版本输出最终模型</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>ML</tag>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data: JPA</title>
    <url>/blogs/2025/07/06/spring-data-jpa/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Spring framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java EE: Servlet API</title>
    <url>/blogs/2025/07/05/java-servlet/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="javax.servlet"><code>javax.servlet</code></h2>
<h3 id="java-ee介绍"><code>Java EE</code>介绍</h3>
<ul>
<li><p>在<code>Java EE 8</code>及之前，这个企业版是由<code>Oracle</code>开发的闭源项目，包括一系列大型或中小型的商业软件包，但由于<code>Spring</code>等框架的流行，<code>Java EE</code>开始力不从心</p>
<p>于是在之后，<code>Oracle</code>将整个<code>Java EE</code>移交给<code>Eclipse</code>开源基金会维护，并强制要求<code>Eclipse</code>不能继续使用<code>Java EE</code>的项目名以及<code>javax</code>的命名空间，因此在<code>Eclipse</code>接手这个项目后迫不得已将<code>javax</code>改为<code>jakarta</code>，并将大版本号提升至<code>5</code>，表示不再向下兼容</p>
<p>总而言之，<code>javax</code>命名空间适用于<code>4.0</code>及之前的企业版项目，<code>jakarta</code>适用于<code>5.0</code>及之后的企业版</p></li>
<li><p><code>Servlet</code>源于<code>Server Applet</code>，即在服务端上运行的小程序</p>
<p>在<code>SE</code>的网络编程中对于<code>Http</code>的处理只介绍了<code>HttpClient</code>，即客户端的编写，是因为服务端需要考虑的东西过多</p>
<p>而<code>Servlet</code>项目致力于高效而安全地开发服务器</p></li>
<li><p><code>Servlet</code>本质可用于任意通信协议，但主要用于<code>HTTP</code></p>
<p>它内部封装了线程池，通过多线程的方式处理请求，因此比起此前的方案性能更高</p></li>
<li><p><code>Servlet</code>需要部署到专用的<code>Web</code>服务器上，称作<code>Servlet</code>容器，例如<code>Apache</code>的<code>Tomcat</code>项目、<code>Eclipse</code>的<code>Jetty</code>项目</p>
<p>因为<code>Servlet</code>本质是一个<code>Web</code>应用，是<code>Servlet</code>容器向开发者暴露的规范接口，<code>Servlet</code>容器是更复杂的应用</p></li>
</ul>
<h3 id="servlet依赖"><code>servlet</code>依赖</h3>
<ul>
<li><p>接口依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Servlet</code>接口的实现由<code>Web</code>容器提供，可以使用<code>provided</code>表示仅编译时需要</p></li>
</ul>
<h3
id="servlet接口与httpservlet实现类"><code>Servlet</code>接口与<code>HttpServlet</code>实现类</h3>
<ul>
<li><p><code>Servlet</code>有三个重要方法：<code>init()</code>、<code>service()</code>、<code>destroy()</code>，由<code>Servlet</code>容器调用进行生命周期管理</p>
<p><code>service()</code>含有两个参数<code>HttpServletRequest</code>与<code>HttpServletResponse</code></p></li>
<li><p><code>HttpServlet</code>是最常用的实现类，有四个重要方法：<code>doGet()</code>、<code>doPost()</code>、<code>doPut()</code>、<code>doDelete()</code></p>
<p>它们也均含有两个参数：<code>HttpServletRequest</code>与<code>HttpServletResponse</code></p>
<p>重写它们来自定义处理逻辑</p>
<p>一般不需要重写<code>service()</code>，由<code>HttpServlet</code>已经实现好了，他会自动解析请求方法并调用<code>doXxx()</code></p>
<p>除非需要使用<code>HttpServlet</code>处理其它通信协议</p></li>
<li><p><code>HttpServletRequest</code>接口表示一个<code>HTTP</code>请求报文，常用方法如下：</p>
<ul>
<li><p><code>setCharsetEncoding(String)</code>：设置解析的编码集</p></li>
<li><p><code>String getParameter(String name)</code>：获取某个请求参数</p>
<p>这里的参数已经消除了<code>GET</code>、<code>POST</code>等不同请求方法的差异，但对于<code>POST</code>方法而言，只会解析类型为<code>application/x-www-form-urlencoded</code>或<code>multipart/form-data</code>，其它类型如<code>application/json</code>需要通过输入流获取</p></li>
<li><p><code>String getHeader(String name)</code>：获取某个请求头</p></li>
<li><p><code>getRequestDispatcher(String location)</code>：获取一个请求分发器，指向内部的另一个<code>URI</code>，通常会继续调用<code>RequestDispatcher</code>接口的<code>forward(req, resp)</code>内部转发出去或<code>include(req, resp)</code>转发后回来</p></li>
<li><p><code>getAttribute()</code>和<code>setAttribute()</code>：可以主动设置属性，方便请求处理链条中数据的传递</p></li>
</ul></li>
<li><p><code>HttpServletResponse</code>接口表示一个<code>HTTP</code>响应报文，常用方法如下：</p>
<ul>
<li><code>setCharsetEncoding(String)</code>：设置解析的编码集</li>
<li><code>setContentType(String type)</code>：设置响应体的类型</li>
<li><code>PrintWriter getWriter()</code>：获取绑定的字符输出流</li>
<li><code>ServletOutputStream getOutputStream()</code>：获取绑定的字节输出流</li>
<li><code>setStatus(int)</code>：设置状态码</li>
<li><code>setHeader(String name, String value)</code>：设置响应头</li>
<li><strong><code>sendRedirect(String)</code></strong>：<code>302</code>临时重定向到另一个<code>URI</code></li>
</ul></li>
<li><p>一个服务器的所有<code>Servlet</code>实现类只会有一个实例，因此遇到多个请求时会用同一个实例来处理</p>
<p>因此实现类的实例属性的所有访问需要保证线程安全</p></li>
</ul>
<h3 id="session与cookie"><code>Session</code>与<code>Cookie</code></h3>
<ul>
<li><p><code>Session</code>用于存储客户端的某种状态，能保证每个<code>Session</code>唯一，内部类似于一个<code>Map&lt;String, Object&gt;</code></p></li>
<li><p><code>HttpServletRequest</code>对象的<code>getSession()</code>方法会(若不存在)创建并返回一个<code>HttpSession</code>对象，(若存在)直接返回<code>HttpSession</code>对象</p>
<p><code>getSession(false)</code>则不会创建，而只是返回已有的对象，若无则返回<code>null</code></p></li>
<li><p><code>HttpSession</code>实例的常用方法为<code>setAttribute(String, Object)</code>和<code>Object getAttribute(Stirng)</code>以及<code>removeAttribute(String)</code></p>
<p>分别为设置、获取、删除其存储的对象数据</p></li>
<li><p><code>Session</code>通常是通过<code>Cookie</code>技术实现的，它会让客户端在发送请求时同时发送一个<code>Session</code></p>
<p>自定义<code>Cookie</code>需直接通过构造方法<code>new Cookie(String name, String value)</code>创建</p>
<p><code>Cookie</code>可设置最大时间<code>setMaxAge(seconds)</code></p>
<p>通过<code>HttpServletResponse</code>实例的<code>addCookie(Cookie)</code>方法传递给客户端</p>
<p>通过<code>HttpServletRequest</code>实例的<code>getCookies()</code>获取<code>Cookie[]</code>数组</p>
<p>通过<code>Cookie</code>实例的<code>getName()</code>和<code>getValue()</code>获取键值对</p></li>
</ul>
<h3 id="servletcontext"><code>ServletContext</code></h3>
<ul>
<li><code>ServletContext</code>是<code>Web</code>应用上下文的抽象，可以用它获取整个<code>Web</code>应用的信息，最常用的方法如下：</li>
<li>获取<code>Web</code>应用的属性：<code>Object getAttribute(String)</code></li>
<li>设置<code>Web</code>应用的属性：<code>void setAttribute(String, Object)</code></li>
<li>移除<code>Web</code>应用的属性：<code>void removeAttribute(String)</code></li>
<li>记录日志：<code>log(String)</code></li>
<li>使用上下文需注意，因为处于多线程环境，虽然<code>ServletContext</code>本身是线程安全的，但传入的属性值需要自行确保线程安全</li>
</ul>
<h3 id="servletconfig"><code>ServletConfig</code></h3>
<ul>
<li><code>ServletConfig</code>是某个<code>Servlet</code>服务的配置的抽象，可以用它获取某个<code>Servlet</code>服务独有的配置项，最常用的方法如下：</li>
<li>获取初始参数：<code>String getInitParameter()</code>，这个初始参数可以用<code>XML</code>或注解的形式设置，也可由内嵌<code>Tomcat</code>的<code>Wrapper</code>配置</li>
</ul>
<h3 id="jsp技术"><code>JSP</code>技术</h3>
<ul>
<li><p><code>JSP</code>技术比较落后，了解即可</p></li>
<li><p>由于<code>Servlet</code>本质是内嵌<code>HTML</code>的<code>Java</code>微服务程序，大量的<code>HTML</code>文本由一行行的输出流打印比较麻烦，因此<code>JSP</code>技术出现</p>
<p><code>JSP</code>本质也是一个<code>Servlet</code>应用，由<code>Web</code>服务器在启动时自动将其编译成<code>Servlet</code>程序并在服务器上运行</p>
<p><code>JSP</code>作为静态资源可由<code>Web</code>容器自动部署，但也可以自定义部署<code>URL</code>路径</p></li>
<li><p><code>JSP</code>语法：</p>
<ul>
<li><code>Jsp</code>脚本：<code>&lt;% Java代码 %&gt;</code>，只执行代码，没有返回值</li>
<li><code>Jsp</code>表达式：<code>&lt;%= Expr %&gt;</code>，返回表达式的值</li>
<li><code>Jsp</code>声明：<code>&lt;%! 成员变量、方法 %&gt;</code></li>
<li><code>Jsp</code>指令：<code>&lt;%@ 指令 %&gt;</code></li>
<li><code>Jsp</code>动作：<code>&lt;jsp:action /&gt;</code></li>
<li><code>Jsp</code>注释：<code>&lt;%-- 注释 --%&gt;</code></li>
<li><code>EL</code>表达式：<code>$ { expr }</code></li>
</ul></li>
<li><p><code>JSP</code>隐含对象：在<code>Jsp</code>脚本中不用声明就可使用的对象，但不能重复定义</p>
<ul>
<li><code>HttpServletRequest request</code>与<code>HttpServletResponse response</code>：因为<code>JSP</code>本身就是一个<code>Servlet</code>，自然有<code>request</code>和<code>response</code>参数</li>
<li><code>HttpSession session</code>：等价于<code>request.getSession()</code></li>
<li><code>ServletConfig config</code>：<code>JSP</code>这个<code>Servlet</code>的配置</li>
<li><code>JspWriter out</code>：不常用</li>
<li><code>PageContext pageContext</code>：是整个页面上下文的抽象</li>
<li><code>page</code>：等价于<code>this</code>，是这个<code>Jsp</code>翻译得到的<code>Servlet</code>程序实例，因为<code>this</code>是可省略的所以<code>page</code>不会被直接使用</li>
<li><code>Exception exception</code>：用于异常处理</li>
</ul></li>
<li><p><code>JSP</code>指令：</p>
<ul>
<li>声明页面的属性：<code>&lt;%@ page import="java.util.*, java.net.*" %&gt;</code></li>
<li>声明页面包含其它页面：<code>&lt;%@ include other.jsp %&gt;</code></li>
<li>声明<code>Tag</code>的来源以及前缀：<code>&lt;%@ taglib uri="" prefix="" %&gt;</code></li>
</ul></li>
<li><p><code>EL</code>表达式的隐含对象</p>
<ul>
<li><code>PageContext pageContext</code>：除它之外，以下所有<strong>都是<code>Map</code></strong></li>
<li><code>param</code>：对应<code>request</code>的参数表</li>
<li><code>paramValues</code>：对应<code>request</code>的参数表，只不过值是数组用于存储含多个值的参数</li>
<li><code>header</code>：对应<code>request</code>的请求头表</li>
<li><code>headerValues</code>：对应<code>request</code>的请求头表，只不过值是数组用于存储含多个值的请求头</li>
<li><code>cookie</code>：对应<code>cookie</code>表</li>
<li><code>initParam</code>：对应<code>ServletConfig</code>的初始参数表</li>
<li><code>pageScope</code>：页面作用域，可通过它访问所有在页面内定义的标识符</li>
<li><code>requestScope</code>：请求作用域，可通过它访问所有在<code>request</code>中定义的<code>attribute</code></li>
<li><code>sessionScope</code>：会话作用域，可通过它访问所有在<code>session</code>中定义的<code>attribute</code></li>
<li><code>applicationScope</code>：应用作用域</li>
<li><code>EL</code>表达式可以不指定隐含对象地输出字段，此时会从小到大(<code>pageScope-&gt;requestScope-&gt;sessionScope-&gt;applicationScope</code>)地查找该字段</li>
</ul></li>
<li><p><code>EL</code>表达式的关键字：<code>not、le、lt、ge、gt、eq、ne、div</code>等</p></li>
<li><p><code>Jsp</code>动作：</p>
<ul>
<li><p><code>&lt;jsp:useBean id="a" class="com.Clazz" scope="page|request|session|application"/&gt;</code></p>
<p>创建一个标识为<code>a</code>、类型为<code>com.Clazz</code>、所属作用域为所有作用域的对象</p></li>
<li><p><code>&lt;jsp:getProperty name="a" property="age"/&gt;</code></p>
<p>获取标识为<code>a</code>的对象的<code>age</code>属性</p></li>
<li><p><code>&lt;jsp:setProperty name="a" property="age" value="value"/&gt;</code></p>
<p>设置标识为<code>a</code>的对象的<code>age</code>属性为字面量<code>"value"</code></p></li>
<li><p><code>&lt;jsp:setProperty name="a" property="age" param="age"/&gt;</code></p>
<p>设置标识为<code>a</code>的对象的<code>age</code>属性为引用变量<code>age</code>的值</p></li>
</ul></li>
</ul>
<h3 id="filter"><code>Filter</code></h3>
<ul>
<li><code>Filter</code>接口作用于收到请求、初始化响应之后，<code>Servlet</code>服务处理请求之前，可用于身份校验、初始化配置等</li>
<li>实现<code>Filter</code>接口需要实现<code>doFilter(ServletRequest, ServletResponse, FilterChain)</code>方法，如果需要拦截则直接<code>return</code>，如果放行则需要调用<code>FilterChain</code>实例的<code>doFilter(ServletRequest, ServletResponse)</code>方法</li>
</ul>
<h3 id="listener"><code>Listener</code></h3>
<ul>
<li><code>Listener</code>采用观察者模式，当某种实例创建、更改、销毁时，自定义的<code>Listener</code>组件会随之调用对应的方法</li>
<li><code>Listener</code>本身并不存在，只存在一系列的<code>XxxListener</code>接口</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>webapp</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring framework: Resource API</title>
    <url>/blogs/2025/07/04/spring-core-resource/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="spring资源管理"><code>Spring</code>资源管理</h1>
<h2 id="resource接口"><code>Resource</code>接口</h2>
<ul>
<li><code>Resource</code>类似<code>File</code>、<code>Path</code>、<code>URL</code>，是<code>Spring</code>提供的对一类资源的抽象
<code>Resource</code>会增加应用与<code>Spring</code>框架的耦合，但实际上它只是一个对于<code>URL</code>等传统资源类的有力替代品和实用<code>API</code>，用其它资源<code>API</code>也是可以的
<code>Resource</code>的好处是：方便，例如能够使用<code>classpath*</code>等路径前缀查找而不需要写完整的文件或<code>URL</code>的路径信息</li>
<li><code>Resource</code>接口包含的日常常用方法：
<ul>
<li><code>boolean exists()</code>：判断资源是否存在</li>
<li><code>boolean isReadable()</code>：判断资源是否可读</li>
<li><code>InputStream getInputStream()</code>：获取该资源的输入流(继承<code>InputStreamSource</code>接口)</li>
<li><code>ReadableByteChannel readableChannel()</code>：获取<code>nio</code>接口</li>
<li><code>String getDescription()</code>：获取资源的全路径名，通常用于错误日志输出</li>
</ul></li>
<li><code>Resource</code>的常见实现类：
<ul>
<li><code>UrlResource</code>：是<code>java.net.URL</code>的包装</li>
<li><code>ClassPathResource</code>：表示所有可以从<code>classpath</code>中获取的资源</li>
<li><code>FileSystemResource</code>：是<code>java.io.File</code>以及<code>java.nio.file.Files</code>的包装</li>
<li><code>ServletContextResource</code>：表示所有可以从<code>Web</code>应用中获取的资源</li>
<li><code>ByteArrayResource</code>：表示一个<code>byte</code>数组资源</li>
</ul></li>
</ul>
<h2
id="resourceloader与resourcepatternresolver接口"><code>ResourceLoader</code>与<code>ResourcePatternResolver</code>接口</h2>
<ul>
<li>在平时，一般不会直接使用上述的实现类来显式地用<code>new</code>创建<code>Resource</code>实例，而是用<code>ResourceLoader</code>或<code>ResourcePatternResolver</code>帮助我们自动地选择实现类</li>
<li><code>ResourceLoader</code>包含两个方法，最常用的是<code>Resource getResource(String loc)</code>，用于加载<code>loc</code>指向的资源并自动选择合适的实现类，然后返回<code>Resource</code>实例</li>
<li><code>ResourcePatternResolver</code>继承<code>ResourceLoader</code>接口，此外还包含一个方法<code>Resource[] getResources(String locPattern)</code>，用于加载匹配<code>locPattern</code>模式串的所有资源，然后返回<code>Resource[]</code>数组</li>
<li>此前所说的<code>ApplicationContext</code>接口继承了<code>ResourcePatternResolver</code>接口，因此我们不需要额外地创建一个<code>ResourceLoader</code>或<code>ResourcePatternResolver</code>实例，而是使用<code>ctx.getResource(loc)</code>或<code>ctx.getResources(locPattern)</code>即可</li>
<li><code>String</code>转化为<code>Resource</code>格式：
<ul>
<li><code>classpath:bean.xml</code>：从<code>classpath</code>(例如<code>target/classes</code>)中加载，使用<code>ClassPathResource</code>实现类</li>
<li><code>file:///src/main/config.xml</code>：从文件系统中加载，使用<code>UrlResource</code>实现类</li>
<li><code>https://www.baidu.com/</code>：从<code>URL</code>中加载，使用<code>UrlResource</code>实现类</li>
<li><code>classpath*:WEB-INF/**/*.xml</code>：从<code>classpath</code>中查找，使用<code>Ant</code>风格的通配符，<code>**</code>表示零或多个目录、<code>*</code>表示零或多个字符(不能跨越目录)，会查找所有包含该路径的资源</li>
<li>无前缀：视具体的<code>ApplicationContext</code>实现类不同，可能是<code>ClassPathResource</code>或<code>ServletContextResource</code></li>
</ul></li>
</ul>
<h2 id="例子">例子</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;a.xml&quot;</span>);</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> resourceLoader.getResource(<span class="string">&quot;https://www.baidu.com/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (res.exists() &amp;&amp; res.isReadable()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> res.getInputStream(); <span class="type">ReadableByteChannel</span> <span class="variable">bc</span> <span class="operator">=</span> res.readableChannel();) &#123;</span><br><span class="line">            <span class="comment">// use bio or nio</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="resourceloaderaware接口可选"><code>ResourceLoaderAware</code>接口(可选)</h2>
<ul>
<li>当一个<code>bean</code>需要在内部使用<code>ResourceLoader</code>或<code>ResourcePatternResolver</code>来方便地在类内部加载资源时，采用<code>@Autowired</code>才是更推荐的方式</li>
<li>如果需要隐式注入而非显式声明，可以使<code>bean</code>实现<code>ResourceLoaderAware</code>接口</li>
<li><code>ResourceLoaderAware</code>接口有一个方法<code>setResourceLoader(ResourceLoader rl)</code>，当这个<code>bean</code>被<code>ApplicationContext</code>实例纳入管理时，<code>ApplicationContext</code>会把自己当作参数传递给这个<code>set</code>方法</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Spring framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring framework: IoC容器</title>
    <url>/blogs/2025/07/03/spring-core-IoC/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="ioc容器"><code>IoC</code>容器</h1>
<h2 id="简介">简介</h2>
<ul>
<li><p><code>IoC</code>(<code>Inversion of Control</code>，控制反转)容器的原则是使原本有相互依赖的各个部分解耦，实现松耦合地运作
在传统的组合中，上层的模块在内部定义某些对象的类型，控制权在上层的模块中，如果需要修改内部的业务逻辑则会违反开闭原则
而<code>IoC</code>的思想则是使上层的模块将控制权“反转”给一个第三方，例如开发者自己或者一个<code>IoC</code>容器，由外部来控制并决定向上层模块提供什么样的实现类</p></li>
<li><p><code>IoC</code>容器的常见的实现方法是<code>DI</code>(<code>Dependency Injection</code>，依赖注入)，即上层模块所依赖的其它对象仅通过<strong>构造方法</strong>或<strong>工厂方法</strong>或<strong><code>setter</code></strong>方法暴露注入入口，容器在创建对象时控制注入对象的实现类</p></li>
<li><p>当我们用到<code>IoC</code>容器时，说明一个类的实例往往是全局单例的，只要明白这个点，就能理解为什么会发生注入冲突
但同样可以实现非单例的实例化</p></li>
<li><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Eye</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackEye</span>(); <span class="comment">// 在后续改动时违反开闭原则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Eye e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Eye e)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">BlackEye</span>()); <span class="comment">// 在外部注入</span></span><br></pre></td></tr></table></figure></li>
<li><p>而在<code>Spring</code>框架中，这个“外部注入”不需要由开发者手动地注入，而是通过声明式注解由<code>Spring</code>内置的<code>IoC</code>容器<strong>自动注入</strong></p></li>
<li><p><code>org.springframework.beans</code>与<code>org.springframework.context</code>是<code>IoC</code>容器的核心</p></li>
<li><p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0-M9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="元数据配置">元数据配置</h2>
<h3 id="上下文">上下文</h3>
<ul>
<li><p><code>Spring</code>的<code>IoC</code>容器通过解析元数据来管理<code>Bean</code></p>
<p>元数据通常包括以下内容：</p>
<ul>
<li><code>Bean</code>的类型</li>
<li><code>Bean</code>的<code>id</code></li>
<li><code>Bean</code>的依赖注入</li>
<li><code>Bean</code>的作用域</li>
<li><code>Bean</code>的生命周期行为(以回调形式存在)</li>
<li><code>Bean</code>的懒加载、协作者等其它元数据</li>
</ul></li>
<li><p><code>ApplicationContext</code>：应用上下文接口的实例表示一个<code>IoC</code>容器，它会自动创建、配置、组装所有的<code>Bean</code></p>
<ul>
<li>继承<code>BeanFactory</code>接口：该接口提供一系列和<code>Bean</code>有关的方法
<code>T getBean(String name, Class&lt;T&gt; clazz)</code>：获取它管理的类型为<code>T</code>、名字为<code>name</code>的<code>Bean</code></li>
<li>继承<code>MessageSource</code>接口：该接口提供国际化处理信息的能力
<code>String getMessage(String msg, Object[] args, Locale locale)</code>：根据<code>locale</code>以及可选的选项<code>args</code>解析<code>msg</code></li>
</ul></li>
<li><p>创建一个<code>ApplicationContext</code>实例：
创建<code>ApplicationContext</code>实例同时意味着许多配置，在<strong>不依靠外部框架</strong>(如<code>Spring Boot</code>和<code>Tomcat</code>)的情况下，<code>ApplicationContext</code>只能通过<code>new</code>创建
<code>Spring</code>提供了两种构造<code>ApplicationContext</code>实例的方式，分别为基于<code>XML</code>的配置、基于<code>Java</code>的配置
基于<code>XML</code>的配置：实现类为<code>ClassPathXmlApplicationContext</code>，构造方法需要的参数是<code>String...</code>，即一系列<strong><code>xml</code>配置文件的路径</strong>
基于<code>Java</code>的配置：实现类为<code>AnnotationConfigApplicationContext</code>，构造方法需要的参数是<code>Class&lt;?&gt;...</code>，即一系列<strong>由<code>@Configuration</code>注解的配置类</strong></p></li>
<li><p>基于<code>XML</code>、基于注解、基于<code>Java</code>的关系</p>
<ul>
<li>三种方式都由<code>Spring</code>控制实例的注入</li>
<li><code>XML</code>是最早的<code>Spring</code>提供的配置方式，它是外部的、支持非侵入式地修改元数据配置</li>
<li><code>Spring 2.0</code>开始逐步地提供一系列注解来方便分散化、简洁化配置，提供了基于注解的配置，位于<code>org.springframework.stereotype</code>和<code>org.springframework.beans.factory.annotations</code>包中
在基于注解的配置里，开发者对实例的创建和注入的控制方式和<code>XML</code>形式类似，只是停留在<strong>声明<code>Bean</code></strong>上，目的是简化配置代码书写并提供编译时的类型检查
例如<code>stereotype</code>包中的<code>@Service</code>、<code>@Repository</code>、<code>@Component</code>，它们的修饰表示<strong>声明这个类属于某种<code>Bean</code></strong>，即配置<strong>是什么</strong>的元数据
例如<code>beans.factory.annotations</code>包中的<code>@Autowired</code>和<code>@Qualifier</code>，它们修饰表示指示如何创建<code>Bean</code>
这种方式的配置需要在<code>XML</code>或<code>Java</code>中启用组件扫描来纳入管理</li>
<li><code>Spring 3.0</code>开始，提供<code>org.springframework.context.annotations</code>来替代整个<code>XML</code>形式的配置，并提供了新的<code>ApplicationContext</code>的实现类，例如<code>@Configuration</code>与<code>@Bean</code>
尽管注入仍由<code>Spring</code>框架管理，但这种方式允许开发者十分灵活地决定如何创建一个实例，允许使用<code>Java</code>代码进行带有分支判断地创建实例</li>
<li>第二种方式和另外两种方式并不是互斥的，第一种方式和第三种方式对应着两种不同的实现类，而第二种方式则是作为一种方便的声明式<code>API</code>存在，适用于结构简单的<code>Bean</code>的声明
现代应用中常使用第二种与第三种方式混合的配置方案，但并不意味着<code>XML</code>配置完全无用，它的外部、非侵入性正是它的特点</li>
</ul></li>
</ul>
<h3 id="bean的xml配置"><code>Bean</code>的<code>XML</code>配置</h3>
<ul>
<li><p><code>&lt;bean/&gt;</code>的<code>id</code>、<code>name</code>属性或<code>&lt;alias/&gt;</code>：它们都是可选项，默认由<code>Spring</code>生成一个唯一的<code>id</code></p>
<ul>
<li><code>id</code>是唯一标识，若自定义，则必须是唯一的，不允许使用特殊字符，通常使用驼峰命名法</li>
<li><code>name</code>是别名集合(字符串表示)，不同别名用<code>,</code>或<code>;</code>隔开，允许重复、允许使用类似<code>/</code>的特殊字符</li>
<li>若使用引用，则查找<code>id</code>是否含有匹配项、然后查找<code>name</code>是否含有匹配项、然后查找类型是否匹配，若有二义性则报错</li>
<li><code>&lt;alias name="" alias=""/&gt;</code>：在定义<code>bean</code>标签以外的地方定义它的别名</li>
</ul></li>
<li><p>选择<code>bean</code>的构造器：</p>
<ul>
<li><code>class</code>属性：用于指定该<code>bean</code>所使用的构造器的来源，并不一定是<code>class</code>类型的</li>
<li>若不提供任何构造方法，则自动根据提供的参数匹配合适的构造方法</li>
<li>使用静态工厂方法：指定<code>factory-method</code>属性，会调用指定<code>class</code>属性这个类内部的<code>factory-method</code>静态方法</li>
<li>使用工厂类实例的工厂方法：不能指定<code>class</code>属性，而是指定<code>factory-bean</code>属性，它是另一个类型为某个工厂类的<code>bean</code></li>
<li><code>primary</code>布尔属性：标识该<code>&lt;bean/&gt;</code>对应的构造器为默认的创建方法</li>
</ul></li>
<li><p>提供构造参数(依赖注入)来消除同名构造器的二义性：</p>
<ul>
<li>基于构造器的注入：<code>&lt;constructor-arg/&gt;</code>：作为<code>&lt;bean/&gt;</code>的子标签，表示传递给构造器的参数，为了消除二义性，它有若干属性，不必全部指定而只需要保证不存在歧义即可：
<code>name</code>属性表示参数的名称
<code>index</code>属性表示参数的索引(<code>0-idx</code>)
<code>type</code>属性表示参数的类型
<code>value</code>属性表示参数的字面值
<code>ref</code>属性表示使用其它<code>bean</code>作为参数</li>
<li>基于<code>setter</code>的注入：要求该<code>bean</code>对应的<code>class</code>含有指定属性的<code>setter</code>方法，则可使用<code>&lt;property/&gt;</code>传递用<code>setter</code>设置的参数
其属性与<code>&lt;constructor-arg/&gt;</code>一致</li>
<li>一般来说，<code>&lt;constructor-arg/&gt;</code>会严格匹配构造器，因此会更安全(不会出现<code>null</code>)
<code>&lt;property/&gt;</code>则是在构造后通过调用<code>setter</code>方法进行配置的方案，可能导致某些属性没被注意而为<code>null</code>
前者若想达到可选参数的效果，也可使构造器参数为<code>Optional&lt;T&gt;</code>或使用<code>@Nullable</code>注解</li>
</ul></li>
<li><p>启用组件扫描：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;包名&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- primary标识首选 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo.beans.UserBean&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 根据构造参数唯一确定构造器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;otherBean&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;otherBean&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;str&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后续的setter配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;optionalArg&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 不带任何参数表示选择默认构造方法, 但这是在primary之后的选择 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo.beans.UserBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在外部起别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;userBean&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;uB&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bean的java配置"><code>Bean</code>的<code>Java</code>配置</h3>
<ul>
<li><p>声明为具有某种功能的<code>bean</code>(类级修饰)：</p>
<ul>
<li><code>@Component(value="")</code>：声明为一般的<code>bean</code>，<code>value</code>可选，表示该<code>bean</code>的名称，默认为类名的驼峰命名</li>
<li><code>@Service</code>：声明为服务类，<code>@Component</code>的一种</li>
<li><code>@Repository</code>：声明为持久化类，<code>@Component</code>的一种</li>
<li><code>@Controller</code>：声明为控制器类，<code>@Component</code>的一种</li>
<li>需要用<code>@ComponentScan(basePackages="")</code>启动扫描</li>
</ul></li>
<li><p>依赖注入：</p>
<ul>
<li><code>@Autowired(required=true)</code>：修饰方法或属性，表示自动注入，修饰方法时若修饰构造器或<code>setter</code>则对应构造器注入或<code>setter</code>注入、修饰一般方法则会使<code>bean</code>在初始化完成后调用该方法，(不推荐)修饰属性时表示直接注入
默认强制要求注入，可使<code>required=false</code>或使用<code>Optional&lt;T&gt;</code>或使用<code>@Nullable</code>表示可选
如果含有多个构造方法，基于注解的配置要求至少有一个<code>@Autowired</code></li>
<li><code>@Qualifier(value="")</code>：修饰类或<code>@Bean</code>方法时给该<code>bean</code>起限定符，修饰属性或形参时表示指定使用<code>value</code>对应的<code>bean</code>注入该属性</li>
<li><code>@Value(value="")</code>：注入简单字面值，<strong>可以修饰形参</strong></li>
<li><code>@Primary</code>：标识某个类时表示当某个接口或某个抽象类存在多个实现类时，选择该类作为首选的实现
标识某个<code>@Bean</code>方法时表示当存在多个返回同一类型的方法时首选该方法</li>
</ul></li>
<li><p>基于<code>Java</code>的配置：</p>
<ul>
<li><code>@Configuration</code>：标识某个类为配置类<code>bean</code>，它也是一个<code>@Component</code></li>
<li><code>@Bean</code>：标识某个方法为创建某个类型<code>bean</code>的方法，配合<code>@Primary</code>决定首选方法
其<code>name</code>属性表示这个<code>bean</code>的名字，它可以同<code>@Qualifier</code>的<code>value</code>属性一样被绑定然后用<code>@Qualifier</code>指定注入
因为一般<code>name</code>的命名有一定风格(通常是类名的驼峰命名)，而如果需要用含特殊语义的命名，<code>@Qualifier</code>的<code>value</code>属性是一种选择</li>
</ul></li>
<li><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;demo.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认用方法名作为@Bean的name</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Primary</span></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> demo.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepo, <span class="meta">@Value(&quot;0&quot;)</span> <span class="type">int</span> type)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.userRepo = userRepo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(demo.config.BeansConfiguration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Spring framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库: 期末复习</title>
    <url>/blogs/2025/06/18/db-review/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="期末总复习">期末总复习</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="文件系统的弊端">文件系统的弊端</h3>
<ul>
<li>数据冗余、数据不一致：在多个文件中，某些数据会出现冗余，导致修改时涉及很多文件，此时发生异常将导致数据不一致问题；这里的<strong>一致性</strong>指的是<strong>不同文件</strong>中数据<strong>本该相同，但实际上不同</strong>的情况</li>
<li>访问困难</li>
<li>数据孤立</li>
<li>数据<strong>完整性</strong>：指<strong>文件中数据不符合现实逻辑</strong>的情况，对某个数据添加约束时，很难约束所有涉及到该文件的程序</li>
<li>操作的原子性：对文件的修改难以做到要么全部完成、要么完全没有修改</li>
<li>多用户并发访问：当多个用户同时访问文件时，容易导致数据不一致问题</li>
<li>安全性问题：难以灵活调整不同用户对文件的访问权限</li>
</ul>
<h3 id="dbms基本概念"><code>DBMS</code>基本概念</h3>
<ul>
<li>数据是描述现实事物的符号记录</li>
<li>数据库是数据的集合</li>
<li><code>DBMS</code>(数据库管理系统)，是用于管理数据库的基础软件系统，也是通常意义上的数据库
数据库系统则是由<code>DBMS</code>、数据库、管理员、应用进程组成的一套系统</li>
<li>数据库的三级模式：分为外部层(视图层、外模式)、概念层(逻辑层、模式)、内部层(物理层、内模式)
<ul>
<li>先考虑模式的概念：相当于一种数据类型，一个模式包含多个属性名及对应的属性类型和完整性约束
平常接触的表就是一个模式的实例
平常一个模式只会有一个实例，所以经常将“关系”、“关系模式”混着说</li>
<li>视图层：对于不同的用户、根据权限和需求展现不同的数据
例如平时使用查询语句以及创建视图时，查出来的结果，用户可以修改视图的列名，由系统完成从视图层到概念层的映射，只不过这些视图是</li>
<li>逻辑层：包含由创建该模式的用户起的名称及类型，例如平常接触的表就是一个概念层的实例</li>
<li>物理层：包含具体来说在数据库管理系统中真正的由系统起名、由系统管理的名称；以及其对应的存储大小、存储位置等</li>
</ul></li>
<li>数据库的两级映射：使数据库具有独立性，在一层发生变动时，其它层不需要由用户维护而仍保持不变
<ul>
<li>视图层和逻辑层：使数据库具有逻辑独立性</li>
<li>逻辑层和物理层：使数据库具有物理独立性</li>
</ul></li>
<li>数据模型：是数据、数据联系、数据语义、数据一致性约束的集合
<ul>
<li>概念数据模型：实体-联系模型 也就是<code>ER</code>图</li>
<li>逻辑数据模型：关系模型、网状模型、层次模型、基于对象数据模型、半结构化数据模型</li>
<li>物理数据模型：<code>B</code>树等</li>
</ul></li>
</ul>
<h3 id="关系数据模型">关系数据模型</h3>
<ul>
<li>关系数据模型是一种逻辑数据模型
其中数据结构、数据完整性约束体现在用户设计的模式上
数据操作和数据结构、数据完整性约束共同构成关系数据模型</li>
<li>在关系数据模型中：
<ul>
<li>关系模式的实例称为关系，它们通常是一对一的，所以会混着用</li>
<li>关系也称为表</li>
<li>属性相当于表的一列</li>
<li>元组相当于表的一行，元组是一个关系的最小单位</li>
</ul></li>
<li>一个属性的域是所有可以作为该属性的值的集合
域的原子性是第一范式，即域的所有值都是不可再分的</li>
<li>空值<code>NULL</code>是一个特殊的值，表示未知、不确定，其参与的所有表达式都返回<code>false</code>(除<code>is null</code>等特殊表达式)</li>
<li>关系完整性约束：
<ul>
<li>超码：是一个属性组，若这个属性组的值确定，则可以唯一确定关系中所有属性的值</li>
<li>候选码：是最小的超码，其任何真子集都不是超码
所有在候选码中出现过的属性称作<strong>主属性</strong>，其余是非主属性</li>
<li>主码：被设计者选中来作为关系的唯一标识的那个候选码</li>
<li>实体完整性约束：对于一个主码，它会受到<strong>实体完整性约束</strong>，用户插入的主码的值必须满足唯一、非空</li>
<li>参照完整性约束和外码：一个关系<span
class="math inline"><em>R</em><sub>1</sub></span>的属性组<span
class="math inline"><em>T</em><sub>1</sub></span>参照另一个关系<span
class="math inline"><em>R</em><sub>2</sub></span>的主码<span
class="math inline"><em>T</em><sub>2</sub></span>，称为<span
class="math inline"><em>T</em><sub>1</sub></span>是参照<span
class="math inline"><em>R</em><sub>2</sub></span>的外码 其中，<span
class="math inline"><em>T</em><sub>1</sub></span>不要求是主码，但有<strong>参照完整性约束</strong>，<span
class="math inline"><em>T</em><sub>1</sub></span>的值要么<strong>为空</strong>、要么是<strong>现在</strong><span
class="math inline"><em>R</em><sub>2</sub></span>中<strong>存在的<span
class="math inline"><em>T</em><sub>2</sub></span>的值</strong> <span
class="math inline"><em>T</em><sub>2</sub></span>要求是<span
class="math inline"><em>R</em><sub>2</sub></span>的主码</li>
<li>用户自定义完整性约束：唯一性约束、非空约束、检查约束(约束值的范围)</li>
</ul></li>
</ul>
<h2 id="关系代数">关系代数</h2>
<h3 id="概述">概述</h3>
<ul>
<li><p>过程式查询语言</p></li>
<li><p>基本、附加、扩展</p></li>
<li><p>基本运算：<span
class="math inline"><em>σ</em>、<em>Π</em>、</span></p></li>
<li><p><span
class="math inline">$\Pi_{投影的若干列}\left(\begin{align}\sigma_{选择条件}\left(数据源\right)\end{align}\right)$</span></p></li>
<li><p><span
class="math inline"><em>σ</em></span>：选择(限制)运算</p></li>
<li><p>选择条件可用的逻辑运算符：<span
class="math inline"> ∧ 、 ∨ 、¬</span></p></li>
<li><p><span
class="math inline"><em>Π</em></span>：狭义的投影运算，只能选择属性进行投影</p></li>
<li><p><span
class="math inline"><em>ρ</em><sub><em>新</em><em>名</em></sub>(<em>原</em><em>名</em>)</span>：重命名运算</p></li>
<li><p><span class="math inline">$\cross$</span>：笛卡尔积运算</p></li>
<li><p>集合运算：<span class="math inline"> ∪ 、−</span></p></li>
<li><p><span class="math inline">⋈</span>：自然连接</p></li>
<li><p><span
class="math inline">⟕、⟖、⟗</span>：左/右/全外连接，在<strong>自然连接的基础</strong>上保留左端/右端/两端的所有行</p></li>
<li><p><span class="math inline">⋈<sub><em>θ</em></sub></span>：<span
class="math inline"><em>θ</em></span>连接，其中<span
class="math inline"><em>θ</em></span>是自定义的连接条件</p></li>
<li><p>关系除：<span
class="math inline"><em>r</em>(<em>R</em>)</span></p></li>
<li><p>聚集函数：<span
class="math inline"><sub><em>分</em><em>组</em><em>依</em><em>据</em></sub>𝒢<sub><em>聚</em><em>集</em><em>函</em><em>数</em><em>值</em></sub></span></p></li>
</ul>
<p><span
class="math inline">$\begin{align}\Large\rm\Pi_{ename,sal}(\sigma_{dept.loc='New\
York'\wedge emp.deptno=dept.deptno}(emp\cross
dept))\end{align}$</span></p>
<h2 id="数据库设计">数据库设计</h2>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li>在进行需求分析后，数据库设计分为三步：
<ul>
<li>设计概念数据模型</li>
<li>设计逻辑数据模型</li>
<li>设计物理数据模型</li>
</ul></li>
</ul>
<h3 id="er模型设计"><code>ER</code>模型设计</h3>
<ul>
<li><p><code>ER</code>模型是最常见的概念数据模型，全称<code>Entity-Relationship</code>模型，即实体-联系模型</p></li>
<li><p><code>ER</code>模型由以下部分组成：</p>
<ul>
<li>实体集</li>
<li>联系集</li>
<li>属性和它的域</li>
</ul></li>
<li><p>属性的类型：</p>
<ul>
<li><p>简单类型</p></li>
<li><p>复合类型：由多个属性组成的属性，在<code>ER</code>模型中表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">composite_attribute</span><br><span class="line"> component_1</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>即由缩进表示从属关系</p></li>
<li><p>多值类型：可能同时含有多个值的类型，在<code>ER</code>模型中表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;multivalue_attribute&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>派生属性(或导出属性)：可以由其它属性求出的属性，在<code>ER</code>模型中表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">derived_attribute()</span><br></pre></td></tr></table></figure></li>
<li><p>作为码的属性：在<code>ER</code>模型中用<strong>下划线</strong>指出</p></li>
</ul></li>
<li><p>实体由属性和具体的值表示，由所有可能的实体构成的集合就是实体集
实体集在<code>ER</code>模型中表示为方框，上面是实体集名称，下面是属性集合</p></li>
<li><p>联系是若干实体之间的关联，也就是一个联系允许关联多个实体(但本文仅考虑二元联系)，但<strong>不允许有关联联系的联系</strong>
由相同类型的联系构成的集合就是联系集，在<code>ER</code>模型中表示为棱形
一个联系集允许有不同于相关联实体集属性的属性，称为<strong>描述性属性</strong>，在<code>ER</code>模型中表示为由<strong>虚线引出的方框</strong>中的属性</p></li>
<li><p>参与度约束：</p>
<ul>
<li>称一个实体<strong>参与</strong>一个联系集，是一个实体<strong>至少对应一个</strong>另一端的实体，即限制对应关系的<strong>下限</strong></li>
<li>称一个实体集<strong>完全参与</strong>一个联系集，是这个实体集的所有实体都参与这个联系集
否则称这个实体集<strong>部分参与</strong>这个联系集</li>
<li>完全参与和部分参与在<code>ER</code>模型中表示为双线、单线</li>
</ul></li>
<li><p>映射基数约束：限制对应关系的<strong>上限</strong>，分为一对一基数、一对多基数、多对多基数</p>
<ul>
<li>一对一基数：双方实体集都满足“所有实体<strong>至多对应一个</strong>另一端的实体”</li>
<li>一对多(或多对一)基数：对于多方实体集，没有上述限制</li>
<li>多对多基数：对于双方实体集都没有上限的限制</li>
</ul></li>
<li><p>码约束：</p>
<ul>
<li>对于实体集来说，用户定义的码属性就是该实体集的码，它们的某个值必须能够唯一标识一个实体</li>
<li>对于联系集来说，多方实体集的码属性就是联系集的码；如果两边都是多方，则使用双方的码作为联系集的码；如果双方都是“一”方，则使用任意一方的码作为联系集的码</li>
<li><code>ER</code>模型中不允许出现起外码功能的属性，如果实体集中存在这样的属性则需要删去
如果删去后剩余的码属性无法唯一标识一个实体，但依赖于另一方的码属性后又可以唯一标识时，则称该实体集为<strong>弱实体集</strong>，关联该弱实体集和其依赖的强实体集的<strong>联系集</strong>用<strong>双棱形</strong>表示
弱实体集的“码属性”没有码的职责，因此它们的集合称为<strong>分辨符</strong>，用<strong>虚线下划线</strong>表示</li>
</ul></li>
</ul>
<h3 id="关系型数据模型设计">关系型数据模型设计</h3>
<ul>
<li>关系型数据模型是一种逻辑数据模型，将<code>ER</code>模型转化为关系型数据模型</li>
<li>对于所有一对一的联系集，联系集不需要单独作为一个关系，两个实体集各作为一个关系，联系集的属性可作为任意一个实体集的属性</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>树的算法: 点分治</title>
    <url>/blogs/2025/06/11/algo-tree-point-dac/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="概述">概述</h3>
<ul>
<li>点分治适用于处理类似问题：需要维护/查询树中<strong>任意两点的路径长度</strong>(不含平行边)
其输出往往不是给出两点求距离，而是<strong>给出距离</strong>查询<strong>是否存在这样的路径长度/小于该距离的路径数量</strong>等等
因为所有路径都可通过<strong>经过/不经过某点来分类</strong>，点分治是比一般暴力更优的借助分治思想的另类暴力</li>
<li>(朴素暴力法)：对每个结点都作为起点进行遍历，每次遍历<span
class="math inline"><em>O</em>(<em>n</em>)</span>，因此总共<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>
</ul>
<h3 id="算法结构">算法结构</h3>
<ul>
<li><p>考虑一棵带权无根树，即<strong>任意结点均可作为根结点且不影响答案</strong>，任选一根结点<span
class="math inline"><em>r</em></span>
则任意两点的路径可分为<strong>经过<span
class="math inline"><em>r</em></span></strong>、<strong>不经过<span
class="math inline"><em>r</em></span></strong>的两类路径 经过<span
class="math inline"><em>r</em></span>的路径分为<strong>以<span
class="math inline"><em>r</em></span>为起点</strong>、<strong>不以<span
class="math inline"><em>r</em></span>为起点</strong>(也不为终点)两类路径；所有不以<span
class="math inline"><em>r</em></span>为起点的路径可由前者排列组合求得(并不是前者所有路径的排列组合，<strong>两条路径途径结点必须没有交集才可合并</strong>为新的经过<span
class="math inline"><em>r</em></span>的路径) 所有<strong>不经过<span
class="math inline"><em>r</em></span></strong>的路径可由<strong>递归</strong>算法(其新的根结点为原根结点的孩子，且计算时<strong>删去原根结点</strong>)求得
因此仅需要考虑经过<span
class="math inline"><em>r</em></span>的路径如何计算</p></li>
<li><p>上述给出了分治的雏形(递归求解)，为了使分治不退化至<span
class="math inline"><em>O</em>(<em>n</em>)</span>的深度，一般分治需要使分割点尽量在序列中间；点分治也同理，需要使分治中心：<strong>根结点为树的重心</strong>，以尽量达到<span
class="math inline"><em>O</em>(log<em>n</em>)</span>的递归深度
<strong>寻找重心过程</strong>：详见<a
href="6.6_树的重心.md"><code>6.6_树的重心</code></a>，由于需要多次查询重心、且每次查询的总结点数将变化，需要改动：</p>
<ul>
<li>添加<code>visited</code>数组，标识“某结点被删除”</li>
<li>求子树的重心时，总结点数变为<code>size[son]</code></li>
</ul></li>
<li><p><strong>合并过程</strong>：关于所有经过<span
class="math inline"><em>r</em></span>但不以<span
class="math inline"><em>r</em></span>为起点的路径，先记录所有向下结点至根结点的距离(同时记录所属的子树)，合并时如<strong>若所属子树不同直接相加</strong>即可</p></li>
<li><p>一般可用桶/哈希表来记录路径，并支持在线查询(预处理后常数时间得到答案)
也可以用<strong>离线方式处理</strong>一批查询(对每批查询都使用一次点分治)
先对这批查询排序，然后使用双指针遍历一批路径(指计算完经过<span
class="math inline"><em>r</em></span>的所有路径后遍历)，更新布尔数组即可
为了方便排序+查询其所属子树，不宜对深搜时得到的路径数组进行改动，需要额外的数组再存储一遍路径(通过存结点编号来存路径，排序时修改排序函数即可)</p></li>
<li><p>```c++ // 采用链式前向星存树(边编号为0表示空) //
以”查询是否存在长为K的路径”为例 bool visited[VN], queryAns[QN]; //
已访问结点、查询结果Ans int size[VN], w[VN], center, //
树大小、树大小最大值、重心 n, qn, queryK[QN], //
现在遍历子树的总结点数、查询个数、查询值K dis[VN], tmp[VN], cntTmp, //
一批路径个数不多于总结点数、tmp作为将路径排成连续序列的副本(存储编号来代表路径)
from[VN]; // 所属子树 // 寻找当前树重心(赋值给center), O(n) void
getCenter(int rt, int fa, int curN) { size[rt] = 1; w[rt] = 0; for (int
i = head[rt]; i; i = edge[i].next) { if (edge[i].to != fa &amp;&amp;
!visited[edge[i].to]) { getCenter(edge[i].to, rt, curN); size[rt] +=
size[edge[i].to]; w[rt] = max(w[rt], size[edge[i].to]); } } if (!center)
{ w[rt] = max(w[rt], curN - size[rt]); if (w[rt] &lt;= (curN &gt;&gt;
1)) { center = rt; } } } // 获取所有向下结点离center的距离, O(n) void
getDistance(int rt, int fa) { for (int i = head[rt]; i; i =
edge[i].next) { if (edge[i].to != fa &amp;&amp; !visited[edge[i].to]) {
dis[edge[i].to] = dis[fa] + edge[i].w; tmp[cntTmp++] = edge[i].to; //
也可用tmp[0]代替cntTmp, 大差不差 from[edge[i].to] = from[rt] ? from[rt]
: edge[i].to; getDistance(edge[i].to, rt); } } } //
对离center距离进行合并+处理查询 void calc() { int left, right; cntTmp =
0; // 部分题解在遍历子树时调用getDis(方便确定所属子树),
其实对getDis稍作改动即可简化 dis[center] = 0; //
用来表示以center为起点的路径 tmp[cntTmp++] = center; getDistance(center,
0); sort(tmp, tmp + cntTmp, <a
href="const%20int%20l,%20const%20int%20r"></a> -&gt; bool { return
dis[l] &lt; dis[r]; }); for (int i = 0; i &lt; qn; ++i) { l = 0; r =
cntTmp - 1; if (!queryAns[i]) { // 已有查询结果的不用查 while (l &lt; r)
{ // 双指针遍历 // 前两个分支查以center为起点(和过大则右指针左移) if
(dis[tmp[l]] + dis[tmp[r]] &gt; queryK[i]) { –r; } else if (dis[tmp[l]]
+ dis[tmp[r]] &lt; queryK[i]) { ++l; } // 和相等又分两种,
可以合并/不可合并 else if (from[tmp[l]] == from[tmp[r]]) { // 不可合并
if (dis[tmp[l]] == dis[tmp[l + 1]]) ++l; // 两分支顺序无要求 else –r; }
else { // 可合并 queryAns[i] = true; break; } } } } } //
递归进行所有子树的calc() void solve(int rt, int curN) { int tmpN;
calc(); // 计算经过center的路径 visited[rt] = 1; // 表示center已计算 for
(int i = head[rt]; i; i = edge[i].next) { // 子树比重心更大,
说明在原来的有根树中子树是重心的向上子树, 因此用树大小减去rt大小 tmpN =
size[edge[i].to] &gt; size[rt] ? curN - size[rt] : size[edge[i].to];
getCenter(edge[i].to, 0, tmpN); solve(center, tmpN); } } int main() {
cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; // 输入略 getCenter(1, 0, n); //
计算整棵树重心 solve(center, n); // 输出略 }</p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Tree Algo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
        <tag>devide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统: 期末复习</title>
    <url>/blogs/2025/06/11/os-review/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="操作系统复习">操作系统复习</h1>
<h2 id="概述">概述</h2>
<h3 id="计算机启动boot">计算机启动(<code>Boot</code>)</h3>
<ul>
<li>分为四个阶段，第一阶段为<code>BIOS</code>(<code>Basic Input/Output System</code>)
<ul>
<li>硬件自检(<code>Power-On Self-Test</code>，即<code>POST</code>)</li>
<li><code>BIOS</code>将控制权交给下一个启动程序，启动的顺序被存储在外存中</li>
</ul></li>
<li>第二阶段：主引导记录(<code>Master Boot Record</code>，即<code>MBR</code>)，是某个硬盘第零柱面的第一扇区
<ul>
<li>将控制权转让，即<code>BIOS</code>读取<code>MBR</code>并将其放入内存，并通过<code>MBR</code>得知操作系统的具体分区</li>
<li>如果此时拥有控制权的设备不能用于启动(在<code>MBR</code>中有特殊标注)，则按顺序继续转让控制权，继续读取下一个设备的<code>MBR</code></li>
<li>当计算机有启动管理器这个程序时，计算机在转让控制权时会由用户决定</li>
</ul></li>
<li>第三阶段：硬盘启动
<ul>
<li>当找到可以用于启动的硬盘时，也就知道了操作系统的具体分区，计算机会读取这个分区的卷引导记录(<code>Volumn Boot Record</code>，即<code>VBR</code>)，即这个分区的第一个扇区
计算机就可以精确地找到操作系统的位置并加载</li>
</ul></li>
<li>第四阶段：操作系统
<ul>
<li>系统内核先被加载，然后运行<code>init</code>进程，直到运行<code>login</code>进程让用户登录</li>
</ul></li>
</ul>
<h3 id="os的目的和发展"><code>OS</code>的目的和发展</h3>
<ul>
<li>在最初没有<code>OS</code>，输入、输出完全由手工操作时，每个任务由操作人员准备和放入，效率低下
<code>OS</code>出现的目的是<strong>提高系统资源利用率</strong>，增加系统吞吐量，以至于到后来提供方便性(对用户方便)、可扩充性(对扩充新模块方便)、开放性(对不同计算机的程序的移植方便)</li>
<li><strong>单道批处理</strong>：用户事先放入<strong>多个同类作业</strong>，由监控程序整理为<strong>一批作业串行执行</strong>
但当作业无法继续运行时，它不会放弃<code>CPU</code>，导致仍存在系统资源的浪费</li>
<li><strong>中断和通道技术的出现(进入集成电路时代)，推动了现代意义上操作系统的出现</strong>
发展为<strong>多道程序批处理系统</strong>，主存中可同时存在多个作业，<code>CPU</code>在其中切换
实现了一定程度的<strong>并发</strong>，即不同进程交替占用<code>CPU</code>运行，实现了<strong>微观上串行、宏观上并行</strong>的效果
但人机脱离，<strong>没有交互性</strong></li>
<li><strong>分时操作系统</strong>：相比多道程序批处理系统，分时操作系统是<strong>联机的、多用户的、交互的</strong>操作系统，具有交互性、多用户同时性、独立性、及时性
<code>Unix</code>是典型的分时系统</li>
<li>实时操作系统：强调可靠性和实时性，通用性差，专用于有实时控制需求的场景
分为硬实时和软实时，硬实时保证在限定的时间内完成任务，软实时并不保证这一点但也不允许过多地超过规定时间</li>
</ul>
<h3 id="操作系统服务">操作系统服务</h3>
<ul>
<li>用户接口：<code>CLI、GUI</code>等</li>
<li>进程管理：对进程进行调度</li>
<li>存储管理：针对内存进行存储分配、存储共享、存储保护(越界发生中断)、存储扩张(虚存)</li>
<li>设备管理：管理<code>I/O</code>设备</li>
<li>文件管理：文件存储管理、目录管理、文件操作管理、文件保护</li>
<li>通信服务：同一机器上不同进程的<code>IPC</code>和不同计算机上的<code>IPC</code></li>
<li>资源分配</li>
<li>错误检测</li>
<li>统计</li>
<li>保护和安全</li>
</ul>
<h3 id="操作系统的结构">操作系统的结构</h3>
<h3 id="系统调用">系统调用</h3>
<ul>
<li>操作系统分为两种模式：内核模式和用户模式，通过<code>CPU</code>状态位帮助<code>OS</code>判断现在<code>CPU</code>处于<strong>管态(内核态)</strong>或<strong>目态(用户态)</strong>，目态相比于管态，无法执行一些特定的指令
若发生中断或错误，系统会自动切换到<strong>管态来执行中断处理程序</strong></li>
<li>系统调用是<strong>内核暴露给用户的原始接口</strong>，用户可通过系统调用申请内核的服务，内核调用的实现是通过<strong>软中断</strong>或<strong><code>syscall</code></strong>指令使用户态<strong>切换到内核态</strong>执行内核态的特殊指令和内核函数，执行完毕后再<strong>切换回用户态</strong></li>
<li><code>API</code>是应用程序接口，也即在内核之上的库例程，是用高级语言编写的更高级的封装接口，可能完全在用户空间运行，也可能封装了系统调用
用户通常用<code>API</code>编写程序，因为<code>API</code>类似一个中间件，使程序具有更强的可移植性、更直观</li>
<li>系统调用的传参方式：寄存器传参(限制参数个数)、内存块传参、堆栈传参</li>
</ul>
<h3 id="posix-api"><code>POSIX API</code></h3>
<ul>
<li><code>POSIX</code>全称<code>Portable Operating System Interface of UNIX</code>，即针对所有类<code>UNIX</code>系统的可移植操作系统接口，它是一套标准</li>
<li><code>pid_t fork()</code>：头文件<code>unistd.h</code>，用于创建一个子进程
<ul>
<li><code>fork()</code>执行一次，创建一个子进程，向父进程和子进程均返回<code>pid_t</code>值</li>
<li>对父进程的返回值一定不等于零，若小于零说明创建失败，若大于零则是子进程的<code>pid</code></li>
<li>对子进程的返回值一定等于零，子进程会采用<strong>写时拷贝</strong>的方式复制父进程的堆栈和数据段，只共享代码段且<code>PC</code>均指向<code>fork()</code>的下一条指令</li>
<li>在不使用<code>wait()</code>的情况下，父进程和子进程的执行顺序是未定的，如果父进程提前结束，子进程将挂靠在父进程的父进程上</li>
</ul></li>
<li><code>pid_t wait(int* stat_loc)</code>：头文件<code>sys/types.h</code>和<code>sys/wait.h</code>，使父进程阻塞，直至所有子进程执行完毕后唤醒
<ul>
<li><code>stat_loc</code>若不为空指针，<code>wait()</code>会将子进程的结束状态赋给<code>stat_loc</code>指向的整型变量
一般用法不关心子进程的结束状态，会使用<code>wait(NULL)</code></li>
</ul></li>
<li><code>void exit(int status)</code>：头文件<code>stdlib.h</code>，用于以状态码<code>status</code>结束当前进程</li>
</ul>
<h3 id="简单bash-shell">简单<code>bash shell</code></h3>
<ul>
<li><code>chmod</code></li>
</ul>
<h2 id="进程和线程">进程和线程</h2>
<h3 id="进程的概念">进程的概念</h3>
<ul>
<li><p>进程和程序的本质区别是<strong>动态性</strong>，进程相当于<strong>程序、<code>PCB</code>、数据</strong>的组合体
此外，进程还具有并发性、独立性、异步性</p>
<ul>
<li>并发性：多个进程在宏观上并行执行的现象</li>
<li>独立性：进程是资源分配、调度的基本单位</li>
<li>异步性：不同进程的执行通常不需要按相同的节奏推进</li>
</ul></li>
<li><p>具体来说，进程包含<strong>代码段</strong>、<strong>数据段</strong>、<strong>堆</strong>、<strong>栈</strong>、<code>PC</code>
其中，全局变量存放在数据段中，局部变量存放在栈中，动态分配内存的变量存放在堆中</p></li>
<li><p>进程状态模型： <pre><code class="highlight mermaid">graph LR
Ready(就绪) --&gt;|调度| Run(运行) --&gt;|时间片结束或被抢占式调度算法中断| Ready
Run --&gt;|处理I/O或等待事件发生| Wait(阻塞) --&gt;|I/O完成或事件发生| Ready</code></pre></p>
<pre><code class="highlight mermaid">graph LR
Ready(就绪) --&gt;|调度| Run(运行) --&gt;|时间片结束或被抢占式调度算法中断| Ready
Run --&gt;|处理I/O或等待事件发生| Wait(阻塞) --&gt;|I/O完成或事件发生| Ready
Wait &lt;--&gt; SuspendWait(挂起阻塞)
Ready &lt;--&gt; SuspendReady(挂起就绪)
Run --&gt; SuspendReady
SuspendWait --&gt; SuspendReady</code></pre></li>
<li><p>进程上下文切换</p>
<ul>
<li>指<code>CPU</code>切换到另一个进程时，保存原来进程状态、并加载新进程的状态的过程</li>
<li>涉及到用户级上下文(用户代码段、用户数据段、用户堆栈)、寄存器上下文(<code>PSW</code>程序状态寄存器、栈指针、通用寄存器)、系统级上下文(<code>PCB</code>、内存区表、内核栈)</li>
</ul></li>
<li><p><code>CPU</code>调度层次：</p>
<ul>
<li>长期调度、作业调度：选择作业载入内存的就绪队列</li>
<li>中期调度、平衡负载调度：通过交换技术，将内存中的进程换出或将挂起的进程换入，缓解内存空间压力</li>
<li>短期调度、进程调度：选择一个处于就绪队列的进程占有<code>CPU</code>执行</li>
</ul></li>
<li><p>引起进程阻塞的原因：</p>
<ul>
<li>请求系统服务</li>
<li>无新工作可做(例如无工作可做的系统进程)</li>
</ul></li>
<li><p>调度是一个系统服务，其本质是执行一个系统调用<code>schedule()</code>，正如之前所说执行系统调用是通过软中断或<code>syscall</code>指令进行，执行系统调用相当于<strong>执行一个中断处理程序</strong>，所以<strong>进程执行系统调用和陷入内核态不属于进程的调度</strong>
而通常在实现上，从<strong>内核态返回用户态</strong>时，会发生一次调度，原因大概是为了减少上下文切换的开销，在执行完系统调用后返回用户态前顺便进行一次<code>schedule()</code>，能减少因“返回用户态后立刻因为时间片结束或新进程到达导致再次被中断进行调度”造成的开销</p></li>
</ul>
<h3 id="ipc"><code>IPC</code></h3>
<ul>
<li><code>IPC</code>：<code>Inter-Process Communication</code>，进程间通信</li>
<li>低级通信：用于传递控制消息，用<strong>互斥锁</strong>、<strong>信号量</strong>实现</li>
<li>高级通信：用于传输数据，用<strong>管道</strong>、<strong>消息队列</strong>、<strong>共享内存</strong>实现</li>
</ul>
<h3 id="线程概念">线程概念</h3>
<ul>
<li>为了减少因进程调度产生的上下文切换开销，将调度的基本单位设置为进程内的若干<strong>执行序列</strong>，并将其称为线程</li>
<li>线程和进程的区别：
<ul>
<li>在引入线程后，进程仍是资源分配的基本单位，线程是系统调度的基本单位</li>
<li>同一进程下的不同线程<strong>共享代码段、数据段</strong>，每个线程有自己的<strong>堆栈、<code>PC</code>、寄存器集</strong></li>
<li>线程切换的开销小于进程切换的开销</li>
<li>线程间共享比进程间共享更简单</li>
<li>线程的引入提高了并发性，使得一个进程的不同计算任务也可以并发推进</li>
</ul></li>
<li>用户级线程：操作系统内核不支持线程，进程通过线程库来实现多线程编程的情况
<ul>
<li>若进程的一个线程进入阻塞，则所有其它对等线程也进入阻塞</li>
<li>同一进程的不同线程的切换不需要经过内核，切换时间短</li>
<li>一个进程含有多个线程不会增加整个进程的执行时间</li>
</ul></li>
<li>内核级线程：操作系统内核支持线程
<ul>
<li>一个线程的阻塞不会影响其它线程的状态</li>
<li>线程切换时需要中断并执行系统调用，切换开销大</li>
<li>多线程编程下，一个进程的执行时间更长</li>
</ul></li>
<li>多线程模型：
<ul>
<li>多对一：多个用户级线程映射到一个内核级线程</li>
<li>一对一：每个用户级线程都对应一个内核级线程</li>
<li>多对多：多个用户级线程对应<strong>相同个或更少</strong>的内核级线程</li>
<li>二级模型：允许多对多和一对一映射</li>
</ul></li>
</ul>
<h3 id="进程调度">进程调度</h3>
<ul>
<li>进程调度即短期调度，指从就绪队列中选择一个进程，将<code>CPU</code>控制权分配给它</li>
<li>调度时机：
<ul>
<li>进程从运行态到阻塞态 进程结束
均为非抢占的，进程自愿放弃<code>CPU</code></li>
<li>进程从运行态到就绪态 进程从阻塞态到就绪态
均为抢占的，进程被迫放弃<code>CPU</code>、进程根据先到先得的方式获得非<code>CPU</code>资源</li>
</ul></li>
<li>进程调度算法：
<ul>
<li>先来先服务：优先考虑等待时间</li>
<li>最短作业优先(<code>SJF</code>)：非抢占、存在饥饿</li>
<li>最短剩余时间优先(<code>SRTF</code>)：抢占、存在饥饿</li>
<li>最高响应比优先(<code>HRF</code>)：<span
class="math inline">$\begin{align}R=\frac{W+T}{T}\end{align}$</span>，周转时间(等待时间加运行时间)除以运行时间，同时考虑等待时间和运行时间</li>
<li>轮转法(<code>RR</code>)</li>
<li>最高优先级调度：静态优先级存在饥饿现象</li>
<li>多级反馈轮转法：现代操作系统采用的方式，分为多个优先级的队列，每个队列内部采用轮转法</li>
</ul></li>
</ul>
<h3 id="进程互斥与同步">进程互斥与同步</h3>
<ul>
<li><p>临界资源：多个进程共享但同一时间只允许一个进程访问的资源</p></li>
<li><p>互斥：一组并发进程由于共享某些资源，导致它们的<strong>临界区不允许交替执行</strong></p></li>
<li><p>同步：一个进程的输出作为另一个进程的输入，导致它们<strong>有执行的先后顺序</strong></p></li>
<li><p>临界区三大要求：互斥、空闲让进、有限等待</p></li>
<li><p>互斥软件解法(面包店算法)：进程先取号，在已经取号的进程里面，根据(取得的号，进程id)元组从小到大的顺序访问临界资源</p></li>
<li><p>互斥硬件解法(原子操作<code>TestAndSet()</code>)</p></li>
<li><p>信号量的两种实现：</p>
<ul>
<li>自旋锁：进程会循环申请锁，出现忙等现象，这在多处理器环境或只需要短时间占有锁的情况下是有益的，不会导致频繁的切换上下文导致巨大开销</li>
<li>非自旋锁：进程如果无法申请锁，则会进入对应的阻塞队列并阻塞，在单处理器情况下是常用的</li>
</ul></li>
<li><p>互斥信号量的<code>P</code>操作必须紧贴临界区，<code>V</code>操作无所谓</p></li>
<li><p>读者写者问题：可同时读-读、不可同时读-写、写-写
定义读信号量<code>S</code>、写信号量<code>X</code>、共享变量<code>r_cnt</code>表示读者个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读者</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(S);</span><br><span class="line">    ++r_cnt;</span><br><span class="line">    <span class="keyword">if</span> (r_cnt == <span class="number">1</span>) &#123;	<span class="comment">// 此前没有读者, 需要保证当前没有写者</span></span><br><span class="line">        P(X);</span><br><span class="line">    &#125;</span><br><span class="line">    V(S);</span><br><span class="line">    <span class="comment">/* 读取操作 */</span></span><br><span class="line">    P(S);</span><br><span class="line">    --r_cnt;</span><br><span class="line">    <span class="keyword">if</span> (r_cnt == <span class="number">0</span>) &#123;	<span class="comment">// 现在没有读者了, 释放写锁</span></span><br><span class="line">        V(X);</span><br><span class="line">    &#125;</span><br><span class="line">    V(S);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写者</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(X);</span><br><span class="line">    <span class="comment">/* 写操作 */</span></span><br><span class="line">    V(X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似这种<code>A</code>类进程间有互斥关系、<code>A</code>和<code>B</code>类进程间有互斥关系、<code>B</code>类进程间<strong>没有互斥关系</strong>，需要用共享变量统计<code>B</code>类进程的个数并用信号量维护
同理，如果<code>A</code>类进程间也没有互斥关系，也要用一个共享变量和信号量统计并维护<code>A</code>类进程个数
然后用一个互斥信号量维护资源的个数</p></li>
</ul>
<h3 id="进程死锁">进程死锁</h3>
<ul>
<li>四大方式：死锁预防、死锁避免、死锁检测、死锁恢复</li>
<li>死锁的根本原因：资源不足</li>
<li>死锁预防是预防发生死锁的四大必要条件：互斥、占有并等待、不可抢占、循环等待
<ul>
<li>解决占有并等待：进程必须一次性获取所有资源才可分配，即静态资源分配</li>
<li>解决不可抢占：如果进程申请资源失败，则要释放所有已占有的资源</li>
<li>解决循环等待：对不同类资源进行编号，进程按照资源编号递增的顺序申请资源，即有序分配资源</li>
</ul></li>
<li>死锁避免：进程申请资源分配时，动态执行银行家算法判断分配后是否仍属于安全状态，若属于则允许分配
<ul>
<li>进程需要事先说明最大所需资源数</li>
</ul></li>
<li>现代操作系统的做法是：允许进入死锁，及时进行死锁检测并恢复
<ul>
<li>死锁检测：画出资源分配图看进程之间是否存在环，实际上就是执行银行家算法</li>
<li>死锁恢复：终止引起死锁的进程或剥夺其占有的所有资源</li>
</ul></li>
</ul>
<h2 id="内存管理">内存管理</h2>
<h3 id="绑定内存地址时机">绑定内存地址时机</h3>
<ul>
<li>重定位：将逻辑地址转化为物理地址的过程</li>
<li>编译时期绑定：内存位置已知，可执行文件中存放的地址就是内存中的地址</li>
<li>装入时期绑定：内存位置未知，可执行文件中存放的地址是逻辑地址，加载到内存时才进行重定位，转化为物理地址</li>
<li>运行时期绑定(动态地址重定位)：内存位置未知，可执行文件中、装入内存后的地址均为逻辑地址，只在执行指令时通过基地址寄存器<code>BR</code>和程序虚拟地址寄存器<code>VR</code>(文件中存储的逻辑地址)算出</li>
</ul>
<h3 id="存储管理方案">存储管理方案</h3>
<ul>
<li>单一连续分配：出现在单道程序操作系统中，不需要考虑多个进程同时装入内存</li>
<li>分区管理方案
<ul>
<li>固定分区：存在内部碎片和外部碎片</li>
<li>动态分区：存在内部碎片</li>
</ul></li>
<li>页式管理方案：将内存分帧、进程空间分页，页和帧大小一致且固定
<ul>
<li>只在进程的最后一页可能存在内部碎片</li>
<li>不利于进程共享代码</li>
<li>对用户来说，进程的空间是一维线性空间，只需要提供一个逻辑地址就可以由硬件自动完成映射</li>
<li>优化页表访问：<code>TLB</code>，即<code>Translation Lookaside Buffer</code>，地址转换后备缓冲</li>
</ul></li>
<li>段式管理方案：支持由用户观点划分程序段，相当于将大进程分为多个小进程进行动态分区管理
<ul>
<li>存在外部碎片</li>
<li>对用户来说，进程的空间是二维线性空间，用户需要同时提供段号、段内偏移</li>
<li>优化段表访问：快表</li>
</ul></li>
<li>段页式管理方案：在段式的基础上，将段内偏移分为了页号、页内偏移
先通过段表地址寄存器访问段表，获取段号对应的页表位置；再访问页表获取页号对应的页面号；再加上页内偏移计算出物理地址</li>
</ul>
<h3 id="动态存储空间分配">动态存储空间分配</h3>
<ul>
<li>最先适配法：按可用空间的起始地址从小到大匹配</li>
<li>最好适配法：按可用空间的大小从小到大匹配，容易出现极小的外部碎片，每次都要重新调整可用表</li>
<li>最坏适配法：按可用空间的大小从大到小匹配，每次都要重新调整可用表</li>
</ul>
<h3 id="虚拟内存">虚拟内存</h3>
<ul>
<li>实现方式：按需调页和按需调段</li>
<li>页表每个页添加有效位表示是否有对应的物理页面，访问无效页时，发生<strong>缺页中断</strong></li>
<li>访问无效页时的缺页中断处理时，如果在内存中不存在空闲的页面，则进行页面替换，页面替换算法有：
<ul>
<li><code>FIFO</code>：淘汰最先进入内存的页
存在<code>Belady</code>现象，即内存页面数增加时反而导致缺页次数增加的现象</li>
<li><code>OPT</code>：淘汰在未来，最久不会被使用的页
这个算法是最优的，但无法实现</li>
<li><code>LRU</code>：最近最少使用，即淘汰内存中最久没被使用过的页，实现为每次命中时将页移至队尾，淘汰时替换掉队头的页
利用局部性原理，根据调用历史模拟<code>OPT</code>算法</li>
<li><code>LRU</code>近似算法——二次机会算法(<code>Clock</code>)：所有页添加引用位(初始为<code>1</code>)，淘汰时循环检查队列，若引用位为<code>1</code>则忽略并置<code>0</code>(给予二次机会)</li>
<li><code>LRU</code>近似算法——增强型二次机会算法(<code>E-Clock</code>)：添加脏位，循环检查队列，先找<code>vis=0,dirt=0</code>的页
若找不到，则找<code>vis=0,dirt=1</code>的页，将所有遇到的页<code>vis</code>置<code>0</code>
若仍找不到，则再找<code>vis=0,dirt=0</code>的页，由于第二部将<code>vis</code>置<code>0</code>，故一定能找到一页</li>
</ul></li>
<li>用户进程内存分配：
<ul>
<li>固定分配(平均或比例分配)、优先级分配</li>
<li>颠簸现象：进程没有足够的帧时，页可能会频繁地在内存、外存之间调度
解决方法：增加物理内存页面数，修改页面替换算法，降低多道程序数量</li>
</ul></li>
<li>内核进程内存分配：
<ul>
<li><code>Buddy</code>系统：固定分区分配，分区大小一定为<code>2</code>的幂，最小分区是一页</li>
<li><code>Slab</code>系统：以<code>slab</code>为最小单位</li>
</ul></li>
</ul>
<h2 id="文件系统">文件系统</h2>
<h3 id="文件系统层次">文件系统层次</h3>
<ul>
<li>用户接口</li>
<li>目录系统</li>
<li>虚拟文件系统(<code>VFS</code>)：统一的文件系统访问接口</li>
<li>磁盘调度系统</li>
</ul>
<h3 id="文件概念">文件概念</h3>
<ul>
<li>文件系统功能：按名存取、文件共享</li>
<li>逻辑结构：无结构文件(流式文件)、有结构文件(记录式文件)</li>
<li>文件访问方法：顺序存取(磁带)、随机存取(磁盘)、按键存取(索引文件)</li>
</ul>
<h3 id="目录系统">目录系统</h3>
<ul>
<li>单级目录、双级目录(主文件目录、用户文件目录)、树状结构目录、无环图结构目录</li>
<li>树状：支持文件分组、快速检索</li>
</ul>
<h3 id="空间分配方法文件的物理结构">空间分配方法(文件的物理结构)</h3>
<ul>
<li>连续空间分配、链接式分配、索引分配(在链接式分配的基础上，将所有指针存放在一个物理块中，称为索引表)</li>
<li>文件存储空间通过<strong>空闲文件目录</strong>或<strong>空闲块链</strong>或<strong>位示图</strong>管理</li>
</ul>
<h3 id="磁盘调度系统">磁盘调度系统</h3>
<ul>
<li><code>FCFS</code></li>
<li><code>SSTF</code>：最短寻道时间优先，类似<code>OPT</code>，最好但难以实现</li>
<li><code>SCAN</code>：又称电梯算法，按固定方向扫描并处理沿途请求，到达另一端后反向扫描，以此循环</li>
<li><code>C-SCAN</code>：按固定方向扫描并处理沿途请求，到达一端后立刻返回另一端(时间忽略不计)，继续沿原有方向扫描，等待时间更均匀</li>
<li><code>LOOK</code>和<code>C-LOOK</code>：记录请求柱面号的最小值和最大值，与<code>SCAN</code>和<code>C-SCAN</code>的区别是不会移动到磁盘的尽头而是移动到最小值或最大值</li>
</ul>
<h2 id="io设备管理"><code>I/O</code>设备管理</h2>
<h3 id="中断分类">中断分类</h3>
<ul>
<li>硬中断：
<ul>
<li>外部中断(中断)：<code>DMA</code>申请的中断、用户发起的中断等</li>
<li>内部中断：
<ul>
<li>陷阱：有意的中断，如系统调用</li>
<li>故障：可恢复的错误引起的中断，如缺页中断</li>
<li>终止：不可恢复的错误引起的中断，如除以零</li>
</ul></li>
</ul></li>
<li>软中断</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统: 文件系统</title>
    <url>/blogs/2025/06/10/os-filesystem/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<ul>
<li>文件是操作系统在外部持久性存储设备上存储信息的基本单位</li>
<li>文件的逻辑结构：
<ul>
<li>流式文件(无结构)：在<code>OS</code>中看作<strong>字节流</strong>或字符流，通常用于<code>OS</code>支持的文件系统中</li>
<li>记录式文件(有结构)：由固定格式的<strong>记录</strong>组成，通常用于<code>DBMS</code>中
记录的存储方式有：
<ul>
<li>顺序逻辑结构：文件中的连续记录即为文件的内容</li>
<li>索引逻辑结构：用一个顺序文件作为索引文件，对记录进行索引</li>
<li>索引顺序逻辑结构：用一个顺序文件作为索引文件，对记录组进行索引；每个记录组内顺序查找</li>
</ul></li>
</ul></li>
<li>文件的访问模式：
<ul>
<li>顺序访问：如编译器访问代码文件，磁带、磁盘均支持</li>
<li>直接访问(随机访问)：可按地址直接访问文件内数据，磁盘支持</li>
<li>索引访问：</li>
</ul></li>
<li>磁盘分区结构：
<ul>
<li><code>MBR</code>(<code>Master Boost Record</code>，主引导记录)</li>
<li><code>GPT</code>(<code>GUID Partition Table</code>，全局唯一标识分区表)</li>
</ul></li>
<li>文件系统：
<ul>
<li><code>FAT</code></li>
<li><code>NTFS</code>(<code>New Technology FS</code>)</li>
<li><code>EXT</code></li>
</ul></li>
<li>文件的目录结构：文件/目录是按名访问的
<ul>
<li>一级目录结构：仅用一个线性表存储文件的属性，多个文件容易重名</li>
<li>二级目录结构：第一级为主文件目录(每个目录项为第二级目录的索引)，第二级为用户的文件目录，用户仅能查看自己的文件目录
解决多个用户协作时文件的私有性问题和文件名混乱问题
但单个用户的文件仍容易重名、过多</li>
<li>树形目录结构：每个目录可包含多个子目录</li>
<li>非循环图目录结构：不同目录的目录项允许指向同一文件/目录，但整体目录结构无环</li>
</ul></li>
<li>文件系统设计：
<ul>
<li>分区/目录/文件的存储(核心问题)：
<ul>
<li>磁盘数据结构：保证文件系统数据在断点后仍完整保存
<ul>
<li><code>BCB</code>(<code>Boot Control Block</code>，启动控制块)：包含加载<code>FS</code>的代码</li>
<li>分区控制块(例如<code>Superblock</code>超级块)：包含分区信息、文件系统的元信息</li>
<li><code>FCB</code>(文件控制块)：存储文件/目录的元信息</li>
<li>文件的具体数据</li>
</ul></li>
<li>内存数据结构：为了提速
<ul>
<li>文件系统加载表(<code>fstab</code>)：将超级块信息读入内存</li>
<li>目录缓存：将常用目录项读入内存，加快路径解析速度</li>
<li>全系统打开文件表</li>
<li>进程打开文件表</li>
</ul></li>
</ul></li>
<li>目录实现：</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统: 内存管理</title>
    <url>/blogs/2025/06/03/os-memory/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="主存管理">主存管理</h3>
<ul>
<li><p>地址绑定：将逻辑地址和物理地址绑定</p>
<ul>
<li>编译时绑定：</li>
<li>装入时绑定(静态重定位)：</li>
<li>运行时绑定(动态重定位)：</li>
</ul></li>
<li><p>内存分配：为进程分配内存空间(以下管理方式指的是逻辑地址的管理方式)</p>
<ul>
<li>内存碎片问题：
<ul>
<li>内部碎片：</li>
<li>外部碎片：</li>
</ul></li>
<li>连续内存分配：通过分配<strong>连续的物理地址</strong>表示<strong>连续的逻辑地址</strong>
<ul>
<li>固定分区分配</li>
<li>动态分区分配：
<ul>
<li><code>First-Fit</code>(首次适配)分配算法：</li>
<li><code>Best-Fit</code>(最佳适配)分配算法：</li>
<li><code>Worst-Fit</code>(最差适配)分配算法：</li>
</ul></li>
</ul></li>
<li>页式管理及其分配：
<ul>
<li>定义：逻辑地址分页(一页大小固定，系统确定)，物理地址分块(与页大小一致)，<strong>连续的逻辑页</strong>对应的<strong>物理地址块不一定连续</strong>
并通过页表映射逻辑/物理地址</li>
<li><code>MMU</code>(<code>Memory Management Unit</code>，内存管理单元)：为每个进程都分配较大逻辑地址空间(但实际物理地址较小)，将虚拟地址通过页表转换为物理地址</li>
<li><code>TLB</code>(<code>Translation Lookaside Buffer</code>，地址转换后援缓冲器)：因引入分页机制导致访存效率降低，引入<code>TLB</code>缓存加快翻译速度</li>
<li>多级页表：相比单级页表，可降低页表所占空间
哈希页表：当任务占用较少的虚存时较为合适，但可能造成哈希冲突引起额外处理
反置页表：当逻辑地址空间远大于物理空间时，通过增加翻译花销，降低页表所占空间</li>
</ul></li>
<li>段式管理及其分配：
<ul>
<li>定义：逻辑地址根据程序的逻辑意义(人为管理)分段，物理地址根据段大小分配，连续的逻辑段对应的物理地址段不一定连续</li>
</ul></li>
<li>段页式管理：</li>
</ul></li>
<li><p>内存保护：保证一个进程只能访问自己的内存空间、以及对共享内存的保护</p></li>
<li><p>内存扩充方式：</p>
<ul>
<li>覆盖：</li>
<li>交换：例如进程任务的挂起和取消挂起</li>
</ul></li>
</ul>
<h3 id="虚存管理">虚存管理</h3>
<ul>
<li>程序的局部性原理</li>
<li>按需分配</li>
<li></li>
<li>页的置换：
<ul>
<li><code>FIFO</code></li>
<li><code>OPT</code></li>
<li><code>LRU</code></li>
</ul></li>
<li>惰性加载</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: JDBC编程</title>
    <url>/blogs/2025/06/02/java-jdbc/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="java数据库编程"><code>Java</code>数据库编程</h1>
<h2 id="传统jdbc编程">传统<code>JDBC</code>编程</h2>
<h3
id="driver和drivermanager和connection"><code>Driver</code>和<code>DriverManager</code>和<code>Connection</code></h3>
<ul>
<li><p><code>JDBC</code>由各种数据库支持，提供各种包下的<code>Driver</code>类(例如<code>com.mysql.cj.jdbc.Driver</code>)，它们实现了<code>java.sql.Driver</code>接口</p></li>
<li><p><code>Driver</code>接口是驱动类，所有实现了这个接口的驱动类会在静态加载时将其本身注册到<code>DriverManager</code>类中(用一个写时拷贝的<code>CopyOnWriteArrayList</code>管理)</p></li>
<li><p><code>DriverManager</code>接口是驱动的管理器，用于创建一个连接</p></li>
<li><p><code>Conection</code>是用于管理一个数据库连接的</p></li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;数据库驱动主类名&quot;</span>);</span><br><span class="line"><span class="type">Connectoin</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;连接url&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="preparedstatement"><code>PreparedStatement</code></h3>
<ul>
<li><code>PreparedStatement</code>是预编译的语句</li>
</ul>
<h2 id="jpa"><code>JPA</code></h2>
<h2 id="spring-jdbc"><code>Spring JDBC</code></h2>
<h2 id="spring-data-jpa"><code>Spring Data JPA</code></h2>
<h2
id="spring-boot与mybatis"><code>Spring Boot</code>与<code>MyBatis</code></h2>
<h2 id="spring-data-jdbc"><code>Spring Data JDBC</code></h2>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构: 笛卡尔树</title>
    <url>/blogs/2025/05/30/algo-descartes-tree/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="笛卡尔树">笛卡尔树</h3>
<ul>
<li><p>笛卡尔树中的笛卡尔指的是二元组，笛卡尔树<strong>针对第一元素</strong>是一棵<strong>二叉搜索树</strong>、<strong>针对第二元素</strong>是一个最大/最小<strong>堆</strong>；由二叉搜索树的性质，当第一、第二元素都不重复时，笛卡尔树是唯一的
根据定义，笛卡尔树其实就是一个树堆的特例；平常使用中，通常<strong>第一元素是数组下标、而第二元素是数组值</strong>，对应到树堆就是<strong>数组下标是键，数组值是优先级</strong>
也就是说，数据中给出的数组值需要是比较随机的，否则笛卡尔树就退化成链表了</p></li>
<li><p>笛卡尔树的用处：比较小众，适用于维护<strong>连续区间值</strong>的问题，例如：</p>
<ul>
<li>需要快速知道每一个元素<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>扩展出去的连续区间<span
class="math inline">[<em>l</em>,<em>r</em>]</span>，区间满足<span
class="math inline"><em>i</em> ∈ [<em>l</em>,<em>r</em>]</span>且<span
class="math inline"><em>a</em><sub><em>j</em></sub> ≤ <em>a</em><sub><em>i</em></sub>, <em>j</em> ∈ [<em>l</em>,<em>r</em>]</span>
这样的需求可以用两次单调栈得到每个元素的<span
class="math inline"><em>l</em>、<em>r</em></span>，也可以建一个最大堆笛卡尔树来维护</li>
<li>需要维护区间最值，当然可以用线段树维护，但也可以用笛卡尔树(转化为<code>LCA</code>问题，<span
class="math inline">[<em>l</em>,<em>r</em>]</span>的最值就是<span
class="math inline"><em>a</em><sub><em>l</em><em>c</em><em>a</em>(<em>l</em>,<em>r</em>)</sub></span>)</li>
</ul></li>
<li><p>树的构造：和树堆类似，以最小堆笛卡尔树举例，维护一个栈顶元素始终最大的单调栈，从栈底到栈顶表示一条由根结点到最右结点的链，即栈顶元素表示当前树的最右结点
由于第一元素通常是数组下标，所以从左到右插入元素即可 每插入一个元素<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>，需要在单调栈中找到第一个比<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>小的结点，然后使<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>成为该结点的右儿子，如果它本身就有右儿子，则让整棵右子树成为<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>的左子树即可
此外，如果栈为空，则当前结点将成为根结点
由于每个元素最多进出栈一次，所以建树是<span
class="math inline"><em>O</em>(<em>n</em>)</span>的
实际上对应于树堆的建树过程，这就相当于先对数组值排序再<span
class="math inline"><em>O</em>(<em>n</em>)</span>建树，而笛卡尔树中，数组下标恰好是自然有序的</p></li>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p为原数组, 范围[1, n]; tr[][2]为树, rt为根结点编号</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">rt = <span class="number">1</span>;</span><br><span class="line">stk.<span class="built_in">push</span>(<span class="number">1</span>);    <span class="comment">// 插入首元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; p[stk.<span class="built_in">top</span>()] &gt; p[i]) &#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;  <span class="comment">// 说明该结点是根结点</span></span><br><span class="line">        tr[i][<span class="number">0</span>] = rt;  <span class="comment">// 原来的根结点作为左儿子</span></span><br><span class="line">        rt = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tr[i][<span class="number">0</span>] = tr[stk.<span class="built_in">top</span>()][<span class="number">1</span>];    <span class="comment">// 使原本的右儿子成为当前结点的左儿子</span></span><br><span class="line">        tr[stk.<span class="built_in">top</span>()][<span class="number">1</span>] = i;           <span class="comment">// 使当前结点成为栈顶结点的右儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    stk.<span class="built_in">push</span>(i);    <span class="comment">// 当前结点成为栈顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="例题">例题</h3>
<ul>
<li><a
href="https://www.luogu.com.cn/problem/P1377"><code>[TJOI2011] 树的序</code></a>
本题题意言简意赅，就是要你根据它给的顺序建<code>BST</code>，然后输出其前序遍历；然而一般的<code>BST</code>建树时极其容易退化为<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>，所以考虑用构造笛卡尔树的方式建树
考虑建成之后，结点的键值<span
class="math inline"><em>k</em></span>是构成<code>BST</code>的，且所有父亲结点的<strong>插入时间</strong>都比其儿子结点的插入时间早，构成最小堆；因此考虑二元组<span
class="math inline"> &lt; <em>k</em>, <em>t</em>&gt;</span>建笛卡尔树，因为<span
class="math inline"><em>k</em> ∈ [1,<em>n</em>]</span>且不重复，故将其看作数组下标即可</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 反射API</title>
    <url>/blogs/2025/05/24/java-reflection/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2: Windows下极其轻量的Linux虚拟机</title>
    <url>/blogs/2025/05/19/WSL/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="wsl2"><code>WSL2</code></h2>
<h3 id="基本介绍">基本介绍</h3>
<ul>
<li><code>WSL</code>全称<code>Windows Subsystem for Linux</code>，是<code>2016</code>年发布的适用于<code>Windows</code>的<code>Linux</code>子系统</li>
<li>通常在一个电脑上，通过装虚拟机软件会比装两个系统更方便，例如安装<code>VMWare</code>或<code>VirtualBox</code>，它们能在更广泛的系统上安装其它子系统，例如在<code>MacOS</code>里安装<code>Windows</code>子系统(通过提供一个镜像文件)，而<code>WSL</code>只适用于在<code>Windows</code>里安装<code>WSL</code>支持的<code>Windows</code>子系统，且不提供<code>GUI</code></li>
<li>但<code>WSL</code>有它独有的优势，它的速度更快、配置更简单，且启动极快</li>
<li>实现原理：
<ul>
<li><code>wsl</code>本身不带<code>Linux</code>内核，仅仅是作为表示层/翻译层，将<code>Linux</code>命令翻译成<code>Windows</code>兼容的内核命令
性能极高(因为只进行翻译)，但仅兼容<code>ELF</code>可执行文件，不支持<code>Docker</code>等</li>
<li><code>wsl2</code>具有完整内核，是通过<code>Hyper-V</code>实现的轻量级虚拟机，同样与<code>Windows</code>深度集成，在<code>Linux</code>内部使用虚拟硬盘性能较高，但访问<code>Windows</code>文件系统(<code>/mnt/</code>)时性能较低
兼容所有的<code>Linux</code>软件</li>
<li><code>VMWare</code>等重量级虚拟机软件：完全模拟计算机硬件，需要完整启动<code>BIOS</code>、完整的上下文切换和硬件模拟，因此性能低，但在网络配置上自由度高</li>
</ul></li>
</ul>
<h3 id="wsl配置"><code>WSL</code>配置</h3>
<ul>
<li><p>安装<code>wsl</code>：一键式安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">管理员powershell(会将wsl2作为默认版本)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装后需要重启电脑</span></span><br><span class="line">wsl --install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启后会安装默认的Ubuntu20发行版并要求创建新的用户名和密码</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装<code>wsl</code>：手动配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">管理员powershell</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用wsl</span></span><br><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用虚拟机平台</span></span><br><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>
<p>然后安装<code>WSL2 Linux kernel update package for x64 machines</code>
最后在<code>powershell</code>执行启用<code>wsl2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure></li>
<li><p>安装<code>Linux</code>发行版：在<code>Microsoft Store</code>中搜索即可
或通过命令行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Microsoft Store里的所有发行版</span></span><br><span class="line">wsl --list --online   # wsl -l -o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装对应发行版(实例名称为默认的发行版名称)</span></span><br><span class="line">wsl --install -d &lt;Distro-name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="wsl常用命令"><code>WSL</code>常用命令</h3>
<ul>
<li><code>wsl -l -v</code>/<code>wsl --list --verbose</code>：查看已安装的虚拟机实例的状态</li>
<li><code>wsl --set-default &lt;Distro-name&gt;</code>：设置指定的虚拟机实例为默认虚拟机</li>
<li><code>wsl</code>：启动并进入默认虚拟机实例</li>
<li><code>wsl --shutdown</code>：关闭所有虚拟机</li>
<li><code>wsl --unregister &lt;Distro-name&gt;</code>：删除虚拟机实例</li>
<li><code>wsl -d &lt;Distro-name&gt;</code>：启动并进入指定虚拟机实例</li>
<li><code>wsl &lt;command&gt; [-d &lt;Distro-name&gt;]</code>：在虚拟机实例中执行指定的命令(执行结束后退出)</li>
<li><code>wsl --export &lt;Distro-name&gt; &lt;Filename&gt;</code>：导出指定发行版为指定的文件</li>
<li><code>wsl --import &lt;Distro-name&gt; &lt;InstallDir&gt; &lt;Filename&gt;</code>：导入指定的归档文件为指定名称的虚拟机实例，其中<code>InstallDir</code>为该虚拟机所挂载的目录</li>
</ul>
]]></content>
      <categories>
        <category>Tools &amp; Utilities</category>
        <category>virtual machine</category>
        <category>wsl</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>linux</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 多线程编程</title>
    <url>/blogs/2025/05/17/java-multithreading/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="java多线程编程"><code>Java</code>多线程编程</h2>
<h3 id="runnable接口"><code>Runnable</code>接口</h3>
<ul>
<li>所有类，如果希望让它单独作为一个线程运行，可以<strong>继承</strong><code>Thread</code>类并重写<code>void run()</code>方法</li>
<li>所有类，如果希望让它单独作为一个线程运行，更常用的方法是<strong>实现</strong><code>Runnable</code><strong>接口</strong>以便用多态特性被调用</li>
<li><code>Runnable</code>接口要求实现<code>void run()</code>方法，当这个类作为线程运行时，运行的就是这个<code>run()</code>方法
使用这种方法，实现了<code>Runnable</code>接口的类称为线程任务对象，传递给<code>Thread</code>运行，创建的<code>Thread</code>对象称为线程对象</li>
</ul>
<h3 id="thread类"><code>Thread</code>类</h3>
<ul>
<li><code>Thread</code>的常用构造器：
<ul>
<li><code>Thread()</code>：创建空线程</li>
<li><code>Thread(Runnable task, String name)</code>：将实现了<code>Runnable</code>接口的方法引用传递给它，并命名为<code>name</code></li>
</ul></li>
<li><code>java</code>线程包括七个状态：
<ul>
<li><code>New</code>：新建的线程，尚未执行</li>
<li><code>Runnable</code>：正在执行<code>run()</code>的线程</li>
<li><code>Blocked</code>：因阻塞而被挂起的线程</li>
<li><code>Waiting</code>：因某些原因在等待的线程</li>
<li><code>Timed Waiting</code>：因主动调用<code>Thread.sleep()</code>而计时等待的线程</li>
<li><code>Terminated</code>：终止的线程，<code>run()</code>因各种原因而结束</li>
</ul></li>
<li><code>start()</code>：启动一个线程，使其开始以另一个线程的形式执行<code>run()</code>
在主线程直接调用某个线程类的<code>run()</code>无法达到多线程的效果，必须通过<code>start()</code>在<code>JVM</code>中登记</li>
<li><code>join()</code>：使当前线程等待调用该方法的线程实例结束，再继续运行
<code>join(long)</code>：使当前线程仅等待有限时间，其它同上</li>
<li><code>interrupt()</code>：使该线程的中断标志位置<code>1</code>，可以通过<code>isInterrupted()</code>循环检查，实现中断线程的效果
但<code>interrupt()</code>并不立刻生效，仅仅是发出一个中断请求
而且当外部线程调用该线程的<code>interrupt()</code>方法时，若该线程处于等待状态(例如调用<code>join()</code>或<code>sleep()</code>)，则<code>join()</code>或<code>sleep()</code>等会抛出<code>InterruptedException</code>异常</li>
<li><code>volatile</code>关键字：由于<code>JVM</code>的内存模型，在线程修改共享变量时不会立刻写回主内存
而<code>volatile</code>修饰的变量则会使<code>JVM</code>在读取时总是读取最新值、写入时总是立刻写入
但<code>volatile</code>并不保证原子性，在读写含有多个字段的<code>volatile</code>变量时可能会有问题</li>
<li><code>setDaemon(true)</code>：一个线程默认是非守护线程，<code>JVM</code>进程会等待所有的非守护线程结束后再结束
但一些线程是无限循环的，可以调用<code>setDaemon(true)</code>将它们设置为守护线程，<code>JVM</code>进程结束时不会关心它们是否结束
守护线程不能占有任何需要显式关闭的资源，守护线程本身无法保证这些资源能在<code>JVM</code>进程结束时关闭</li>
</ul>
<h3 id="传统线程同步">传统线程同步</h3>
<ul>
<li><p>不同线程在读写同一份资源、或需要相互协作时，就需要考虑线程同步问题
除非资源是只读的，例如不可变类型，则不需要考虑线程同步
大部分标准库中的类为了提高性能，都是非线程安全的，涉及到非线程安全的读写操作时，必须手动添加线程同步代码以保证线程安全</p></li>
<li><p><code>synchronized</code>关键字：</p>
<ul>
<li>作用于对象时，会对该对象加锁</li>
<li>修饰实例方法时，等价于作用于<code>this</code></li>
<li>修饰静态方法时，等价于作用于所在类的<code>class</code>实例</li>
<li>一般不用该关键字修饰方法，因为会导致加锁混乱、不明确且在很多情况会使两个本不冲突的方法变为冲突
使用<code>synchronized</code>的代码块无法并发执行，且加锁解锁有额外开销
对某对象加锁，不代表其它线程就无法访问该对象，如果一个线程对该对象加锁而另一个线程并不这样做，则仍存在线程同步问题</li>
</ul></li>
<li><p><code>JVM</code>的基础原子操作：除<code>long</code>、<code>double</code>以外的任意变量的赋值操作
涉及多行的赋值操作时，仍需要用<code>synchronized</code>修饰代码块</p></li>
<li><p>可重入锁：<code>JVM</code>允许<strong>同一个线程</strong>重复获取同一个锁，其本质是一个信号量，进入/退出<code>synchronized</code>代码块使信号量加/减<code>1</code></p></li>
<li><p>死锁的必要条件：互斥、不可抢占、占有并等待、循环等待，只要破坏其中一种条件即可避免死锁</p>
<ul>
<li>破坏循环等待：所有线程获取同一组锁的顺序保持一致，这是最简单的一种方案</li>
<li>互斥不可破坏，破坏不可抢占可能导致混乱，破坏占有并等待必须一次性分配需要的资源、资源利用率低且可能导致饥饿</li>
</ul></li>
<li><p>继承自<code>Object</code>的<code>wait()</code>：可使该线程暂时放弃调用<code>wait()</code>的对象锁，进入等待状态直至被唤醒，唤醒后立刻尝试重新请求这个对象锁
需要注意这不是作用于线程类对象的，而是<strong>作用于被加锁的资源</strong></p></li>
<li><p>继承自<code>Object</code>的<code>notify()</code>和<code>notifyAll()</code>：可随机唤醒某一个等待该资源的线程/唤醒全部等待该资源的线程
同上，这两者作用于被加锁的资源，通常后者更安全</p>
<ul>
<li><code>notify()</code>可能会唤醒同类线程，导致活锁或死锁，例如生产者消费者问题：
两个消费者阻塞<span
class="math inline">→</span>生产者<code>P1</code>唤醒消费者<code>C1</code><span
class="math inline">→</span>两个生产者阻塞<span
class="math inline">→</span>消费者<code>C1</code>消耗资源，但唤醒同类消费者<code>C2</code><span
class="math inline">→</span>两个消费者阻塞，至此所有线程均阻塞，造成死锁</li>
<li>使用<code>notifyAll()</code>，至少能唤醒一个非同类线程，而其它同类线程应该继续等待，所以<strong><code>wait()</code>应该在循环</strong>里而非<code>if</code>语句块中</li>
</ul></li>
<li><p><code>JVM</code>线程同步原理是对象监视器，<code>Object</code>的<code>wait()</code>和<code>notify()</code>相当于每个变量都可以作为信号量的封装，由于<strong><code>wait()</code>使线程可以短暂释放已获得的锁</strong>，使其不需要像操作系统课程上讲的那般麻烦(需要互斥信号量与同步信号量且互斥信号量的<code>PV</code>操作紧贴临界区)，而是使同步信号量围绕着互斥资源通过<code>wait()</code>和<code>notify()</code>进行同步
例如在生产者消费者问题中，互斥资源的空/满可以化作<code>while</code>中的条件，充当同步信号量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个线程同步的生产者消费者队列类</span></span><br><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; q;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">final</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (size == <span class="number">0</span>) &#123; <span class="comment">// Condition: Empty</span></span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    e = q.poll(); <span class="comment">// consume</span></span><br><span class="line">    --size;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provider</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (size == MAX_SIZE) &#123; <span class="comment">// Condition: Full</span></span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    q.offer(e); <span class="comment">// provide</span></span><br><span class="line">    ++size;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3
id="java.util.concurrent.locks与semaphore"><code>java.util.concurrent.locks</code>与<code>Semaphore</code></h3>
<ul>
<li><code>synchronized</code>的加锁机制是<strong>悲观锁</strong>、<strong>重量级锁</strong>、<strong>阻塞的</strong>，这种锁适合竞争激烈的多线程同步场景，线程先必须获得锁(进入或退出<code>Monitor</code>)才能读写对象</li>
<li><code>java.util.concurrent</code>是<code>Java 5</code>开始提供的高级并发包，以下是需要提前了解的一些概念
<ul>
<li>乐观锁：线程无需获取锁地尝试修改，在修改时检查是否冲突
理念是估计在读过程中不会有其它线程在写
乐观读锁在读多写少的场景中好处显而易见：一是乐观读锁不排它，减少写锁饥饿的情况；二是因为写少，乐观读大概率成功而减少了悲观锁的阻塞开销</li>
<li><code>CAS</code>(<code>Compare And Swap</code>或<code>Compare And Set</code>)机制是实现乐观锁的一种方式：线程查询内存中的值和此前读取的值是否相同，若相同则更新，否则失败
若失败则读取内存中的值，循环地进行<code>CAS</code>直至更新成功</li>
<li><code>CAS</code>机制存在<code>ABA</code>问题，即线程<code>T1</code>尝试通过<code>CAS</code>读写时，虽然内存值和此前读取的值一致，但这个内存值<code>A</code>可能被另一个线程先改为<code>B</code>再改为<code>A</code>，在<code>T1</code>看来没有改变过的资源实际上被其它线程更改过
因此实现上对资源的更改会添加时间戳/版本号</li>
<li><code>CAS</code>机制有时会配合自旋的机制：
<strong>自旋锁</strong>优点在于可避免不必要的上下文切换开销，缺点在于循环导致的<code>CPU</code>忙等
自旋锁仅在<code>CPU</code><strong>多核</strong>的并行处理场景中，线程能在忙等中获取其它线程释放的资源时才有效
接下来从完全悲观到完全乐观地介绍<code>java.util.concurrent</code>提供的线程同步机制</li>
</ul></li>
<li><code>Lock</code>接口：可以替代<code>synchronized</code>，是一种显式锁，由代码层面而非语法层面实现加锁和解锁，其实现类是对<code>synchronized</code>的封装
<code>Lock</code>是悲观锁
<ul>
<li><code>lock()</code>：显式加锁</li>
<li><code>unlock()</code>：需要在<code>finally</code>块中解锁</li>
<li><code>tryLock()</code>和<code>tryLock(long, TimeUnit)</code>：<code>Lock</code>支持非阻塞获取锁或有限忙等地获取锁，前者仅尝试一次、后者在有限时间内循环尝试
返回<code>true</code>表示获取成功</li>
<li><code>newCondition()</code>：返回一个<code>Condition</code>对象，<code>Lock</code>支持多条件锁，与<code>synchronized</code>单锁相区别
<code>ReentrantLock</code>是<code>Lock</code>的实现类之一，译为“可重入锁”</li>
<li>支持公平锁，在构造时传递<code>true</code>即可
公平锁即每次向等待队列加入新的线程时，它无法插队，保证每次获取锁的线程是队列中等待时间最长的线程</li>
</ul></li>
<li><code>Condition</code>接口：表示某条件的等待队列，如上文传统的线程同步代码中，由于空/满这两种条件使不同类线程在同一等待队列中，因此会出现死锁现象而必须用<code>notifyAll()</code>来唤醒非同类线程
而<code>Condition</code>和<code>Lock</code>允许在一个锁对象上分配多个不同条件的等待队列，能保证每次唤醒都能唤醒非同类线程
<ul>
<li><code>await()</code>：使线程在该条件上短暂地释放锁，进入等待状态，被唤醒后重新尝试获取</li>
<li><code>await(long, TimeUnit)</code>：可以在有限时间内地等待</li>
<li><code>signal()</code>：唤醒在该条件上等待的某个线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; q;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notempty</span> <span class="operator">=</span> lock.newCondition(), notfull = lock.newCondition();</span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        notempty.await();</span><br><span class="line">    &#125;</span><br><span class="line">    e = q.poll();</span><br><span class="line">    --size;</span><br><span class="line">    notfull.signal();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provider</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (size == MAX_SIZE) &#123;</span><br><span class="line">        notfull.await();</span><br><span class="line">    &#125;</span><br><span class="line">    q.offer(e);</span><br><span class="line">    ++size;</span><br><span class="line">    notempty.signal();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>ReadWriteLock</code>接口：有时排它锁过于重量，在多读少写的场景下，希望允许多个线程同时读，这个接口就用于这种场景
<ul>
<li><code>readLock()</code>：获取读锁</li>
<li><code>writeLock()</code>：获取读锁
类的内部会维护，若有线程占有读锁，则不会有线程能占有写锁，反之亦然；若没有线程占有写锁，则允许多个线程占有读锁
虽然它实现了读写分离，但它仍是<strong>悲观锁</strong>，因此也可能导致需要<strong>写锁的线程饥饿</strong>
<code>ReentrantReadWriteLock</code>是<code>ReadWriteLock</code>的实现类之一，是可重入锁</li>
</ul></li>
<li><code>AQS</code>框架：</li>
<li><code>StampedLock</code>类：<code>Java 8</code>开始提供的<strong>乐观读锁</strong>和<strong>读写分离的悲观锁</strong>两者的封装锁，在互斥上可替代<code>ReadWriteLock</code>，但要注意它不是可重入锁、不支持公平锁
<ul>
<li><code>StampedLock</code>和<code>ReadWriteLock</code>一样有<code>readLock()</code>和<code>writeLock()</code>方法，用于获取读锁和写锁
但它们的实现有所区别：它们不返回<code>Lock</code>对象而是在内部就调用了锁的<code>lock()</code>方法，然后返回<code>long</code>类型的版本号<code>stamp</code></li>
<li>因此需要使用<code>unlockRead(stamp)</code>和<code>unlockWrite(stamp)</code>释放掉这个版本号的读写锁</li>
<li><code>StampedLock</code>还支持<strong>乐观读锁</strong>，通过<code>tryOptimisticRead()</code>尝试获取乐观读锁的版本号<code>stamp</code>，然后通过<code>validate(stamp)</code>检验，<strong>乐观锁不需要解锁，因为本质上并没有加锁操作</strong>
如前文所说，乐观锁不排它，乐观读过程中允许其它线程写，如果检验成功，说明加乐观读锁途中没有线程占有死锁
如果检验不成功则有两种选择：自旋地重复乐观读、悲观读</li>
<li>同<code>Lock</code>一样支持非阻塞或有限阻塞地获取悲观读锁和悲观写锁</li>
<li>支持锁转换：
<code>tryConvertToReadLock(stamp)</code>：若<code>stamp</code>有效，原子地，悲观读锁则返回其本身、悲观写锁则释放它并返回悲观读锁、乐观读锁则非阻塞地请求一个悲观读锁
<code>tryConvertToWriteLock(stamp)</code>：若<code>stamp</code>有效，原子地，悲观读锁且写锁空闲则返回写锁、悲观写锁则返回其本身、乐观读锁则非阻塞地请求一个悲观写锁
<code>tryConvertToOptimisticRead(stamp)</code>：若<code>stamp</code>有效，原子地，悲观锁则释放它们并返回乐观读锁、有效的乐观锁则返回其本身</li>
<li>但<code>StampedLock</code>不支持基于条件的线程间协作，因此只适用于单个资源的互斥读写场景</li>
</ul></li>
<li><code>Semaphore</code>：信号量可以被最多<code>N</code>个线程获取，但不支持基于条件的线程间协作，用于复数个资源的互斥获取，它也支持公平锁
<ul>
<li><code>acquire()</code>：阻塞地获取该信号量</li>
<li><code>release()</code>：需要在<code>finally</code>块中释放</li>
<li><code>tryAcquire()</code>和<code>tryAcquire(long, TimeUnit)</code>：非阻塞地或有限阻塞地获取信号量</li>
</ul></li>
</ul>
<h3
id="callablet接口与异步线程池"><code>Callable&lt;T&gt;</code>接口与异步线程池</h3>
<ul>
<li><code>Callable&lt;T&gt;</code>接口：由于<code>Runnable</code>的<code>run()</code>没有返回值且不允许抛出异常，因此<code>Callable&lt;T&gt;</code>诞生了，是单方法接口，包含方法<code>T call() throws Exception</code></li>
<li><code>java</code>线程池提供了<strong>多线程异步</strong>的功能，能更好地利用多核资源
所谓同步，即各个任务有一定的执行顺序，一些任务必须等待其它任务完成后，利用其计算结果才能继续运行；异步是各个任务没有执行顺序，任务通过回调函数或其它手段获取其它任务的计算结果，在这段时间内可以执行其它计算
同步异步与线程个数没有必然联系，单线程异步可以通过检测事件循环实现</li>
<li><code>Future&lt;T&gt;</code>接口是实现多线程异步的核心，表示“能在未来得到计算结果的对象”，包括以下核心方法：
<ul>
<li><code>get()</code>：获取结果，如果其对应的计算任务尚未完成则会使调用<code>get()</code>的线程进入阻塞</li>
<li><code>get(long, TimeUnit)</code>：仅等待有限时间地获取结果</li>
<li><code>cancel(true)</code>：<code>true</code>表示通过发出中断请求来取消任务，若任务尚未开始或线程响应中断请求后则成功取消，返回<code>true</code>，否则返回<code>false</code>
<code>cancel(false)</code>：若任务尚未完成则一定能取消成功，但任务可以继续执行直至结束
成功调用<code>cancel()</code>后，<code>isCancelled()</code>返回<code>true</code>，此后<code>get()</code>会抛出<code>CancellationException</code>异常</li>
</ul></li>
<li><code>ExecutorService</code>接口：
<ul>
<li>任务提交：把任务提交给线程池，异步地执行
<code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：提交一个计算任务给线程池执行，<strong>立刻</strong>获得一个<code>Future&lt;T&gt;</code>对象</li>
<li>任务执行：把多个任务提交给线程池，当前线程阻塞，即同步地执行
<code>List&lt;Future&lt;T&gt;&gt; invokeAll(List&lt;Callable&lt;T&gt;&gt;)</code>：执行多个计算任务，当前线程阻塞直至它们全部执行完成，返回值顺序和提交的任务顺序一致
<code>invokeAll()</code>还允许传递时间参数，有限地阻塞</li>
<li><code>shutdown()</code>：停止接受所有新线程，执行完已提交的线程，然后关闭线程池</li>
<li><code>shutdownNow()</code>：停止接受所有新线程，尝试中断地取消所有已提交线程，返回所有未开始的任务</li>
</ul></li>
<li>创建<code>ExecutorService</code>对象：
<ul>
<li><code>Executors</code></li>
<li><code>ThreadPoolExecutor</code></li>
</ul></li>
<li><code>Fork/Join</code>线程池：</li>
</ul>
<h3 id="其它api">其它<code>API</code></h3>
<ul>
<li><code>java.util.concurrent.atomic</code>中的类基于<code>CAS</code>机制实现无锁的线程同步，使用<strong>乐观锁</strong>、<strong>非阻塞</strong>地封装资源
例如<code>AtomicReferencte&lt;T&gt;、AtomicReferenceArray&lt;T&gt;</code>，除此之外还对三个基本数据类型有更全面的封装：<code>AtomicInteger、AtomicLong、AtomicBoolean</code>
如果<code>ABA</code>问题会影响业务逻辑，则应使用<code>AtomicStampedReference</code>或<code>AtomicMarkableReference</code>
以下是<code>AtomicReference</code>一系列常用的<strong>原子方法</strong>：
<ul>
<li><code>get()</code>：获取当前值</li>
<li><code>set(T)</code>：<code>volatile</code>地写入新值</li>
<li><code>compareAndSet(T ept, T upd)</code>：<code>CAS</code>地更新值，可能失败</li>
<li><code>getAndSet(T)</code>：获取旧值，写入新值</li>
<li><code>getAndUpdate()</code>或<code>updateAndGet()</code>：提供单元运算函数更新值，返回更新前/更新后的值</li>
<li><code>getAndAccumulate()</code>或<code>accumulateAndGet()</code>：提供二元运算函数和加值，返回更新前/更新后的值</li>
</ul></li>
<li>线程安全的集合：
<ul>
<li><code>List</code>的实现类<code>CopyOnWriteArrayList</code></li>
<li><code>Map</code>的实现类<code>ConcurrentHashMap</code></li>
<li><code>Set</code>的实现类<code>CopyOnWriteArraySet</code></li>
<li><code>Queue</code>的实现类<code>ArrayBlockingQueue</code>与<code>LinkedBlockingQueue</code></li>
<li><code>Deque</code>的实现类<code>LinkedBlockingDeque</code></li>
</ul></li>
<li><code>CompletableFuture</code></li>
<li><code>ThreadLocal</code></li>
<li>虚拟线程：</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>multithreading</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 网络编程基础</title>
    <url>/blogs/2025/05/10/java-net/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="网络编程基础">网络编程基础</h2>
<h3 id="tcp客户端"><code>TCP</code>客户端</h3>
<ul>
<li><code>Java</code>在客户端提供的<code>TCP</code>套接字的类为<code>Socket</code>
<code>Socket</code>构造方法：<code>Socket(String, int)</code>，和提供的服务器<code>IP</code>和端口号绑定</li>
<li><code>Socket</code>常用实例方法：
<ul>
<li>如果不用构造方法，也可使用<code>connect()</code>发起<code>TCP</code>连接</li>
<li><code>getInputStream()</code>和<code>getOutputStream()</code>：获取对应的输入流和输出流对象
其中<code>OutputStream</code>对象应该及时<code>flush()</code>
通常使用<code>InputStreamReader</code>和<code>OutputStreamWriter</code>将字节流转化为字符流并传递指定的字符集处理</li>
</ul></li>
</ul>
<h3 id="tcp服务端"><code>TCP</code>服务端</h3>
<ul>
<li><code>Java</code>在服务端提供的<code>TCP</code>套接字的类为<code>ServerSocket</code>
<code>ServerSocket</code>构造方法：<code>ServerSocket(int)</code>，和提供的端口号绑定</li>
<li><code>ServerSocket</code>常用实例方法：
<ul>
<li><code>accept()</code>：<strong>阻塞</strong>式地等待请求，收到请求后返回<code>Socket</code>对象，它和客户端的<code>Socket</code>对象相关联
建议使用<code>try-with-resources</code>语法块构造<code>ServerSocket</code>对象避免调用<code>close()</code></li>
<li><code>getPort()</code>和<code>getInetAddress()</code>：返回服务器绑定的本地端口号、本地<code>IP</code>地址
<code>getLocalSocketAddress()</code>：返回服务器绑定的<code>IP</code>地址与端口号组成的<code>SocketAddress</code>对象</li>
</ul></li>
</ul>
<h3 id="udp客户端与服务端"><code>UDP</code>客户端与服务端</h3>
<ul>
<li><code>Java</code>在客户端和服务端提供的<code>UDP</code>套接字的类为<code>DatagramSocket</code>
<code>DatagramSocket</code>的构造方法同<code>ServerSocket</code>，但是注意，由于<code>TCP</code>和<code>UDP</code>是两种不同的协议，不同协议使用的端口号是互不干扰的，它们的相同点在于使用<code>16</code>位的端口号</li>
<li><code>DatagramPacket</code>：这个类对象作为数据报的抽象，是数据传输的中介
<ul>
<li>构造方法：<code>DatagramPacket(byte[], int, InetAddress, int)</code>
和一个<code>byte[]</code>数组绑定，后两个参数可选，和待发送的<code>IP</code>与端口绑定</li>
<li><code>getData()、getOffset()、getLength()</code>：获取数据、偏移、长度
通常用<code>new String(packet.getData(), packet.getOffset(), packet.getLength(), Charset)</code>解析收到的数据报</li>
<li><code>setData(byte[])</code>：设置存储的数据</li>
</ul></li>
<li><code>DatagramSocket</code>常用实例方法：
<ul>
<li><code>receive(DatagramPacket)</code>：收取一个<code>UDP</code>数据报赋值给提供的引用
接收后，这个<code>DatagramPacket</code>对象的目标<code>IP</code>和端口会被替换为发送方的<code>IP</code>与端口</li>
<li><code>send(DatagramPacket)</code>：发送该数据报到提供的数据报对象指向的<code>IP</code>与端口</li>
<li><code>connect(InetAddress, int)</code>：使当前的套接字对象绑定一个默认的目标<code>IP</code>及端口，它并不像<code>TCP</code>那样会发起连接，而只是在本地进行记录
连接后，<code>send()</code>发送的<code>DatagramPacket</code>不需要有绑定的目标<code>IP</code>，且接收时会过滤掉这个<code>IP</code>及端口以外的数据报
为了方便，通常在客户端使用<code>connect()</code>过滤掉不需要的包
而服务端自然不需要也不应该设置默认的目标<code>IP</code>，由<code>receive()</code>自动设置即可</li>
<li><code>disconnect()</code>：删除本地的默认连接</li>
</ul></li>
</ul>
<h3 id="http客户端"><code>HTTP</code>客户端</h3>
<ul>
<li>直接使用<code>TCP</code>和<code>UDP</code>套接字灵活性很强，但应用层协议需要自己制定，在安全性和性能上没有设计好的协议简易而安全，例如要开发一个网页客户端，使用<code>HTTP</code>协议是最好不过的
但是处理<code>HTTP</code>报文需要检查和解析响应行、响应头、响应体，十分麻烦
早期<code>JDK</code>通过<code>HttpURLConnection</code>访问<code>HTTP</code>，但是不好用，<code>Java 11</code>后提供<code>java.net.http</code>简化开发</li>
<li><code>HttpClient</code>构造方法：建议通过静态方法创建
<ul>
<li><p><code>HttpClient.newHttpClient()</code>：使用默认配置构建</p></li>
<li><p><code>HttpClient.newBuilder().build()</code>：使用<code>HttpClient.Builder</code>构建器构建
这种方法是最常用的，可以在<code>build()</code>前链式调用一系列方法自定义配置，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newBuilder()</span><br><span class="line">     .version(Version.HTTP_2)     <span class="comment">// HTTP版本</span></span><br><span class="line">     .followRedirects(Redirect.NORMAL)   <span class="comment">// 重定向策略</span></span><br><span class="line">     .connectTimeout(Duration.ofSeconds(<span class="number">20</span>)) <span class="comment">// 超时时长</span></span><br><span class="line">     .proxy(ProxySelector.of(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;proxy.example.com&quot;</span>, <span class="number">80</span>))) <span class="comment">// 正向代理</span></span><br><span class="line">     .authenticator(Authenticator.getDefault()) <span class="comment">// HTTP身份认证</span></span><br><span class="line">     .build(); <span class="comment">// 返回由该Builder构造的HttpClient对象</span></span><br></pre></td></tr></table></figure>
<p>其中<code>Redirect</code>与<code>Authenticator</code>是<code>HttpClient</code>的内部枚举，包含一系列重定向策略与身份认证策略</p></li>
</ul></li>
<li>创建<code>HTTP</code>请求：一个<code>HttpRequest</code>对象代表一个请求报文，通过静态方法<code>HttpRequest.newBuilder()</code>创建构建器，这个构建器包含若干配置方法：
<ul>
<li><code>uri(URI)</code>：设置目标网络资源</li>
<li><code>header(String, String)</code>：设置某个请求头的键值
也可以通过<code>headers()</code>一次性设置多个请求头</li>
<li><code>GET()</code>与<code>POST(BodyPublisher)</code>：设置请求方式，默认是<code>GET()</code>，因此前者通常会被省略
<code>BodyPublishers</code>是工厂类，用于创建<code>BodyPublisher</code>对象，常用方法有<code>ofString()</code>等</li>
</ul></li>
<li>处理<code>HTTP</code>响应：一个<code>HttpResponse</code>对象代表一个响应报文，通过<code>HttpClient</code>对象的<code>send()</code>发送请求报文后阻塞式地(同步式地)获取<strong>最终</strong>响应报文
<ul>
<li>该类是泛型类，泛型类型表示响应体被解析而成的类型，由<code>send()</code>时提供的<code>BodyHandler</code>参数决定解析类型，例如：
<code>HttpResponse&lt;String&gt; resp = client.send(req, BodyHandlers.ofString())</code></li>
<li><code>statusCode()</code>获取响应码</li>
<li><code>headers()</code>：获取只读的响应头集合<code>HttpHeaders</code></li>
<li><code>previousResponse()</code>：获取前一次响应，用于回溯重定向链</li>
<li><code>version()、uri()、request()</code>：更多获取信息的方法</li>
</ul></li>
</ul>
<h3 id="异步网络编程">异步网络编程</h3>
<h3 id="了解rmi">了解<code>RMI</code></h3>
<ul>
<li><p><code>RMI</code>(<code>Remote Method Invotation</code>，远程方法调用)是<code>java.rmi</code>提供的远程调用<code>API</code>，仅需了解即可
远程调用十分常用，这使得客户端代码无需有接口的实现类，而只需要声明接口即可正常调用，实现类由服务端提供</p></li>
<li><p>远程方法调用的服务接口(即服务器端)需要继承<code>Remote</code>空接口且所有方法需要抛出受检异常<code>RemoteException</code>，创建实例后，通过<code>UnicastRemoteObject</code>转化为<code>RMI</code>服务，通过<code>Registry</code>注册到本地的端口上
而客户端需要通过<code>Registry</code>的<code>getRegistry(host, port)</code>和<code>lookup(serv_name)</code>获取服务以及服务接口</p></li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端: 包含RemoteDemo接口, RemoteDemoImpl实现类</span></span><br><span class="line"><span class="comment">// 在本地1999号端口上启动一个RMI注册表</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocalRegistry.createRegistry(<span class="number">1999</span>);</span><br><span class="line"><span class="comment">// 将普通接口转化为RMI服务接口</span></span><br><span class="line"><span class="type">RemoteDemo</span> <span class="variable">serv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteDemoImpl</span>();</span><br><span class="line"><span class="type">RemoteDemo</span> <span class="variable">serv_obj</span> <span class="operator">=</span> UnicastRemoteObject.exportObject(serv, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 将该RMI服务注册到注册表中</span></span><br><span class="line">registry.rebind(<span class="string">&quot;Serv_name&quot;</span>, serv_obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端: 只包含RemoteDemo接口</span></span><br><span class="line"><span class="comment">// 获取目标IP及端口的注册表</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocalRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1999</span>);</span><br><span class="line"><span class="comment">// 获取服务, 需要强制转换</span></span><br><span class="line"><span class="type">RemoteDemo</span> <span class="variable">remoteDemo</span> <span class="operator">=</span> (RemoteDemo) registry.lookup(<span class="string">&quot;Serv_name&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计: 常见的随机变量汇总</title>
    <url>/blogs/2025/05/05/probability-rdnvar/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="常见随机变量分布及其数学特征">常见随机变量分布及其数学特征</h2>
<h3 id="离散型随机变量">离散型随机变量</h3>
<ul>
<li>二项分布<span
class="math inline"><em>X</em> ∼ <em>B</em>(<em>n</em>,<em>p</em>)</span>：可看作<span
class="math inline"><em>n</em></span>个独立同分布的<span
class="math inline">0 − 1</span>分布
<ul>
<li><span
class="math inline">$\begin{align}P(X=k)=\left(\begin{matrix}n\\k\end{matrix}\right)p^k(1-p)^{n-k}\end{align}$</span>，<span
class="math inline"><em>k</em> ∈ [0,<em>n</em>]</span></li>
<li><span
class="math inline"><em>E</em><em>X</em> = <em>n</em><em>p</em></span>：<span
class="math inline">$\begin{align}\sum_{k=0}^nkP(X=k)=nEX_i=np\end{align}$</span>，前者用二项式定理或生成函数证明、后者为<span
class="math inline"><em>n</em></span>个<span
class="math inline">0 − 1</span>分布叠加
<ul>
<li>前者的二项式定理证明： <span
class="math inline">$\begin{align}&amp;原式=np\sum_{k=1}^n\frac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k}=np\sum_{k=0}^{n-1}\left(\begin{matrix}n-1\\k\end{matrix}\right)p^k(1-p)^{n-k-1}=np\end{align}$</span></li>
</ul></li>
<li><span
class="math inline"><em>D</em><em>X</em> = <em>n</em><em>p</em>(1−<em>p</em>)</span>：由于为<span
class="math inline"><em>n</em></span>个独立的<span
class="math inline">0 − 1</span>分布，可以由<span
class="math inline"><em>D</em><em>X</em><sub><em>i</em></sub></span>叠加得出
<ul>
<li>定义证法： <span
class="math inline">$\begin{align}&amp;EX^2=\sum_{k=0}^nk^2P(X=k)=\sum_{k=1}^nk\frac{n!}{(k-1)!(n-k)!}p^k(1-p)^{n-k}\\&amp;=\sum_{k=0}^{n-1}\frac{(k+1)·n!}{k!(n-k-1)!}p^{k+1}(1-p)^{n-k-1}\\&amp;=\sum_{k=1}^{n-1}k\frac{n!}{k!(n-k-1)!}p^{k+1}(1-p)^{n-k-1}+np\sum_{k=0}^{n-1}\frac{(n-1)!}{k!(n-k-1)!}p^{k}(1-p)^{n-k-1}\\&amp;=n(n-1)\sum_{k=0}^{n-2}\frac{(n-2)!}{k!(n-k-2)!}p^{k+2}(1-p)^{n-k}+np\\&amp;=n(n-1)p^2+np=n^2p^2-np^2+np\\&amp;DX=EX^2-(EX)^2=np(1-p)\end{align}$</span></li>
</ul></li>
<li><span
class="math inline">$\begin{align}EX^k=nEX^k_i=np^k\end{align}$</span></li>
</ul></li>
<li>泊淞分布<span
class="math inline"><em>X</em> ∼ <em>P</em>(<em>λ</em>)</span>
<ul>
<li><span
class="math inline">$\begin{align}P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}\end{align}$</span>，<span
class="math inline"><em>k</em> ∈ <em>N</em><sup>+</sup></span></li>
<li><span
class="math inline">$\begin{align}EX=\lambda\end{align}$</span>：经典级数
<ul>
<li><span
class="math inline">$\begin{align}\sum_{k=1}^{+\infty}k\frac{\lambda^k}{k!}e^{-\lambda}=\lambda
e^{-\lambda}e^{\lambda}=\lambda\end{align}$</span></li>
</ul></li>
<li><span class="math inline"><em>D</em><em>X</em> = <em>λ</em></span>
<ul>
<li><span
class="math inline">$\begin{align}&amp;EX^2=\sum_{k=1}^{+\infty}k\frac{\lambda^k}{(k-1)!}e^{-\lambda}=\lambda
e^{-\lambda}S(\lambda)\\&amp;\int S\mathrm
d\lambda=\int\sum_{k=1}^{+\infty}\frac{k\lambda^{k-1}}{(k-1)!}\mathrm
d\lambda=\sum_{k=1}^{+\infty}\frac{\lambda^{k}}{(k-1)!}=\lambda
e^{\lambda}\\&amp;S=(\lambda+1) e^{\lambda}\Rightarrow
EX^2=\lambda^2+\lambda\\&amp;DX=EX^2-(EX)^2=\lambda\end{align}$</span></li>
<li>或者： <span
class="math inline">$\begin{align}&amp;EX^2=\sum_{k=1}^{+\infty}(k-1+1)\frac{\lambda^{k}}{(k-1)!}e^{-\lambda}\\&amp;=e^{-\lambda}\sum_{k=1}^{+\infty}(k-1)\frac{\lambda·\lambda^{k-1}}{(k-1)!}+\lambda=\lambda+e^{-\lambda}\lambda\sum_{k=0}^{+\infty}\frac{k\lambda^{k}}{k!}\\&amp;=\lambda+\lambda^2\end{align}$</span></li>
</ul></li>
<li><span
class="math inline">$\begin{align}&amp;EX^n=\sum_{k=1}^{+\infty}k^n\frac{\lambda^k}{k!}e^{-\lambda}\end{align}$</span>，可以将<span
class="math inline"><em>k</em><sup><em>n</em></sup></span>替换为系数为第二类斯特林数的<span
class="math inline"><em>k</em></span>的下阶幂的和
可递归表示为第二类斯特林数系数结合<span
class="math inline"><em>λ</em></span>的幂、或二项式系数结合低阶期望的形式：
<span
class="math inline">$\begin{align}EX^n=\sum_{k=0}^n\left[\begin{matrix}n\\k\end{matrix}\right]\lambda^k=\lambda\sum_{k=0}^{n-1}\left(\begin{matrix}n-1\\k\end{matrix}\right)EX^k\end{align}$</span></li>
</ul></li>
</ul>
<h3 id="连续型随机变量">连续型随机变量</h3>
<ul>
<li>均匀分布<span
class="math inline"><em>X</em> ∼ <em>U</em>(<em>a</em>,<em>b</em>)</span>：
<ul>
<li><span
class="math inline">$f(x)=\begin{cases}{\Large\frac1{b-a}},&amp;a\le
x\le b\\0,&amp;\rm otherwise\end{cases}$</span></li>
<li><span
class="math inline">$F(x)=\begin{cases}0,&amp;x&lt;a\\{\Large\frac{x-a}{b-a}},&amp;a\le
x\le b\\1,&amp;x&gt;b\end{cases}$</span></li>
<li><span
class="math inline">$\begin{align}EX=\int_{a}^b\frac{x}{b-a}\mathrm
dx=\frac{b+a}{2}\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}EX^k=\int_{a}^b\frac{x^k}{b-a}\mathrm
dx=\frac{b^{k+1}-a^{k+1}}{(k+1)(b-a)}\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}DX=EX^2-(EX)^2=\frac{(b-a)(b^2+ab+a^2)}{3(b-a)}-\frac{(b+a)^2}4=\frac{(b-a)^2}{12}\end{align}$</span></li>
</ul></li>
<li>指数分布<span
class="math inline"><em>X</em> ∼ <em>e</em>(<em>λ</em>)</span>：
<ul>
<li><span class="math inline">$f(x)=\begin{cases}\lambda e^{-\lambda
x},&amp;x&gt;0\\0,&amp;\rm otherwise\end{cases}$</span></li>
<li><span
class="math inline">$F(x)=\begin{cases}0,&amp;x\le0\\1-e^{-\lambda
x},&amp;x&gt;0\end{cases}$</span>，可以记住<span
class="math inline">$\begin{align}\int_x^{+\infty}\lambda e^{-\lambda
x}\mathrm dx=e^{-\lambda x}\end{align}$</span></li>
<li><span class="math inline">$\begin{align}EX=\int_0^{+\infty}\lambda
xe^{-\lambda x}\mathrm dx=-\int_{0}^{+\infty}x\mathrm d\left(e^{-\lambda
x}\right)=-xe^{-\lambda
x}\Bigg|_{0}^{+\infty}+\int_0^{+\infty}e^{-\lambda x}\mathrm
dx=\frac1\lambda\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}&amp;EX^k=\int_0^{+\infty}\lambda
x^ke^{-\lambda x}\mathrm dx=-\int_{0}^{+\infty}x^k\mathrm
d\left(e^{-\lambda x}\right)\\&amp;=-x^ke^{-\lambda
x}\Bigg|_0^{+\infty}+k\int_0^{+\infty}x^{k-1}e^{-\lambda x}\mathrm
dx=\frac{k}{\lambda}EX^{k-1}\\&amp;由EX=\frac1\lambda,得EX^k=\frac{k!}{\lambda^k}\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}DX=EX^2-(EX)^2=\frac1{\lambda^2}\end{align}$</span></li>
</ul></li>
<li>正态分布<span
class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>,<em>σ</em><sup>2</sup>)</span>：
<ul>
<li><span
class="math inline">$\begin{align}f(x)=\frac1{\sqrt{2\pi}\sigma}e^{\Large-\frac{(x-\mu)^{\large2}}{2\sigma^{\large2}}}\end{align}$</span>，<span
class="math inline"><em>x</em> ∈ <em>R</em></span></li>
<li><span
class="math inline">$\begin{align}\int_{-\infty}^{+\infty}f(x)\mathrm
dx=1\end{align}$</span>，你可以由归一性使用结论，其证明过程如下(标准正态分布为例)：
<ul>
<li><span
class="math inline">$\begin{align}&amp;令I=\int_{-\infty}^{+\infty}e^{\large-\frac{x^{\normalsize2}}{2}}\mathrm
dx,则I^2=\int_{-\infty}^{+\infty}e^{\large-\frac{x^{\normalsize2}}2}\mathrm
dx\int_{-\infty}^{+\infty}e^{\large-\frac{y^{\normalsize2}}2}\mathrm
dy\\&amp;=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}e^{-\frac{x^2+y^2}2}\mathrm
dx\mathrm
dy=\lim_{a\rightarrow+\infty}\int_{-a}^{a}\int_{-a}^{a}e^{-\frac{x^2+y^2}2}\mathrm
dx\mathrm dy\end{align}$</span><span
class="math inline">$\begin{align}&amp;虽然被积区域不是圆,但可以用夹逼定理使其极坐标变换\\&amp;D_1&lt;D&lt;D_2,其中D_1为内切圆、D_2为外接圆\\&amp;在D_1上,\lim_{a\rightarrow+\infty}\int_{0}^{2\pi}\mathrm
d\theta\int_{0}^{\large\frac{a}2}re^{\Large-\frac{r^{\normalsize2}}2}\mathrm
dr=2\pi\\&amp;在D_2上,\lim_{a\rightarrow+\infty}\int_{0}^{2\pi}\mathrm
d\theta\int_{0}^{\large\frac{a}{\sqrt2}}re^{\Large-\frac{r^{\normalsize2}}2}\mathrm
dr=2\pi\\&amp;因此I=\sqrt{2\pi},\int_{-\infty}^{+\infty}f(x)\mathrm
dx=\frac I{\sqrt{2\pi}}=1\end{align}$</span></li>
</ul></li>
<li><span
class="math inline"><em>E</em><em>X</em> = <em>μ</em>、<em>E</em><em>X</em><sup>2</sup> = <em>σ</em><sup>2</sup> + <em>μ</em><sup>2</sup></span></li>
<li><span
class="math inline">$\begin{align}&amp;EX^k=\int_{-\infty}^{+\infty}\frac{x^k}{\sqrt{2\pi}}e^{\Large-\frac{x^2}{2}}\mathrm
dx=-\int_{-\infty}^{+\infty}\frac{x^{k-1}}{\sqrt{2\pi}}\mathrm
d\left(e^{\Large-\frac{x^2}2}\right)\\&amp;=0+\int_{-\infty}^{+\infty}\frac{(k-1)x^{k-2}}{\sqrt{2\pi}}e^{\Large-\frac{x^2}2}\mathrm
dx=(k-1)EX^{k-2}\end{align}$</span></li>
<li>标准正态分布：<span
class="math inline">$\begin{align}&amp;EX^k=(k-1)!!,k是偶数\\&amp;EX^k=0,k是奇数\end{align}$</span></li>
<li><span
class="math inline"><em>D</em><em>X</em> = <em>σ</em><sup>2</sup></span></li>
</ul></li>
</ul>
<h3 id="随机变量函数">随机变量函数</h3>
<h3 id="二维随机变量">二维随机变量</h3>
<ul>
<li>二维正态分布</li>
</ul>
<h3 id="统计量">统计量</h3>
<ul>
<li>正态分布<span
class="math inline"><em>N</em>(<em>μ</em>,<em>σ</em><sup>2</sup>)</span>的<span
class="math inline"><em>n</em></span>个简单随机样本的样本均值：<span
class="math inline">$\begin{align}\bar
X=\frac{1}{n}\sum_{i=1}^nX_i\end{align}$</span>
<ul>
<li><span
class="math inline"><em>E</em><em>X̄</em> = <em>μ</em></span></li>
<li><span class="math inline">$\begin{align}D\bar
X=\frac{\sigma^2}n\end{align}$</span></li>
</ul></li>
<li>正态分布<span
class="math inline"><em>N</em>(<em>μ</em>,<em>σ</em><sup>2</sup>)</span>的<span
class="math inline"><em>n</em></span>个简单随机样本的样本方差：<span
class="math inline">$\begin{align}S^2=\frac1{n-1}\sum_{i=1}^n(X_i-\bar
X)^2\end{align}$</span>
<ul>
<li><span
class="math inline"><em>E</em><em>S</em><sup>2</sup> = <em>μ</em><sup>2</sup> + <em>σ</em><sup>2</sup></span></li>
<li>由<span
class="math inline">$\begin{align}U=\frac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)\end{align}$</span>，<span
class="math inline">$\begin{align}&amp;DS^2=\frac{\sigma^4}{(n-1)^2}DU=\frac{\sigma^4}{(n-1)^2}(n-1)DX^2\\&amp;DX^2=EX^4-(EX^2)^2=3EX^2-(EX^2)^2=2\\&amp;DS^2=\frac2{n-1}\end{align}$</span></li>
</ul></li>
<li>标准正态分布：不再赘述，设总体<span
class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>,<em>σ</em><sup>2</sup>)</span>，以下为常见的构造
<ul>
<li><span class="math inline">$\begin{align}\frac{\sqrt n(\bar
X-\mu)}{\sigma}\sim N(0,1)\end{align}$</span></li>
<li><span class="math inline">$\begin{align}\frac{\bar X_1-\bar
X_2+(\mu_1-\mu_2)}{\sqrt{\frac{\sigma^2_1}{n_1}+\frac{\sigma^2_2}{n_2}}}\sim
N(0,1)\end{align}$</span></li>
</ul></li>
<li>卡方分布<span
class="math inline"><em>U</em> ∼ <em>χ</em><sup>2</sup>(<em>n</em>)</span>：设<span
class="math inline"><em>X</em><sub>1</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>为服从标准正态分布且相互独立的随机变量
<ul>
<li><span
class="math inline">$\begin{align}U=\sum_{i=1}^nX_i^2\end{align}$</span></li>
<li><span
class="math inline"><em>E</em><em>U</em> = <em>n</em><em>E</em><em>X</em><sup>2</sup> = <em>n</em></span></li>
<li><span
class="math inline"><em>D</em><em>U</em> = <em>n</em><em>D</em><em>X</em><sup>2</sup> = <em>n</em>(<em>E</em><em>X</em><sup>4</sup>−(<em>E</em><em>X</em><sup>2</sup>)<sup>2</sup>) = 2<em>n</em></span></li>
</ul></li>
<li><span class="math inline"><em>t</em></span>分布<span
class="math inline"><em>U</em> ∼ <em>t</em>(<em>n</em>)</span>：设<span
class="math inline"><em>X</em> ∼ <em>N</em>(0,1)、<em>Y</em> ∼ <em>χ</em><sup>2</sup>(<em>n</em>)</span>，且它们相互独立
<ul>
<li><span
class="math inline">$\begin{align}U=\frac{X}{\sqrt{\large\frac{Y}{n}}}\end{align}$</span></li>
<li>假设<span
class="math inline"><em>X</em><sub>1 ∼ <em>n</em></sub></span>来自<span
class="math inline"><em>N</em>(0,1)</span>，则<span
class="math inline">$\begin{align}\frac{\sqrt n(\bar X-\mu)}{S}\sim
t(n-1)\end{align}$</span></li>
</ul></li>
<li><span class="math inline"><em>F</em></span>分布<span
class="math inline"><em>U</em> ∼ <em>F</em>(<em>n</em>,<em>m</em>)</span>：设<span
class="math inline"><em>X</em> ∼ <em>χ</em><sup>2</sup>(<em>n</em>)、<em>Y</em> ∼ <em>χ</em><sup>2</sup>(<em>m</em>)</span>，且它们相互独立
<ul>
<li><span
class="math inline">$\begin{align}U=\frac{\large\frac{X}{n}}{\large\frac{Y}{m}}\end{align}$</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Probability Math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 函数式编程</title>
    <url>/blogs/2025/05/04/java-stream-api/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="函数式编程">函数式编程</h2>
<h3 id="类的初始化代码">类的初始化代码</h3>
<ul>
<li><p>在一个类中由<code>{}</code>框住的代码块称为初始化代码，在<strong>构造方法之前</strong>执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 实例创建后构造方法执行前运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 类加载后执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="匿名类">匿名类</h3>
<ul>
<li><p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Parent</span>() &#123;</span><br><span class="line">  <span class="comment">// 类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其中<code>Parent</code>必须是存在的类或接口，这个匿名类相当于继承这个<code>Parent</code>类或<code>Parent</code>接口</p></li>
<li><p>若为实现一个接口，则类体必须实现这个接口的方法</p></li>
<li><p>运行到匿名类声明的地方时，会创建一个匿名实例，由于匿名类没有构造方法(因为没有名字)，所以使用初始化代码块<code>{}</code>来初始化</p></li>
</ul>
<h3 id="lambda表达式"><code>lambda</code>表达式</h3>
<ul>
<li><p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数列表) -&gt; &#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 小括号与大括号可省略</span></span><br></pre></td></tr></table></figure></li>
<li><p>从<code>Java 8</code>开始，可以用<code>lambda</code>表达式作为单方法接口的一个实例，表达式的函数体作为该接口的这个方法的实现
单方法接口指由<code>@FunctionalInterface</code>注解的含<strong>一个抽象实例方法</strong>的接口，可以包含<code>default</code>或<code>static</code>方法
被该注解修饰的接口称为<strong>函数式接口</strong>，<code>java.util.function</code>提供了一系列基础的泛型函数式接口</p></li>
<li><p>方法引用：除了<code>lambda</code>表达式，还可以用<code>类名::方法名</code>表示一个方法的引用，这个方法引用只能作为参数传递，不能赋值给一个变量，前提是形参是一个单方法接口且方法签名与提供的方法引用的签名一致
用<code>类名::new</code>表示该类的构造方法引用
若传递的方法为实例方法，则其第一个参数的类型被视为该实例对应的类型</p></li>
<li><p>内置的函数式接口：</p>
<ul>
<li><code>Function&lt;T, R&gt;</code>：提供的方法只有一个类型为<code>T</code>的参数，且返回类型为<code>R</code></li>
<li><code>Consumer&lt;T&gt;</code>：提供的方法只有一个类型为<code>T</code>的参数，且没有返回值</li>
<li><code>Predicate&lt;T&gt;</code>：相当于<code>Function&lt;T, Boolean&gt;</code></li>
<li><code>BiFunction, BiConsumer, BiPredicate</code>：相比于上述函数式接口，允许接受两个参数</li>
<li><code>Supplier&lt;T&gt;</code>：提供的方法不接受任何参数，且返回类型为<code>T</code></li>
<li><code>Comparator&lt;T&gt;</code>：自定义比较器，须实现<code>compare()</code>方法</li>
<li><code>Runnable</code>：自定义线程，须实现<code>run()</code>方法</li>
<li><code>Callable, FileFilter, PathMatcher, InvocationHandler, PropertyChangeListener, ActionListener</code>等</li>
<li>由于<code>java</code>的泛型无法使用基本数据类型，因此为了效率，还提供了一系列类似<code>TypeToTypeFunction, TypeConsumer</code>的针对基本数据类型的函数式接口</li>
</ul></li>
</ul>
<h3 id="流式api">流式<code>API</code></h3>
<ul>
<li>流式<code>API</code>指<code>java.util.stream</code>，和<code>java.io</code>提供的输入输出流完全不同，文件<code>io</code>用于处理输入和输出以及序列化、反序列化，而<code>Stream&lt;T&gt;</code>是顺序输出的一系列同类型对象</li>
<li><code>Stream</code>和<code>List</code>等序列集合的区别是，前者既可以表示有限个集合，也可以通过存储函数映射关系来实现“存储”序列对象，通过实时计算的方式“存储”无限个元素
当然，无限个元素很多时候只需要有限个，所有<code>Stream</code>提供的功能都可以用集合框架实现，但流式<code>API</code>可以使一系列集合操作变得紧凑而清晰</li>
<li><code>Stream</code>对象创建方法：
<ul>
<li><code>Stream.of(T...)</code>：提供一个有限序列</li>
<li><code>Stream.generate(Supplier&lt;T&gt;)</code>：提供一个<code>Supplier</code>的实例，调用聚合函数时通过该方法实时计算元素</li>
<li>通过<code>Collection</code>实例的<code>stream()</code>方法获取</li>
<li>通过流对象的转换方法获取</li>
</ul></li>
<li>常用转换方法：可以链式调用以获取新的流式对象的实例方法
需要注意，<strong>调用转换方法不会有任何实际计算开销</strong>
<ul>
<li><code>limit(long)</code>：流虽然能获取无限个元素，但所有情况下都只需要有限个元素，且处理时也只需要有限个元素，因此可以使用<code>limit()</code>截取前若干个元素的<code>Stream</code>对象</li>
<li><code>skip(long)</code>：同上，流可以跳过若干个元素</li>
<li><code>map(Function&lt;T, R&gt;)</code>：将流的所有元素通过该方法转换为<code>R</code>类型的元素</li>
<li><code>forEach(Consumer&lt;? super T&gt;)</code>：使流中的每个元素经过该函数，要求流是有限集合</li>
<li><code>filter(Predicate&lt;? super T&gt;)</code>：筛选流中的元素，将不符合条件的元素去除</li>
<li><code>sorted()</code>和<code>sorted(Comparator&lt;T&gt;)</code>：排序</li>
<li><code>distinct()</code>：去重</li>
<li><code>concat()</code>：拼接两个流对象</li>
<li><code>flatMap(Function&lt;T, Stream&lt;R&gt;&gt;)</code>：将所有元素经过该方法转化为流对象，再进行<code>concat()</code>使所有流对象转换为单个流对象，通常用于元素为集合类型的流的转换</li>
<li><code>parallel()</code>：获取一个并行的流对象，不需要编写多线程代码</li>
<li><code>count()</code>：获取流对象的元素数量</li>
<li><code>max/min(Comparator&lt;T&gt;)</code>：获取最大值与最小值</li>
<li><code>allMatch(Predicate&lt;T&gt;)</code>与<code>anyMatch(Predicate&lt;T&gt;)</code>：判断是否所有元素/存在元素满足条件</li>
</ul></li>
<li>常用聚合方法：将一个流对象的所有元素聚合为一个统计量的实例方法，会实时计算需要的元素
<ul>
<li><code>reduce(BinaryOperator&lt;T&gt;)</code>：提供一个二元运算函数，使用该函数对所有元素进行从左到右的累加，返回<code>Optional&lt;T&gt;</code></li>
<li><code>toList()</code>：聚合为一个<code>List&lt;T&gt;</code>对象</li>
<li><code>toArray()</code>：不传递任何参数则只能返回<code>Object[]</code>数组，所以一般需要传递<code>T[]::new</code>返回<code>T[]</code>数组</li>
<li><code>collect(Collector&lt;? super T, A, R&gt;)</code>：通过<code>Collector</code>方法进行聚合</li>
<li><code>collect(Supplier&lt;R&gt;, BiConsumer&lt;R, ? super T&gt;, BiConsumer&lt;R, R&gt;)</code>：通过第一个参数获取一个初始的<code>R</code>类型的值，然后通过第二个参数将元素聚合到这个初始值
第三个参数用于并行流的并行计算后，将两个<code>R</code>类型的值合并</li>
</ul></li>
<li>通过上述方法，可以用简洁的代码对集合中的所有元素进行处理，其中<code>collect()</code>方法可以提供<code>Collector</code>，其工具类为<code>Collectors</code>，包含一系列返回<code>Collector</code>实例的静态方法，分别有三类：
<ul>
<li>恒等变换：</li>
<li>分组分区：</li>
<li>统计意义：</li>
</ul></li>
<li><code>Collector&lt;T, A, R&gt;</code>三个泛型参数的实际意义是：元素类型、中间结果类型、收集器返回类型
源码实现为<code>CollectorImpl&lt;T, A, R&gt;</code>，需要提供四个参数：
<ul>
<li><code>Supplier&lt;A&gt;</code>：用于获取一个初始的中间容器</li>
<li><code>BiConsumer&lt;A, T&gt;</code>：用于聚合所有元素到中间容器中</li>
<li><code>BinaryOperator&lt;A&gt;</code>：用于将两个中间容器合并为一个中间容器，用于并行流</li>
<li><code>Function&lt;A, R&gt;</code>：将中间容器转化为<code>R</code>类型的结果</li>
<li><code>Set&lt;Characteristics&gt;</code>：<code>Characteristics</code>枚举的集合
该枚举包含三项：
<code>CONCURRENT</code>：表示收集器可以并发执行合并操作而不影响结果
<code>IDENTITY_FINISH</code>：表示中间容器有标识功能，<code>A</code>可以直接强制转换为<code>R</code>类型
<code>UNORDERED</code>：表示收集器获取两个元素进行合并时，没有固定的获取顺序</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络: 数据链路层</title>
    <url>/blogs/2025/05/03/comp-networking-datalinklayer/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="数据链路层">数据链路层</h2>
<h3 id="提供的服务或功能">提供的服务或功能</h3>
<ul>
<li>成帧<code>Framing</code>：将数据包封装成帧</li>
<li>介质访问控制(<code>Media Access Control, MAC</code>)协议：规定帧在链路上传输的规则，用于协调多个节点的帧传输</li>
<li>可靠交付：在无线环境下，可以提供纠错能力；在有线这种不那么容易出错的环境下，可能不会提供可靠交付服务</li>
<li>差错检测和纠正：比传输层、网络层更加复杂，且用硬件实现</li>
</ul>
<h3 id="差错检测和纠正">差错检测和纠正</h3>
<ul>
<li>奇偶校验码：</li>
<li>循环冗余校验(<code>Cyclic Redundancy Check, CRC</code>)码：</li>
</ul>
<h3 id="多路访问问题">多路访问问题</h3>
<ul>
<li><p>多路访问问题在于，大多数通信链路是广播链路，即是<strong>共享信道</strong>的，任何一台设备发送的报文可以被多个节点收到，但<strong>同一时间应该只有一台设备能够占有该信道</strong>，否则就会互相干扰
多路访问控制(<code>Multiple Access Control, MAC</code>)协议就是用来解决多路访问问题的</p></li>
<li><p>信道划分协议(<code>Channel Partitioning Protocol</code>)：将共享信道根据某种属性分为多个子信道并按需分配出去
这类协议保证绝对不会发生冲突且绝对公平地分配资源</p>
<ul>
<li>时分多路复用(<code>Time Division Mutiplexing, TDM</code>)：将时间平等地分给接入共享信道的主机，会极大限制主机的平均发送速率，且降低了信道的使用率
虽然主机能在其时间段内能占用全部的带宽，但其平均速率需要除以节点数
一个主机必须等到它的专有时隙才能发送数据，即使只有它需要占用信道</li>
<li>频分多路复用(<code>Frequency Division Mutiplexing, FDM</code>)：将信道划分为不同的频段，仍会限制主机的平均发送速率，且降低信道的带宽使用率
主机只能占有一个频段，每个频段的带宽只有总带宽除以节点数这么多
一个主机最多只能占有一个频段的带宽而无法完全占有信道，即使只有它需要占用信道</li>
<li>码分多址(<code>Code Division Multiple Access, CDMA</code>)：为每个节点分配不同的编码，使得节点可以克服上述的问题</li>
</ul></li>
<li><p>随机接入协议(<code>Random Access Protocol</code>)：传输节点总是完全占有信道地发送，发生碰撞时，<strong>随机</strong>地决定一个<strong>重发时延</strong>，直到发送出去为止
这类协议通常不能避免碰撞，但具有较高的信道资源利用率，且对每一个节点可能不是公平的</p>
<ul>
<li><p>时隙<code>ALOHA</code>(<code>Slotted ALOHA</code>)：这个协议将时间轴划分为多个时间帧，每个节点要发送数据时，在下一个时隙开始时发送，并在<strong>时隙结束前检测是否发生碰撞</strong>，若发生碰撞，则以一定的<strong>概率<span
class="math inline"><em>p</em></span>决定</strong>下一个时隙<strong>是否重传</strong>
一个节点成功发送前经过的时隙数量<span
class="math inline"><em>N</em> ∼ <em>G</em>(<em>p</em>)</span>，即<span
class="math inline"><em>P</em>(<em>N</em>=<em>k</em>) = (1−<em>p</em>)<sup><em>k</em> − 1</sup><em>p</em></span>
缺点在于，需要对所有节点保持同步</p></li>
<li><p>非时隙<code>ALOHA</code>(<code>Pure ALOHA</code>)：与时隙<code>ALOHA</code>的区别在于，不用进行同步，但一个节点成功发送前经过<span
class="math inline"><em>k</em></span>个时隙的概率为<span
class="math inline"><em>P</em>(<em>N</em>=<em>k</em>) = (1−<em>p</em>)<sup>2(<em>k</em>−1)</sup><em>p</em></span>，效率为时隙<code>ALOHA</code>的一半</p></li>
<li><p>带碰撞检测的载波侦听多路访问(<code>Carrier Sense Multiple Access with Collision Detection, CSMA/CD</code>)：要求主机<strong>主动地避免</strong>和别的主机发生冲突，具体来说，要实现<strong>载波侦听</strong>和<strong>碰撞检测</strong>
载波侦听即，每个节点在<strong>发送帧之前先侦听信道</strong>，等待没有其它节点占用信道时，才发送
碰撞检测即，虽然每个节点都会侦听，但信号的传输是有延迟的，可能存在多个节点“同时”(一个节点发送后还未传播到另一个想要发送的节点那儿)检测到信道为空，并“同时”发送帧；碰撞检测在于，一旦<strong>检测到碰撞发生，则停止发送帧</strong>，然后以指数增长的延迟决定什么时候重发帧
效率为<span
class="math inline">$\begin{align}\frac1{1+5d_{prop}/d_{trans}}\end{align}$</span>，其中的延迟分别为传播延迟和传输延迟</p></li>
<li><p>带碰撞避免的载波侦听多路访问(<code>CSMA with Collision Avoidance, CSMA/CA</code>)：无线网络是不能使用<code>CSMA/CD</code>的，因为发送出去的帧必须完整发出，无法检测碰撞，因此<code>CSMA/CA</code>采用在广播前尽量避免碰撞的策略，它<strong>不会进行冲突检测</strong>，而是发出数据后通过<strong>链路层确认</strong>来决定是否重发</p>
<ul>
<li>在发送方检测到信道为空闲时，等待一个<strong>分布式帧间间隔</strong>(<code>Distributed Inter-frame Space, DIFS</code>)再发送</li>
<li>接收方收到后，会等待短帧间间隔(<code>Short Inter-frame Space, SIFS</code>)后回应一个确认帧</li>
<li>如果因为冲突、或其它原因，接收方没有收到确认帧，则像<code>CSMA</code>一样以指数增长的延迟重发</li>
</ul>
<p>虽然<code>CA</code>比<code>CD</code>多了一个<code>DIFS</code>，但它仍可能出现问题，即两个主机互相隐藏，但都需要向中间的第三方主机发送帧，这时将发生碰撞
解决这个问题依赖于<strong>无线接入点</strong>(<code>Access Point, AP</code>)，它是一个仲裁机构，所有需要广播的必须向<code>AP</code>发送<strong><code>RTS</code></strong>(<code>Request To Send</code>)控制帧，表示请求发送，在没有发生冲突时，<code>AP</code>才会完整接收到<code>RTS</code>帧，并<strong>广播回应<code>CTS</code></strong>(<code>Clear To Send</code>)控制帧，表示允许发送；发送<code>RTS</code>的主机接收到后可以发送数据帧，其它主机接收到<code>CTS</code>后则会推迟访问共享信道</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust: 基本语法</title>
    <url>/blogs/2025/05/02/rust-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="rust基本语法"><code>Rust</code>基本语法</h1>
<h2 id="语句和表达式">语句和表达式</h2>
<h3 id="通用规则">通用规则</h3>
<ul>
<li><p>语句是不会返回值的命令；表达式是会返回值的命令</p></li>
<li><p>如果一个表达式后接<code>';'</code>，那么它只是一个语句而不是表达式
相反，<code>rust</code>允许一个命令不接<code>';'</code>，这时这条命令是一条表达式
许多函数是可以作为表达式(不加分号)，也可以作为语句的</p></li>
<li><p>块表达式：可以用<code>{}</code>包围一系列语句及<strong>最后接一个</strong>表达式，方便推理，块表达式会返回最后这个表达式的返回值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">1</span>; <span class="comment">// 推理</span></span><br><span class="line">    b + <span class="number">1</span>   <span class="comment">// 块表达式返回值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="控制流语句或表达式">控制流语句或表达式</h3>
<ul>
<li><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;<span class="type">bool</span>型表达式&gt; &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &lt;<span class="type">bool</span>型表达式&gt; &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>loop</code>：无限循环表达式，直到用户通过<code>break</code>退出
它会返回<code>break</code>后跟的值，类似<code>return ...</code>
<code>break</code>也可以不跟值，这时<code>loop</code>块是一条语句</p></li>
<li><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;可变变量&gt; <span class="keyword">in</span> &lt;range&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;range&gt;</code>可用类似<code>1..=10</code>的语法糖快速创建</p></li>
</ul>
<h2 id="变量所有权">变量所有权</h2>
<ul>
<li><p><code>RAII</code>：</p>
<ul>
<li><p>类似<code>java</code>，标识符是一个在栈上的引用，指向常量池或堆上的值</p></li>
<li><p>针对常量池中的值(例如整型、常量字符串)：赋值相当于将常量的引用赋给变量，若赋给多个变量，则它们的引用均指向这个常量</p></li>
<li><p>针对堆上的值：每一个值都有一个所有者，且任意时刻只有一个所有者；这是为了摒弃<code>GC</code>做出的和其它语言的区别：一个值只能有一个引用，使用时只能转让或自动退出时被<code>drop</code>
当变量离开作用域时，值会被丢弃；
经过赋值操作时，值会被转移；也就是说，一个变量通过赋值将值绑定给另一个变量时，前者这个变量就不再拥有这个值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;  <span class="comment">// s1不再拥有上述创建的&quot;hello&quot;, 而s2和&quot;hello&quot;绑定</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><code>rust</code>和其它语言通过垃圾回收(<code>java</code>)或程序员手动分配(<code>C/C++</code>)内存不同，它通过<strong>所有权系统</strong>管理内存</p>
<ul>
<li>在编译时检查程序是否违反所有权机制，这也是容易编译不通过的原因</li>
<li>所有权机制是在编译时起作用的，不像垃圾回收那样，会对性能产生负面影响</li>
</ul></li>
</ul>
<h2 id="数据类型">数据类型</h2>
<h3 id="定义标识符">定义标识符</h3>
<ul>
<li><p>指定数据类型：<code>rust</code>虽然支持对变量自动识别类型，但毕竟是强类型语言，最好手动指定数据类型，语法为
<code>&lt;变量名&gt;: &lt;数据类型&gt; = &lt;值&gt;</code></p></li>
<li><p>定义变量：</p>
<ul>
<li><code>let &lt;变量名&gt;</code>：定义不可变变量(第一次绑定值后只读，且只允许通过<code>let</code>再次声明后重新绑定值)</li>
<li><code>let mut &lt;变量名&gt;</code>：定义可变变量</li>
<li>变量在声明时可以不绑定值，但此时必须指定数据类型</li>
</ul></li>
<li><p>定义常量：<code>const &lt;变量名&gt;: type = value</code></p>
<ul>
<li>必须手动指定数据类型，并在声明时绑定值</li>
</ul></li>
<li><p>定义静态变量：<code>static</code></p></li>
<li><p>定义<strong>引用</strong>：所有类型都有引用类型，这个引用不同于<code>java、python</code>的引用，而更像<code>C/C++</code>的轻量级引用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;oth_obj; <span class="comment">// oth_obj的只读引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;<span class="keyword">mut</span> oth_mutable_obj; <span class="comment">// oth_mutable_obj的可变引用, 要求oth_mutable_obj为可变变量</span></span><br></pre></td></tr></table></figure>
<p>在整个作用域中，只允许最多一个可变引用
结合一个标识符会在作用域结束时释放，可以实现类似以下的操作：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">obj</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">10</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref1</span> = &amp;<span class="keyword">mut</span> obj;</span><br><span class="line">&#125; <span class="comment">// ref1释放</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref2</span> = &amp;<span class="keyword">mut</span> obj; <span class="comment">// 如果替换它们的顺序, 是不允许的</span></span><br></pre></td></tr></table></figure>
<p>关于函数参数：这个引用类型比<code>C++</code>更严格，想传递一个引用参数的话，形参的类型必须为对应的引用类型</p></li>
<li><p>变量名风格：<code>snake case</code>规范(所有字母小写，用下划线分隔单词)</p></li>
</ul>
<h3 id="基本数据类型">基本数据类型</h3>
<ul>
<li>整型：
<ul>
<li><code>i8、i16、...</code>：有符号整型</li>
<li><code>u8、u16、...</code>：无符号整型</li>
<li><code>isize、usize</code>：自适应有/无符号整型</li>
</ul></li>
<li>字符型：
<ul>
<li><code>char</code>：<code>Unicode</code>字符</li>
<li><code>str</code>：基本不会用到的字符串类型，因为是<code>DST</code></li>
<li></li>
</ul></li>
</ul>
<h2 id="类与函数">类与函数</h2>
<h3 id="函数">函数</h3>
<ul>
<li><code>fn &lt;函数名&gt; (&lt;函数参数&gt;) -&gt; &lt;返回值类型&gt; {&lt;函数体&gt;}</code>
在指定返回值类型后，函数体必须通过表达式或<code>return</code>返回指定类型的值</li>
<li>闭包函数，即所谓<code>lambda</code>表达式：</li>
</ul>
<h2 id="集成框架">集成框架</h2>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络: 网络层协议</title>
    <url>/blogs/2025/05/01/comp-networking-iplayer/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="网络层协议">网络层协议</h2>
<h3 id="网络层的功能">网络层的功能</h3>
<ul>
<li>主要功能：分组转发和路由选择</li>
<li>其它功能：不同系统的设备间通信、拥塞控制</li>
</ul>
<h3 id="ipv4协议"><code>IPv4</code>协议</h3>
<ul>
<li><p><code>IP</code>地址：在此介绍<code>ipv4</code>的<code>32</code>位地址(<code>ipv6</code>为<code>128</code>位)，由<strong>网络号</strong>和<strong>主机号</strong>组成，分为<strong>有类别</strong>和<strong>无类别</strong>两种地址；注意，网络层始终讲述的是不同的网络号间如何转发，并不关心同一网段下的不同主机如何转发(那是数据链路层的任务)</p>
<ul>
<li>有两种特殊的主机号<strong>不能分配给主机</strong>：全零和全一
主机号全零的<code>IP</code>地址表示<strong>一个网段本身</strong>
主机号全一的<code>IP</code>地址表示<strong>特定子网的广播地址</strong>，可以<strong>跨网段广播</strong>到特定网段的所有主机号(但这个功能<strong>默认被拦截</strong>，需要管理员开放)</li>
<li>有两个特殊的<code>IP</code>地址有特殊用途：
<code>0.0.0.0</code>表示<strong>本地网段内的所有主机</strong>，通常作为路由器的<strong>默认路由</strong>
<code>255.255.255.255</code>表示<strong>受限广播地址</strong>，和仅主机号全一的<code>IP</code>地址相比，它<strong>只能在本地网段广播</strong>该分组、而后者可以</li>
<li>有类别(比较古老的做法)：分为<strong><code>A、B、C、D、E</code></strong>类，<code>A、B、C</code>类分别以<strong>前<code>8、16、24</code>位</strong>作为网络号
为了区分不同的有类别地址，它们有不同的<strong>前缀</strong>，分别为<strong><code>0、10、110、1110、1111</code></strong>
<code>A</code>类总共提供<span
class="math inline">2<sup>7</sup> = 128</span>个网络号，<span
class="math inline">2<sup>24</sup> = 16777216</span>个主机号
<code>B</code>类总共提供<span
class="math inline">2<sup>14</sup> = 16384</span>个网络号，<span
class="math inline">2<sup>16</sup> = 65536</span>个主机号
<code>C</code>类总共提供<span
class="math inline">2<sup>21</sup> = 2097152</span>个网络号，<span
class="math inline">2<sup>8</sup> = 256</span>个主机号
缺陷显而易见，非常不灵活，例如：当出现<span
class="math inline">10<sup>3</sup></span>量级的主机号数量需求时，显然只能用<code>B</code>类，导致白白浪费一个网段的大部分主机号
<code>D</code>类和<code>E</code>类不区分网络号和主机号，它们的后<code>28</code>位可以随意修改，<code>D</code>给因特网体系结构委员会使用，<code>E</code>类作为保留地址</li>
<li>无类别：网络号位数<span
class="math inline"><em>x</em></span>可变的<code>IP</code>地址，用于无类别域间路由选择(<code>Classless Inter Domain Routing, CIDR</code>)
为了区分不同的无类别地址，不同网段由不同的<strong>子网掩码</strong>来标识，子网掩码是<strong>网络号全为<code>1</code>、主机号全为<code>0</code></strong>的<code>32</code>位掩码，所谓子网掩码的长度指的是<span
class="math inline"><em>x</em></span>的大小 无类别地址简记形式：<span
class="math inline"><em>a</em>.<em>b</em>.<em>c</em>.<em>d</em>/<em>x</em></span>，<span
class="math inline"><em>x</em></span>为网络号长度
如果主机号数量的需求为<span
class="math inline"><em>L</em></span>，则找到<span
class="math inline">2<sup><em>k</em> − 1</sup> − 2 &lt; <em>L</em> ≤ 2<sup><em>k</em></sup> − 2</span>，其中的<span
class="math inline"><em>k</em></span>即最少需要的主机号位数，因此子网掩码最长为<span
class="math inline"><em>x</em> = 32 − <em>k</em></span></li>
</ul></li>
<li><p><code>IPv4</code>报文：</p>
<ul>
<li><p>第一行：版本号(<code>4</code>)+首部长度(<code>4</code>)+服务类型(<code>8</code>)+数据报长度(<code>16</code>)</p>
<ul>
<li>版本号：处于不同版本的兼容，版本号用于标识使用的<code>IP</code>协议版本</li>
<li>首部长度：单位为<code>4</code>个字节</li>
<li>服务类型：区分不同的<code>IP</code>报文，提供不同的优先级</li>
<li>数据报长度：单位为<code>1</code>个字节</li>
</ul></li>
<li><p>第二行：标识(<code>16</code>)+标志(<code>3</code>)+片偏移(<code>13</code>)，用于<code>IP</code>分组(分片)，由于分片/重组相当耗时，<code>ipv6</code>不允许在中间路由进行<code>IP</code>分片，这一行字段被弃用，但应该了解分组的过程：</p>
<ul>
<li>标识：分割出去的分组的该字段继承原<code>IP</code>分组的标识</li>
<li>标志位：包含保留位、<code>DF</code>位(不分片位)和<code>MF</code>位(更多分片位)
<code>DF</code>置<code>1</code>则不允许分片，并在数据大小超过<code>MTU</code>后返回<code>ICMP</code>错误信息
<code>MF</code>置<code>1</code>表示本分组是分片后的分组，且后续还有分组未到达
<code>MF</code>置<code>0</code>表示本分组是分片后的分组，且后续没有更多分片，<code>MF</code>方便重组方能够确认原来分组的大小</li>
<li>片偏移：标识本分组首字节在原分组首字节的位置，这个字段的单位是<code>8</code>个字节(因为<code>13</code>位比数据报长度<code>16</code>位少了<code>3</code>位)，即实际位置是片偏移乘<code>8</code>
也因为这个，每个分片(除最后一个分片)的<strong>有效数据大小必须能被<code>8</code>整除</strong></li>
</ul>
<p>本身分组分割就是因为要使<code>IP</code>分组小于<code>MTU</code>，因此要使分片的有效数据大小<span
class="math inline"><em>L</em></span>满足： <span
class="math inline"><em>L</em><sub><em>m</em><em>a</em><em>x</em></sub> + <em>首</em><em>部</em><em>长</em><em>度</em> ≤ <em>M</em><em>T</em><em>U</em></span>且<span
class="math inline">8|<em>L</em><sub><em>m</em><em>a</em><em>x</em></sub></span></p></li>
<li><p>第三行：<code>TTL</code>(<code>8</code>)+上层协议(<code>8</code>)+首部检验和(<code>16</code>)</p>
<ul>
<li><code>TTL</code>：<code>Time-To-Live</code>，一个分组的最长寿命，每经过一个路由减少一定寿命，防止分组永久地在网络中循环转发</li>
</ul></li>
<li><p>第三、第四行：源<code>IP</code>地址、目的<code>IP</code>地址</p></li>
</ul></li>
</ul>
<h3 id="路由器工作原理">路由器工作原理</h3>
<ul>
<li><p>分组从一个网段到另一个网段，可能需要经过路由器转发
路由器需要先经过<strong>路由选择</strong>，才能进行<strong>转发</strong></p>
<ul>
<li>路由选择：通过软件计算，选择一条从源主机到目的主机的端到端路径</li>
<li>转发：将分组从入接口移动到某个离出接口(由路由选择决定向哪个接口移动)，这是一次较快的硬件操作</li>
</ul></li>
<li><p>静态转发表：由目标网络、子网掩码、下一站<code>IP</code>地址、离出接口组成
静态是指，由管理者手动增删表项</p>
<ul>
<li>目标<strong>网络号</strong>：标识本路由器可以到达的网段，通过使分组的目的<code>IP</code>地址和表项的子网掩码按位相与再和目标网络比对，得出离出接口
用<code>0.0.0.0</code>表示默认路由，即没有任何表项和分组的目的<code>IP</code>网段相匹配的时候，使用的表项</li>
<li>下一站<strong><code>IP</code>地址</strong>：标识下一个路由<strong>设备接口的<code>IP</code>地址</strong>，这个是整个<code>IP</code>地址而不仅是网络号
每个路由器的<strong>每个接口都有<code>IP</code>地址</strong>，这个字段表示的就是接口的<code>IP</code>地址
<code>C</code>表示下一个接口就在本地路由器，即目的网段和本路由器相邻</li>
<li>离出接口：即本地对接口的标识</li>
</ul></li>
<li><p>路由聚合和最长子网掩码匹配：有些时候，一个路由器有<strong>多个表项的离出接口相同</strong>，<strong>目标网络不同但有一定长度的公共前缀</strong>，这时可以进行<strong>路由聚合</strong>，将它们合为一个表项，因为它们虽然目的网段不同，但是转发结果是一致的，而路由表越短、传输延迟越短
但可能会出现问题：分组本应转发到接口<code>A</code>，但因为接口<code>B</code>的表项被路由聚合了，同时意味着这些表项的子网掩码变短了，按位相与后分组可能被误转发到接口<code>B</code>；<strong>最长子网掩码匹配</strong>即，分组<strong>总是先和子网掩码较长的表项</strong>比对，因为较长的子网掩码通常包含更详细的地址信息</p></li>
<li><p>动态路由选择算法：仅少数表项由管理者初始化，其余表项由路由器学习得到</p>
<ul>
<li>集中式路由选择算法，又称<strong>链路状态(<code>LS</code>)算法</strong>：在路由开始学习前<strong>知道了所有链路的开销</strong>，使用<code>Dijkstra</code>算法学习
学习完成后，路由器可以得知<strong>和其它所有网段的最短距离</strong>以及<strong>最合适的离出接口</strong></li>
<li>分布式路由选择算法，又称<strong>距离向量(<code>DV</code>)算法</strong>：使用<code>Bellman-Ford</code>算法，通过报文跳数估计距离，适用于<strong>中小型网络</strong></li>
<li><code>LS</code>和<code>DV</code>算法对比：
更新开销方面：前者需要向所有路由转发链路状态报文、后者只在相邻的链路发生改变时向相邻的路由器报告，后者开销较小
收敛速度和健壮性方面：前者较优，<code>DV</code>算法收敛很慢</li>
</ul></li>
<li><p>自治系统：因特网是多个<code>ISP</code>(网络业务提供商)的网络，不同<code>ISP</code>有自己的管理方式，因此出现了自治域(<code>Autonomous System, AS</code>)
<code>AS</code>内部有<strong>一类</strong>路由选择协议，它们统称为<strong><code>IGP</code></strong>(<code>Interior Gateway Protocol</code>内部网关协议)；不同<code>AS</code>间需要用<strong>统一的</strong>路由选择协议管理，称为<strong><code>BGP</code></strong>(<code>Border Gateway Protocol</code>边界网关协议)
即，<code>IGP</code>是一类开发商自行实现的协议、<code>BGP</code>是一个由<code>RFC</code>规范的协议，<code>IGP</code>有以下协议：</p>
<ul>
<li>路由信息协议(<code>Routing Information Protocol, RIP</code>)：它是一个<code>DV</code>协议，仅适用于中小型网络</li>
<li>内部网关路由协议(<code>Interior Gateway Routing Protocol, IGRP</code>)：它是一个<code>DV</code>协议，现在已经被淘汰，注意和<code>IGP</code>区分</li>
<li>开放最短路优先(<code>Open Shortest Path First, OSPF</code>)：<code>Open</code>意味着这个协议的实现细节是所有人可见的，它是一个<code>LS</code>协议，适用于大型网络，支持分层拓扑架构</li>
<li>中间系统到中间系统(<code>IS-IS</code>)：它是一个<code>LS</code>协议</li>
</ul>
<p><code>BGP</code>规定的边界网关的路由表经过高度路由聚合</p></li>
</ul>
<h3 id="dhcp协议"><code>DHCP</code>协议</h3>
<ul>
<li><code>DHCP</code>协议全称<code>Dynamic Host Configuration Protocol</code>，即<strong>动态主机配置</strong>协议，又称<strong>即插即用</strong>(<code>plug-and-play</code>)或<strong>零配置</strong>(<code>zeroconf</code>)协议
<code>DHCP</code>为随时进入局域网的设备<strong>自动配置<code>IP</code>地址</strong>、设备离开后自动回收<code>IP</code>地址</li>
<li>发现报文：主机进入局域网后，没有<code>IP</code>地址可用，也不知道该网段的网络号，于是向该局域网内的<strong><code>DHCP</code>主机</strong>通过<strong><code>UDP</code></strong>协议<strong>广播<code>DHCP</code>发现报文</strong>(端口号<code>67</code>)，使用<strong><code>0.0.0.0</code>作为本机地址</strong></li>
<li>提供报文：<code>DHCP</code>主机收到后(只有<code>DHCP</code>主机会进行处理)，仍用<strong>广播</strong>方式响应一个<strong><code>DHCP</code>提供报文</strong>，其中在数据段附上推荐的<code>IP</code>地址，以及其它的限制如<strong><code>IP</code>地址租用期</strong></li>
<li>请求报文：局域网内可能有若干个<code>DHCP</code>主机，新进入的主机收到多个<code>DHCP</code>提供报文后，<strong>尝试</strong>选择一个<code>IP</code>地址作为自己的<code>IP</code>地址，并<strong>广播</strong>发送<strong><code>DHCP</code>请求报文</strong>，并仍使用<code>0.0.0.0</code>作为本机地址
<ul>
<li>使用<code>0.0.0.0</code>作为源地址的原因：需要得到<code>DHCP</code>的认可后才能正式租用该<code>IP</code>地址</li>
<li>使用<code>255.255.255.255</code>作为目的地址的原因：因为可能有多个<code>DHCP</code>服务器，广播是为了让其它未被选择的<code>DHCP</code>主机也接收到租用请求报文，更新它们的可用<code>IP</code>表</li>
</ul></li>
<li>响应报文：只有被选中的<code>DHCP</code>主机会用<strong>广播</strong>形式发送<strong><code>DHCP</code>响应报文</strong>，交互完毕后，新主机就可以使用租用的<code>IP</code>地址了；在租用期结束前，新主机可能再次发送请求报文进行续租
仍用广播，是因为新主机还没有正式租用<code>IP</code>地址</li>
</ul>
<h3 id="nat"><code>NAT</code></h3>
<ul>
<li><code>NAT</code>全称<code>Network Address Translation</code>，即<strong>网络地址转换</strong>
用于<strong>搭建专用网络</strong>，专用网络内的所有主机的<code>IP</code>地址对外界都不可见，仅有一个<code>NAT</code>路由器有合法的<code>IP</code>地址
可以节省网络号，但<code>NAT</code>是基于<code>TCP</code>或<code>UDP</code>端口号实现的，在面对不经过传输层的通信要求时需要额外配置</li>
<li>对于专用网络内部，一切通信都是正常的，当需要和外部通信时，<code>NAT</code>路由将所有<code>IP</code>分组的源<code>IP</code>地址改为<code>NAT</code>路由的<code>IP</code>地址，并将里面的端口号改为一个由<code>NAT</code>路由服务器新分配的端口号
同时通过<code>NAT</code>转发表，维护从<strong><code>NAT</code>路由端口号</strong>到<strong>内部主机<code>IP</code>及原端口号</strong>的映射
最后在接收来自外部的报文时，将目的<code>IP</code>地址和目的端口号再映射回去</li>
</ul>
<h3 id="icmp"><code>ICMP</code></h3>
<ul>
<li><code>ICMP</code>全称<code>Internet Control Message Protocol</code>，即<strong>因特网控制报文协议</strong>，通常用于差错报告</li>
<li><code>ping</code>就是用<code>ICMP</code>实现的，通过发送类型<code>8</code>编码<code>0</code>的回显请求到目的主机，目的主机发送类型<code>0</code>编码<code>0</code>的回显回答来实现</li>
<li><code>Traceroute</code>也是通过<code>ICMP</code>实现的，源主机通过逐渐增大<code>UDP</code>分组的<code>TTL</code>来发现到某个目的主机之间的所有路由，路由收到<code>TTL</code>恰好降为<code>0</code>的分组时，报告一个类型<code>11</code>编码<code>0</code>的<code>TTL</code>过期报文，主机就可以知道到这个路由的时延、包括该路由的<code>IP</code>地址
当<code>TTL</code>足够大以至于到达目的主机时，<code>Traceroute</code>刻意将<code>UDP</code>分组的端口号设置为不可达端口号，因此目的主机会报告一个表示目的端口不可达的<code>ICMP</code>报文，当源主机收到该报文时，就知道不用再发送<code>UDP</code>探测报文了</li>
</ul>
<h3 id="arp和rarp"><code>ARP</code>和<code>RARP</code></h3>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>IPv4</tag>
        <tag>NAT</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络: 传输层协议</title>
    <url>/blogs/2025/05/01/comp-networking-trsflayer/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="传输层协议">传输层协议</h2>
<h3 id="可靠数据传输的组成">可靠数据传输的组成</h3>
<ul>
<li><p>处理比特差错：比特差错指，分组能运输到主机，但具有比特位丢失或错误；又分为非响应分组错误和响应分组错误</p>
<ul>
<li>通过<strong>重传分组</strong>解决，又因为重传会导致<strong>分组冗余</strong>，故需要给分组添加<strong>编号</strong></li>
<li>完备的解决方案：
发送方：发送分组后进入阻塞态，若收到有错误的响应报文，则重传；否则完成委托，等待下一个来自应用层的调用
接收方：有比特差错或无比特差错但序号错，则响应上一个序号的报文，并丢弃当前收到的报文；否则响应当前序号的报文，并增加确认序号</li>
</ul></li>
<li><p>处理丢包：通过<strong>超时重传</strong>解决，超时即一段时间内未收到正确的响应报文，若超时则响应上一个序号的报文；在此处，发送方接收到有错响应报文时，不立刻重传，而是超时再重传
丢包大概率因为中间路由缓存满而丢弃分组，小概率因为链路中断</p></li>
<li><p>上述是一次只传输一个分组的情况，称为<strong>停等协议</strong>(发送方在收到响应前进入阻塞)；为了效率，需要实现流水线传输，有以下方案：</p>
<ul>
<li><p>回退<code>N</code>步(<code>GBN</code>)协议：只要一切正常，效率就可以大幅提高
发送方：维护基序号<code>b</code>，发送方可以<strong>一次性发送序号为<code>[b,b+N]</code></strong>内的分组，直到<strong>收到<code>ACK_b</code></strong>，才将<code>b</code>右移，并将新的窗口中未发送的分组发送；否则，一旦<strong>超时，就将窗口内的分组全部重传</strong>
接收方：接收窗口长度只为<code>1</code>，即接收方<strong>只接收序号为<code>b</code>的分组</strong>，响应策略和停等协议一致(分组出错时响应<code>ACK_b-1</code>)
即，<strong><code>GBN</code>协议是发送方可以发送多个分组的停等协议</strong>，当<code>N=1</code>时退化为停等协议，其始终等待<code>b</code>号响应报文的策略使其具有自然有序、且每一时刻序号小于<code>b</code>的报文均已可靠传输的性质</p></li>
<li><p>选择重传(<code>SR</code>)协议：上述接收方的策略可以优化，接收方可以选择<strong>缓存</strong>并自行排序而非丢弃序号错误的分组，相当于将接收方窗口长度拉长，使接收方可以确认所有正确的报文(无论其序号是多少)
对于发送方的好处是，发送方下次<strong>超时重传时就不需要重传已经确认的分组</strong>，而不是像<code>GBN</code>那样全部重传，发送方的具体策略为：</p>
<ul>
<li>一开始全部发送后，对<strong>每个分组都设置定时器</strong>，一次超时事件<strong>只会重传一个分组</strong>(“选择重传”的来历)</li>
<li>接收到的<code>ACK</code>确认号不是<code>b</code>(一定会落在窗口内)，则进行标记</li>
<li>接收到的<code>ACK</code>确认号是<code>b</code>，则移动<code>b</code>到下一个没被标记的分组，发送新窗口的未被标记分组</li>
</ul>
<p>接收方的具体策略为：</p>
<ul>
<li>收到序号不为<code>b</code>的报文：缓存，响应<code>ACK_b</code></li>
<li>收到序号为<code>b</code>的报文：立刻交付它以及窗口内所有已缓存的报文，移动窗口到下一个没有收到过的序号</li>
</ul>
<p>基于序号有限的现实问题，<strong>发送方窗口<span
class="math inline">=</span>接收方窗口<span
class="math inline">≤</span>序号数量的一半</strong>，因为响应报文完整/丢失可能导致同步问题：如果接收方窗口长度超过序号数量的一半，那么在一次完美的传输后，<strong>接收方</strong>窗口会<strong>第二次使用相同的序号</strong>，此时若响应报文完整，则发送方会第二次使用相同的序号，此次分组实际是新分组；若<strong>响应报文丢失，则发送方会重传</strong>，此次分组<strong>实际是已确认分组</strong>，但接收方会<strong>误以为是新分组</strong>(因为序号相同)
长度不超过序号数量的一半就不会有这样的问题</p></li>
</ul></li>
</ul>
<h3 id="tcp性质及功能"><code>TCP</code>性质及功能</h3>
<ul>
<li>全双工协议，即双方都可作为发送方或接收方</li>
<li>面向连接的协议，即双方真正传输数据前需要建立连接、后需要关闭连接</li>
<li>支持百分百的可靠数据传输，同时有一定的拥塞控制、流量控制、检错功能</li>
<li>通过端口号来标识进程，为了支持全双工，双方都需要提供<code>IP</code>和端口号</li>
<li>协商<code>MSS</code>(<code>MSS=MTU+IP头部长+TCP头部长</code>，即<code>MSS</code>本身不包含<code>TCP</code>头部)，以避免<code>IP</code>分组
<ul>
<li>主机是边缘设备，在传输层<strong>控制一个<code>TCP</code>分组的长度</strong>可以<strong>避免在发送方被网络层分组</strong>，有效降低网络负载(因为<strong>网络层分组/重组</strong>并保证完整传输相比不分组，<strong>需要更多开销</strong>)</li>
<li>现代路径发现<code>MSS</code>：为了防止在中途路由被分组，现代设备可以动态发现整个路径所有网段中的最小<code>MTU</code>而不仅仅是本地网段的<code>MTU</code>，进一步避免被网络层分组</li>
</ul></li>
</ul>
<h3 id="tcp协议报文"><code>TCP</code>协议报文</h3>
<ul>
<li>第一行字段：源端口号、目的端口号
<ul>
<li>每个<strong>端口号共<code>16</code>位</strong>，端口号分为<strong>周知端口号(<code>0~1023</code>)</strong>和非周知端口号(<code>1024~65535</code>)</li>
<li>周知端口号是给服务器使用的，这样客户端就可以默认向使用该端口号作为目的端口号</li>
<li>常见的周知端口号：<code>HTTP~80、FTP传输数据~20、FTP传输控制信息~21、Telnet~23、DNS~53</code></li>
</ul></li>
<li>第二行字段：<code>32</code>位序号，表示本报文所承载数据段的<strong>首字节编号</strong></li>
<li>第三行字段：<code>32</code>位确认号，表示本报文所希望的下一个数据段的首字节编号
小于确认号的序号的报文均已被接收方完整接收</li>
<li>第四行字段：
<ul>
<li><code>4</code>位首部长度：标记首部的字节数，<strong>单位为<code>4</code>个字节</strong></li>
<li>标记位：<code>URG、ACK、PSH、RST、SYN、FIN</code></li>
<li><code>16</code>位接收窗口：用于<strong>流量控制</strong>，流量控制用于解决发送方<strong>发送速率</strong>和接收方<strong>接收速率</strong>不匹配问题
<strong>触发流量控制的事件不是超时</strong>，超时是触发拥塞控制的事件，而流量控制依赖于响应报文的接收窗口，当接收窗口为<code>0</code>时，表示接收方已经无法再接收，发送方随即停止发送，并试探性地发送一个没有数据的报文直到响应报文的接收窗口不为<code>0</code></li>
</ul></li>
</ul>
<h3 id="tcp连接过程"><code>TCP</code>连接过程</h3>
<ul>
<li>假设发送方为<code>A</code>、接收方为<code>B</code>，发送方、接收方期望发送的第一个字节编号分别为<code>a、b</code>
那么三次握手过程为：
<ul>
<li>发送方发送报文，其中<code>ACK=0、SYN=1、序列号=a-1</code></li>
<li>接收方发送报文，其中<code>ACK=1、SYN=1、序列号=b-1、确认号=a</code></li>
<li>发送方发送报文，其中<code>ACK=1、SYN=0、序列号=a、确认号=b</code>
这里因为接收方不再发送响应报文，所以发送方下次发送的报文序号仍为<code>a</code></li>
</ul></li>
<li>四次挥手过程为：
<ul>
<li>主动结束方发送报文，其中<code>FIN=1、ACK=1、序列号=x(上次接收的确认号)、确认号=y(上次接收的序列号+字节数)</code>
此后主动结束方不会再发送数据报文，但仍能接收数据报文</li>
<li>被动结束方发送响应报文，其中<code>FIN=0、ACK=1、序列号=y、确认号=x+1</code></li>
<li>被动结束方发送结束报文，其中<code>FIN=1、ACK=1、序列号=z(被动结束方上次接收报文的确认号)、确认号=x+1</code></li>
<li>主动结束方发送响应报文，其中<code>FIN=0、ACK=1、序列号=x+1、确认号=z+1</code>
防止响应报文丢失，主动结束方最后会进入<code>TIME_WAIT</code>，如果响应报文丢失，被动结束方会超时重传，主动结束方则在<code>TIME_WAIT</code>内受理该重传的<code>FIN</code>报文
注意，这个<code>TIME_WAIT</code>和超时重传是两回事</li>
</ul></li>
</ul>
<h3 id="tcp的附加功能"><code>TCP</code>的附加功能</h3>
<ul>
<li><p>流量控制：不再赘述</p></li>
<li><p>基于序号和确认号在同一份报文内的机制，通常不单独发送响应报文，而是在要发送的数据中<strong>捎带</strong>上确认信息</p></li>
<li><p>期望<code>RTT</code>(往返时间)：通过对最近<code>RTT</code>采样，并加权重(越近的样本权重越大)计算期望<code>RTT</code>
方差<code>RTT</code>：测量期望<code>RTT</code>的变化
重传计时器的时间通常设为：期望<code>RTT</code>+<code>4</code>方差<code>RTT</code>
在超时事件未发生时，<code>TCP</code>通过它来指导计时器的时间</p></li>
<li><p>快速重传：每次丢包都等超时后再重传效率过低，因为丢包后，有概率能接收到冗余<code>ACK</code>报文(确认号相同的报文)，发送方可以将这个事件视为丢包的暗示，进行快速重传</p></li>
<li><p>拥塞起因：发送方的<strong>发送速率</strong>和中间路由<strong>转发速率</strong>不匹配导致数据分组冗余
拥塞控制：当丢包事件(<strong>超时</strong>或接收到若干个<strong>冗余<code>ACK</code></strong>报文，被认为是丢包)发生时，触发拥塞控制机制，其中超时事件相比冗余<code>ACK</code>事件，更能说明链路拥塞(因为冗余<code>ACK</code>起码能接收到，丢包可能是因为物理链路出问题)
<code>TCP</code>通过<strong>慢启动</strong>来控制发送速率：</p>
<ul>
<li>慢启动状态：初始发送窗口为一个<code>MSS</code>，但以指数增长
超时事件发生时，重新进入慢启动状态，将触发超时时候的<strong>发送窗口大小的一半</strong>设置为<strong>慢启动阈值</strong>
冗余<code>ACK</code>事件发生时，执行快速重传，进入快速恢复状态
指数增长到慢启动阈值(从未发生过超时时，为无穷大)时，进入拥塞避免状态</li>
<li>拥塞避免状态：谨慎地增加发送窗口长度，可能是线性地增加
超时事件发生时，进入慢启动状态，并更新慢启动阈值
冗余<code>ACK</code>事件发生时，需要作出反应但不应过于剧烈，因此将<strong>发送窗口减半</strong>而非重置(通常因为有<code>k</code>个冗余<code>ACK</code>，说明中间链路起码还有转发<code>k</code>个分组的能力，所以还要在减半后加上<code>k</code>个<code>MSS</code>)，并进入快速恢复状态</li>
<li>快速恢复状态：快速重传后，仍可能收到冗余<code>ACK</code>，每接收一个冗余<code>ACK</code>，相应地增加一个<code>MSS</code>
超时事件发生时，同上
当接收到新的<code>ACK</code>而不是冗余<code>ACK</code>时，将发送窗口置为慢启动阈值，进入拥塞避免状态</li>
</ul>
<p>因此，进入慢启动状态一定是因为超时发生，且初始为<code>1</code>个<code>MSS</code>
进入拥塞避免状态是因为在慢启动时超过了慢启动阈值、或在快速恢复时收到新<code>ACK</code>，<strong>初始为慢启动阈值</strong>
进入快速恢复状态一定是因为收到冗余<code>ACK</code>，处于快速恢复状态的时间较短</p></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>树的算法: 寻找树的重心</title>
    <url>/blogs/2025/04/30/algo-tree-gravity/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="概述">概述</h3>
<ul>
<li>针对于无根树(所有结点均可作为根结点且对答案没有影响)，以树的重心为根结点能在分治思想中减少递归层次
其定义为：删除树的重心后，剩下的若干个<strong>连通分支各自的结点数不超过总结点数的一半</strong>
为表述方便，下称树的结点数<span
class="math inline">→</span>树的大小、向上/向下表示以一个确定的结点为根结点的情况下形成的有向树的方向、一个结点的子树<span
class="math inline">→</span>以该结点为根结点的有向树中，该结点的子树</li>
<li>树的重心的性质有：
<ul>
<li>树的重心有<span
class="math inline">1 ∼ 2</span>个，若有两个重心则它们相邻</li>
<li>在无权树中，所有点到某点的距离和中，到树的重心的距离和是最小的(若有两个重心则到它们的距离和相等)</li>
<li>合并两棵无根树，则新树的重心在两棵旧树重心之间的路径上
直接连接两个原有重心(而不是其它结点)能够最快速度找到新树的重心(两个原有重心之一、或两个都是)</li>
<li>若上述两棵无根树中的一棵为平凡树，则新树重心不仅在旧树重心和该平凡树之间的路径上，而且离旧树重心最多一条边</li>
</ul></li>
</ul>
<h3 id="算法结构">算法结构</h3>
<ul>
<li><p>考虑以任意结点为根结点(转化为有根树)，要求树中某个分支结点的子树大小，其向下子树大小只需要<strong>深搜</strong>即可
而其向上子树(只有一个、不包括该结点)大小为<strong>总结点数减去其向下子树(包括该结点)大小</strong>
因此对于所有结点，均可用这种方法求出其子树大小，然后根据定义(记录子树的最大值)求重心(<strong>所有结点子树大小最大值中最小的那个不超过总结点数的一半</strong>)即可</p></li>
<li><p>时间复杂度<span
class="math inline"><em>O</em>(<em>n</em>)</span></p>
<p>```c++ // 随意选择初始结点作为根结点, 这里选择结点1 //
采用链式前向星存树(且为了方便、边的next为0时表示空) int i, size[VN],
w[VN], g[2]; // 分别表示 向下子树大小、所有子树大小的最大值、重心编号
void getCenter(int pos, int fa) { // 表示当前遍历的结点、当前结点的爹 //
该函数只会访问每个结点一次, 初始时设置当前结点的大小为1(后续更新),
表示包括其本身 size[pos] = 1; w[pos] = 0; //
当前没有计算出任何子树的大小, 最大值自然为0 for (i = head[pos]; i; i =
edge[i].next) { if (edge[i].to != fa) { // 不计算向上子树
getCenter(edge[i].to, pos); // 深搜计算出size[edge[i].to] size[pos] +=
size[edge[i].to]; w[pos] = max(w[pos], size[edge[i].to]); //
向下子树的最大值 } } w[pos] = max(w[pos], VN - size[pos]); //
再和向上子树大小比 if (w[pos] &lt;= (VN &gt;&gt; 1)) { g[g[0] != 0] =
pos; // 记录该重心 } }</p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Tree Algo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>树的算法: LCA（最近公共祖先）</title>
    <url>/blogs/2025/04/30/algo-tree-lca/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="lca算法"><code>LCA</code>算法</h2>
<h3 id="lca性质"><code>LCA()</code>性质</h3>
<ul>
<li><code>LCA(Lowest Common Ancestor)</code>，即最小公共祖先，<span
class="math inline"><em>L</em><em>C</em><em>A</em>()</span>接受一个结点集合，返回集合中所有结点的最小公共祖先结点</li>
<li><span
class="math inline"><em>L</em><em>C</em><em>A</em>({<em>u</em>}) = <em>u</em></span>，即任意结点的<code>LCA</code>是自身</li>
<li><span
class="math inline"><em>L</em><em>C</em><em>A</em>({<em>u</em>,<em>v</em>}) = <em>u</em> ⇔ <em>u</em><em>是</em><em>v</em><em>的</em><em>祖</em><em>先</em></span></li>
<li><span
class="math inline"><em>L</em><em>C</em><em>A</em>(<em>S</em><sub>1</sub>∪<em>S</em><sub>2</sub>) = <em>L</em><em>C</em><em>A</em>({ <em>L</em><em>C</em><em>A</em>(<em>S</em><sub>1</sub>), <em>L</em><em>C</em><em>A</em>(<em>S</em><sub>2</sub>) })</span></li>
<li>给定结点集合<span
class="math inline"><em>S</em> ⊆ <em>V</em></span>，则<span
class="math inline"><em>L</em><em>C</em><em>A</em>(<em>S</em>)</span>在前序遍历中位于集合中所有结点之前，在后序遍历中位于所有结点之后</li>
<li><span
class="math inline"><em>L</em><em>C</em><em>A</em>(<em>u</em>,<em>v</em>)</span>必然在<span
class="math inline"><em>u</em>, <em>v</em></span>最短路上，且<span
class="math inline"><em>d</em>(<em>u</em>,<em>v</em>) = <em>h</em>(<em>u</em>) + <em>h</em>(<em>v</em>) − 2<em>h</em>(<em>L</em><em>C</em><em>A</em>({<em>u</em>,<em>v</em>}))</span>(无权树)，有权树只需额外添加权重即可</li>
</ul>
<h3 id="朴素算法">朴素算法</h3>
<p>很容易想到，当两结点处于同一深度时，若两结点相同，则该结点为所求</p>
<p>否则，目标结点为<span
class="math inline"><em>L</em><em>C</em><em>A</em>(<em>直</em><em>接</em><em>祖</em><em>宗</em><em>结</em><em>点</em>)</span></p>
<p>由此，需要先进行预处理，使两结点达到同一深度，即让深度较大的结点上移(经过的结点不可能是所求)</p>
<p>这样的算法要求结点结构能够访问父结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> h, fa;</span><br><span class="line">&#125;;</span><br><span class="line">node tree[LEN]; <span class="comment">// 以 下标 为结点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> uh = tree[u].h, vh = tree[v].h; <span class="comment">// 存储两结点的深度方便最短路计算</span></span><br><span class="line"> <span class="keyword">if</span> (uh &lt; vh) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tree[u].h &gt; tree[v].h) &#123;</span><br><span class="line">        u = tree[u].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">        u = tree[u].fa;</span><br><span class="line">        v = tree[v].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// uh + vh - 2 * tree[u].h   即为无权树两点间最短路</span></span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：单次查询时，时间为<span
class="math inline"><em>O</em>(<em>n</em>)</span></p>
<h3 id="倍增算法">倍增算法</h3>
<p>不难发现对于共同祖先这个性质，<span
class="math inline"><em>L</em><em>C</em><em>A</em>({<em>u</em>,<em>v</em>})</span>的祖先一定是<span
class="math inline"><em>u</em>, <em>v</em></span>的共同祖先，它的孩子一定不是<span
class="math inline"><em>u</em>, <em>v</em></span>的共同祖先；回顾二分思想，若通过一个性质能对可能解集划分为两部分连续的区间，就能二分搜索出最优/最大/最小的具有该性质的解</p>
<p>倍增算法就是二分思想优化的朴素算法，在朴素算法中，只能一级一级跳，单次查询时间为<span
class="math inline"><em>O</em>(<em>n</em>)</span></p>
<p>而倍增算法通过给每个结点多分配<span
class="math inline"><em>O</em>(log<em>h</em>)</span>空间来存储比它高<span
class="math inline">2<sup><em>j</em></sup></span>处的祖先结点，达到倍增跳跃的效果</p>
<p>类比朴素算法，分为两步：</p>
<ul>
<li>两结点先达到同一深度：先算出深度差，根据其二进制码决定在何时跳、跳多远</li>
<li>两结点共同跳跃，根据解的二分性质，取起始点为<span
class="math inline">$\begin{cases}left=0\\right=h(u)\\mid=(left+right)&gt;&gt;1\end{cases}$</span></li>
</ul>
<p>重申倍增算法和朴素算法的区别：</p>
<ul>
<li>预处理时，每个结点额外消耗<span
class="math inline"><em>O</em>(log<em>h</em>)</span>的时间和空间</li>
<li>查询目标方式使用二分查找，时间复杂度为<span
class="math inline"><em>O</em>(log<em>n</em>)</span></li>
<li>为了能快速到达目标，使用倍增祖先数组，使每次查询距离深度<span
class="math inline"><em>h</em></span>的祖先的时间复杂度为<span
class="math inline"><em>O</em>(log<em>h</em>)</span></li>
<li>因此整个算法的预处理时间复杂度<span
class="math inline"><em>O</em>(<em>n</em>log<em>n</em>)</span>，单次查询<span
class="math inline"><em>O</em>(log<em>n</em>)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, n, m, s, son, fa, f[<span class="number">500001</span>][<span class="number">18</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> h, cnt, next[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line">node tree[<span class="number">500001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    tree[s].h = <span class="number">1</span>;</span><br><span class="line">    stk.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        i = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (j = tree[i].cnt - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(tree[i].next[j]);</span><br><span class="line">            f[tree[i].next[j]][<span class="number">0</span>] = i;</span><br><span class="line">            tree[tree[i].next[j]].h = tree[i].h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = son = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (son &lt; tree[i].h) &#123;</span><br><span class="line">            f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            ++j;</span><br><span class="line">            son &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jmp</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            u = f[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        h &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[u].h &lt; tree[v].h) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    u = <span class="built_in">jmp</span>(u, tree[u].h - tree[v].h);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = tree[u].h, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">jmp</span>(u, mid) == <span class="built_in">jmp</span>(v, mid)) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right = <span class="built_in">jmp</span>(u, left);</span><br><span class="line">    left = <span class="built_in">jmp</span>(v, left);</span><br><span class="line">    <span class="keyword">return</span> left == right ? left : f[left][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; son &gt;&gt; fa;</span><br><span class="line">        tree[fa].next[tree[fa].cnt++] = son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; son &gt;&gt; fa;</span><br><span class="line">        ans.<span class="built_in">push</span>(<span class="built_in">lca</span>(son, fa));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ans.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        ans.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Tree Algo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串算法: 马拉车（manacher）回文串统计</title>
    <url>/blogs/2025/04/26/algo-string-manacher/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> d[<span class="number">11000010</span> &lt;&lt; <span class="number">1</span>], l = <span class="number">0</span>, r = <span class="number">-1</span>, i, ans, n;</span><br><span class="line">string t;</span><br><span class="line"><span class="type">char</span> s[<span class="number">11000010</span> &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        s[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = t[i];</span><br><span class="line">        s[(i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = (i &lt;&lt; <span class="number">1</span>) + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">            d[i] = <span class="built_in">min</span>(d[l + r - i], r - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i - d[i] &gt;= <span class="number">0</span> &amp;&amp; i + d[i] &lt; n &amp;&amp; s[i - d[i]] == s[i + d[i]]) &#123;</span><br><span class="line">            ++d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + d[i] &gt; r) &#123;</span><br><span class="line">            l = i - d[i];</span><br><span class="line">            r = i + d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>String Algo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>string</tag>
        <tag>palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>数论: 质数筛法</title>
    <url>/blogs/2025/04/22/algo-prime-selection/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="埃氏筛法">埃氏筛法</h3>
<ul>
<li><p>埃氏筛法，全名埃拉托斯特尼筛法
若一个数是素数，那么必然不可能存在有除<code>1</code>和它自身的因子，也就是比它小的数(除了<code>1</code>)都无法整除它
那么，从小到大遍历除<code>1</code>外的正整数，将所有素因子的倍数都标记上，如果遍历到一个数<code>i</code>，它没有被标记，那么它就是素数；初始时，<code>notprime[2]=false</code>(即<code>2</code>是素数)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> notprime[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notprime[i]) &#123; <span class="comment">// 说明它是素数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; i * j &lt;= MAXN; ++j) &#123;</span><br><span class="line">                notprime[i * j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简单地写出时间表达式：<span
class="math inline">$\begin{align}\left\lfloor\frac{N}{2}\right\rfloor+\left\lfloor\frac{N}{3}\right\rfloor+\left\lfloor\frac{N}{5}\right\rfloor+\cdots+\left\lfloor\frac{N}{p}\right\rfloor\end{align}$</span>，<span
class="math inline"><em>p</em></span>为小于或等于<code>MAXN</code>的最大质数，证明过程是很难的，只需要知道埃氏筛法的时间复杂度为<span
class="math inline"><em>O</em>(<em>n</em>log(log(<em>n</em>)))</span>即可
也就是说，在<span
class="math inline">10<sup>6</sup></span>数量级内，且需要快速判断一个大范围内的素数时，埃氏筛法是有效的</p></li>
</ul>
<h3 id="欧拉筛法">欧拉筛法</h3>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>数论: 扩展欧拉定理</title>
    <url>/blogs/2025/04/20/algo-math-ext-euler-theorem/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="扩展欧拉定理">扩展欧拉定理</h3>
<ul>
<li><p>扩展欧拉定理通常<strong>用于快速模幂中的降幂</strong>，其内容为：<span
class="math inline">$a^b\equiv\begin{cases}a^{b\ {\rm mod}\
\varphi(m)},&amp;\gcd(a,m)=1\\a^{(b{\rm \ mod}\
\varphi(m))+\varphi(m)},&amp;\gcd(a,m)\ne1,b\ge\varphi(m)\\a^b,&amp;\gcd(a,m)\ne1,b&lt;\varphi(m)\end{cases}\
\ \ \ ({\rm mod}\ m)$</span></p>
<p>即，若底数和模数互素，可将幂<span
class="math inline"><em>b</em></span>降为<span
class="math inline"><em>φ</em>(<em>m</em>)</span>
否则，若指数比模数大，可将幂<span
class="math inline"><em>b</em></span>降为<span
class="math inline">(<em>b</em> mod  <em>φ</em>(<em>m</em>)) + <em>φ</em>(<em>m</em>)</span>
很简单可以得到，如果<strong>模数为质数</strong>，则<span
class="math inline"><em>φ</em>(<em>m</em>) = <em>m</em> − 1</span>，则<span
class="math inline">$a^b\equiv a^{b{\rm\ mod}\ (m-1)}\ ({\rm mod}\
m)$</span> 实际上，当<span
class="math inline">gcd (<em>a</em>,<em>m</em>) = 1</span>时，第二项仍成立，这里的意思是优先考虑第一项、如果不互素才考虑第二项；其实可以把<span
class="math inline">gcd ()</span>限制去掉直接记第二项 即<span
class="math inline">$\begin{align}&amp;a^b\equiv\begin{cases}a^{(b\ {\rm
mod}\
\varphi(m))+\varphi(m)},&amp;b\ge\varphi(m)\\a^b,&amp;b&lt;\varphi(m)\end{cases}\end{align}$</span></p></li>
<li><p>证明：</p>
<ul>
<li><p>第一项是容易得出的，由欧拉定理，若<span
class="math inline">gcd (<em>a</em>,<em>m</em>) = 1</span>，则<span
class="math inline">$a^{\varphi(m)}\equiv1\ ({\rm mod}\ m)$</span>
那么<span class="math inline">$a^b\equiv a^{n\varphi(m)+(b\ {\rm mod}\
\varphi(m))}\equiv1^n·a^{b\ {\rm mod}\ \varphi(m)}\ \ ({\rm mod}\
m)$</span></p></li>
<li><p>第二项：因为<span
class="math inline">gcd (<em>a</em>,<em>m</em>) ≠ 1</span>，将<span
class="math inline"><em>a</em></span>拆解为多个质因数的幂的乘积形式，即<span
class="math inline">$\begin{align}a=\prod_{p_i为素数\wedge p_i|a}
p_i^{r_i}\Rightarrow a^b=\prod_{p_i为素数\wedge p_i|a}
p_i^{b·r_i}\end{align}$</span> 对每一个质因子<span
class="math inline"><em>p</em><sub><em>i</em></sub></span>：</p>
<ul>
<li><p>如果<span
class="math inline">gcd (<em>p</em><sub><em>i</em></sub>,<em>m</em>) = 1</span>，则由欧拉定理得<span
class="math inline">$p_i^{\varphi(m)}\equiv1\ ({\rm mod}\ m)\Rightarrow
p_i^{b}\equiv p_i^{b\ {\rm mod}\ \varphi(m)}\ ({\rm mod}\
m)$</span></p></li>
<li><p>否则，将<span class="math inline"><em>m</em></span>写成<span
class="math inline"><em>p</em><sub><em>i</em></sub></span>因子和非<span
class="math inline"><em>p</em><sub><em>i</em></sub></span>因子的两部分<span
class="math inline"><em>m</em> = <em>s</em> · <em>p</em><sub><em>i</em></sub><sup><em>k</em></sup></span>，其中<span
class="math inline"><em>k</em> &gt; 0</span> 由于<span
class="math inline"><em>s</em></span>不是<span
class="math inline"><em>p</em><sub><em>i</em></sub></span>的幂，即<span
class="math inline">gcd (<em>s</em>,<em>p</em><sub><em>i</em></sub>) = gcd (<em>s</em>,<em>p</em><sub><em>i</em></sub><sup><em>k</em></sup>) = 1</span>，再次用欧拉定理和欧拉函数的性质得<span
class="math inline">$p_i^{\varphi(s)}\equiv1\ ({\rm mod}\
s)、\varphi(m)=\varphi(s·p_i^k)=\varphi(s)\varphi(p_i^k)$</span></p>
<p>因此<span class="math inline">$p_i^{\varphi(m)}\equiv
p_i^{\varphi(s)\varphi(p_i^k)}\equiv1^{\varphi(p_i^k)}\ ({\rm mod}\
s)$</span> 两边同乘<span
class="math inline"><em>p</em><sub><em>i</em></sub><sup><em>k</em></sup></span>，得<span
class="math inline">$p_i^{\varphi(m)+k}\equiv p_i^k\ ({\rm mod}\
m)$</span> 因此<span class="math inline">$p_i^b\equiv p_i^{b-k+k}\equiv
p_i^{b-k+k+\varphi(m)}\equiv p_i^{b+\varphi(m)}\ ({\rm mod}\
m)$</span>，其中<span
class="math inline"><em>b</em> ≥ <em>φ</em>(<em>m</em>)</span>
于是可以对<span class="math inline"><em>b</em></span>进行变换，得<span
class="math inline">$p_i^{b-\varphi(m)}\equiv p_i^{b}\ ({\rm mod}\
m)$</span>，其中<span
class="math inline"><em>b</em> − <em>φ</em>(<em>m</em>) ≥ <em>φ</em>(<em>m</em>)</span>，即<span
class="math inline"><em>b</em> ≥ 2<em>φ</em>(<em>m</em>)</span>
即只有当<span
class="math inline"><em>b</em> ≥ 2<em>φ</em>(<em>m</em>)</span>时，可以降幂；于是幂的最小值范围为<span
class="math inline">[<em>φ</em>(<em>m</em>), 2<em>φ</em>(<em>m</em>))</span>
即降幂的最小值为<span class="math inline">$(b\ {\rm mod}\
\varphi(m))+\varphi(m)$</span></p></li>
</ul>
<p>结合两种情况(第一种情况可以变成第二种情况的形式)，对<span
class="math inline"><em>a</em></span>的任意质因子<span
class="math inline"><em>p</em><sub><em>i</em></sub></span>，有<span
class="math inline">$p_i^b\equiv p_i^{(b\ {\rm mod}\
\varphi(m))+\varphi(m)}\ ({\rm mod}\ m)$</span>，即<span
class="math inline">$p_i^{br_i}\equiv p_i^{((b\ {\rm mod}\
\varphi(m))+\varphi(m))r_i}\ ({\rm mod}\ m)$</span> 即<span
class="math inline">$a^b\equiv a^{(b\ {\rm mod}\
\varphi(m))+\varphi(m)}\ ({\rm mod}\ m)$</span>，原式得证</p></li>
<li><p>第三项：既然<span
class="math inline"><em>b</em> &lt; <em>φ</em>(<em>m</em>)</span>了，自然不能降幂了</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络: 应用层协议</title>
    <url>/blogs/2025/04/20/comp-networking-applayer/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="应用层体系结构">应用层体系结构</h3>
<ul>
<li>应用层处于最高层，享受下层提供的可靠稳定传输服务，应用层只需要关心数据的内容，而不需要关心数据如何传输、数据的大小等等(当然开发者需要选择合适的传输层协议进行传输，这里的“不需要关心”指的是下层的具体实现)</li>
<li>应用层体系结构分为<strong>客户端-服务器</strong>体系结构和<strong><code>P2P</code></strong>(对等)结构
前者为仅客户端发送请求、服务器进行响应，是集中服务的，将资源集中在服务器端能高效地服务、维护应用程序
后者为非集中的结构，双方均为用户主机，自扩展性较强</li>
<li>应用层协议间的通信是一个主机某进程到另一个主机某进程的，因此网络层提供了<code>IP</code>地址来标记主机、传输层提供了端口号属性来标记进程</li>
<li>应用层协议定义了数据的实际意义，例如：
<ul>
<li>标记数据来自请求方还是响应方，传输层<code>TCP</code>报文中的序号、确认号看上去也许和它有些类似，但实际上是完全不同的；主机可以通过判断报文是请求或是响应来作出不同的反应，而传输层的这些属性是用于判断进行接收方还是发送方的行为</li>
<li>包含各种语义的字段，这些字段组合并根据规则实现具体的某个应用功能，这些规则的集合便称作“协议”</li>
</ul></li>
</ul>
<h3 id="http"><code>HTTP</code></h3>
<ul>
<li><code>HTTP</code>(<code>HyperText Transfer Protocol</code>，超文本传输协议)是<strong>用于传输网页(<code>Web page</code>)</strong>的应用层协议
网页本身是由<code>HTML</code>文件作为框架(这个框架定义了其中文本的属性，是文本的文本，因此称为超文本)，其中嵌入各种类型的文件资源组成的
而<code>HTTP</code>则定义了网页的编码方式等</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL: 基本用法</title>
    <url>/blogs/2025/04/20/sql-std/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="sql语法"><code>SQL</code>语法</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<h3 id="域和属性">域和属性</h3>
<ul>
<li>在数据库中，域是具有<strong>相同数据类型</strong>的<strong>有意义</strong>的<strong>值的集合</strong>，属性是<strong>域的实例</strong>
对应于编程语言，可以不严谨地把域看作数据类型，把属性看作变量，把某一行中的某一属性值看作变量的取值</li>
<li>域的组成：
<ul>
<li>相同数据类型：要求一个域必须基于一个<strong>基本数据类型</strong>上作约束</li>
<li>有意义：用户可以自定义约束，限制取值范围，使属性的取值符合现实</li>
</ul></li>
<li>域的第一要求(或者说域的第一范式)：域是<strong>原子性</strong>的，即属性的<strong>每一个取值都不可分割</strong>
例如，如果某一个取值是元组或值列表，那就不符合域的第一范式，因为元组是可分的</li>
</ul>
<h3 id="数值类型">数值类型</h3>
<ul>
<li>整型：各种数据库都支持不同大小的整型类型，如小整型、整型、大整型，但命名不同</li>
<li>定点数：<code>decimal(P, D)</code>或<code>numeric(P, D)</code>
<ul>
<li>在<code>SQL</code>标准中它们有细微差别：<code>numeric</code>会严格保证<strong>运算过程中精度不变</strong>，而<code>decimal</code>在存储时会分配更多空间以便<strong>运算时提高精度</strong>，只在显示时收敛精度；各种数据库对它们的实现和标准也有差别
但在实践中，可以认为没什么差别</li>
<li><code>P</code>表示<strong>总的有效位数</strong></li>
<li><code>D</code><strong>大于<code>0</code></strong>时，表示<strong>小数点后</strong>的有效位数；<strong>小于<code>0</code></strong>时，表示<strong>小数点前</strong>的有效位数；不能等于<code>0</code></li>
</ul></li>
<li>浮点数：比定点数<strong>运算更快</strong>，但会<strong>损失精度</strong>，适用于存储近似值
各种数据库的命名不同</li>
</ul>
<h3 id="字符串类型">字符串类型</h3>
<ul>
<li>各种数据库的字符串类型命名一致</li>
<li><code>char(size)</code>：定长字符串，<strong>存储长度</strong>固定为<code>size</code>的字符串，无论值的长度是多少</li>
<li><code>varchar(size)</code>：可变长字符串，最大存储长度为<code>size</code>，实际存储长度和值的长度相等</li>
<li>字符串<strong>数据</strong>是用<strong>单引号</strong>括起的字符串
<strong>表名、列名、属性名</strong>等<strong>标识符</strong>是用<strong>双引号</strong>括起的字符串(当属性名中存在空格时，需要用<code>""</code>括起)
但应该遵循命名规范：用小写字母、不同单词用下划线连接</li>
</ul>
<h3 id="其它类型">其它类型</h3>
<ul>
<li>文本类型：数据库通过在表外存储大文本，在表内存储对应的指针来实现文本类型，存储效率较低
各种数据库命名不一致</li>
<li>布尔类型：</li>
<li>日期和时间：
<ul>
<li><code>DATE</code>：日期类型</li>
<li><code>TIME</code>：时间类型</li>
<li>日期时间类型：各种数据库命名不同</li>
<li><code>TIMESTAMP</code>：时间戳类型</li>
<li>字面量：为符合规范，尽量使用标准格式的字面量<code>YYYY-MM-DD HH:MM:SS</code>或<strong>显式转换</strong></li>
</ul></li>
</ul>
<h3 id="类型转换">类型转换</h3>
<ul>
<li>隐式类型转换：</li>
<li>显式类型转换：</li>
</ul>
<h3 id="不同数据库的实现">不同数据库的实现</h3>
<p>待查</p>
<h2 id="表达式">表达式</h2>
<h3 id="表达式的本质">表达式的本质</h3>
<ul>
<li><p>表达式就是一个函数，只不过是编程语言通过一些语法糖对表达式进行了简化
<strong>表达式的输入输出都是值</strong>，输入可以是一组值，输出只能是标量值</p></li>
<li><p><strong>原子表达式</strong><a id=expl_atomexpr></a>：指那些不能再分割的表达式，基于原子表达式可以通过运算符、标量值函数组合得到新的表达式</p>
<ul>
<li>字面量</li>
<li>列引用：即某个表中某个属性的名称</li>
</ul></li>
<li><p><strong><code>Sql</code>语句的输入输出都是表</strong>，是多组值，一个表经过表达式，相当于输入一个列向量(每个元素是一组值)，表达式会对该列向量按元素求值，返回一个新的列向量(每个元素是一个标量值)
例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- e 是一个元组</span></span><br><span class="line"><span class="number">1</span>			<span class="comment">-- f(e) = 1			1是一个整型字面量</span></span><br><span class="line">attr		<span class="comment">-- f(e) = e.attr	attr是一个列引用</span></span><br><span class="line">attr <span class="operator">&gt;</span> <span class="number">1</span>	<span class="comment">-- f(e) = boolean(e.attr &gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- f(表) ~ f([e1, e2, ...]) ~ [f(e1), f(e2), ...]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数值表达式及部分函数">数值表达式及部分函数</h3>
<ul>
<li><p>标量值：指单个不可分割的值
绝大多数数据库对返回一个复合类型(如集合等)的支持很有限，这里讨论的大多是<strong>返回标量值的表达式</strong>
所以可以将标量值看作一个数值表达式的返回值</p></li>
<li><p><strong>值列表</strong>：用<code>()</code>括住一系列标量值，表示由这些值组成的<strong>集合</strong></p></li>
<li><p>基本算术运算：<code>+ - * / % ^</code></p></li>
<li><p><code>CASE</code>：对输入值从上到下地进行逻辑判断，若成立则返回指定的标量值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 较灵活的写法</span></span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">	<span class="keyword">WHEN</span> logic_expr1(input) <span class="keyword">THEN</span> value1</span><br><span class="line">	<span class="keyword">WHEN</span> ... <span class="keyword">THEN</span> ...</span><br><span class="line">	<span class="keyword">ELSE</span> default_value		<span class="comment">-- 若不加则为ELSE null</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 较偷懒的写法, 只支持等值比较</span></span><br><span class="line"><span class="keyword">case</span> input</span><br><span class="line">	<span class="keyword">WHEN</span> val1 <span class="keyword">THEN</span> ret_val1</span><br><span class="line">	<span class="keyword">WHEN</span> ... <span class="keyword">THEN</span> ...</span><br><span class="line">	<span class="keyword">ELSE</span> default_value</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>null</code></strong>：空值，表示一种不确定的状态
若参与<strong>运算则一定返回<code>null</code></strong>，参与<strong>一般比较一定会返回<code>false</code></strong>，会<strong>被聚集函数无视</strong>
只能通过<code>is null</code>和<code>is not null</code>判断是否为空</p>
<ul>
<li><a
href="#more_nullfc">空值处理</a><a id='expl_nullfc'></a>：涉及空值的函数</li>
</ul></li>
<li><p><a
href="#more_gfunc">聚集函数值</a><a id='expl_gfunc'></a>：对<strong>多行</strong>进行<strong>聚集</strong>，<strong>返回标量值</strong>
很多函数都只接受一行数据的输入，输出一个标量值
而聚集函数<strong>接受多行数据的输入</strong>，仍输出一个标量值</p></li>
</ul>
<h3 id="逻辑表达式">逻辑表达式</h3>
<ul>
<li>连接逻辑表达式的运算符：<code>and、or、not</code></li>
<li>连接数值表达式的运算符：
<ul>
<li><code>is null</code>和<code>is not null</code>：若左值是/不是空则返回真</li>
<li><code>in</code>和<code>not in</code>，前跟标量值，后跟值列表，若左值属于/不属于该值列表则返回真</li>
<li><code>between left_val and right_val</code>：闭区间比较</li>
</ul></li>
<li>连接数值表达式和子查询语句的函数：
<ul>
<li><code>any()/some()</code></li>
<li><code>all()</code></li>
</ul></li>
</ul>
<h2 id="数据完整性约束">数据完整性约束</h2>
<h3 id="限制不可重复">限制不可重复</h3>
<ul>
<li><p><code>primary key</code>：声明主键，主键能够<strong>唯一标识元组</strong>，天生包括了<strong>非空约束</strong>及<strong>唯一性约束</strong>
为了性能，虽然关系是一个集合，但数据库不会时时刻刻保证没有重复，除非添加了主码约束
添加后，若插入元组中的主键已经存在，将会报错</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时声明 主键</span></span><br><span class="line">(<span class="number">1</span>) <span class="operator">&lt;</span>属性名<span class="operator">&gt;</span> <span class="operator">&lt;</span>属性类型<span class="operator">&gt;</span> <span class="keyword">primary key</span>		这样的主键只有一个属性</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">primary key</span> (attr1, attr2, ...)		允许声明一组属性作为主键</span><br></pre></td></tr></table></figure></li>
<li><p><code>unique</code>：声明唯一性约束，被约束的<strong>属性值的集合</strong>只能存在至多一次
和主键不同，它<strong>允许值为空，且允许有多个记录的该属性的值为空</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时 声明方式与主键类似, 但unique可声明多次, 被约束的属性组可以重叠、甚至重复</span></span><br><span class="line">(<span class="number">1</span>) <span class="operator">&lt;</span>属性名<span class="operator">&gt;</span> <span class="operator">&lt;</span>属性类型<span class="operator">&gt;</span> <span class="keyword">unique</span></span><br><span class="line">(<span class="number">2</span>) <span class="keyword">unique</span> (attr1, attr2, ...)		这时它们会作为一个整体受到唯一性约束</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="限制输入范围">限制输入范围</h3>
<ul>
<li><p><code>not null</code>：声明非空约束，<strong>一个非空约束只能针对一个属性</strong>，即只能用上述的第一种方式声明
字面意义，若没有默认值约束，则插入元组时必须指定该属性的值，且不能为<code>null</code></p></li>
<li><p><code>default(value)</code>：声明默认值约束，一个默认值约束只能针对一个属性，即只能用上述的第一种方式声明
平时就相当于<code>default (null)</code>，指定后将在插入元组且未指定值时填充默认值
声明<code>default</code>约束必须指定默认值<code>value</code></p></li>
<li><p><code>check(logic_expr)</code>：声明检查约束，检查约束必须指定逻辑表达式，插入元组时会检查，若违反约束则会报错
实际上检查约束无论用哪一种方法声明都无所谓，因为是通过表达式来约束属性的
最好是使用第二种方式声明</p></li>
</ul>
<h3 id="外码">外码</h3>
<ul>
<li><p><code>foreign key (&lt;参照属性组&gt;) refereces &lt;被参照表&gt;(&lt;被参照属性组&gt;)</code>：声明外键约束，其中被参照属性组必须是被参照表的主键
声明后，<code>&lt;参照属性组&gt;</code>的值要么是被参照表中<strong>已有的主键值</strong>，要么为<strong><code>null</code></strong>
外键的声明方式有点特别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="operator">&lt;</span>属性名<span class="operator">&gt;</span> <span class="operator">&lt;</span>属性类型<span class="operator">&gt;</span> <span class="keyword">references</span> <span class="operator">&lt;</span>关系名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>属性名<span class="operator">&gt;</span>)</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">foreign key</span> <span class="operator">&lt;</span>属性名<span class="operator">&gt;</span> <span class="keyword">references</span> <span class="operator">&lt;</span>关系名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>属性名<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意，如果<strong>一个表被其它表参照，那么它是不能被删除的</strong></p></li>
</ul>
<h3 id="约束对象">约束对象</h3>
<ul>
<li><p>约束实际上是一个数据库对象，是可以起名的(默认是系统起名)，起名也有两种方式(都是在键前添加<code>constraint &lt;约束名&gt;</code>)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="operator">&lt;</span>属性名<span class="operator">&gt;</span> <span class="operator">&lt;</span>属性类型<span class="operator">&gt;</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">references</span> tbl_name(attr_name)</span><br><span class="line">	<span class="operator">&lt;</span>属性名<span class="operator">&gt;</span> <span class="operator">&lt;</span>属性类型<span class="operator">&gt;</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">unique</span></span><br><span class="line">(<span class="number">2</span>) <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">foreign key</span> () <span class="keyword">references</span> ..()</span><br><span class="line">	<span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">primary key</span> ()</span><br></pre></td></tr></table></figure>
<p>实践中，最好自己起约束名</p></li>
<li><p>最后对比一下两种声明方式：</p>
<ul>
<li>第一种声明方式<strong>针对一个属性</strong>，可以用空格分隔并<strong>声明多个约束</strong>
可以看作是在一个属性后列出其约束</li>
<li>第二种声明方式针对含多个属性的约束，一条只能<strong>声明一个约束</strong>，但能<strong>约束一个属性组</strong></li>
</ul></li>
</ul>
<h2 id="ddl数据定义语言"><code>DDL</code>(数据定义语言)</h2>
<h3 id="数据库对象">数据库对象</h3>
<ul>
<li><code>database</code>：数据库</li>
<li><code>schema</code>：模式</li>
<li><code>table</code>：表</li>
<li><code>view</code>：视图</li>
<li><code>function</code>：函数</li>
<li><code>constraint</code>：约束</li>
</ul>
<h3 id="通用语法">通用语法</h3>
<ul>
<li><p>通用语法是指，所有数据库对象创建/更改/删除时都需要用到的主语句，例如<code>create、drop</code>等</p></li>
<li><p><code>create</code>：创建某种数据库对象</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span> <span class="operator">&lt;</span>obj_name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>drop</code>：删除某种数据库对象 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span> <span class="operator">&lt;</span>obj_name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>alter</code>：更新某种数据库对象的结构
在实践中，<code>alter</code>尽量作为最后手段，一切结构尽量在创建时定义完整</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span> <span class="operator">&lt;</span>obj_name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关于表">关于表</h3>
<ul>
<li><p>创建表需要在表名后附加元组，表示每一列的属性名、属性类型，以及表的约束
创建表时添加约束的语法已在前面详细讲过</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> (</span><br><span class="line">    <span class="operator">&lt;</span>attr_name<span class="operator">&gt;</span> <span class="operator">&lt;</span>attr_type<span class="operator">&gt;</span> <span class="operator">&lt;</span>attr_constraint<span class="operator">&gt;</span>,</span><br><span class="line">    <span class="operator">&lt;</span>attr_constraint<span class="operator">&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>更新表的结构： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>	<span class="comment">-- 后跟子句:</span></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">column</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>					<span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span> 				<span class="comment">-- 删除列</span></span><br><span class="line"><span class="comment">-- 重命名列</span></span><br><span class="line"><span class="keyword">add constraint</span> <span class="operator">&lt;</span>constraint_name<span class="operator">&gt;</span> (<span class="operator">&lt;</span>attrs<span class="operator">&gt;</span>)	<span class="comment">-- 添加约束, 定义方式同上</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>constraint_name<span class="operator">&gt;</span>			<span class="comment">-- 删除约束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="查询语句">查询语句</h2>
<h3 id="from"><code>FROM</code></h3>
<ul>
<li><p><code>FROM</code>子句用于<strong>添加数据源</strong>，后<strong>跟表或视图</strong>，有两种添加数据源的方式</p></li>
<li><p>笛卡尔积：直接用<code>','</code>连接表，<code>FROM</code>会将它们进行笛卡尔积后交给下一个子句
这样的<code>FROM</code>通常配合<code>WHERE</code>子句进行限制</p></li>
<li><p>内连接：用<strong><code>JOIN ON</code></strong>子句连接数据源，这样的子句必须跟<code>ON</code>及一个逻辑表达式
会将两表进行<strong>笛卡尔积</strong>并<strong>只保留使该逻辑表达式为真的行</strong>，再交给下一个子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> <span class="operator">&lt;</span>logic_expr<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>自然连接：部分数据库支持，等价于<code>ON</code>后跟一系列<strong>同名属性的等值比较</strong>的内连接
因此不需要跟<code>ON</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> t2</span><br></pre></td></tr></table></figure></li>
<li><p>交叉连接：部分数据库的语法，等价于直接进行笛卡尔积
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> t1 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> t2</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>外连接：在<strong>内连接的基础</strong>上，保留那些不满足逻辑表达式的行，连接后未知的值设为<code>NULL</code>
分为<code>LEFT JOIN、RIGHT JOIN、FULL JOIN</code>
分别是：保留左表、保留右表、保留两边的表
使用外连接要注意，如果要进行多表连接，那么一个内连接很有可能丢弃掉外连接保留下来的行(因为部分属性是<code>NULL</code>，很容易经过逻辑表达式后返回假)</p></li>
</ul>
<h3 id="where"><code>WHERE</code></h3>
<ul>
<li><code>WHERE</code>子句用于进一步限制由<code>FROM</code>得来的查询结果，后<strong>跟逻辑表达式</strong>
逻辑表达式的细节不再赘述</li>
</ul>
<h3 id="group-by"><code>GROUP BY</code></h3>
<ul>
<li><code>GROUP BY</code>子句用于<strong>根据某些属性</strong>进行<strong>分组</strong>，需要和<code>SELECT</code>等语句区分开，<code>GROUP BY</code>后<strong>跟一系列属性名</strong>(列引用)，而<strong>不是值列表</strong>
后跟多个属性时，<code>GROUP BY</code>会根据<strong>元组的等值比较</strong>规则来分组
分组后由于<strong>域的原子性</strong>这个第一范式，只能选择<strong>分组依据</strong>或者<strong>聚集函数值</strong>作为<a
href="#expl_atomexpr"><strong>原子表达式</strong></a></li>
<li>很多时候用户会在使用<code>GROUP BY</code>后<code>SELECT</code>那些不能作为原子表达式的属性，并误以为是<code>SELECT</code>的问题，实际上是<code>GROUP BY</code>后能作为原子表达式的内容变为了分组依据或聚集函数值</li>
</ul>
<h3 id="having"><code>HAVING</code></h3>
<ul>
<li><code>HAVING</code>子句用于<strong>过滤分组</strong>，后<strong>跟逻辑表达式</strong>
前面说了，<code>WHERE</code>只能用于限制由<code>FROM</code>得来的查询结果
而又有分组后再根据聚集函数值来限制结果的需求，因此有了<code>HAVING</code>子句
一旦<strong>使用<code>HAVING</code></strong>子句则<strong>默认使用了<code>GROUP BY</code></strong>(没有<code>GROUP BY</code>时将整个表视为一组)，因此如<code>GROUP BY</code>中说的那样，<strong>只能用分组依据或聚集函数值作为原子表达式</strong></li>
</ul>
<h3 id="select"><code>SELECT</code></h3>
<ul>
<li><code>SELECT</code>是整个查询语句的核心，后<strong>跟一个数值表达式列表</strong>，也就是值列表，<code>SELECT</code>会对输入表的<strong>每一行计算值列表的结果</strong>，并输出查询结果呈现给用户</li>
<li><code>SELECT</code>的返回值是一个表，不是视图，不要因视图的创建语法而误判</li>
<li><code>DISTINCT</code>关键字：只能在<code>SELECT</code>后添加，用于对得到的结果<strong>去重</strong>
去重规则：将整一行视为元组，若存在两行完全一致，则去重
可配合<code>count()</code>统计不重复的值的数量</li>
</ul>
<h3 id="order-by"><code>ORDER BY</code></h3>
<ul>
<li><p><code>ORDER BY</code>子句用于<strong>排序</strong>，后<strong>跟值列表</strong>，<code>ORDER BY</code>会像<code>SELECT</code>那样对<code>SELECT</code>输出的表的每一行计算值列表的值，并根据结果排序
当值列表中有多个值时，排序规则是进行<strong>元组的比较</strong>，即从左到右，若前一个值相等则比较后一个值，从此类推下去</p></li>
<li><p>自定义排序规则：因为跟的是数值表达式列表，可以<strong>配合<code>CASE</code></strong>表达式来<strong>自定义排序</strong>规则</p></li>
<li><p>默认下，会对计算结果进行<strong>升序排序</strong>，即<strong><code>ASC</code></strong>
如要<strong>降序排序</strong>，需要在表达式后添加<strong><code>DESC</code></strong>，会单独对该表达式值进行降序排序</p></li>
<li><p><code>NULLS FIRST</code>和<code>NULLS LAST</code>：部分数据库支持，会将计算结果为<code>NULL</code>的行放在最前/最后
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> attr1, <span class="keyword">NULLS FIRST</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>虽然<code>ORDER BY</code>在<code>SELECT</code>后执行，但它实际上能看到所有没被<code>SELECT</code>选中的属性
所以<code>ORDER BY</code>仍能使用<code>SELECT</code>能使用的那些属性作为原子表达式</p></li>
</ul>
<h3 id="limit"><code>LIMIT</code></h3>
<ul>
<li><code>LIMIT</code>子句用于限制表的显示前若干行，后跟一个整型表示要显示的行数</li>
</ul>
<h3 id="子查询">子查询</h3>
<ul>
<li>不相关子查询
<ul>
<li><code>WITH AS</code>：</li>
</ul></li>
<li>相关子查询</li>
</ul>
<h3 id="集合查询">集合查询</h3>
<ul>
<li><code>UNION</code></li>
<li><code>INTERSECT</code></li>
<li><code>EXCEPT</code>或<code>MINUS</code></li>
<li><code>ALL</code>关键字：集合运算默认进行去重，将<code>ALL</code>添加在上述语句后，会保留所有重复的行</li>
</ul>
<h2 id="其它dml">其它<code>DML</code></h2>
<h3 id="insert-into"><code>INSERT INTO</code></h3>
<h3 id="update"><code>UPDATE</code></h3>
<h3 id="delete"><code>DELETE</code></h3>
<h2 id="sql函数"><code>SQL</code>函数</h2>
<h3 id="常见空值处理函数"><a
href="#expl_nullfc">常见空值处理函数</a><a id='more_nullfc'></a></h3>
<ul>
<li><p><code>coalesce(...)</code>：返回从左到右第一个非<code>null</code>值(除非不存在非<code>null</code>值)，要求所有值的数据类型相同
不想无视某些为空值的属性时，可用<code>coalesce()</code></p></li>
<li><p><code>nullif(a, b)</code>：若<code>a=b</code>，返回<code>null</code>，否则返回<code>a</code>
前面说到空值一旦参与运算即返回空且会被聚集函数无视，可以通过<code>nullif</code>忽略某些非空值</p></li>
<li><p><code>is [not] distinct with</code>：空值安全比较，相比于<code>=</code>和<code>!=</code>，将<code>null</code>视为一般值
即<code>null = null</code>返回真/<code>null != null</code>返回真</p></li>
<li><p><code>nulls first</code>和<code>nulls last</code>：空值排序，将该字段放在<code>order by</code>的某个属性后面，会把为<code>null</code>的元组放在最前/最后显示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见聚集函数"><a
href="#expl_gfunc">常见聚集函数</a><a id='more_gfunc'></a></h3>
<ul>
<li>固有的聚集函数(所有数据库都支持)：<code>count()、avg()、sum()、min()、max()</code></li>
<li>统计类聚集函数：<code>variance()、stddev()、corr(x, y)</code></li>
<li>字符串聚集函数：<code>string_agg(..., delim_char)</code></li>
<li>自定义聚集函数</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络: 概览</title>
    <url>/blogs/2025/04/18/comp-networking-profile/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="计算机网络指标">计算机网络指标</h3>
<ul>
<li>计算机网络为通信技术和计算机技术的结合，互连、自治(无主从关系)</li>
<li>数据率/数据传输率/比特率：单位时间传输的比特数 ~波特率</li>
<li>时延：路由器缓存未满时、数据排队造成的延迟
<ul>
<li>结点处理：数据检错、确定通信链路，通常少于毫秒</li>
<li>排队延迟：通过流量强度描述，<code>0~1</code>为正常值、越大表示排队延迟越大</li>
<li>传输延迟：<span
class="math inline">$\begin{align}f\left(\frac{数据量}{带宽}\right)\end{align}$</span>，是路由器推出分组分批的时间(带宽有限，需要分批次传输分组数据包)</li>
<li>传播延迟：<span
class="math inline">$\begin{align}f\left(\frac{通信链路长度}{信号传播速率}\right)\end{align}$</span>，是路由器传播一批数据所需时间，与两个路由器之间的距离、传输线路性能有关</li>
</ul></li>
<li>时延带宽积：传播时延和带宽的乘积，可视作以比特为单位的链路长度
计算传播延迟除了原有公式，还可用时延带宽积除以带宽得到</li>
<li>丢包：路由器缓存满时、后来数据将被丢弃；丢包率：<span
class="math inline">$\begin{align}\frac{丢包数}{分组包数}\end{align}$</span></li>
</ul>
<h3 id="网络体系结构">网络体系结构</h3>
<ul>
<li>从功能上描述计算机网络结构，是一种分层结构
每层均遵循某些协议，完成其功能</li>
<li>对所有网络体系结构，每一层的实体使用下层透明的服务、实现本层功能、向上层提供服务
同层相邻实体通过本层协议通信
相邻层实体通过<code>SAP</code>(<code>Service Access Point</code>，服务访问点)交换原语，使用服务</li>
<li><code>OSI</code>(开发系统互联)参考模型：用于参考的国际标准模型
该模型学术价值高、但工程价值低，难以实现且难以扩展
每一层都有自己的<code>PDU</code>(协议数据单元)，前接本层的缩写来区分不同层的<code>PDU</code>
<ul>
<li>物理层：接收<code>DL-PDU</code>进行比特编码、通过物理介质传输数据
<ul>
<li>接口特性：机械、电气、功能、规程</li>
<li>传输模式：单工、半双工、全双工</li>
</ul></li>
<li>数据链路层(<code>Data link</code>)：完成结点-结点传输
<ul>
<li>负责组帧(<code>Framing</code>)/拆帧，并在帧头添加发送端/接收端的<strong>物理地址</strong>，帮助物理层确定目标主机</li>
<li>组帧：接收<code>N-PDU</code>，将数据分为若干帧(每帧由若干比特位组成)，并添加帧头<code>DH</code>、帧尾<code>DT</code>
拆帧为组帧的反过程</li>
<li>控制功能：流量控制、差错控制(检错并重传)、访问控制(决定哪些设备拥有通信链路的控制权)</li>
</ul></li>
<li>网络层(<code>Network</code>)：完成源主机-目的主机的分组传输
<ul>
<li>负责分组，并添加发送端/接收端的<strong>逻辑地址</strong>，来<strong>唯一标识目标主机</strong></li>
<li>路由(<code>Routing</code>)：由路由器(<code>Router</code>)及网关等互连网络，由网络层进行路由(选择较优路径进行数据传输)</li>
</ul></li>
<li>传输层(<code>Transport</code>)：完成端-端进程的报文传输
<ul>
<li>负责接收<code>S-PDU</code>，进行<strong>分段</strong></li>
<li>添加<code>SAP</code>地址，如端口号等信息，来<strong>确定</strong>目标端的<strong>进程</strong></li>
</ul></li>
<li>会话层(<code>Session</code>)：负责对话控制，例如在数据流中<strong>插入同步点</strong></li>
<li>表示层(<code>Presentation</code>)：将<code>A-PDU</code>通过<strong>编码、加密、压缩</strong>，转化为<code>P-PDU</code>，处理来自应用层数据的语法、语义问题</li>
<li>应用层：支持用户通过用户代理、网络接口等使用网络服务</li>
</ul></li>
<li>结合<code>OSI</code>、<code>TCP/IP</code>参考模型，有五层参考模型(将会话层、表示层合并到应用层中)</li>
<li>数据传输过程中，需经过交换机(<code>Switch</code>)、路由器(<code>Router</code>)
<ul>
<li>交换机仅含物理层、链路层，通过<code>MAC</code>地址确定目的地
由于只能分割冲突域，因此常用于局域网的互联，且安全性不足</li>
<li>路由器仅含物理层、链路层、网络层，通过<code>IP</code>地址确定目的地
通常用于连接不同网段，进行跨网络数据传输</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>Java: IO</title>
    <url>/blogs/2025/04/17/java-io/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="java-io"><code>Java IO</code></h1>
<h2 id="java.io"><code>java.io</code></h2>
<h3 id="文件类">文件类</h3>
<ul>
<li><code>File</code>：文件类对象可表示一个文件，包括普通文件和目录文件，在文档中称为“抽象路径”</li>
<li><code>File</code>类对象只能修改文件的属性，不能读写文件</li>
<li><code>File</code>构造方法：提供文件路径或其它<code>File</code>类对象</li>
<li><code>File</code>文件操作在大多数情况下不常用且不好用，更多是查询文件的属性，很多时候应该使用<code>Files</code>或<code>apache</code>提供的<code>io</code>方法，因此这里不介绍</li>
<li><code>RandomAccessFile</code>：随机访问文件类和文件类完全不同，不能修改文件的元属性，但是能随机访问或修改文件的内容</li>
<li><code>RandomAccessFile</code>构造方法：提供文件路径或其它<code>File</code>类对象，并提供用字符串表示的模式参数
<ul>
<li><code>"r"</code>：只读打开，文件不存在或发生写操作会抛出<code>IOException</code>受检异常</li>
<li><code>"rw"</code>：读写打开，文件不存在会创建，此处的“写”是覆盖</li>
<li><code>"rwd"</code>：读写打开，并在缓存满时或调用<code>close()</code>时同步</li>
<li><code>"rws"</code>：读写打开，并在每一次写操作后同步</li>
</ul></li>
<li><code>RandomAccessFile</code>常用方法：
<ul>
<li><code>long getFilePointer()</code>：返回当前的文件指针</li>
<li><code>seek(long pos)</code>：将文件指针移到<code>pos</code>处</li>
<li><code>close()</code>：关闭并释放这个随机访问流</li>
<li><code>Type readType()</code>和<code>writeType(Type x)</code>：支持读写并自动解析一个基本数据类型的数据</li>
<li><code>String readLine()</code>：读一行文本</li>
<li><code>readFully(byte[] b, int off, int len)</code>：读取当前指针后最多<code>len</code>个字节，读入<code>b+off</code>中
此函数有<code>readFully(byte[] b)</code>重载，将当前指针后的所有字节读入<code>b</code>中</li>
<li><code>writeBytes(String)</code>和<code>writeChars(String)</code>：将字符串以<code>byte</code>序列形式、<code>Unicode</code>编码形式写入文件</li>
<li><code>String readUTF()</code>和<code>writeUTF(String s)</code>：以<code>UTF8</code>编码读写字符串</li>
<li><code>getFD()</code>：获取<code>FileDescriptor</code>对象</li>
</ul></li>
<li><code>FileDescriptor</code>：不含任何操作功能，而是文件资源在<code>java</code>中抽象的描述符
<ul>
<li><code>boolean valid()</code>：检查描述符是否有效</li>
<li><code>sync()</code>：将缓冲区内容同步到硬盘，上述<code>RandomAccessFile</code>的同步就是调用<code>getFD().sync()</code>完成的</li>
</ul></li>
</ul>
<h3 id="流的概念">流的概念</h3>
<ul>
<li>流是<code>java</code>提供的另一种操作数据输入输出的机制，和<code>RandomAccessFile</code>不同，它们是顺序读写的，曾经读过的数据无法再读(除非支持标记)，在读取数据前必须将所有前面的数据全部读取</li>
<li>按数据流向分类，分为输入流、输出流</li>
<li>按数据单位分类，分为字符流、字节流，字符流以两个字节为单位、字节流以单个字节为单位
<code>java</code>对这两个分类依据有较易区分的命名风格，输入字符流为<code>XxxReader</code>、输出字符流为<code>XxxWriter</code>、输入字节流为<code>XxxInputStream</code>、输出字节流为<code>XxxOutputStream</code></li>
<li>按功能分类，分为节点流、处理流，节点流对象直接和数据源绑定，仅提供读取字节或字符的功能，处理流则是节点流的封装，具体体现在构造方法上，节点流需要资源描述符对象，而处理流需要流对象</li>
</ul>
<h3 id="字节流">字节流</h3>
<ul>
<li>所有字节流类都继承<code>InputStream</code>或<code>OutputStream</code>
<ul>
<li><code>InputStream</code>：仅提供读取单个或多个字节的方法，除此之外：
<code>long skip(long n)</code>：跳过最多<code>n</code>个字节，返回实际跳过的字节数
<code>boolean markSupported()</code>：测试该输入流是否支持<code>mark()</code>和<code>reset()</code>
<code>mark(int lim)</code>：对现在指针作标记，该标记在此后的<code>lim</code>个字节内才有效
<code>reset()</code>：复位到上一个有效的标记，若不存在则抛出异常
通过<code>mark()</code>和<code>reset()</code>配合可以实现重复读取某一段连续字节</li>
<li><code>OutputStream</code>：仅提供写入单个或多个字节的方法，除此之外有<code>flush()</code>方法能快速清空缓冲区</li>
</ul></li>
<li>节点流最重要的是<code>FileInputStream</code>和<code>FileOutputStream</code>，可以提供文件路径或抽象文件对象构造文件字节流，<code>FileOutputStream</code>可以提供<code>append</code>布尔值参数表示是否以追加模式写入
文件流本身不支持标记，<code>ByteArray</code>系列的流支持但并不常用(因为只能处理小文件)，更常用的是处理流<code>Buffered</code>系列的流</li>
<li>处理流则非常多样：
<ul>
<li><code>BufferedInput/OutputStream</code>：十分常用的缓冲处理流，本身不提供解析之类的方法，而是用于管理缓冲区的流，支持<code>mark</code></li>
<li><code>DataInput/OutputStream</code>：能将字节数据解析为一系列基本数据类型的处理流，和<code>RandomAccessFile</code>提供的输入/输出方法一致
<code>readLine()</code>方法已被弃用，建议使用<code>BufferedReader</code>提供的<code>readLine()</code>方法</li>
<li><code>ObjectInput/OutputStream</code>：能将字节数据解析为<code>Object</code>对象的处理流，用于序列化和反序列化，要求类实现<code>Serializable</code>空接口；<code>java</code>原生的序列化有安全、性能问题</li>
<li><code>PipedInput/OutputStream</code>：用于线程间通信，输入流或输出流通过<code>connect()</code>方法连接配套的输出流或输入流</li>
<li><code>SequenceInputStream</code>：序列处理流，用于将一系列输入流串联起来，统一由<code>SequenceInputStream</code>对象管理
需要用到传统的<code>Enumeration</code>枚举器接口，调用<code>Vector&lt;InputStream&gt;</code>对象的<code>elements()</code>方法即可，但实际上现在已经很少使用了</li>
<li><code>PrintStream</code>：提供的最常用的方法是<code>print()</code>、<code>println()</code>的一系列重载方法，<code>System.out</code>是<code>PrintStream</code>类的<code>final</code>对象</li>
</ul></li>
</ul>
<h3 id="字符流">字符流</h3>
<ul>
<li>所有字符流类都继承<code>Reader</code>或<code>Writer</code></li>
<li>处理对象数据或二进制数据时，字节流通常更好用，但当数据是字符时，用字符流类来处理更简单(例如编码问题)，所以一般会用<code>InputStreamReader</code>将输入字节流转化为输入字符流，处理后通过<code>OutputStreamWriter</code>这个输出字符流将内容写入输出字节流</li>
</ul>
<h2 id="java.nio"><code>java.nio</code></h2>
<ul>
<li><code>java.io</code>是阻塞型<code>IO</code>(<code>BIO</code>)，是面向流的，而<code>java.nio</code>是<code>java 1.4+</code>支持的<code>New IO</code>(或译为<code>Non-Block IO</code>)，是面向通道、缓冲区、选择器的非阻塞<code>IO</code>
这两种<code>IO</code>都是同步的，需要程序主动检查<code>IO</code>任务是否完成，传统的<code>IO</code>优势在于小规模、低并发的操作(例如小文件操作)，而在网络<code>IO</code>中<code>nio</code>有较大优势</li>
<li><code>java.nio</code>的读写是全双工的</li>
</ul>
<h3 id="buffer"><code>Buffer</code></h3>
<ul>
<li>在<code>nio</code>中，<code>Buffer</code>用于<strong>处理数据</strong>，其子类包含<code>IntBuffer</code>、<code>ByteBuffer</code>、<code>CharBuffer</code>、<code>LongBuffer</code>，最常用的自然是<code>ByteBuffer</code></li>
<li><code>Buffer</code>及上述几个子类都是抽象类，不能被实例化但其子类可以通过以下静态方法获取<code>Buffer</code>对象：
<ul>
<li><code>allocate(int)</code>：获取一个自动分配静态数组的<code>Buffer</code>实例对象(<code>HeapXxxBuffer</code>)
使用<code>JVM</code>堆内内存</li>
<li><code>wrap(type[])</code>将提供的静态数组封装为<code>Buffer</code>对象</li>
<li><code>allocateDirect(int)</code>：获取一个自动分配静态数组的<code>Buffer</code>实例对象(<code>DirectXxxBuffer</code>)
使用堆外的本地内存，本地内存在分配与回收时消耗更大，但面对大量、频繁的读写更快</li>
</ul></li>
<li><code>Buffer</code>有三个重要属性：<code>mark</code>(标记)、<code>position</code>(指向当前指针)、<code>limit</code>(现存数据大小)，<code>mark&lt;=position&lt;=limit</code></li>
<li><code>Buffer</code>也提供随机读写的功能，允许对象在<code>position</code>属性小于<code>limit</code>属性时读写，并提供了以下和<code>position</code>与<code>mark</code>有关的方法：
<ul>
<li><code>position()</code>和<code>position(int)</code>：获取或设置<code>position</code>属性</li>
<li><code>limit()</code>和<code>limit(int)</code>：获取或设置<code>limit</code>属性</li>
<li><code>mark()</code>：标记当前的<code>position</code>为<code>mark</code></li>
<li><code>reset()</code>：设置当前的<code>position</code>为当前的<code>mark</code></li>
<li><strong><code>flip()</code></strong>：设置<code>limit</code>为当前的<code>position</code>，再将<code>position</code>设置为<code>0</code>，相当于<code>buf.limit(buf.position()).position(0)</code></li>
<li><code>rewind()</code>：设置<code>mark</code>为当前的<code>position</code></li>
<li><code>remaining()</code>和<code>hasRemaining()</code>：返回<code>limit</code>与<code>position</code>的差值、判断该差值是否大于零
它们均返回对象本身，因此可以级联操作，其中<code>flip()</code>很常用，因为通常需要向<code>Buffer</code>对象写入数据后紧接着读取这些数据</li>
</ul></li>
<li><code>ByteBuffer</code>提供的读写方法在命名上和流有所区别：<code>read</code>变为<code>get</code>、<code>write</code>变为<code>put</code>，它们会自动更新<code>position</code>和<code>limit</code>
除了相对存取，还允许提供<code>index</code>参数作为第一个参数，称为绝对存取，绝对存取不影响<code>position</code>和<code>limit</code></li>
<li><code>Buffer</code>提供<code>duplicate()</code>方法创建一个共享同一个数据数组的缓冲区对象
<code>XxxBuffer</code>提供<code>asXxxBuffer()</code>和<code>asReadOnlyBuffer()</code>创建一个其它类型的、或只读的本类型的<code>Buffer</code>对象，仍然共享同一个数据数组</li>
</ul>
<h3 id="filechannel"><code>FileChannel</code></h3>
<ul>
<li><code>Channel</code>是一个接口，实现该接口的实例对象表示数据源到缓冲区的通道，它不能处理数据，而是负责<strong>存取和传输数据</strong></li>
<li>有以下类实现了该接口：
<ul>
<li><code>FileChannel</code>：文件通道，可以通过<code>RandomAccessFile</code>对象或流对象的<code>getChannel()</code>方法获取，也可以通过静态方法<code>open()</code>获取，其中<code>open()</code>方法实际上是<code>nio.2</code>提供的，将在下一节介绍</li>
<li><code>SocketChannel</code>：客户端的<code>TCP</code>套接字通道，可以通过<code>Socket</code>对象的<code>getChannel()</code>方法获取</li>
<li><code>ServerSocketChannel</code>：服务端<code>TCP</code>套接字连接的通道，可以通过<code>ServerSocket</code>对象的<code>getChannel()</code>方法获取</li>
<li><code>DatagramChannel</code>：<code>UDP</code>套接字的通道
在这里仅介绍<code>FileChannel</code>提供的方法，其余通道将在网络编程中详细介绍</li>
</ul></li>
<li><code>read(Buffer dest)</code>和<code>write(Buffer src)</code>是通道类最重要的两个方法</li>
<li><code>force(false)</code>方法允许强制刷盘，立刻同步通道的更改到硬盘中，<code>force(true)</code>不仅会同步内容，还会同步文件元数据</li>
<li><code>truncate(long size)</code>：截断通道的内容，丢弃第<code>size</code>个字节及之后的数据</li>
</ul>
<h3 id="mappedbytebuffer"><code>MappedByteBuffer</code></h3>
<ul>
<li><code>MappedByteBuffer</code>：文件映射缓冲，是文件在内存中的直接映射，避免了传统<code>IO</code>那样需要切换内核态进行存取操作，效率更高，但和硬盘上的数据不是随时同步的，可以通过<code>force()</code>立刻刷新缓冲区
通常通过通道对象调用<code>map()</code>方法创建，同样是本地内存，因此读写更快而分配与回收较慢，适用于大型文件</li>
<li>映射有三种模式：<code>FileChannel.MapMode</code>的<code>READ_ONLY</code>与<code>READ_WRITE</code>与<code>PRIVATE</code>
其中<code>READ_WRITE</code>模式的更改会同步到文件但不会同步到其它缓冲区，<code>PRIVATE</code>模式的更改只会修改当前的缓冲区，必须通过<code>force()</code>刷盘同步更新</li>
<li><code>MappedByteBuffer</code>和<code>DirectByteBuffer</code>的区别是它和通道有直接关联，所以可以不通过<code>FileChannel</code>进行<code>read()</code>和<code>write()</code>，而是依靠缺页中断直接在内存映射文件中读写数据</li>
</ul>
<h3 id="java.nio.charset"><code>java.nio.charset</code></h3>
<h2 id="nio2"><code>nio2</code></h2>
<h3 id="asynchronouschannel"><code>AsynchronousChannel</code></h3>
<ul>
<li><code>nio2</code>或称<code>AIO</code>，支持异步操作和更全面的跨文件系统支持，主体为<code>java.nio.file</code>包</li>
<li>除此之外提供异步的通道，名称均以<code>Asynchronous</code>开头，它们和<code>nio</code>的通道的方法一致，不再赘述</li>
</ul>
<h3 id="path和paths"><code>Path</code>和<code>Paths</code></h3>
<ul>
<li><code>Paths</code>是工具类，仅提供静态方法用于创建<code>Path</code>对象，但在新版本中由于接口允许含有静态方法，<code>Paths.get()</code>内部被替换为<code>Path.of()</code>
所以直接调用<code>Path.of()</code>创建<code>Path</code>对象即可，需要提供<code>URI</code>(网络资源)或<code>String</code>(本地资源)</li>
<li>在<code>Path</code>中，<code>.</code>表示<code>classpath</code></li>
<li><code>Path</code>和<code>File</code>起的作用类似，均表示一个抽象路径，提供以下实例方法：
<ul>
<li><code>getFileName()</code>：获取<code>String</code>表示的文件名</li>
<li><code>getFileSystem()</code>：获取<code>FileSystem</code>对象</li>
<li><code>getNameCount()</code>：获取该<code>Path</code>上级目录的个数</li>
<li><code>getName(int idx)</code>：获取第<code>idx</code>层上级目录的<code>Path</code>对象，<code>idx</code>从<code>0</code>开始表示最上级目录</li>
<li><code>iterator()</code>：获取用于遍历上级目录的迭代器</li>
<li><code>getParent()</code>：获取绝对路径中上级目录的<code>Path</code>对象，若为相对路径则返回<code>null</code></li>
<li><code>getRoot()</code>：获取绝对路径中根目录的<code>Path</code>对象，若为相对路径则返回<code>null</code></li>
<li><code>isAbsolute()</code>：判断是否为绝对路径</li>
<li><code>normalize()</code>：规范化路径，将所有<code>.</code>和<code>..</code>解析并去除</li>
<li><code>relative(Path p)</code>：返回该对象和<code>p</code>之间的相对路径</li>
<li><code>resolve(Path p)</code>：若<code>p</code>为绝对路径则返回<code>p</code>，否则拼接在本<code>Path</code>对象之后并返回</li>
<li><code>resolveSibling(Path p)</code>：若<code>p</code>为绝对路径则返回<code>p</code>，否则拼接在本<code>Path</code>对象的<code>getParent()</code>对象之后并返回</li>
<li><code>startsWith()</code>和<code>endsWith()</code>：判断该对象是否以某个<code>Path</code>或某个<code>String</code>起始、结尾</li>
<li><code>toAbsolutePath()</code>：返回对应的绝对路径</li>
<li><code>toUri()</code>：返回对应的<code>URI</code></li>
</ul></li>
</ul>
<h3 id="files"><code>Files</code></h3>
<ul>
<li><code>Files</code>是工具类，提供更丰富的文件操作</li>
<li><code>copy(Path, Path, CopyOption...)</code>：复制文件，默认行为为非原子地复制文件内容和最后修改时间到未存在文件，不保留硬链接、若源文件为软链接则取其指向文件的数据
其中<code>CopyOption</code>是空接口，有枚举<code>StandardCopyOption</code>实现
<ul>
<li><code>ATOMIC_MOVE</code>：原子地移动，仅支持<code>move()</code></li>
<li><code>REPLACE_EXISTING</code>：若目标已存在则覆盖内容</li>
<li><code>COPY_ATTRIBUTES</code>：复制文件元数据，包括权限和所有者等</li>
</ul></li>
<li><code>move(Path, Path, CopyOption...)</code>：移动文件，默认行为为非原子性地移动文件内容到未存在文件，若为软链接则复制软链接本身</li>
</ul>
<h3
id="java.nio.file.attribute"><code>java.nio.file.attribute</code></h3>
<h3 id="pathmatcher"><code>PathMatcher</code></h3>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>I/O API</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>图的遍历: 链式前向星</title>
    <url>/blogs/2025/04/10/algo-linked-forward-star/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="对顶堆">对顶堆</h3>
<ul>
<li><p>对顶堆是用于解决<strong>寻找序列中第<span
class="math inline"><em>k</em></span>小数</strong>的数据结构，其中序列可动态变化、<span
class="math inline"><em>k</em></span>可动态变化
对顶堆较易实现，比实现权值线段树、平衡树有码量上的优势</p></li>
<li><p>基本组成：一个大顶堆和一个小顶堆(辅助堆)，大顶堆维护前<span
class="math inline"><em>k</em></span>小的元素(包括<span
class="math inline"><em>k</em></span>)，小顶堆维护其它元素(即比第<span
class="math inline"><em>k</em></span>元素大的元素)</p>
<p>这样，大顶堆的堆顶就是第<span
class="math inline"><em>k</em></span>个元素、小顶堆的堆顶是第<span
class="math inline"><em>k</em> + 1</span>个元素
如果要求寻找序列中第<span
class="math inline"><em>k</em></span>大的数，则反过来用小顶堆维护前<span
class="math inline"><em>k</em></span>大的元素、用大顶堆作辅助堆即可</p></li>
<li><p>每次涉及到动态修改(如插入、修改<span
class="math inline"><em>k</em></span>值)，需要在操作结束后维护：
若大顶堆元素超出<span
class="math inline"><em>k</em></span>个，则将大顶堆的堆顶弹出后插入小顶堆中
否则将小顶堆堆顶插入大顶堆中</p></li>
<li><p>插入元素：若插入元素不小于大顶堆堆顶，则插入小顶堆中，否则插入大顶堆中</p></li>
<li><p>查询第<span
class="math inline"><em>k</em></span>小元素：返回大顶堆堆顶</p></li>
<li><p>删除第<span
class="math inline"><em>k</em></span>小元素：推出大顶堆堆顶和小顶堆堆顶，将后者插入大顶堆中</p></li>
<li><p>动态修改<span
class="math inline"><em>k</em></span>值：与维护操作描述一致，若<span
class="math inline"><em>k</em></span>增大，则推出小顶堆堆顶插入大顶堆中；否则推出大顶堆堆顶插入小顶堆中</p></li>
<li><p>时间复杂度：查询<span
class="math inline"><em>O</em>(1)</span>，其余操作<span
class="math inline"><em>O</em>(log<em>n</em>)</span></p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构: 对顶堆</title>
    <url>/blogs/2025/04/10/algo-minmax-heap/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="对顶堆">对顶堆</h3>
<ul>
<li><p>对顶堆是用于解决<strong>寻找序列中第<span
class="math inline"><em>k</em></span>小数</strong>的数据结构，其中序列可动态变化、<span
class="math inline"><em>k</em></span>可动态变化
对顶堆较易实现，比实现权值线段树、平衡树有码量上的优势</p></li>
<li><p>基本组成：一个大顶堆和一个小顶堆(辅助堆)，大顶堆维护前<span
class="math inline"><em>k</em></span>小的元素(包括<span
class="math inline"><em>k</em></span>)，小顶堆维护其它元素(即比第<span
class="math inline"><em>k</em></span>元素大的元素)</p>
<p>这样，大顶堆的堆顶就是第<span
class="math inline"><em>k</em></span>个元素、小顶堆的堆顶是第<span
class="math inline"><em>k</em> + 1</span>个元素
如果要求寻找序列中第<span
class="math inline"><em>k</em></span>大的数，则反过来用小顶堆维护前<span
class="math inline"><em>k</em></span>大的元素、用大顶堆作辅助堆即可</p></li>
<li><p>每次涉及到动态修改(如插入、修改<span
class="math inline"><em>k</em></span>值)，需要在操作结束后维护：
若大顶堆元素超出<span
class="math inline"><em>k</em></span>个，则将大顶堆的堆顶弹出后插入小顶堆中
否则将小顶堆堆顶插入大顶堆中</p></li>
<li><p>插入元素：若插入元素不小于大顶堆堆顶，则插入小顶堆中，否则插入大顶堆中</p></li>
<li><p>查询第<span
class="math inline"><em>k</em></span>小元素：返回大顶堆堆顶</p></li>
<li><p>删除第<span
class="math inline"><em>k</em></span>小元素：推出大顶堆堆顶和小顶堆堆顶，将后者插入大顶堆中</p></li>
<li><p>动态修改<span
class="math inline"><em>k</em></span>值：与维护操作描述一致，若<span
class="math inline"><em>k</em></span>增大，则推出小顶堆堆顶插入大顶堆中；否则推出大顶堆堆顶插入小顶堆中</p></li>
<li><p>时间复杂度：查询<span
class="math inline"><em>O</em>(1)</span>，其余操作<span
class="math inline"><em>O</em>(log<em>n</em>)</span></p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构: 递归式线段树</title>
    <url>/blogs/2025/04/10/algo-recursive-segment-tree/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="递归式线段树">递归式线段树</h2>
<h3 id="概述">概述</h3>
<ul>
<li><p>线段树基于<strong>分治思想</strong>，本质是将分治过程中产生的<strong>子区间解存储在树中</strong>，以达到<strong>快速查询</strong>的效果</p>
<p>典型如求解<strong>最大连续子数组</strong>，虽然运用贪心算法是更快的单次算法，但如果大区间不变，而只是进行<strong>多次的子区间解查询</strong>时，线段树比贪心算法更快</p>
<p>若加上简单的维护，则能使其很简单地支持区间修改，同时不用消耗更多的资源</p></li>
<li><p>适用的修改操作：所有符合结合律的运算，例如比大小、求和等
这也是和树状数组的区别，<strong>树状数组</strong>是<strong>维护所有前缀区间</strong>的信息来查询任意子区间的信息，而线段树是直接<strong>维护一些有代表性的子区间</strong>的信息并将它们<strong>组合</strong>来得到任意子区间的信息，因此不需要运算的元素拥有逆元</p></li>
<li><p>适用问题：要求维护<strong>连续子区间</strong>的问题，例如<code>RMQ</code>(区间最大/最小查询)和<code>RSQ</code>(区间求和查询)问题</p></li>
</ul>
<h3 id="递归式线段树的组成">递归式线段树的组成</h3>
<ul>
<li><p>基本结构：</p>
<ul>
<li>假设根结点编号为<span class="math inline">1</span>，则所有结点<span
class="math inline"><em>i</em></span>维护一个子区间<span
class="math inline">[<em>l</em>,<em>r</em>]</span>的信息，其左儿子<span
class="math inline">2<em>i</em></span>维护<span
class="math inline">$\begin{align}\left[l,\left\lfloor\frac{l+r}{2}\right\rfloor\right]\end{align}$</span>，右儿子<span
class="math inline">2<em>i</em> + 1</span>维护另一半区间</li>
<li>叶子结点维护长度为一的区间信息，它们没有儿子</li>
<li>递归式线段树不存在度为<span
class="math inline">1</span>的结点，且<strong>是一棵平衡二叉树</strong>
但它<strong>不一定是完全二叉树</strong>，不过没什么影响就是了</li>
</ul></li>
<li><p>建树：</p>
<ul>
<li>分治过程通常通过递归实现：如果结点的区间长度不为<span
class="math inline">1</span>，则进行上述递归，最后合并左、右儿子返回的值作为本结点的值，然后返回给父结点
否则，直接返回这个长度为<span
class="math inline">1</span>的区间的值(即原数组中对应的值)</li>
<li>空间消耗：有用的叶子结点即<span
class="math inline"><em>n</em></span>个，同时存在着无用的叶子结点，在<strong>不存在无用的叶子</strong>结点时，<strong>深度达到最大</strong>，为<span
class="math inline">⌈log<em>n</em>⌉</span>，则以最大深度为深度的<strong>满二叉树数组</strong>一定可以满足下标的分配，即<strong>空间为<span
class="math inline">2<sup>⌈log <em>n</em>⌉ + 1</sup> − 1</span></strong>
一个容易记的形式是，因为<span
class="math inline">⌈log <em>n</em>⌉ ≤ ⌊log <em>n</em>⌋ + 1</span>，因此最大空间<span
class="math inline"> &lt; 2<sup>⌊log <em>n</em>⌋ + 2</sup> &lt; 4 · 2<sup>log <em>n</em></sup> = 4<em>n</em></span>，直接取<span
class="math inline">4<em>n</em></span>即可</li>
</ul></li>
<li><p>区间操作：</p>
<ul>
<li>区间查询：同样通过分治来得到答案，不过一部分分治不需要深入到叶子结点
将待查询区间分为两种：完全覆盖当前结点维护的区间(即当前结点区间是待查询区间的子集)、以及另一种区间
对于前者，不需要继续递归，直接返回维护的值即可
对于后者，分为向左儿子递归和向右儿子递归的部分，如果查询区间的左端小于结点区间的中间点，则向左儿子递归；向右儿子递归同理，需要查询区间的右端大于结点区间的中间点；人话就是保证递归下去的区间和待查区间有交集
最后合并来自各个结点的极大区间信息即可 可以证明，这些极大区间最多有<span
class="math inline"><em>O</em>(log<em>n</em>)</span>个，即区间查询操作是<span
class="math inline"><em>O</em>(log<em>n</em>)</span>的</li>
<li>区间修改：需要维护一个<strong>懒惰标记</strong>，<strong>类似写时拷贝</strong>的概念，取若干个构成待修改区间的结点进行修改，需要修改时将结点的<code>lazy</code>置<code>1</code>，只修改这个结点的值，但不去修改子结点的值
具体来说，将这次修改看作区间查询，将待修改区间分为<strong>若干个极大的子区间</strong>，所有被置<code>lazy</code>的区间都是待修改区间的极大子集(同时告知需要增加/减去的值)，对同一个子区间的多次连续修改只需要将值叠加即可；当然，最后需要像合并更新上面的结点
直到下一次查询，如果待查询区间不完全覆盖当前区间(即<strong>需要递归时</strong>)，则要将当前结点的<strong>懒惰标记下放</strong>以保证同步
注意这里的<strong>懒惰标记并非表示本结点未修改，而是标记子结点未修改</strong>
为了<strong>防止懒惰标记溢出</strong>，通常在区间修改时也需要下放标记</li>
</ul></li>
<li><p>不同操作的线段树：</p>
<ul>
<li>区间内所有值赋为<code>k</code>：懒惰标记初始化为输入范围外的<code>k</code>来表示没有赋值</li>
<li>区间内所有值加<code>k</code>：懒惰标记初始化为<code>0</code></li>
<li>区间内所有值乘<code>k</code>：懒惰标记初始化为<code>1</code></li>
<li>三种操作结合：赋值操作是优先级最高的，乘法操作会影响以前的加法操作，加法操作对其他操作没什么影响
<ul>
<li>对于极大子集(即不着急下放标记的那个分支)：
若为赋值，则应初始化乘法标记、加法标记，因为它们没有意义了
若为乘法，则让乘法标记乘上<code>k</code>，同时会影响以前的加法操作，需要使加法标记乘上<code>k</code>
若为加法，直接让加法标记加上<code>k</code>即可</li>
<li>对于下放操作：
若赋值标记存在，则应首先下放，同时初始化左右儿子的乘法、加法标记
由于乘法标记、加法标记在初始状态下放时，不会对信息造成影响，所以不需要判断是否存在这些标记；且加法标记在之前已经经过处理，可以直接加到左右儿子区间信息上
拿维护最大值举例，下放乘法、加法标记时，左右儿子的最大值需乘上<code>p</code>的乘法标记、再加上<code>p</code>的加法标记；左右儿子的乘法标记直接乘以<code>p</code>的乘法标记；左右儿子的加法标记先乘上<code>p</code>的乘法标记、再加上<code>p</code>的加法标记；最后初始化<code>p</code>的乘法、加法标记</li>
</ul></li>
</ul></li>
<li><p>区间加、区间求和的模板实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, s, lz; <span class="comment">// s表sum</span></span><br><span class="line">&#125;t[<span class="number">100010</span> &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l; <span class="comment">// 初始化结点p管辖的区间</span></span><br><span class="line">    t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; <span class="comment">// 到叶子结点, 可以初始化了</span></span><br><span class="line">        t[p].ans = b[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, l + r &gt;&gt; <span class="number">1</span>); <span class="comment">// 左边</span></span><br><span class="line">    <span class="built_in">bulid</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, (l + r &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, r); <span class="comment">// 右边</span></span><br><span class="line">    t[p].s = t[p &lt;&lt; <span class="number">1</span>].s + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].s;  <span class="comment">// 可以将合并操作单独写一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].lz) &#123; <span class="comment">// 下放标记</span></span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].s += (t[p &lt;&lt; <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>) * t[p].lz;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].s += (t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span>) * t[p].lz;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].lz += t[p].lz;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz += t[p].lz;</span><br><span class="line">        t[p].lz = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">        t[p].s += (t[p].r - t[p].l + <span class="number">1</span>) * v;</span><br><span class="line">        t[p].lz += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> m = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m) <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span>, l, r, v);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; m) <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, v);</span><br><span class="line">    t[p].s = t[p &lt;&lt; <span class="number">1</span>].s + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[p].s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> m = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m) ans += <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; m) ans += <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见区间信息的设计">常见区间信息的设计</h3>
<ul>
<li><p>首先要判断一道题是否能用线段树来做：</p>
<ul>
<li>对题目要求的信息，是否满足<strong>区间可加性</strong>；即是否能由子区间的值求出父区间的值</li>
<li>对要求区间修改的线段树，是否满足<strong>懒惰标记可加性</strong>和区间信息易改，即子结点的懒惰标记可以由父结点下放得到，而父结点可以快速求出整个区间进行某种修改后的值(而不需要递归)
如果不能，看是否能降为暴力单点修改(适用于经过有限次修改后就不再改变的信息)</li>
</ul></li>
<li><p>区间信息及懒惰标记的设计：</p>
<ul>
<li>设计区间信息取决于要求什么样的区间信息：
通常要考虑到怎么通过维护某些<strong>额外的信息</strong>：使得<strong>区间修改时，区间信息易改</strong>
一般是将修改前和修改后的待求信息进行对比，来得出额外信息：
例如区间加+区间和：<span class="math inline">$\begin{align}s=\sum
a_i、s'=\sum(a_i+d)\end{align}$</span>，因此额外信息为<strong>区间长度</strong>
区间加+区间平方和：<span class="math inline">$\begin{align}s=\sum
a_i^2、s'=\sum(a_i+d)^2=s+2d\sum a_i+\sum
d^2\end{align}$</span>，因此额外信息为<strong>区间和、区间长度</strong></li>
<li>设计懒惰标记取决于要进行什么样的区间操作：
懒惰标记要能唯一地标识两个信息，即子区间要不要改、子区间怎么改
例如区间加就将上述两个信息合并，因为懒惰标记为<span
class="math inline">0</span>时，自然表示不用改 其它如区间赋值，因为<span
class="math inline">0</span>不代表不用改，所以需要：一个布尔值标识要不要改，一个值表示要赋的值
或将这个值<strong>初始化设为范围外的值</strong>，来表示不用改</li>
</ul></li>
<li><p>一些常见的区间操作及它们的组合：</p>
<ul>
<li>区间赋值、区间加：不再赘述</li>
<li>区间乘：下放乘标记时直接相乘即可，因为整数的乘法是半群；此外，乘法标记初始化为<span
class="math inline">1</span></li>
</ul></li>
<li><p>一些常见的区间信息：</p>
<ul>
<li>区间<code>hash</code>：区间哈希一般用于比较两个区间是否相等，用树状数组也可
学过字符串哈希就知道，求一个区间的基本哈希值是将它看作<span
class="math inline"><em>p</em></span>进制数，即 <span
class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em>(<em>a</em>[1,<em>n</em>]) = <em>a</em><sub>1</sub><em>p</em><sup><em>n</em> − 1</sup> + <em>a</em><sub>2</sub><em>p</em><sup><em>n</em> − 2</sup> + ⋯ + <em>a</em><sub><em>n</em> − 1</sub><em>p</em> + <em>a</em><sub><em>n</em></sub></span>
这其实有点像前缀和，只是多了一个<span
class="math inline"><em>p</em></span>的幂的因子，通过简单推导可以得出：
<span
class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em>(<em>a</em>[1,<em>r</em>]) = <em>h</em><em>a</em><em>s</em><em>h</em>(<em>a</em>[1,<em>l</em>−1]) × <em>p</em><sup><em>r</em> − <em>l</em> + 1</sup> + <em>h</em><em>a</em><em>s</em><em>h</em>(<em>a</em>[<em>l</em>,<em>r</em>])</span>
也就是：<span
class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em>(<em>a</em>[<em>l</em>,<em>r</em>]) = <em>h</em><em>a</em><em>s</em><em>h</em>(<em>a</em>[<em>l</em>,<em>m</em>]) × <em>p</em><sup><em>r</em> − <em>m</em></sup> + <em>h</em><em>a</em><em>s</em><em>h</em>(<em>a</em>[<em>m</em>+1,<em>r</em>])</span>
这里不考虑如何解决冲突，选择一个<strong>大质数</strong>作为模数和<strong>比<span
class="math inline"><em>m</em><em>a</em><em>x</em>(<em>a</em>)</span>大的<span
class="math inline"><em>p</em></span></strong>即可
再不济，就用双值哈希</li>
</ul></li>
<li><p>特定区间的最大连续子区间和(所有连续子区间中，元素和最大的子区间)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">int</span> i, n, m, k, a, b, gd[<span class="number">500005</span>];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">      <span class="type">int</span> lm, rm, am, ll, rr, sum;</span><br><span class="line">  &#125;tr[<span class="number">500005</span> &lt;&lt; <span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">edit</span><span class="params">(Info&amp; p, Info sl, Info sr)</span> </span>&#123;</span><br><span class="line">      p.lm = <span class="built_in">max</span>(sl.lm, sl.sum + sr.lm);</span><br><span class="line">      p.rm = <span class="built_in">max</span>(sr.rm, sr.sum + sl.rm);</span><br><span class="line">      p.sum = sl.sum + sr.sum;</span><br><span class="line">      p.am = <span class="built_in">max</span>(<span class="built_in">max</span>(sl.am, sr.am), (sl.rm &lt; <span class="number">0</span> &amp;&amp; sr.lm) ? <span class="built_in">max</span>(sl.rm, sr.lm) : <span class="built_in">max</span>(<span class="number">0</span>, sl.rm) + <span class="built_in">max</span>(<span class="number">0</span>, sr.lm));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">      tr[p].ll = l;</span><br><span class="line">      tr[p].rr = r;</span><br><span class="line">      <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">          tr[p].lm = tr[p].rm = tr[p].am = tr[p].sum = gd[l];</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">      <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line">      <span class="built_in">edit</span>(tr[p], tr[p &lt;&lt; <span class="number">1</span>], tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t, <span class="type">int</span> v)</span> </span>&#123; <span class="comment">// 单点修改</span></span><br><span class="line">      <span class="keyword">if</span> (tr[p].ll == tr[p].rr &amp;&amp; tr[p].ll == t) &#123;</span><br><span class="line">          tr[p].lm = tr[p].rm = tr[p].am = tr[p].sum = v;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> m = tr[p].ll + tr[p].rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (t &lt;= m) &#123;</span><br><span class="line">          <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span>, t, v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, t, v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">edit</span>(tr[p], tr[p &lt;&lt; <span class="number">1</span>], tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= tr[p].ll &amp;&amp; r &gt;= tr[p].rr) &#123;</span><br><span class="line">          <span class="keyword">return</span> tr[p];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> m = tr[p].ll + tr[p].rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= m &amp;&amp; r &gt; m) &#123;</span><br><span class="line">          Info ans;</span><br><span class="line">          <span class="built_in">edit</span>(ans, <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r), <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">较复杂线段树：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, i, opt, L, R;</span><br><span class="line"><span class="type">bool</span> a[<span class="number">100006</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">bool</span> fil, filv, swt;</span><br><span class="line">    <span class="type">int</span> l, r, lm[<span class="number">2</span>], rm[<span class="number">2</span>], am[<span class="number">2</span>], sum, len;</span><br><span class="line">    <span class="built_in">Info</span>() &#123;</span><br><span class="line">        fil = swt = lm[<span class="number">0</span>] = lm[<span class="number">1</span>] = rm[<span class="number">0</span>] = rm[<span class="number">1</span>] = am[<span class="number">0</span>] = am[<span class="number">1</span>] = sum = len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[<span class="number">100006</span> &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Info&amp; p, Info l, Info r)</span> </span>&#123;</span><br><span class="line">    p.lm[<span class="number">0</span>] = l.lm[<span class="number">0</span>] + (l.lm[<span class="number">0</span>] == l.len ? r.lm[<span class="number">0</span>] : <span class="number">0</span>);</span><br><span class="line">    p.lm[<span class="number">1</span>] = l.lm[<span class="number">1</span>] + (l.lm[<span class="number">1</span>] == l.len ? r.lm[<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">    p.rm[<span class="number">0</span>] = r.rm[<span class="number">0</span>] + (r.rm[<span class="number">0</span>] == r.len ? l.rm[<span class="number">0</span>] : <span class="number">0</span>);</span><br><span class="line">    p.rm[<span class="number">1</span>] = r.rm[<span class="number">1</span>] + (r.rm[<span class="number">1</span>] == r.len ? l.rm[<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">    p.am[<span class="number">0</span>] = <span class="built_in">max</span>(l.rm[<span class="number">0</span>] + r.lm[<span class="number">0</span>], <span class="built_in">max</span>(l.am[<span class="number">0</span>], r.am[<span class="number">0</span>]));</span><br><span class="line">    p.am[<span class="number">1</span>] = <span class="built_in">max</span>(l.rm[<span class="number">1</span>] + r.lm[<span class="number">1</span>], <span class="built_in">max</span>(l.am[<span class="number">1</span>], r.am[<span class="number">1</span>]));</span><br><span class="line">    p.len = l.len + r.len;</span><br><span class="line">    p.sum = l.sum + r.sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[p].l = l;</span><br><span class="line">    tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[p].len = <span class="number">1</span>;</span><br><span class="line">        tr[p].lm[<span class="number">0</span>] = tr[p].rm[<span class="number">0</span>] = tr[p].am[<span class="number">0</span>] = !a[l];</span><br><span class="line">        tr[p].lm[<span class="number">1</span>] = tr[p].rm[<span class="number">1</span>] = tr[p].am[<span class="number">1</span>] = tr[p].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, l + r &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, (l + r &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">merge</span>(tr[p], tr[p &lt;&lt; <span class="number">1</span>], tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].fil) &#123;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].fil = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].fil = <span class="literal">true</span>;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].swt = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].swt = <span class="literal">false</span>;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].filv = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].filv = tr[p].filv;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].lm[tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span>].rm[tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span>].am[tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span>].len;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].lm[!tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span>].rm[!tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span>].am[!tr[p].filv] = <span class="number">0</span>;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].sum = tr[p].filv ? tr[p &lt;&lt; <span class="number">1</span>].len : <span class="number">0</span>;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lm[tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rm[tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].am[tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lm[!tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rm[!tr[p].filv] = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].am[!tr[p].filv] = <span class="number">0</span>;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum = tr[p].filv ? tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len : <span class="number">0</span>;</span><br><span class="line">        tr[p].fil = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].swt) &#123;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].swt = !tr[p &lt;&lt; <span class="number">1</span>].swt;</span><br><span class="line">        <span class="built_in">swap</span>(tr[p &lt;&lt; <span class="number">1</span>].am[<span class="number">0</span>], tr[p &lt;&lt; <span class="number">1</span>].am[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(tr[p &lt;&lt; <span class="number">1</span>].rm[<span class="number">0</span>], tr[p &lt;&lt; <span class="number">1</span>].rm[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(tr[p &lt;&lt; <span class="number">1</span>].lm[<span class="number">0</span>], tr[p &lt;&lt; <span class="number">1</span>].lm[<span class="number">1</span>]);</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span>].sum = tr[p &lt;&lt; <span class="number">1</span>].len - tr[p &lt;&lt; <span class="number">1</span>].sum;</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].swt = !tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].swt;</span><br><span class="line">        <span class="built_in">swap</span>(tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].am[<span class="number">0</span>], tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].am[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rm[<span class="number">0</span>], tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rm[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lm[<span class="number">0</span>], tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lm[<span class="number">1</span>]);</span><br><span class="line">        tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len - tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">        tr[p].swt = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[p].l &amp;&amp; r &gt;= tr[p].r) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                tr[p].fil = <span class="literal">true</span>;</span><br><span class="line">                tr[p].filv = mode;</span><br><span class="line">                tr[p].lm[mode] = tr[p].rm[mode] = tr[p].am[mode] = tr[p].len;</span><br><span class="line">                tr[p].lm[!mode] = tr[p].rm[!mode] = tr[p].am[!mode] = <span class="number">0</span>;</span><br><span class="line">                tr[p].sum = mode ? tr[p].len : <span class="number">0</span>;</span><br><span class="line">                tr[p].swt = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                tr[p].swt = !tr[p].swt;</span><br><span class="line">                <span class="built_in">swap</span>(tr[p].am[<span class="number">0</span>], tr[p].am[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">swap</span>(tr[p].rm[<span class="number">0</span>], tr[p].rm[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">swap</span>(tr[p].lm[<span class="number">0</span>], tr[p].lm[<span class="number">1</span>]);</span><br><span class="line">                tr[p].sum = tr[p].len - tr[p].sum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> m = tr[p].l + tr[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">        <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span>, l, r, mode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; m) &#123;</span><br><span class="line">        <span class="built_in">update</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, mode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(tr[p], tr[p &lt;&lt; <span class="number">1</span>], tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[p].l &amp;&amp; r &gt;= tr[p].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> m = tr[p].l + tr[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Info ans1, ans2, ans;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">        ans1 = <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; m) &#123;</span><br><span class="line">        ans2 = <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(ans, ans1, ans2);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; L &gt;&gt; R;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>, L + <span class="number">1</span>, R + <span class="number">1</span>, opt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, L + <span class="number">1</span>, R + <span class="number">1</span>).sum &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, L + <span class="number">1</span>, R + <span class="number">1</span>).am[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态开点线段树">动态开点线段树</h3>
<ul>
<li><p>使用<code>p &lt;&lt; 1</code>和<code>p &lt;&lt; 1 | 1</code>作为结点的左右儿子编号，显然是很浪费空间的(因为部分结点可能从不会被读、被写)
所以一个自然的优化是，用我们维护的<code>cnt</code>记录当前的总结点数，然后需要创建新的结点时(即需要访问从未维护过的子区间时)将<code>cnt+1</code>作为其编号，并找到有直接父子关系的结点，维护其<code>ls</code>或<code>rs</code>(就像存储二叉树那样)
这样的话，通常只需要<span
class="math inline">4<em>m</em>log <em>n</em></span>(<span
class="math inline"><em>m</em></span>为查询次数)的空间，如果<span
class="math inline"><em>m</em> ≤ 10<sup>5</sup>、<em>n</em> ≤ 10<sup>9</sup></span>，那么大概需要<span
class="math inline">10<sup>7</sup></span>空间；当然，如果<span
class="math inline"><em>n</em></span>较小，那是没有必要用动态开点的(除非要实现更复杂的数据结构)
需要说明，区间信息必须<strong>能快速地初始化</strong>，否则如果要依赖子结点的区间信息，那么用动态开点就没有意义了</p></li>
<li><p>代码实现：和一般线段树相比，不需要建树，只多了一步判断是否需要新增结点的操作
很多参数的设计是需要根据题意修改的，这里仅提供一个区间加、求区间和的模板</p>
<p>```c++ int n, cnt, rt; // 以1作为根结点 long long pre[MAXN]; //
假设已经预处理好了前缀和, 注意这样无法处理n过大的情况 const int LEN =
适合的大小; int ls[LEN], rs[LEN]; struct Info{ long long s, lz; //
因为无法事先初始化, 所以结点就不存l, r了 }t[LEN]; void init(int&amp; p,
int l, int r) { p = ++cnt; t[p].s = pre[r] - pre[l - 1]; } void
pushdown(int p, int l, int r) { if (t[p].lz) { int m = l + r &gt;&gt; 1;
if (!ls[p]) init(ls[p], l, m); // 子结点未创建 if (!rs[p]) init(rs[p], m
+ 1, r); t[ls[p]].s += t[p].lz * (m - l + 1); t[rs[p]].s += t[p].lz * (r
- m); t[p].lz = 0; } } void update(int&amp; p, int l, int r, int L, int
R, int v) { if (!p) init(p, L, R); if (l &lt;= L &amp;&amp; r &gt;= R) {
t[p].s += v * (R - L + 1); t[p].lz += v; return; } pushdown(p, L, R);
int m = L + R &gt;&gt; 1; if (l &lt;= m) update(ls[p], l, r, L, m, v);
if (r &gt; m) update(rs[p], l, r, m + 1, R, v); t[p].s = t[ls[p]].s +
t[rs[p]].s; } void query(int&amp; p, int l, int r, int L, int R) { if
(!p) init(p, L, R); if (l &lt;= L &amp;&amp; r &gt;= R) { return t[p].s;
} pushdown(p, L, R); int m = L + R &gt;&gt; 1; long long ans = 0; if (l
&lt;= m) ans += query(ls[p], l, r, L, m); if (r &gt; m) ans +=
query(rs[p], l, r, m + 1, R); return ans; }</p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 数据结构与算法</title>
    <url>/blogs/2025/04/10/java-collection/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="java数据结构与算法"><code>Java</code>数据结构与算法</h1>
<h2 id="包装类">包装类</h2>
<h3 id="概念">概念</h3>
<ul>
<li><p><code>java</code>中只有八种基础数据类型，都是全小写的，出于一切皆对象的理念和泛型参数对引用类型的需求，<code>java</code>提供了八个包装类</p></li>
<li><p>其中，<code>Number</code>是所有数值类型<code>Byte、Short、Integer、Long、Float、Double</code>的基类</p></li>
<li><p><code>Character</code>和<code>Boolean</code>对应<code>char</code>和<code>boolean</code></p></li>
<li><p>虽说包装类是引用类型，但它们的<strong>构造方法已经被弃用</strong>，取而代之的是自动装箱机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;                <span class="comment">// 自动装箱, 不需要new</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);   <span class="comment">// 已被弃用</span></span><br></pre></td></tr></table></figure></li>
<li><p>包装类的存储位置：</p>
<ul>
<li><p>当数值是一个整型且范围为<code>-128~127</code>时，<code>JVM</code>会使用<strong>缓存池</strong>中的数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i == i2;            <span class="comment">// 将返回true, 虽然i和i2都是引用, 但由于使用的是缓存池中的值, 所以i和i2指向同一份内存</span></span><br></pre></td></tr></table></figure></li>
<li><p>其余情况，每次声明包装类的对象并初始化时，<code>JVM</code>均会在堆中创建新对象</p></li>
</ul></li>
<li><p>关于常量池的细节：要求这个类实现<code>Constable</code>接口，则<code>JVM</code>会将这个类的对象存储在常量池</p>
<p>例如包装类、<code>String</code>、<code>Enum</code>等都实现了该接口</p></li>
</ul>
<h3 id="number及其子类"><code>Number</code>及其子类</h3>
<ul>
<li><code>Number</code>是一个<strong>抽象类</strong>，在<code>java.lang</code>包下，常用实例方法如下：
<ul>
<li><code>typeValue()</code>：将对象转化为类型为<code>type</code>的值，例如<code>byteValue()</code>等</li>
</ul></li>
<li>整型包装类，<code>Integer、Short、Byte、Long</code>，以<code>Integer</code>为例：
<ul>
<li>构造器：<code>Integer(String)</code>和<code>Integer(int)</code></li>
<li>常用静态成员：<code>MAX_VALUE</code>和<code>MIN_VALUE</code></li>
<li>常用实例方法：
<ul>
<li><code>boolean compareTo()</code>：实现了<code>Comparable</code>接口</li>
<li><code>String toString()</code>：实现了转字符串方法</li>
</ul></li>
<li>常用静态方法：
<ul>
<li><code>int bitCount(int)</code>：返回二进制表示中<code>1</code>的个数</li>
<li><code>int parseInt(String, int)</code>：将字符串解析为整数，第二个参数可选，表示基数</li>
<li><code>Integer valueOf(String, int)</code>：同上，但是返回引用对象</li>
<li><code>int signum(int)</code>：返回符号函数值</li>
<li><code>String toString(int)</code>：将一个基础数据类型的整型转化为字符串</li>
<li><code>String toHexString(int)</code>：转十六进制字符串，其它进制如<code>toBinaryString()、toOctalString()</code></li>
</ul></li>
</ul></li>
<li>浮点数包装类，<code>Double、Float</code>，以<code>Double</code>为例：
<ul>
<li>构造器类似整型类</li>
<li>常用静态成员：
<ul>
<li><code>MAX_VALUE</code>和<code>MIN_VALUE</code></li>
<li><code>NaN</code>：不是一个数</li>
<li><code>POSITIVE_INFINITY</code>和<code>NEGETIVE_INFINITY</code>：正负无穷</li>
</ul></li>
<li>常用实例方法：
<ul>
<li><code>boolean isInfinite()</code>：是否为无穷</li>
<li><code>boolean isNaN()</code>：是否为<code>NaN</code></li>
<li><code>String toStirng()</code>：转字符串</li>
</ul></li>
<li>常用静态方法：
<ul>
<li>同样有<code>parseDouble()、toString()、valueOf()</code>系列方法</li>
<li>还有<code>isFinite()、isInfinite()、isNaN()</code>等判断方法</li>
</ul></li>
</ul></li>
</ul>
<h2 id="数组">数组</h2>
<h3 id="语法糖"><code>[]</code>语法糖</h3>
<ul>
<li><p>通过<code>type[]</code>可声明一个类型为<code>type</code>的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[N];     <span class="comment">// 允许N是变量, 即允许动态绑定</span></span><br></pre></td></tr></table></figure></li>
<li><p>只能通过初始化设定数组具体的值，编译器自动解析数组的长度</p></li>
<li><p><code>length</code>是静态数组最重要的属性，用于获取其长度</p></li>
<li><p>由于静态数组本质是一个引用类型，一个引用可以随时更换其指向，因此二维数组每一行的元素个数可以不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][];    <span class="comment">// 声明一个长度为8的二维数组, 每一行的元素个数未知(为null)</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];           <span class="comment">// 将int[3]赋给a[0]</span></span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">9</span>];   <span class="comment">// 声明一个长度为8的二维数组, 每一行都是int[9]对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="array"><code>Array</code></h3>
<ul>
<li><code>java</code>的数组实际上是<code>java.lang.reflect.Array</code>类的对象，其构造方法是私有的</li>
<li><code>Array</code>本身并不提供更多的方法，而是归纳于集合框架里的<code>Arrays</code>类和<code>Collections</code>类</li>
</ul>
<h2 id="字符串">字符串</h2>
<h3 id="charsequence"><code>CharSequence</code></h3>
<ul>
<li><code>CharSequence</code>(字符序列)是一个接口，字符串类均实现了该接口</li>
<li>该接口的常用方法包括：
<ul>
<li><code>char charAt(int)</code>：<code>0-idx</code>地获取字符串的字符</li>
<li><code>boolean isEmpty()</code>：判空</li>
<li><code>int length()</code>：返回长度</li>
<li><code>String toString()</code>：返回<code>String</code>对象</li>
</ul></li>
</ul>
<h3 id="string"><code>String</code></h3>
<ul>
<li><p><code>String</code>是一个<strong>不可变类</strong>，其所有属性都被<code>final</code>修饰</p></li>
<li><p>和包装类的整型常量池同样道理，字符串常用所以不应该经常在堆中创建，希望它能够成为一个封装好的字面量，因此<code>String</code>变量同样有两种初始化方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;     <span class="comment">// 在字符串常量池中检索, 若没有则创建, 若有则指向它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;    <span class="comment">// s == s2 将返回 true</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);    <span class="comment">// 单独在堆中创建, 其内容是&quot;123&quot;的副本, 因此 s2 == s3 将返回 false</span></span><br></pre></td></tr></table></figure>
<p>如果你尝试使用<code>String(String)</code>构造器而不是<code>String(StringBuilder)</code>或其它构造器，你会受到警告<code>Unless an explicit copy of original is needed, use of this constructor is unnecessary since Strings are immutable.</code>，即除非真的需要原字符串的副本，否则使用这样的构造器是不必要的，因为<code>String</code>对象是不可变的</p>
<p>重新复习一下不可变对象：其属性全都被<code>final</code>修饰，只能通过用<code>=</code>赋值修改变量的指向，而不能通过该对象的方法修改其指向的值</p></li>
<li><p><code>String</code>实现了<code>CharSequence</code>接口的方法，除此之外还包括以下常用方法：</p>
<ul>
<li>构造器：接受<code>byte[]</code>或<code>char[]</code>或<code>StringBuilder</code>或<code>StringBuffer</code>或<code>String</code>参数</li>
<li>常用实例方法：
<ul>
<li><code>String concat(String)</code>：返回拼接后的字符串，和<code>+</code>语法糖效果一致</li>
<li><code>boolean contains(CharSequence)</code>：判断是否包含目标字符序列，可以是任何实现了该接口的类</li>
<li><code>boolean contentEquals(CharSequence)</code>：因为不止含<code>String</code>一个字符串类，<code>StringBuilder</code>等不是<code>String</code>的子类，通过<code>contentEquals()</code>可以快速判断两个类型不同的字符串是否内容相等，用<code>s.equals(sb.toString())</code>也可</li>
<li><code>boolean equalsIgnoreCase(String)</code>：忽略大小写地判断两个<code>String</code>是否相等</li>
<li><code>byte[] getBytes()</code>：以默认编码转换为<code>byte[]</code>，<code>JVM</code>默认编码为操作系统的编码集
可以传递字符集参数例如<code>getBytes("GBK")</code>或<code>getBytes("UTF-8")</code>解析为对应编码的字节数组，再用<code>new String(byte[], String charset)</code>转化为<code>String</code>对象</li>
<li><code>int indexOf(s)</code>：找到字符或子串<code>s</code>的起始位置，找不到返回<code>-1</code>，诸如<code>indexOf(char)</code>或<code>indexOf(String)</code>，还可以加上<code>fromIndex</code>和<code>endIndex</code>参数
需要注意的是<code>java</code>没有正整数一说，若找不到，返回<code>-1</code>，是不会像<code>cpp</code>一样等同于无穷大的</li>
<li><code>int lastIndexOf()</code>：和<code>indexOf()</code>的区别是，从右开始找</li>
<li><code>int length()</code>：返回长度</li>
<li><code>boolean matches(String regex)</code>：判断字符串是否匹配正则表达式<code>regex</code></li>
<li><code>String replace(char, char)</code>：将所有的前者字符改为后者字符，该方法还有一个字符串替换成字符串的重载版本</li>
<li><code>String[] split(String regex)</code>：根据正则表达式<code>regex</code>匹配字符串，并以匹配成功的子串为分隔，分割字符串</li>
<li><code>String toUpperCase()</code>和<code>String toLowerCase()</code></li>
<li><code>String trim()</code>：去除前后空白(包括空格、制表符)</li>
<li><code>String substring(int begin, int offset)</code>：获取子串<code>[begin, begin + offset)</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="stringbuilder"><code>StringBuilder</code></h3>
<ul>
<li>先讲一下<code>StringBuffer</code>类，这是十分古老的<code>java</code>提供的可变字符串类，是线程安全的
但就算是线程安全的，也不能完全保证拼接的逻辑正确，反而因为加锁导致开销极大，因此基本没有适用场景</li>
<li>因此，<code>StringBuilder</code>类应运而生，它实现了<code>CharSequence</code>接口和<code>Appendable</code>接口，提供以下方法：
<ul>
<li><code>indexOf()</code>系列</li>
<li><code>append()</code>系列</li>
<li><code>delete()</code>系列</li>
<li><code>insert()</code>系列</li>
<li><code>StringBuilder reverse()</code>：使该对象逆序，然后返回它自己</li>
<li><code>void setCharAt(int, char)</code>：将前者指向的字符改为后者</li>
</ul></li>
</ul>
<h2 id="集合框架">集合框架</h2>
<h3 id="iterablee接口"><code>Iterable&lt;E&gt;</code>接口</h3>
<ul>
<li><p><code>Iterable&lt;E&gt;</code>是所有元素集合都实现了的接口</p></li>
<li><p><code>Iterator&lt;E&gt; iterator()</code>：获取一个迭代器</p></li>
<li><p><code>void forEach(Consumer&lt;? super E&gt;)</code>：为集合的每一个元素都执行一遍你提供的<code>lambda</code>表达式</p></li>
<li><p>所有实现了<code>Iterable</code>接口的类均可使用语法糖<code>for (type e : c)</code>，其中<code>e</code>是临时变量，是集合对象<code>c</code>中的元素</p></li>
<li><p><code>Iterator&lt;E&gt;</code>接口包含以下方法：</p>
<ul>
<li><code>boolean hasNext()</code>：判断是否有下一个元素</li>
<li><code>E next()</code>：返回下一个元素，若没有则抛出<code>NoSuchElementException</code>异常</li>
<li><code>void remove()</code>：用于安全地删除当前元素
在使用迭代器遍历时，一旦通过对象进行增删行为，调用迭代器的方法将抛出异常
因此应该使用迭代器的<code>remove()</code>删除当前指向的元素
当当前迭代器从未使用过<code>next()</code>或已经使用过<code>remove()</code>时，调用<code>remove()</code>将抛出<code>IllegalStateException</code>异常</li>
</ul></li>
<li><p><code>Iterator</code>以及集合框架是随着泛型的实现而出现的，传统的枚举器是<code>Enumeration</code>接口，现在已经很少使用</p></li>
<li><p>通过非语法糖的方式遍历集合的方法如下(如果需要在遍历过程中删除元素)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list;</span><br><span class="line"><span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  <span class="type">var</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="number">1</span>) &#123;</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为什么<code>Iterator</code>是一个接口，在文档中也找不到实现它的类，为什么能获取到一个实例化的对象？</p>
<p>因为实现这个接口的是在各个容器内部定义的私有内部类</p></li>
</ul>
<h3 id="collectione接口"><code>Collection&lt;E&gt;</code>接口</h3>
<ul>
<li><code>Collection&lt;E&gt;</code>接口继承自<code>Iterable</code>接口，所有元素集合都实现了该接口</li>
<li>定义的方法如下，实现它的类可以有不同的实现，但语义满足：
<ul>
<li><code>boolean add(E)</code>：调用后，集合中应能够找到该元素</li>
<li><code>void clear()</code>：调用后，集合应没有元素</li>
<li><code>boolean contains(Object)</code>：若集合存在该对象应返回<code>true</code></li>
<li><code>boolean isEmpty()</code>：若集合为空应返回<code>true</code></li>
<li><code>boolean remove(Object)</code>：若该对象存在于集合中，调用该方法后应保证删除它</li>
<li><code>int size()</code>：应返回集合的长度</li>
<li><code>Object[] toArray()</code>：应返回由集合中元素构成的静态数组</li>
</ul></li>
</ul>
<h3 id="liste接口"><code>List&lt;E&gt;</code>接口</h3>
<ul>
<li><code>List</code>接口继承自<code>Collection</code>接口，所有有序集合(列表)都实现了该接口</li>
<li>该接口额外包含以下常用方法：
<ul>
<li><code>void add(int idx, E)</code>：向第<code>idx</code>位置插入元素，<code>0-idx</code></li>
<li><code>void set(int idx, E)</code>：设置第<code>idx</code>位置的元素</li>
<li><code>E get(int)</code>：获取指定位置的元素</li>
<li><code>E getFirst()</code>和<code>E getLast()</code></li>
<li><code>void remove(int)、E removeFirst()、E removeLast()</code></li>
<li><code>List&lt;E&gt; subList(int, int)</code>：获取子列表，以视图形式存在(没有在堆中新分配内存)</li>
</ul></li>
<li>实现<code>List</code>接口的常用类有<code>ArrayList、LinkedList、Vector、Stack</code>，分别是数组实现、链表实现、线程安全列表、线程安全栈，其中<code>LinkedList</code>类还实现了<code>Deque</code>接口</li>
</ul>
<h3 id="sete接口"><code>Set&lt;E&gt;</code>接口</h3>
<ul>
<li><code>Set</code>接口同样继承自<code>Collection</code>接口，所有唯一性集合都实现了该接口</li>
<li><code>Set</code>本身没有提供更多的方法，实现它的常用类有<code>HashSet、TreeSet、LinkedHashSet</code>，分别是哈希表实现(乱序)、红黑树实现(键有序)、哈希表实现(插入顺序排序)</li>
</ul>
<h3
id="queuee和dequee接口"><code>Queue&lt;E&gt;</code>和<code>Deque&lt;E&gt;</code>接口</h3>
<ul>
<li><code>Queue</code>接口同样继承自<code>Collection</code>接口，所有只操作端元素的集合都实现了该接口</li>
<li><code>Queue</code>接口提供了额外的方法，它们的功能和<code>Collection</code>接口定义的方法有对应关系，但<code>Queue</code>新增的方法在操作失败时会返回特殊值，而<code>Collection</code>的方法会抛出异常
<ul>
<li><code>offer()</code>和<code>add()</code></li>
<li><code>peek()</code>和<code>element()</code></li>
<li><code>poll()</code>和<code>remove()</code></li>
</ul></li>
<li><code>Deque</code>接口猜都能猜到，在方法名后加<code>First</code>和<code>Last</code></li>
<li>实现了<code>Queue</code>的常用类有<code>PriorityQueue</code>(优先队列)和<code>ArrayDeque</code>(数组实现的双端队列)</li>
</ul>
<h3 id="mapk-v接口"><code>Map&lt;K, V&gt;</code>接口</h3>
<ul>
<li><code>Map</code>接口并不继承<code>Iterable</code>和<code>Collection</code>，所有映射集合都实现了该接口</li>
<li><code>Map</code>提供的常用方法有：
<ul>
<li><code>clear()</code></li>
<li><code>containsKey()</code>和<code>containsValue()</code></li>
<li><code>V get(K)</code></li>
<li><code>put(K, V)</code></li>
<li><code>remove(Object)</code></li>
</ul></li>
<li>含有公有内部类<code>Entry&lt;K, V&gt;</code></li>
<li>实现了<code>Map</code>接口的常用类有<code>HashMap、TreeMap、HashTable、WeakHashMap、LinkedMap</code>，分别是哈希表实现、红黑树实现、线程安全的哈希表实现、基于弱引用的哈希表实现、哈希表实现(插入顺序排序)</li>
</ul>
<h2 id="内置算法">内置算法</h2>
<h3 id="math"><code>Math</code></h3>
<h3 id="arrays"><code>Arrays</code></h3>
<h3 id="collections"><code>Collections</code></h3>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛: 常数优化之快读快写</title>
    <url>/blogs/2025/04/07/algo-fastio/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="快读快写">快读快写</h3>
<ul>
<li><p>快读有两套模板：</p>
<ul>
<li><p>使用内置<code>getchar()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, sig = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sig = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sig * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用文件<code>fread()</code>加速<code>getchar()</code>：此后不能再通过终端输入数据，但在<code>OI</code>是可行的因为输入数据都是文件</p>
<p>```c++ // 即, 一次性将文件所有内容读入buf,
然后让p1(文件开头)递增到p2(文件结尾)处, 每次调用递增一次并返回字符 //
这里的判断条件分为两部分 // 1: p1 == p2 初始状态时,
会立刻执行条件2读入文件 // 2: p2 = (p1 = buf) + fread(), p1 == p2
执行后, p1在文件开头, p2在文件结尾 // 读入后, 若p1 == p2则立刻返回EOF,
否则返回第一个字符, p1递增 // 此后调用gc(), 除非到达文件结尾,
否则不会进入2, 直接返回<em>p1后递增 // 到达文件结尾后,
由于stdin没有字符了, 这里调用fread()也没有变化, p1 == p2 == buf //
fread()最多调用2次, 相当于将文本一次性读到缓冲区 #define gc() (p1 == p2
&amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 ==
p2) ? EOF : </em>p1++) char buf[1 &lt;&lt; 23], <em>p1 = buf, </em>p2 =
buf; int read() { int x = 0, sig = 1; char ch = gc(); while
(!isdigit(ch)) { if (ch == ‘-’) { sig = -1; } ch = gc(); } while
(isdigit(ch)) { x = x * 10 + (ch - ‘0’); ch = getchar(); } return sig *
x; }</p></li>
</ul></li>
<li><p>快写：</p>
<p>```c++ void write(long long x) { if (x &lt; 0) { putchar(‘-’); x =
-x; } if (x &gt; 9) { write(x / 10); } putchar(x % 10 + ‘0’); }</p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Trick</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 异常处理</title>
    <url>/blogs/2025/04/04/java-exception/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="java异常处理"><code>Java</code>异常处理</h2>
<h3 id="异常的分类">异常的分类</h3>
<ul>
<li><p>所有异常分为受检异常、非受检异常、错误</p></li>
<li><p>声明某方法可能会抛出某异常：<code>throws</code>关键字
在某方法内抛出某异常<code>new</code>后跟一个异常类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>受检异常：编译器会在编译期检查的异常，如果用户的某个方法<strong>调用了会抛出受检异常的方法</strong>，但既没有<strong>处理</strong>也没有<strong>显式地抛出</strong>，就会有红色波浪线提醒
所有受检异常都是<code>Exception</code>的子类且不是<code>RuntimeException</code>的子类
受检异常一般表示程序员无法控制的异常，它们必须包含显式处理，例如由文件系统发出的、动态引入库发出的等</p></li>
<li><p>非受检异常：运行时可能抛出的异常，不需要显式地用<code>throws</code>声明
所有非受检异常都是<code>RuntimeException</code>的子类
非受检异常一般表示程序员能够通过提高编程技巧而避免的异常</p></li>
<li><p>错误：这种异常是脱离程序的，可能是硬件出了问题，例如内存溢出</p></li>
</ul>
<h3 id="异常的实质">异常的实质</h3>
<ul>
<li><pre><code class="highlight mermaid">graph TD
Throwable --&gt; Error
Throwable --&gt; Exception
Exception --&gt; RuntimeException
Exception --- Checked((&quot;检查性异常\nChecked Exception&quot;)) --&gt; IOException
RuntimeException --&gt; A(...)
Checked --&gt; ParseException
Checked --&gt; ...</code></pre></li>
<li>所有异常和错误类都实现了<code>Throwable</code>接口</li>
<li>自定义异常：很简单，只需要根据需求继承<code>Exception</code>或<code>RuntimeException</code>(通常是后者)并实现构造方法即可
通常由业务层抛出，用户接口层捕获并处理</li>
<li>子类重写的方法抛出的<strong>受检异常范围</strong>不能比父类方法<code>throws</code>的<strong>受检异常</strong>范围大</li>
</ul>
<h3 id="异常处理">异常处理</h3>
<ul>
<li><code>catch-try-finally</code>：<code>finally</code>可选，表示<code>try</code>后(即时出现异常)必须执行的代码块，例如关闭文件等</li>
<li><code>try-with-resource</code>：指在<code>try()</code>中定义需要<code>close()</code>的资源，此时不需要使用<code>finally</code>就可自动关闭<code>try</code>的资源</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统: 进程管理</title>
    <url>/blogs/2025/04/03/os-process/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="进程组成">进程组成</h3>
<ul>
<li><p>进程(<code>Process</code>)是程序的执行过程，也即运行中的程序；一个进程即某个程序在给定输入下的一次执行</p>
<ul>
<li>在其它<code>OS</code>中，可称为作业(<code>Job</code>)、任务(<code>Task</code>)</li>
<li>在宏观上，进程支持多任务，看起来进程在“同时”执行，是<strong>并发</strong>的
不同进程是<strong>串行执行</strong>的(通过调度分时执行)</li>
</ul></li>
<li><p>多任务环境下，进程是<code>OS</code><strong>分配资源的基本单位</strong></p>
<ul>
<li>多任务(<code>Multitasking</code>)是现代操作系统的基本属性</li>
<li>最早为<strong>批处理系统</strong>(<code>Batch System</code>)，通过将一系列任务打包送给操作系统队列运行而非人工提交单个任务，来提高<code>CPU</code>利用率
由单道(内存中只载入一个任务)到多道(前方任务进行<code>I/O</code>读写等操作时使<code>CPU</code>处理后方任务)，均为批处理系统
现代提供特定的交互功能(用户可干预进程的优先级、状态等)并进行优化，成为专用的多任务系统</li>
</ul></li>
<li><p>进程的结构：</p>
<ul>
<li><code>PCB</code>(<code>Process Control Block</code>，进程控制块)：管理进程的唯一数据结构
<ul>
<li><code>PID</code>：唯一标识一个进程的标识符</li>
</ul></li>
<li>进程映像：<strong>独立</strong>的存储进程地址的内存空间，包含指向各种数据的地址指针</li>
<li>数据段</li>
</ul></li>
<li><p>进程的控制功能：</p>
<ul>
<li>创建/撤销</li>
<li>阻塞：进程提出系统请求，但内核未响应时，将调用阻塞命令</li>
<li>唤醒：阻塞进程所等待的事件完成/发生，将调用唤醒命令</li>
</ul></li>
<li><p>进程状态：</p>
<p><span class="math display">$$\begin{align}&amp;\rm
new\stackrel{admitted}\rightarrow
ready\stackrel{interrupt}\leftrightarrows
running\stackrel{exit}\rightarrow terminated\\&amp;\ \ \ \rm \ \ \ \ \ \
\ \ \ {\small事件发生}\uparrow\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
\downarrow{\small等待事件}\\&amp;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
\ \ \ \ \ \ \ \ \ \ \ \rm waiting\end{align}$$</span>
有时因内存空间不足，<code>OS</code>会将一些进程主动移出内存(放入交换空间)，称为<strong>挂起</strong>
被挂起的进程可能处于就绪或等待状态，因此挂起队列有两种
挂起等待进程在等待事件发生后，变为挂起就绪
取消挂起状态需要由<code>OS</code>主动将其载入内存</p></li>
</ul>
<h3 id="进程调度">进程调度</h3>
<ul>
<li><p>调度(分配<code>CPU</code>资源)：管理处于<strong>不同状态的多个进程</strong>
将所有进程根据状态归入阻塞队列、就绪队列、部分<code>OS</code>含挂起队列</p></li>
<li><p>通过支持<code>CPU</code>调度，可实现<strong>并发</strong>，即宏观上同时执行多个进程
与并行的区别：并发强调调度提高<code>CPU</code>利用率，并行需要多核实现真正的同时执行</p>
<p>频繁调度将导致频繁进行系统调用(切换执行态)，降低执行效率</p></li>
<li><p>切换进程时，需保护上下文，上下文可分为：</p>
<ul>
<li>用户级上下文：代码段、数据段、用户堆栈、共享内存区</li>
<li>寄存器上下文：所有寄存器的数据</li>
<li>系统级上下文：进程控制块、内存管理信息、内核栈</li>
</ul></li>
<li><p>调度层次：</p>
<ul>
<li>短程调度：从就绪队列中选择合适进程被<code>CPU</code>执行</li>
<li>中程调度：交换进程，即将进程从内存移出/从交换空间中取出</li>
<li>长程调度：将用户提交的批作业载入内存</li>
</ul></li>
</ul>
<h3 id="ipc进程间通信"><code>IPC</code>(进程间通信)</h3>
<ul>
<li><code>IPC</code>用于支持不同进程间的相互协作、共享/交换信息</li>
<li><code>IPC</code>的底层实现有：
<ul>
<li>低级通信：用于<strong>传递控制信息</strong>，通过信号量、互斥锁实现</li>
<li>高级通信：用于进程间大量信息的<strong>交换/共享</strong>，通过<strong>共享内存区/消息传递</strong>实现
<ul>
<li>消息传递：进程通过调用内核的<strong>发送/接收函数</strong>，和其它进程通信
由于使用<strong>隐式同步</strong>(阻塞式通信/协议通信)且传递的消息为副本，过程清晰可查，编程简单易于调试而不易出错；但效率较低
<ul>
<li>阻塞式通信：即进程调用函数后进入阻塞队列</li>
<li>由于消息为副本，进程修改消息不会对其它进程产生影响</li>
</ul></li>
<li>共享内存：所有进程可直接读写共享内存区内的数据
由于使用同一份数据，为保证进程安全，需进行<strong>显式的同步控制</strong>(低级通信)
使一份数据同时仅能被一个进程访问 编程较复杂，调试难度高，但效率高</li>
</ul></li>
</ul></li>
<li>根据用户的需求不同，有不同的通信模型(上述方法的接口)：
<ul>
<li><code>LPC</code>(<code>Local Produce Call</code>，本地过程调用)：同一进程内/同一主机的不同进程调用<code>IPC</code>的接口</li>
<li><code>RPC</code>(<code>Remote Produce Call</code>，远程过程调用)：不同主机的进程调用<code>IPC</code>的接口，涉及网络通信</li>
</ul></li>
<li>管道(<code>Pipe</code>)：是<code>Linux</code>中消息传递机制的具体实现，由内核为两个进程开创管道</li>
<li>套接字(<code>Socket</code>)：套接字即一组信息组成的唯一标识，是计网模型里低层协议为高层协议提供的接口，在<code>RPC</code>中通过<code>IP</code>地址、协议、端口地址组成套接字来唯一标识一个进程(因为远程<code>IPC</code>中<code>pid</code>无法唯一标识进程)</li>
</ul>
<h3 id="线程">线程</h3>
<ul>
<li><p>线程(<code>Thread</code>)是更<strong>细粒度</strong>的计算单位，一个线程是进程中一个<strong>单一顺序的控制流</strong>(独立于其它线程的代码流)</p>
<ul>
<li>线程的引入支持充分<strong>利用多核</strong>资源，实现多个线程的<strong>并行执行</strong>，加快一个进程的执行速度</li>
<li>线程独有<code>TCB</code>(线程控制块)、堆栈、
和其它在同一进程下的不同线程共享代码段、共享内存区，同一进程下不同线程间通信较<code>IPC</code>简单</li>
</ul></li>
<li><p>分为用户级线程(用户在高级语言中使用线程库)、内核级线程(由内核直接管理)</p>
<ul>
<li><p>用户级线程由线程库实现，不需要内核线程的支持；但也意味着它们并非真正的并行执行</p>
<p>在用户眼中，用户级线程可随意调度，可由用户编写专用的调度算法
在内核眼中，用户级线程不可见因此不可调度，当一个用户级线程进入阻塞态，其所属的进程也进入阻塞态</p></li>
<li><p>内核级线程由内核支持，创建线程时需要<strong>进行系统调用</strong>，并真正更新在线程表中，由内核调度
实现并行执行，但消耗内核资源多</p></li>
<li><p>~协程</p></li>
</ul></li>
<li><p>线程模型：用户级线程需要通过内核级线程运行</p>
<ul>
<li><code>M:1</code>模型：多个用户级线程绑定到一个内核级线程，会导致某个用户级线程阻塞后，其它<code>M-1</code>个用户级线程也被阻塞</li>
<li><code>1:1</code>模型</li>
<li><code>M:N</code>模型</li>
<li>混合模型</li>
</ul></li>
</ul>
<h3 id="进程调度算法">进程调度算法</h3>
<ul>
<li>调度过程：
<ul>
<li><code>CPU</code>调度：进行一次短程调度(处于内核态)</li>
<li>派遣：切换上下文<span class="math inline">→</span>切换回用户态<span
class="math inline">→</span>执行从就绪队列推出的任务</li>
</ul></li>
<li>调度时机：
<ul>
<li>进程阻塞/结束：进程主动放弃<code>CPU</code>，属于<strong>非抢占点</strong></li>
<li>进程被唤醒/被中断：因中断等事件发生，该进程从阻塞状态/运行状态进入就绪队列，属于<strong>可抢占点</strong>，两种原因造成的可抢占的资源分别是非<code>CPU</code>资源、<code>CPU</code>资源</li>
</ul></li>
<li>调度算法评价指标：
<ul>
<li><code>CPU</code>利用率：倾向使<code>CPU</code>不含空余时间</li>
<li>进程吞吐率：倾向选择短进程执行</li>
<li><strong>周转时间</strong>：进程从第一次到达就绪队列到全部运行结束的时间</li>
<li>带权周转时间：进程的周转时间除以运行的总时间</li>
<li>平均周转时间/平均带权周转时间：多个进程的平均周转时间/平均带权周转时间，可表示进程的总体执行效率</li>
<li><strong>等待时间</strong>：进程就绪后等待执行所花费的<strong>全部时间</strong></li>
<li><strong>响应时间</strong>：进程提交后到<strong>第一次</strong>获得<code>CPU</code>的时间</li>
</ul></li>
<li>抢占式/非抢占式调度：进程进入就绪队列后，是否会影响运行中的进程，如果是抢占式调度，在新进程根据调度算法比运行中进程更优时，新进程将和运行中进程交换</li>
<li>优先级调度算法：任务队列为<strong>优先数</strong>的最小堆(分为非抢占式/抢占式)
<ul>
<li><code>FCFS</code>(<code>First Come First Serve</code>，先进先服务)算法：就绪队列为一般的先进先出队列，等待前方进程结束后执行下一进程
<ul>
<li>各指标不稳定，且为非抢占式调度</li>
</ul></li>
<li><code>SJF</code>(<code>Shortest Job First</code>，短作业优先)算法：就绪队列为剩余时间(所需时间-已执行时间)的最小堆
<ul>
<li>追求<strong>更低的平均周转时间</strong>，但响应时间长</li>
<li>为<strong>非抢占式调度</strong>，先到的任务一定比后到的任务先完成(尽管执行中进程的剩余时间比后到任务多)</li>
<li>存在<strong>饥饿</strong>问题：剩余时间长的进程可能永远得不到调度</li>
</ul></li>
<li><code>SRTF</code>(<code>Shortest Remaining Time First</code>，最短剩余时间优先)算法：就绪队列及运行中进程组成剩余时间的最小堆
<ul>
<li>为<strong>抢占式调度</strong>，就绪队列每次更新时都需要对比，使执行中任务始终为剩余时间最短的</li>
<li>存在饥饿问题</li>
</ul></li>
<li><code>HRRN</code>(<code>Highest Response Ratio Next</code>，最高响应比优先)算法：就绪队列为响应比<span
class="math inline">$\begin{align}\left(R=\frac{周转时间}{执行时间}=\frac{等待时间+执行时间}{执行时间}\right)\end{align}$</span>的最大堆</li>
<li>饥饿现象：优先级调度算法中，无论是非抢占式还是抢占式调度，均会发生饥饿现象，即某进程因优先级过低而<strong>等待时间过长</strong>，导致即使其最终完成也失去其实际意义(饿死)
可使用<strong>老化机制</strong>，即优先级同时需<strong>考虑其等待时间</strong>，<code>HRRN</code>即一种采用老化机制的优先级调度算法</li>
</ul></li>
<li><code>RR</code>(<code>Round Robin</code>，轮转)调度：轮转调度考虑进程的公平性(使它们的平均值最短)，将时间分为多个<strong>时间片</strong>，每个进程执行一个时间片后必须返回就绪队列，使资源被轮转使用
<ul>
<li>平均等待时间与时间片长度成正比，最坏等待时间为<code>(就绪进程数-1)*时间片长度</code>，使时间片较短，可<strong>提升交互体验</strong></li>
<li>吞吐率较低，批处理速度慢</li>
<li>通过<strong>计时器中断</strong>实现</li>
<li>一个进程可以通过产生多个子进程，增大本身的占有<code>CPU</code>的时间</li>
</ul></li>
<li><code>MLQ</code>(<code>Multi-Level Queue</code>，多级队列)调度：全体就绪进程采用优先级调度算法，但处于同一优先级的进程采用轮转调度(或其他调度算法)</li>
<li><strong><code>MLFQ</code></strong>(<code>Multi-Level Feedback Queue</code>，多级反馈队列)调度：在<code>MLQ</code>调度基础上，支持<strong>动态优先级</strong>；即任务执行一个时间片释放资源后，增加<strong>考虑是否降低其优先级</strong>的步骤(允许进程在不同优先级队列间移动)</li>
</ul>
<h3 id="进程同步">进程同步</h3>
<ul>
<li><p>进程协作以异步为主(保证效率)，同步为辅(保证进程间通信的数据安全)</p></li>
<li><p>进程同步根据<code>IPC</code>方式有所区别：</p>
<ul>
<li>进程直接协作：采用消息传递，属于隐式同步，进程间有特定的执行顺序，此方发送/接收消息时需进入阻塞态、直到对方接收/发送消息时被唤醒</li>
<li>进程间接协作：采用共享内存，进程间不互锁，因此需要显式同步以保证数据一致性
<ul>
<li>一个进程的<strong>临界区</strong>(连续的访问共享内存的代码)执行过程中不能被其它进程的临界区影响
在并发执行中，起因为抢占式调度/<code>RR</code>调度算法等的分时执行</li>
</ul></li>
</ul></li>
<li><p>针对间接协作的同步控制(互斥)，有以下解法：</p>
<ul>
<li><code>Peterson</code>解法(互斥的软件解法)：</li>
<li>互斥锁(互斥的硬件解法，也称互斥量<code>Mutex</code>)：</li>
<li>信号量(<code>Semaphore</code>)：
<ul>
<li><code>P-V</code>问题：</li>
<li>读者写者问题：</li>
</ul></li>
<li>互斥信号量必须紧贴临界区</li>
</ul></li>
<li><p>管程：</p></li>
<li><p>同步控制造成死锁：</p>
<ul>
<li>特点/必要条件：
<ul>
<li>进程在运行结束前不释放资源</li>
<li>b</li>
<li>c</li>
<li>d</li>
</ul></li>
<li>死锁预防：在程序未执行时，进程的申请阶段
<ul>
<li>要求进程执行前先申请整个进程所需的所有资源，仅当全部所需资源均满足时分配(破坏)</li>
<li>要求进程按资源的编号顺序申请资源(破坏循环等待)</li>
</ul></li>
<li>死锁避免：程序的执行阶段(未发生死锁)
<ul>
<li>对进程的动态申请资源进行审查</li>
<li>银行家算法：</li>
</ul></li>
<li>死锁检测：
<ul>
<li>检测算法：构建进程等待图，求拓扑排序检测是否有环</li>
<li>鸵鸟机制：由于死锁检测代价高昂且死锁概率十分小，一般不进行处理</li>
</ul></li>
<li>死锁恢复：直接终止相关进程，让它们释放资源</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构: 树状数组</title>
    <url>/blogs/2025/03/19/algo-fenwick-tree/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="概述">概述</h3>
<ul>
<li>树状数组(<code>Binary Indexed Tree</code>，<code>BIT</code>，或称<code>Fenwick Tree</code>)支持<strong>区间查询</strong>、<strong>单点修改</strong>
一个区间的总信息由区间内所有元素共同贡献而得
然而<strong>一般的</strong>树状数组具有限制(与前缀和数组类似，因为朴素树状数组查询取件信息依赖于前缀和)：
<ul>
<li>元素间运算<strong>满足结合律</strong></li>
<li>所有元素具有逆元，即<strong>满足消去律</strong>(可由运算结果及其中一个操作数得知另一个操作数)</li>
<li>满足上述要求的区间信息包括加和、乘积、异或等</li>
</ul></li>
<li>一些特殊类型的树状数组可实现一些不满足上述要求的区间查询问题：
<ul>
<li>双树状数组求区间最值</li>
<li>扩展树状数组求不满足消去律的运算的区间信息</li>
</ul></li>
<li>树状数组可求解的问题是<strong>线段树的子集</strong>，在后面可见其结构并非一棵完美的二叉树
但其价值在于能以<strong>更简单的代码</strong>、更小的空间/时间常数因子来完成相似任务</li>
</ul>
<h3 id="基本结构">基本结构</h3>
<ul>
<li><p>为了实现最基本的树状数组的功能，需要考虑(接下来以求区间和为例)：</p>
<ul>
<li>数组的每个元素代表哪一个区间的区间信息(称为基本区间)</li>
<li>如何通过基本区间信息，来求任意范围的区间信息</li>
<li>修改单点值时，如何更新所有涉及该点的元素</li>
</ul></li>
<li><p>设数组索引为<span class="math inline"><em>i</em></span>(<span
class="math inline">1 ≤ <em>i</em> ≤ <em>n</em></span>)，<span
class="math inline"><em>g</em>(<em>i</em>)</span>为<span
class="math inline"><em>i</em></span>二进制最右边第一个<span
class="math inline">1</span>的位置(<span
class="math inline"><em>g</em>(<em>i</em>) ≥ 0</span>) 则<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>管辖的范围为<span
class="math inline">[<em>i</em>−2<sup><em>g</em>(<em>i</em>)</sup>+1, <em>i</em>]</span>
例如，<span class="math inline"><em>a</em><sub>1</sub></span>管辖<span
class="math inline">[1,1]</span>、<span
class="math inline"><em>a</em><sub>2</sub></span>管辖<span
class="math inline">[1,2]</span>、<span
class="math inline"><em>a</em><sub>4</sub></span>管辖<span
class="math inline">[1,4]</span>、<span
class="math inline"><em>a</em><sub>6</sub></span>管辖<span
class="math inline">[5,6]</span> 考虑<span
class="math inline">2<sup><em>g</em>(<em>i</em>)</sup></span>的具体实现：实际就是<span
class="math inline"><em>i</em> − (<em>i</em>&amp;(<em>i</em>−1)) = <em>i</em>&amp;(−<em>i</em>)</span></p></li>
<li><p>区间查询：获取任意范围的区间信息便很简单，由于前缀区间信息非常易于获取、且运算<strong>满足消去律</strong>
因此若设<span
class="math inline"><em>h</em>(<em>x</em>,<em>y</em>)</span>为区间<span
class="math inline">[<em>x</em>,<em>y</em>]</span>的区间信息，则<span
class="math inline"><em>h</em>(<em>x</em>,<em>y</em>) = <em>h</em>(1,<em>y</em>) − <em>h</em>(1,<em>x</em>−1)</span>，其中<code>-</code>为该运算的逆运算
获取前缀区间信息的方式：令<span
class="math inline"><em>i</em></span>迭代为<span
class="math inline"><em>i</em> − 2<sup><em>g</em>(<em>i</em>)</sup></span>直到<span
class="math inline"><em>i</em> = 0</span>退出循环、将途径的基本区间信息<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>求和即可，是<span
class="math inline"><em>O</em>(log<em>n</em>)</span>的</p></li>
<li><p>单点修改：</p>
<ul>
<li>先考虑其树形态，即不同元素区间之间的包含关系，可以发现： 若有<span
class="math inline"><em>x</em> &lt; <em>y</em> &lt; <em>x</em> + 2<sup><em>g</em>(<em>x</em>)</sup></span>，则<span
class="math inline"><em>a</em><sub><em>y</em></sub> : [<em>y</em>−2<sup><em>g</em>(<em>y</em>)</sup>+1,<em>y</em>]</span>、<span
class="math inline"><em>a</em><sub><em>x</em></sub> : [<em>x</em>−2<sup><em>g</em>(<em>x</em>)</sup>+1,<em>x</em>]</span>
由于<span
class="math inline"><em>y</em> − 2<sup><em>g</em>(<em>y</em>)</sup> + 1 &gt; <em>x</em></span>，故此时<span
class="math inline"><em>a</em><sub><em>y</em></sub>、<em>a</em><sub><em>x</em></sub></span>管辖区间互不包含
且<span
class="math inline"><em>a</em><sub><em>x</em></sub></span>区间真包含于<span
class="math inline"><em>a</em><sub><em>x</em> + 2<sup><em>g</em>(<em>x</em>)</sup></sub></span>区间
其树形结构便是：对于一个结点<span
class="math inline"><em>y</em></span>，其直接子结点<span
class="math inline"><em>x</em></span>必须满足<span
class="math inline"><em>x</em> + 2<sup><em>g</em>(<em>x</em>)</sup> = <em>y</em></span>
对任意<span
class="math inline"><em>x</em> &lt; <em>y</em> &lt; <em>x</em> + 2<sup><em>g</em>(<em>x</em>)</sup></span>，<span
class="math inline"><em>x</em>、<em>y</em></span>所在结点的最近共同祖宗不是<span
class="math inline"><em>x</em></span>或<span
class="math inline"><em>y</em></span></li>
<li>因此单点修改的过程类似获取前缀区间信息的逆过程：令<span
class="math inline"><em>i</em></span>迭代为<span
class="math inline"><em>i</em> + 2<sup><em>g</em>(<em>i</em>)</sup></span>直到<span
class="math inline"><em>i</em> &gt; <em>n</em></span>退出循环、使途径的基本区间信息<span
class="math inline"><em>a</em><sub><em>i</em></sub> ← <em>a</em><sub><em>i</em></sub> + <em>n</em><em>e</em><em>w</em> − <em>o</em><em>l</em><em>d</em></span>
因此也是<span
class="math inline"><em>O</em>(log<em>n</em>)</span>的</li>
</ul></li>
<li><p>建树：</p>
<ul>
<li><span
class="math inline"><em>O</em>(<em>n</em>log<em>n</em>)</span>：变为<span
class="math inline"><em>n</em></span>次单点修改，其中<span
class="math inline"><em>n</em><em>e</em><em>w</em> = <em>r</em><sub><em>i</em></sub>、<em>o</em><em>l</em><em>d</em> = 0</span></li>
<li><span class="math inline"><em>O</em>(<em>n</em>)</span>：在<span
class="math inline"><em>O</em>(<em>n</em>log<em>n</em>)</span>的方法中，每次从叶子结点(原数组元素)上升到根结点，多花了<span
class="math inline">log <em>n</em></span>；
由于该树中，父结点的编号一定比所有直接子结点的编号大 因此除了方法一<span
class="math inline"><em>c</em><sub><em>i</em></sub> = ∑<em>a</em><sub><em>k</em></sub>[<em>i</em>−2<sup><em>g</em>(<em>i</em>)</sup>+1≤<em>k</em>≤<em>i</em>]</span>，还可<span
class="math inline"><em>c</em><sub><em>i</em></sub> = ∑<em>a</em><sub><em>k</em></sub>[<em>k</em>+2<sup><em>g</em>(<em>k</em>)</sup>=<em>i</em>]</span>
因此在从小到大更新结点时，可顺便更新其直接父结点：<span
class="math inline"><em>a</em><sub><em>i</em></sub> ← <em>a</em><sub><em>i</em></sub> + <em>r</em><sub><em>i</em></sub>、<em>a</em><sub><em>i</em> + 2<sup><em>g</em>(<em>i</em>)</sup></sub> ← <em>a</em><sub><em>i</em> + 2<sup><em>g</em>(<em>i</em>)</sup></sub> + <em>a</em><sub><em>i</em></sub></span></li>
<li><span
class="math inline"><em>O</em>(<em>n</em>)</span>：在输入时不进行建树，而是计算前缀和，输入完成后进行区间查询来建树
因此空间、时间复杂度的常数因子比方法二略大</li>
</ul></li>
<li><p>原数组的<strong>区间修改与单点查询</strong>：差分运算也可使用树状数组，因为差分数组的前缀和即为原数组元素，对于这个问题，只需要多一步计算差分数组的步骤
即，如果要求是<strong>原数组的区间修改+单点查询</strong>，可转化为原数组的<strong>差分数组的</strong>：<strong>两点修改+求出区间和</strong>，这个要求和之前的分析一致
因为区间<span
class="math inline">[<em>x</em>,<em>y</em>]</span>修改后，差分数组只有<span
class="math inline"><em>a</em><sub><em>x</em></sub>、<em>a</em><sub><em>y</em> + 1</sub></span>需要修改
此时使用方法二建树时，由于只使用一个数组，因此需记录<span
class="math inline"><em>a</em><sub><em>i</em> − 1</sub></span>来计算<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>的值(令<span
class="math inline"><em>a</em><sub>0</sub> = 0</span>)
时间复杂度：仅在预处理时多了一遍<span
class="math inline"><em>O</em>(<em>n</em>)</span>，各种操作的复杂度均不变</p></li>
<li><p>原数组的<strong>区间修改与区间查询</strong>：沿用上述方法，用差分数组来实现<span
class="math inline"><em>O</em>(log<em>n</em>)</span>的区间修改，对于区间查询，通过两个前缀和相减得到
可以对式子展开：如果原数组为<span
class="math inline"><em>a</em></span>，差分数组为<span
class="math inline"><em>b</em></span>，那么<span
class="math inline">$\begin{align}s_k=\sum_{i=1}^ka_i=\sum_{i=1}^k\sum_{j=1}^ib_j=\sum_{i=1}^k(k-i+1)b_i=k\sum_{i=1}^kb_i-\sum_{i=1}^k(i-1)b_i\end{align}$</span>
即，维护两个树状数组，一个是其差分数组，另一个是带<span
class="math inline"><em>i</em> − 1</span>系数的差分数组(更新时乘上系数即可)
计算原数组的前缀和<span
class="math inline"><em>s</em><sub><em>k</em></sub></span>时，使第一个树状数组的前缀和乘<span
class="math inline"><em>k</em></span>再减去第二个树状数组的前缀和即可
时间复杂度：各种操作的复杂度的常数因子增大</p></li>
<li><p>朴素树状数组模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lbit(x) (x &amp; (-x))</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>], n, i, t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 查询前缀和</span></span><br><span class="line"> <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += a[x];</span><br><span class="line">        x -= <span class="built_in">lbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// O(log n) 区间查询</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_a</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> </span>&#123; <span class="comment">// O(log n) 单点修改</span></span><br><span class="line">    val = val - a[idx];</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        a[idx] += val;</span><br><span class="line">        idx += <span class="built_in">lbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 使用方法二建树</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[i] += t;</span><br><span class="line">        <span class="keyword">if</span> ((t = i + <span class="built_in">lbit</span>(i)) &lt;= n) &#123;</span><br><span class="line">         a[t] += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="扩展树状数组">扩展树状数组</h3>
<h3 id="bit应用"><code>BIT</code>应用</h3>
<h4 id="统计逆序对问题">统计逆序对问题</h4>
<ul>
<li>即冒泡排序的最小交换次数[ <a
href="https://www.luogu.com.cn/problem/P1966">NOIP 2013 提高组]
火柴排队</a></li>
</ul>
<h4 id="区间最值问题">区间最值问题</h4>
<h4 id="区间与区间求和问题">区间与区间求和问题</h4>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构: 前缀和</title>
    <url>/blogs/2025/03/19/algo-prefix-sum/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="一维前缀和">一维前缀和</h3>
<ul>
<li><p>对一个原数组<span
class="math inline"><em>a</em><sub>1 ∼ <em>n</em></sub></span>，令<span
class="math inline">$\begin{align}s_i=\sum_{k=1}^ia_k\end{align}$</span>，即称<span
class="math inline"><em>s</em></span>为<span
class="math inline"><em>a</em></span>的前缀和数组</p></li>
<li><p>不难发现有以下性质：</p>
<ul>
<li><span class="math inline">${\rm len}(a)={\rm len}(s)$</span></li>
<li>任意以<span
class="math inline"><em>a</em><sub>1</sub></span>为起始的子区间<span
class="math inline">[<em>a</em><sub>1</sub>,<em>a</em><sub><em>i</em></sub>]</span>，其元素和为<span
class="math inline"><em>s</em><sub><em>i</em></sub></span></li>
</ul></li>
<li><p>对于满足如下要求的运算：</p>
<ul>
<li>元素间运算<strong>满足结合律</strong></li>
<li>所有元素具有逆元，即<strong>满足消去律</strong>(可由运算结果及其中一个操作数得知另一个操作数)</li>
<li>满足上述要求的区间信息包括加和、乘积、异或等</li>
</ul>
<p>令<span
class="math inline"><em>s</em><sub>0</sub> = 0</span>，则有<span
class="math inline"><em>s</em><em>u</em><em>m</em>(<em>a</em><sub><em>i</em></sub>,<em>a</em><sub><em>j</em></sub>) = <em>s</em><sub><em>j</em></sub> − <em>s</em><sub><em>i</em> − 1</sub></span></p></li>
<li><p>原地实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN], t;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    a[i] += t;</span><br><span class="line">    a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二维前缀和">二维前缀和</h3>
<ul>
<li><p>类似一维前缀和，对一个<span
class="math inline"><em>n</em></span>行<span
class="math inline"><em>m</em></span>列的二维数组，令<span
class="math inline">$\begin{align}s_{ij}=\sum_{i=1}^n\sum_{j=1}^ma_{ij}\end{align}$</span>，即称<span
class="math inline"><em>s</em></span>为<span
class="math inline"><em>a</em></span>的前缀和数组</p></li>
<li><p>类似一维前缀和，结合容斥原理，对于特定的运算，任意一个子区间(左上角为<span
class="math inline"><em>a</em><sub><em>i</em><em>j</em></sub></span>，右下角为<span
class="math inline"><em>a</em><sub><em>x</em><em>y</em></sub></span>)的元素和为<span
class="math inline"><em>s</em><sub><em>x</em><em>y</em></sub> + <em>s</em><sub>(<em>i</em>−1)(<em>j</em>−1)</sub> − <em>s</em><sub><em>x</em>(<em>j</em>−1)</sub> − <em>s</em><sub>(<em>i</em>−1)<em>y</em></sub></span>，其中<span
class="math inline"><em>s</em><sub>0·</sub> = <em>s</em><sub>·0</sub> = 0</span></p></li>
<li><p>原地实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN][MAXM], t;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[i][j] += t;</span><br><span class="line">        a[i][j + <span class="number">1</span>] += a[i][j] - a[i - <span class="number">1</span>][j]; <span class="comment">// 容斥</span></span><br><span class="line">        a[i + <span class="number">1</span>][j] = a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以不依赖容斥，像扫地一样实现(虽然高维前缀和不实用，但这种方法能比较清晰地算出高维前缀和)：</p>
<p>```c++ for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m;
++j) { cin &gt;&gt; t; a[i][j] += t; a[i][j + 1] = a[i][j]; } } for (int
i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { a[i + 1][j]
+= a[i][j]; } }</p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 泛型编程</title>
    <url>/blogs/2025/03/18/java-generics/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="java泛型编程"><code>Java</code>泛型编程</h2>
<h3 id="泛型声明">泛型声明</h3>
<ul>
<li><p>泛型类似<code>cpp</code>的模板编程，用于重用代码</p></li>
<li><p><strong>泛型类型必须为引用类型</strong>，所以基础数据类型都提供了包装类</p></li>
<li><p>泛型类或接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modifiers &lt;T&gt; returnType <span class="title function_">methodName</span><span class="params">(必须包含类型为T的参数)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="泛型参数命名规范">泛型参数命名规范</h3>
<ul>
<li><code>E</code>：集合或数组元素的类型</li>
<li><code>T/U/S/P</code>：泛指所有类</li>
<li><code>K/V</code>：键值类</li>
<li><code>N</code>：<code>Number</code>类</li>
</ul>
<h3 id="通配符">通配符<code>?</code></h3>
<ul>
<li><p>通配符<code>?</code>不是一种类型参数，也不是标记符，<strong>不能在声明泛型参数时</strong>使用，但可以在类型里面使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &lt;?&gt; &#123;&#125;    <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      ClassName&lt;?&gt; a;     <span class="comment">// 正确, 相当于ClassName a;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>仅使用<code>?</code>和省略尖括号没有区别，如果省略尖括号会有<code>RawTypes</code>警告</p></li>
<li><p>在较新版本中，使用<code>&lt;&gt;</code>可由编译器自动推断类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="泛型类或接口的继承">泛型类或接口的继承</h3>
<ul>
<li><p>泛型类是一个整体，即时泛型参数之间有继承关系，泛型类或接口也没有继承关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;      <span class="comment">// B是A的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &lt;A&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &lt;B&gt; &#123;&#125;    <span class="comment">// 但ClassName&lt;B&gt;不是ClassName&lt;A&gt;的子类</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型类的继承规则：</p>
<ul>
<li><p>若子类不是泛型类，则父类必须确定泛型参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;String&gt; &#123;&#125;   <span class="comment">// Father&lt;&gt;必须指定参数</span></span><br></pre></td></tr></table></figure></li>
<li><p>若子类是泛型类，则父类的类型参数必须是子类所使用的参数，或者是具体的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;String&gt; &#123;&#125;   <span class="comment">// 具体的参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &lt;T, S&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T&gt; &#123;&#125;     <span class="comment">// Son提供的泛型参数</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="限定符extendssuper">限定符<code>extends、super</code></h3>
<ul>
<li>正因上述问题，<code>java</code>提供了<code>extends</code>和<code>super</code>表示了其上界和下界</li>
<li><code>extends TypeOrInterface</code>：虽然只提供了<code>extends</code>，但这个限定符后面可以跟类，也<strong>可以跟接口</strong>，表示这个类型参数必须继承或实现自<code>TypeOrInterface</code>类或接口</li>
<li><code>super TypeOrInterface</code>：表明这个类型参数必须是<code>TypeOrInterface</code>的父类或父接口</li>
<li>两者可以一起使用</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>generics</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 面向对象编程</title>
    <url>/blogs/2025/03/06/java-oop/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="java面向对象编程"><code>Java</code>面向对象编程</h2>
<h3 id="数据类型">数据类型</h3>
<ul>
<li><code>java</code>的数据类型分为两种：基础数据类型和对象类型</li>
<li><code>java</code>允许自动提升，不允许自动<code>down cast</code>，需要强制类型转换</li>
<li>基础数据类型只有八种，且全小写，分别为<code>byte、short、int、long、float、double、boolean、char</code>，它们直接存储在栈中
<ul>
<li>不带后缀的整数均为<code>int</code>型字面量</li>
<li>不带后缀的浮点数均为<code>double</code>型字面量</li>
<li><code>boolean</code>类型字面量只有<code>true</code>和<code>false</code></li>
<li><code>char</code>类型字面量均为<code>Unicode</code>编码，一个字符占两个字节</li>
<li>其它类型的字面量：<code>0x????、????h、0b????、?.??f</code></li>
</ul></li>
<li>对象类型是类类型，它们真正存在于堆中，由<code>new</code>关键字创建
所有对象类型的变量<strong>存储在栈中的值都是指针</strong>，称为<strong>引用</strong>，指向在堆中的对象</li>
<li><code>java</code>得益于有<code>GC</code>，所以没有<code>delete</code>也没有析构函数，此乃一胜</li>
<li><code>null</code>为空指针</li>
<li>基本数据类型的默认值为零，且不能将<code>null</code>赋给基本数据类型</li>
</ul>
<h3 id="运算符">运算符</h3>
<ul>
<li>赋值运算符<code>=</code>：所有的赋值均为<strong>传值</strong>，是将<strong>复制栈中的值</strong>给另一个变量，给方法传参也是赋值</li>
<li>比较运算符：所有的比较均为比较栈中的值，所以针对引用变量时，没有意义</li>
<li><code>obj instanceof Type</code>：只用于引用类型，如果<code>obj</code>是<code>Type</code>或<code>Type</code>派生类的对象时，返回<code>true</code></li>
<li>按位运算符：其中移位运算<code>&gt;&gt;&gt;</code>为无符号右移，<code>&gt;&gt;</code>为有符号右移，<code>&lt;&lt;</code>在移动位数大于总位数时会将移动位数自动对总位数取模</li>
<li>逻辑运算符：<code>||</code>、<code>&amp;&amp;</code></li>
<li>算术运算符：针对基础数据类型中的整型类型，最小单位是<code>int</code>，例如两个<code>byte</code>运算时会把<code>byte</code>提升到<code>int</code>然后返回<code>int</code></li>
<li>成员访问运算符<code>.</code>：针对引用类型变量，对比<code>cpp</code>就是<code>-&gt;</code></li>
</ul>
<h3 id="object"><code>Object</code></h3>
<ul>
<li><code>Object</code>是所有类的基类，所有类若没有显式地继承哪个类，就会隐式地继承<code>Object</code></li>
<li><code>Object</code>对象提供的方法一般没有意义，重要在于提供了一套<strong>规范的方法名</strong>，重点在于<strong>重写</strong>
<ul>
<li><code>public boolean equals(Object o)</code>：判等，注意参数为<code>Object</code>类型</li>
<li><code>public int hashCode()</code>：获取哈希值</li>
<li><code>public String toString()</code>：将对象转化为字符串，若实现该方法，则可以通过字符串的<code>+</code>语法糖自动转换</li>
<li><code>protected Object clone() throws CloneNotSupportedException</code>：创建并返回本对象的副本(浅拷贝副本)，会抛出<strong>受检异常</strong><code>CloneNotSupportedException</code>，防止你没有重写但又在某个地方调用了该方法
重写它一般需要声明<code>implements Cloneable</code>(一个空接口)并<code>public</code>地重写
但是<code>clone()</code>是很没用的，一般使用一些集成框架提供的深拷贝或浅拷贝的克隆方法</li>
<li><code>Class&lt;?&gt; getClass()</code>：获取引用指向的<strong>对象所属的类</strong>，是堆中正在运行的那个对象的类，而不是引用的类
详见<code>java</code>反射机制</li>
</ul></li>
</ul>
<h3 id="thissuper"><code>this、super</code></h3>
<ul>
<li><p><code>this</code>引用：指向现在在<code>JVM</code>中<strong>正在运行的那个对象</strong>，无论<code>this</code>在哪个类中，其本质是一个动态绑定的引用
例如以下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">      a();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">      b();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若声明<code>A a = new B()</code>，并调用<code>a.b()</code>，即执行<code>A</code>类的<code>b()</code>方法，即执行<code>this.a()</code>，即执行<code>B</code>类中重写的方法(因为<code>this</code>指向一个<code>B</code>类的实例)，所以这是一个无限循环的调用</p></li>
<li><p><code>super</code>关键字：<code>super</code>和<code>this</code>不同，其本质只是一个关键字，<strong>静态绑定</strong>所在类的父类的一个对象
同样是上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">BaseA</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">      a();</span><br><span class="line">      <span class="built_in">super</span>.a();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">      b();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，调用<code>b()</code>后会调用<code>this.a()</code>，执行<code>B</code>类的<code>a()</code>
而<code>super.a()</code>静态绑定了所在类<code>A</code>的父类<code>BaseA</code>的<code>a()</code>方法，和<code>this</code>指向的对象隔了两代，所以区别还是很大的</p></li>
<li><p>但总而言之，<code>this</code>和<code>super</code>都不应该用来访问类的静态成员</p></li>
<li><p><code>this(参数)</code>和<code>super(参数)</code>还可以引用构造方法，同上<code>this</code>动态绑定当前运行的对象，<code>super</code>静态绑定所属类的父类对象</p></li>
</ul>
<h3 id="类的构造器">类的构造器</h3>
<ul>
<li>构造器：
<ul>
<li>若没有自定义构造器，编译器提供一个没有参数的构造器</li>
<li>若有自定义构造器，编译器不再提供没有参数的构造器</li>
<li>所有构造器的第一条语句，如果不是通过<code>this</code>或<code>super</code>引用的构造方法，则会隐式地添加<code>super()</code>，即父类的无参构造器
所以当父类没有无参构造器且子类没有构造器时，编译器会检查出错误</li>
</ul></li>
<li><code>java</code>创建一个对象分为四步(初始化的顺序)：
<ul>
<li><code>new</code>：分配内存</li>
<li>默认赋值：基础类型赋为零，引用类型赋为<code>null</code></li>
<li>显式初始化：若在声明属性时用<code>=</code>赋值了，那么会将其放在<code>this</code>或<code>super</code>引用的构造器之后，构造方法代码之前</li>
<li>执行用户的代码</li>
</ul></li>
</ul>
<h3 id="注解annotation">注解(<code>Annotation</code>)</h3>
<ul>
<li><p>注解是一种元数据，编译器不会跳过注解，而是根据注解<strong>进行检查</strong>或其它操作</p></li>
<li><p>注解以<code>@</code>开头，例如重写方法要用<code>@Override</code>注解，下面介绍一下<code>java</code>标准库的注解</p></li>
<li><p>针对代码的注解：</p>
<ul>
<li><code>@Override</code>：表明方法被重写</li>
<li><code>@Deprecated</code>：表明方法已过时，检查到使用该方法时，会警告</li>
<li><code>@SuppressWarnings(value={"key"})</code>：标注部分内容，令编译器忽视被标注内容发出的警告</li>
</ul></li>
<li><p>针对注解的注解(元注解)：</p>
<ul>
<li><code>@Retention</code>：标识该如何存储注解</li>
<li><code>@Documented</code>：标识注解应该包含在用户文档中</li>
<li><code>@Inherited</code>：标识注解继承于哪个注解</li>
</ul></li>
<li><p>自定义注解模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">// 可选, 表明该注解可以存在于Javadoc中</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ...&#125;)</span>    <span class="comment">// 指定注解的类型, ElementType是一个枚举, 用于限制该注解作用的范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnocation &#123;&#125;   <span class="comment">// 自定义注解需要实现Annocation接口, @interface表明该注解实现了它</span></span><br></pre></td></tr></table></figure></li>
<li><p>自定义注解的作用主要体现在反射机制上</p></li>
</ul>
<h3 id="接口">接口</h3>
<ul>
<li><code>Java 8</code>后支持在接口内存在有实现的方法或类，具体规则在本节不讨论</li>
<li>接口同样支持多态，可以通过接口类型的引用访问实现了该接口的类对象实例</li>
<li>接口的作用：
<ul>
<li>空接口：接口支持多重实现，空接口可以作为一个标记，然后通过泛型编程就能筛选掉那些没有这个标记的类
例如<code>java.io.Serializable</code>，可序列化空接口</li>
<li>接口可以将程序划分为多个模块，模块解耦实现多人分工</li>
<li>用接口定义公共<code>API</code>更为清晰</li>
</ul></li>
<li>标准库常用接口：
<ul>
<li><code>Comparable&lt;T&gt;</code>：包含<code>public int compareTo(T o)</code></li>
<li><code>Runnable</code>：包含<code>void run()</code>，用于多线程编程</li>
<li>集合框架的接口</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: 基本语法</title>
    <url>/blogs/2025/03/04/java-base/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="java基本语法"><code>Java</code>基本语法</h1>
<h2 id="包管理">包管理</h2>
<h3 id="包的声明">包的声明</h3>
<ul>
<li><code>Java</code>包的功能类似<code>C++</code>的命名空间，减少类名冲突；但它并不是随意声明和引用的：
<ul>
<li><p>包名必须是当前文件/目录的<strong>父目录</strong>相对于<strong>项目根目录</strong>的路径，用<code>.</code>运算符表明父子关系
例如，若<code>.</code>为根目录，当前文件的路径为<code>./test/math</code>，则声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.math;</span><br></pre></td></tr></table></figure></li>
<li><p>一个文件除非直接在项目文件夹下，否则必须声明包，且必须在文件开头(在<code>import</code>前)</p></li>
</ul></li>
<li>一个<code>.java</code>文件只能有一个<code>public</code>类或接口，且<strong>类名必须和文件名相同</strong></li>
<li>不同<code>.java</code>文件在同一个包体内，指的是它们处于同一个目录下，声明的<code>package</code>路径相同</li>
<li>命名规范：所有包名均应小写</li>
</ul>
<h3 id="外部包的引用">外部包的引用</h3>
<ul>
<li><p>引用外部包的类或接口需要使用<code>import</code>关键字，用于减少包名冗余导致的可读性下降</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg1.pkg2.MyClass;     <span class="comment">// 可快捷使用MyClass</span></span><br><span class="line"><span class="keyword">import</span> pkg1.*;                <span class="comment">// 可快捷使用pkg1下的所有公有类或接口, 但不包含子包下的公有类或接口</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用外部包的类的静态成员或静态方法时需要使用<code>import static</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure></li>
<li><p>实践时，引入外部包类等情形不推荐使用通配符<code>*</code>，引用静态成员等可酌情使用，推荐按以下顺序引入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.?;               <span class="comment">// 先引入java标准库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.?;     <span class="comment">// 再引入java扩展的第三方库, 按照依赖顺序, 每个不同的库之间隔一空行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.?;     <span class="comment">// 第三方库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dlut.?;                    <span class="comment">// 最后引入自己开发的模块</span></span><br></pre></td></tr></table></figure></li>
<li><p>实践时，推荐使用格式化插件</p></li>
</ul>
<h3 id="javac命令"><code>javac</code>命令</h3>
<ul>
<li><p><code>javac</code>用于编译<code>.java</code>文件，生成可被<code>JVM</code>执行的<code>.class</code>文件</p></li>
<li><p>最常用的编译命令如下(多个文件使用<code>:</code>分隔，<code>Windows</code>下是<code>;</code>)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d(destination)参数表示保留文件的包路径信息，并生成到目标目录下</span></span><br><span class="line">javac -d 目标目录 待编译的.java文件</span><br></pre></td></tr></table></figure></li>
<li><p>其它参数：<code>-encoding</code>，指定文件编码</p></li>
<li><p>实践中，推荐使用<code>IDE</code>插件提供的脚本服务自动编译</p></li>
</ul>
<h3 id="java命令"><code>java</code>命令</h3>
<ul>
<li><p><code>java</code>用于运行<code>.class</code>文件</p></li>
<li><p>最常用的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-<span class="built_in">cp</span>(classpath)参数标明`JVM`应从哪些路径下查找</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主类名必须包含`main`，链接由JVM在运行时进行，被链接的类同样是在指定的目录下查找</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意主类名不是文件名，不能包含`.class`</span></span><br><span class="line">java -cp 目录 主类名</span><br></pre></td></tr></table></figure></li>
<li><p><code>java</code>的<code>main</code>函数模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jar命令"><code>jar</code>命令</h3>
<ul>
<li><p><code>jar</code>命令与<code>tar</code>命令极其相似，用于归档</p></li>
<li><p>常用参数如下：</p>
<ul>
<li><code>-v</code>：<code>verbose</code>，显示归档/解压详情</li>
<li><code>-c</code>：<code>create</code>，创建归档文件</li>
<li><code>-f</code>：<code>file</code>，指明归档文件名</li>
<li><code>-u</code>：<code>update</code>，更新归档文件</li>
<li><code>-x</code>：<code>extract</code>，解压归档文件</li>
</ul></li>
<li><p>常用语句如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jar -cf a.jar 类列表</span><br><span class="line">jar -uf a.jar 新加入类列表</span><br><span class="line">jar -xf a.jar 解压a.jar</span><br></pre></td></tr></table></figure></li>
<li><p>归档后，可以通过<code>java -cp xxx.jar MainClass</code>运行主类<code>MainClass</code>，所有需要链接的类都在归档文件中找到</p></li>
</ul>
<h2 id="关键字及声明型语句">关键字及声明型语句</h2>
<h3 id="访问控制修饰符">访问控制修饰符</h3>
<ul>
<li><p>本节不讨论内部类</p></li>
<li><p><code>java</code>有四个访问控制权限，分别对应<code>public、protected、default、private</code>四个修饰符</p></li>
<li><p><code>public</code>：可以修饰类、接口、方法、属性，表示所有包可访问，是最常用的修饰符</p></li>
<li><p><code>protected</code>：可以修饰方法、属性，表示同包内均可访问，外部包中仅子孙类可通过<code>this</code>(自己或子孙类的对象)访问，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> a;</span><br><span class="line"><span class="keyword">import</span> b.A;   <span class="comment">// 假设含有protected void methodA() &#123;&#125;方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">      methodA();  <span class="comment">// 正确</span></span><br><span class="line">      <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">      a.methodA();    <span class="comment">// 错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>default</code>：实际上不存在这个关键字，当类或方法或属性没有显式地声明访问控制修饰符时，含有<code>default</code>权限，常称为<strong>包级私有</strong>，仅包内所有类可访问</p></li>
<li><p><code>private</code>：可以修饰方法、属性，仅类内可访问</p></li>
</ul>
<h3
id="staticabstractfinalrecord"><code>static、abstract、final、record</code></h3>
<ul>
<li><p><code>static</code>：声明静态对象或方法或内部类，和<code>cpp</code>类似</p></li>
<li><p><code>abstract</code>：声明抽象方法或抽象类，和<code>cpp</code>的<code>virtual</code>定义类似</p></li>
<li><p><code>final</code>：</p>
<ul>
<li>修饰类时：表明该类不能被继承</li>
<li>修饰方法时：表明该方法不能被重写</li>
<li>修饰变量时：声明常变量，注意只是限制在栈中的值不能改变</li>
</ul></li>
<li><p><code>abstract</code>不能和<code>final</code>或<code>private</code>或<code>static</code>同时出现，因为没有意义</p></li>
<li><p><code>final</code>不能修饰接口，因为没有意义</p></li>
<li><p>修饰符的顺序对程序没有影响，但规范是先是访问控制修饰符，然后是其它修饰符</p></li>
<li><p><code>final</code>修饰引用对象时只能限制该变量<strong>不能改变指向</strong>，但没有限制用户通过该变量<strong>改变其指向的实例</strong></p>
<p>因为<code>final</code>修饰方法只代表该方法不能被重写，所以做不到<code>cpp</code>那样用一个类型声明可变或不可变对象</p>
<p>在<code>java</code>中，一个类要么是可变类，要么是不可变类，<strong>不可变类的所有属性都被<code>final</code>修饰且不提供<code>setter</code>方法</strong>，例如<code>String</code>就是典型的不可变类，不要把实例方法和引用赋值搞混：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;    <span class="comment">// 引用赋值</span></span><br><span class="line">s = s.trim();     <span class="comment">// 实际上是改变了s的指向使其指向s.trim()的返回值，而没有改变原来指向堆中的实例</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);   <span class="comment">// 引用赋值</span></span><br><span class="line">sb.append(<span class="string">&quot;a&quot;</span>);   <span class="comment">// StringBuilder是一个可变类, append()修改了sb指向的实例的属性</span></span><br></pre></td></tr></table></figure></li>
<li><p>重写后的方法的访问控制权不能比父类的该方法低</p></li>
<li><p><code>record</code>关键字可用于修饰类，表示一个类是不可变类，自动添加<code>final</code>等修饰符、自动实现<code>equals(), hashCode()</code>方法、自动实现<code>getter</code>方法</p></li>
</ul>
<h3
id="synchronizedtransientvolatilesealedpermits"><code>synchronized、transient、volatile、sealed、permits</code></h3>
<ul>
<li><p><code>synchronized</code>用于同步</p></li>
<li><p><code>transient</code>修饰表示无法被序列化</p></li>
<li><p><code>volatile</code>修饰表示每次读写都对主存读写，但仍不能保证原子性</p></li>
<li><p><code>sealed</code>和<code>permits</code>是<code>JDK 17</code>及以上提供的继承修饰符，与<code>final</code>相区分，<code>sealed</code>修饰的类只能被其<code>permits</code>的类继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> SuperClass <span class="keyword">permits</span> SubClass &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;&#125;  <span class="comment">// 允许</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="标识符声明">标识符声明</h3>
<ul>
<li><p>声明变量：仅支持用<code>=</code>初始化新变量，且需要指明类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>声明类：<code>java</code>没有函数，所有函数体<strong>都在类内</strong>，抽象类不能被实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modifiers <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;ClassBody&#125;  <span class="comment">// 不需要&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>声明方法：抽象方法所属类必须为抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modifiers returnType <span class="title function_">methodName</span><span class="params">(paramList)</span> &#123;methodBody&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>声明接口：<code>java</code>提供所谓接口，是一系列抽象方法的集合，是其它模块访问你编写的模块的入口，编译时会自动在接口的所有方法前加上<code>public</code>修饰符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceName</span> &#123;</span><br><span class="line">  <span class="comment">// 接口内的方法默认为public，且没有实现</span></span><br><span class="line">  returnType <span class="title function_">methodName</span><span class="params">(paramList)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>声明一个实现了某个接口的类，一个类可以实现多个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> <span class="keyword">implements</span> <span class="title class_">InterfaceName</span> &#123;</span><br><span class="line">  <span class="comment">// 必须重写所有该接口的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>声明一个继承了某个类的类，或一个继承了某个接口的接口，只能单继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceName</span> <span class="keyword">extends</span> <span class="title class_">SuperInterface</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>extends</code>应该在<code>implements</code>之前</p></li>
</ul>
<h3 id="标识符规范">标识符规范</h3>
<ul>
<li>包名规范：应全小写</li>
<li>变量名和方法名规范：构成标识符的所有单词，首单词全小写，其余单词仅首字母大写</li>
<li>类名和接口名规范：构成标识符的所有单词首字母均大写</li>
<li>常量名规范：应全大写</li>
</ul>
<h3 id="protected权限的解释"><code>protected</code>权限的解释</h3>
<ul>
<li>在引入类(链接在<code>.class</code>文件中的字节码)时，<code>JVM</code>会加载类/接口的元数据进方法区，并构建<strong>方法表</strong>来区分不同的访问控制域</li>
<li>在创建对象时，<code>JVM</code>会申请一段内存，并创建<strong>对象的方法表</strong>，用于<strong>单独存储所有非静态成员</strong>
类、对象的方法表是不同的</li>
<li>每个类都会维护一个引用，指向允许访问的类或对象的方法表
<ul>
<li>这个引用能指向所有同一包的类及其对象、所有引入的外包类的方法表</li>
<li>能指向，同时符合访问修饰符的范围，才能正常调用</li>
</ul></li>
<li>因此<code>protected</code>是极其特殊的：
<ul>
<li>包外子类<strong>不能</strong>通过<strong>基类的对象</strong>访问<strong>保护型方法</strong>，因为包外的子类不能指向对象的方法表</li>
<li>包外子类可以通过<strong>基类</strong>访问<strong>保护型静态方法</strong>，因为包外子类能指向类的方法表，同时符合<code>protected</code>的范围</li>
<li>包内子类可以通过基类及其对象访问保护型方法，因为包内类能指向类及其对象的方法表，同时符合<code>protected</code>的范围</li>
</ul></li>
</ul>
<h2 id="java的语法糖"><code>java</code>的语法糖</h2>
<ul>
<li><p><code>java</code>不支持运算符重载，仅有部分特殊的类含有类似的语法糖(<code>String</code>支持<code>+</code>拼接，但没有<code>[]</code>运算符)</p></li>
<li><p><code>java</code>不支持默认参数</p></li>
<li><p><code>java</code>支持函数重载，重载要求方法名相同但参数列表不同</p></li>
<li><p><code>java</code>支持变长参数，<code>java</code>变长参数的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// paramList可以是零或多个String参数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String... paramList)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>java</code>不支持多继承</p></li>
<li><p><code>java</code>不支持常方法，<code>cpp</code>支持用<code>const</code>修复一个方法保证不能被非常量调用</p></li>
<li><p><code>java</code>和<code>cpp</code>均支持类型自动推断，在<code>cpp</code>中是<code>auto</code>而在<code>java</code>中是<code>var</code></p></li>
<li><p><code>java</code>的<code>Type[]</code>整体表示一个数组类型，元素的类型为指定的<code>Type</code></p></li>
</ul>
<h2 id="结构型语句">结构型语句</h2>
<ul>
<li><code>if-else if-else</code></li>
<li><code>where-continue-break</code></li>
<li><code>for(;;)-continue-break</code></li>
<li><code>for(type e : c)</code>语法糖</li>
<li><code>try-catch-finally</code></li>
<li><code>try-with-resource</code></li>
<li><code>switch-case-break</code></li>
<li><code>switch-case -&gt; {yield}</code></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论: 01字典树</title>
    <url>/blogs/2025/02/21/algo-bin-01tire/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, i, u, v, w, head[<span class="number">100002</span>], cnt = <span class="number">1</span>, cnt01 = <span class="number">1</span>, ch[<span class="number">100002</span> * <span class="number">32</span>][<span class="number">2</span>], ans, sum[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to, next, w;</span><br><span class="line">&#125;e[<span class="number">100002</span> &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> ww)</span> </span>&#123;</span><br><span class="line">    e[cnt].to = to;</span><br><span class="line">    e[cnt].w = ww;</span><br><span class="line">    e[cnt].next = head[from];</span><br><span class="line">    head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">31</span>, s = <span class="number">0</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        m = x &amp; (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">        <span class="keyword">if</span> (!ch[s][m]) &#123;</span><br><span class="line">            ch[s][m] = cnt01++;</span><br><span class="line">        &#125;</span><br><span class="line">        s = ch[s][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa, <span class="type">int</span> xorw)</span> </span>&#123;</span><br><span class="line">    sum[p] = xorw;</span><br><span class="line">    <span class="built_in">addWt</span>(xorw);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = head[p]; k; k = e[k].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to != fa) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(e[k].to, p, xorw ^ e[k].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> m;</span><br><span class="line">    <span class="type">int</span> nans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">31</span>, s = <span class="number">0</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        m = x &amp; (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">        <span class="keyword">if</span> (ch[s][!m]) &#123;</span><br><span class="line">            nans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ++nans;</span><br><span class="line">            s = ch[s][!m];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            s = ch[s][m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, nans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">        <span class="built_in">addEdge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">find</span>(sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Trick</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>图的算法: SCC（强连通分量）</title>
    <url>/blogs/2025/02/11/algo-graph-scc/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10004</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">10004</span>], cnt = <span class="number">1</span>, w[<span class="number">10004</span>], sw[<span class="number">10004</span>], i, n, m, u, v, dfn[<span class="number">10004</span>], rt[<span class="number">10004</span>], scecnt = <span class="number">1</span>, schead[<span class="number">10004</span>], ncnt, aans[<span class="number">10004</span>];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from, to, next;</span><br><span class="line">&#125;e[<span class="number">100004</span>], se[<span class="number">100004</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getScc</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    dfn[p] = rt[p] = ++ncnt;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line">    stk.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = head[p]; k; k = e[k].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[e[k].to]) &#123;</span><br><span class="line">            <span class="built_in">getScc</span>(e[k].to);</span><br><span class="line">            rt[p] = <span class="built_in">min</span>(rt[p], rt[e[k].to]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[e[k].to]) &#123;</span><br><span class="line">            rt[p] = <span class="built_in">min</span>(rt[p], rt[e[k].to]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt[p] == dfn[p]) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">top</span>() != p) &#123;</span><br><span class="line">            rt[stk.<span class="built_in">top</span>()] = dfn[p];</span><br><span class="line">            vis[stk.<span class="built_in">top</span>()] = <span class="literal">false</span>;</span><br><span class="line">            sw[rt[p]] += w[stk.<span class="built_in">top</span>()];</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        vis[p] = <span class="literal">false</span>;</span><br><span class="line">        sw[rt[p]] += w[p];</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSccgraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rt[e[k].from] != rt[e[k].to]) &#123;</span><br><span class="line">            se[scecnt].to = rt[e[k].to];</span><br><span class="line">            se[scecnt].next = schead[rt[e[k].from]];</span><br><span class="line">            schead[rt[e[k].from]] = scecnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[p]) &#123;</span><br><span class="line">        <span class="keyword">return</span> aans[p];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!schead[p]) &#123;</span><br><span class="line">        <span class="keyword">return</span> aans[p] = sw[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = schead[p]; k; k = se[k].next) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(se[k].to) + sw[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aans[p] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        e[cnt].from = u;</span><br><span class="line">        e[cnt].to = v;</span><br><span class="line">        e[cnt].next = head[u];</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            <span class="built_in">getScc</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getSccgraph</span>();</span><br><span class="line">    <span class="type">int</span> realans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[i] == rt[i]) &#123;</span><br><span class="line">            realans = <span class="built_in">max</span>(realans, <span class="built_in">dfs</span>(rt[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; realans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Graph Algo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统: 基本结构</title>
    <url>/blogs/2025/02/10/os-structure/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="操作系统概述">操作系统概述</h2>
<h3 id="os本质"><code>OS</code>本质</h3>
<ul>
<li>软件分为系统软件、支撑软件、应用软件(功能专用)，操作系统是一种<strong>系统软件</strong></li>
<li>系统软件包括<code>OS</code>(运行程序)，编译器(生成程序)，数据库系统<code>DBMS</code>(管理数据)等</li>
<li>计算机由上至下可分为用户层、程序层、库例程、系统调用、操作系统、硬件
<ul>
<li>狭义上的操作系统仅包含<strong>系统调用和操作系统</strong>，它们合称内核<code>Core/Kernal</code></li>
<li>广义上还包含库例程、系统程序及硬件层</li>
</ul></li>
<li>根据侧重点不同，可分类：
<ul>
<li>资源共享及工作效率：<code>Unix</code></li>
<li>易用性：<code>Windows</code></li>
<li>资源高效利用：移动端<code>OS</code></li>
<li>安全性：嵌入式<code>OS</code></li>
</ul></li>
</ul>
<h3 id="os功能模块概述"><code>OS</code>功能模块概述</h3>
<ul>
<li><code>CPU</code>管理：
<ul>
<li>包括进程管理(对任务进行管理)、<code>CPU</code>调度(支持多任务)、进程同步控制(支持并发)</li>
</ul></li>
<li>内存管理：
<ul>
<li>包括内存分配、虚存管理</li>
</ul></li>
<li>文件管理：
<ul>
<li>包括接口设计及其实现</li>
</ul></li>
<li>设备管理：
<ul>
<li>包括<code>I/O</code>管理，设备分类，设备驱动</li>
</ul></li>
<li>通信</li>
</ul>
<h3 id="os服务"><code>OS</code>服务</h3>
<ul>
<li><code>UI</code>(<code>user interface</code>，用户接口)服务：
<ul>
<li><code>CLI</code>(<code>command-line interface</code>，命令行接口)：<code>Unix、Linux、Windows  Server</code>
<ul>
<li>效率高且稳定</li>
<li>通过终端(<code>terminal</code>)键入命令，如今均使用特殊的终端环境控制台(<code>Console</code>)
终端环境统称<code>TTY</code>(<code>teletypewriter</code>)
键入的命令为某种<code>Shell</code>，为脚本语言</li>
</ul></li>
<li><code>GUI</code>(<code>graphical user interface</code>，图形用户接口)：<code>Windows</code></li>
<li><code>TSI</code>(<code>touch screen interface</code>，触控接口)：<code>MacOS</code></li>
</ul></li>
<li>程序执行：
<ul>
<li>先将可执行文件(<code>windows-.exe、linux-.elf、macOS-.mach-o</code>)/脚本(<code>shell/python</code>)文件加载到内存</li>
<li>由<code>CPU</code>取指执行</li>
</ul></li>
<li><code>I/O</code>管理</li>
<li>文件系统：
<ul>
<li>接口：如命名、读写等方法</li>
<li>具体实现：需考虑存储结构、性能</li>
</ul></li>
<li>通信：任务间通信等</li>
<li>错误检测(<code>error detection</code>)：即软件中断</li>
<li>服务保障(保证上述服务正常运行的服务)：(<code>CPU</code>、内存、磁盘)资源回收、运行日志、系统资源访问控制</li>
</ul>
<h3 id="os内核分类"><code>OS</code>内核分类</h3>
<ul>
<li>单内核(宏内核)：<code>DOS、Unix</code>
<ul>
<li>用户层包含应用、库例程</li>
<li>内核包含文件系统、<code>IPC</code>(<code>Inter-Process Communication</code>，进程间通信)、<code>I/O</code>控制、进程管理等性能要求高的服务</li>
</ul></li>
<li>微内核：<code>Mach</code>
<ul>
<li>文件系统归入用户层</li>
<li>性能效率低，但可移植、可扩展性强、且支持分布式系统</li>
</ul></li>
<li>混合内核：<code>Windows、XNU、MacOS</code></li>
</ul>
<h3 id="系统调用">系统调用</h3>
<ul>
<li>系统调用是用户程序(及标准库等)和系统服务间的最原始接口，用户程序通过系统调用来主动访问系统程序</li>
<li>和函数调用的区别：将用户态转换为核心态，以访问处于保护状态的程序和设备；执行完后切换回用户态
<ul>
<li>核心态是特殊的执行模式，使核心服务代码在被保护的状态下执行</li>
<li>使用系统调用与函数调用类似，仅仅是由操作系统完成期间的执行模式转换操作</li>
</ul></li>
<li>系统调用的参数传递方式：
<ul>
<li>寄存器传递：效率高，优先使用；但可传递参数数量少</li>
<li>内存块传递：分配内存块给待传递参数，将块地址传递给系统程序</li>
<li>栈传参：用户程序将参数入栈，系统程序退栈使用参数</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python: 使用argparse开发CLI</title>
    <url>/blogs/2025/01/20/python-argparse/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="前置命令行工具知识">前置命令行工具知识</h3>
<ul>
<li><p><code>argparse</code>是用于开发命令行工具接口的库，通过内建的解析器来解析自定义的命令行参数
相比于<code>optparse</code>(<code>py2.7</code>后被<code>argparse</code>替代，并不再维护)，接口功能更强，但灵活性略低
关于<code>getopt</code>，它是基于<code>C</code>的<code>getopt()</code>函数族(通常可以在<code>Linux</code>看到)实现的一套很底层的接口，比较难用(对比<code>optparse</code>接口功能更加单一，需要手动实现复杂功能)</p></li>
<li><p>对于一个开发完毕的命令行工具脚本(假设名为<code>a.py</code>)，其固有(库会自动添加)的命令是<code>-h</code>或<code>--help</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python a.py -h</span><br></pre></td></tr></table></figure>
<p>将输出开发者自定义的命令参数及其帮助字符串
常使用命令行工具的开发者应该已经知道，含<code>'-'</code>和<code>'--'</code>前缀的参数为可选项，其中前者为命令缩写、后者为命令全称；上述<code>-h</code>的全称为<code>--help</code>
称不含此类前缀的参数为<strong>位置参数/占位参数</strong>，即用户必须传递的参数
此类可选项为<strong>可选参数</strong>，即用户可以根据情况传递的参数(并附上选项缩写或全称)</p></li>
<li><p>必须进行约定，以区分开发者向接口传递的参数和用户输入的参数，我们将后者始终称作用户输入(或使用位置参数和可选参数这两个名词)，其余的参数均为接口的参数、或明确说明是“开发者传递的”
用户输入可选参数，需要指出选项缩写或全称，再跟实际要传递的参数
用户输入位置参数，不需要上述操作，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python a.py 1  <span class="comment"># 位置参数不需要选项名</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python a.py -o 1 <span class="comment"># 可选参数需要以选项名-o为该项参数的起点, 后续1为实际要传递的参数</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设有若干个位置参数(a1, a2, ..., an), 那么它们必须按部就班地顺序排列</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python a.py 1 2 ... n</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选参数可以在任意位置插入其中</span></span><br></pre></td></tr></table></figure>
<p>可选参数可以随意插入其中并以选项名作为起点，那么解析器如何区分它们是连续的位置参数、还是掺杂着可选参数的位置参数呢？
实际上，<strong>可选参数后面的实际要传递的参数，默认只能传递一个</strong>
后面可以看见，可以设置让可选参数后可跟多个实际参数，此时可以用显式分隔符<code>--</code>解决上述问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  python a.py -o 1 2 3  # [1, 2, 3] -&gt; o</span><br><span class="line">  python a.py -o 1 2 -- 3 # [1, 2] -&gt; o、3 -&gt; 位置参数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 最常用`API`</span></span></span><br><span class="line"></span><br><span class="line">- `argparse`库通过`ArgumentParser`类(参数解析器)实现其功能，创建一个解析器对象：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  p = argparse.ArgumentParser()</span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法的默认参数基本不用修改(几乎都是对帮助信息的设置)，故可以为空；如果想添加对该命令行工具概括性的描述，可以传递关键字参数<code>prog:str、usage:str、description:str</code>
该描述将在用户传递<code>--help</code>时在<code>positional/optional argument</code>前将程序名称、程序使用说明、功能描述打印在屏幕上</li>
<li>一些其次的参数：
<code>add_help:bool=true</code>：是否自动添加帮助命令
<code>parents:Sequence[ArgumentParser]</code>：从其它解析器对象继承参数(如要使用，其它解析器对象的<code>add_help</code>最好设置为<code>false</code>)
<code>prefix_chars:str='-'</code>：如其名</li>
</ul></li>
<li><p><strong><code>add_augument()</code></strong>：添加用户需要传递的命令行参数，包含一个可变参数及若干关键字参数
解析器将用户输入的参数<strong>存储在一个命名空间</strong>，以<strong>用户输入的参数作为值</strong>、
以开发者传入的<strong>选项名作为键</strong>，<strong>传入的选项名应该符合命名规范(除前缀符)</strong></p>
<ul>
<li><p><code>help:str</code>：对于开发者来说是必填的，将显示在帮助文档中对应参数后，表示该项参数的功能</p></li>
<li><p><strong><code>*name_or_flags:str</code></strong>：
开发者传递单个字符串时，可以是位置参数或可选参数；<strong>传递多个字符串时，只能全部是可选参数</strong>
若为可选参数，如果全为缩写(即前缀为<code>-</code>)，则将第一个缩写视为键
如果<strong>存在全称(即前缀为<code>--</code>)，则将第一个全称视为键</strong>
对一个正常的开发者来说，只会设置一个缩写与一个全称，所以不用了解更多的机制
一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置时没有设置每个参数的数量, 默认为接收1个</span></span><br><span class="line">p.add_argument(<span class="string">&#x27;position_name1&#x27;</span>)<span class="comment"># 添加position_name1作为位置参数</span></span><br><span class="line">p.add_argument(<span class="string">&#x27;p_name2&#x27;</span>)  <span class="comment"># 添加p_name2作为位置参数, 必须在上述参数后传递</span></span><br><span class="line">p.add_argument(<span class="string">&#x27;-a&#x27;</span>, <span class="string">&#x27;--aaa&#x27;</span>) <span class="comment"># 添加全称aaa作为可选参数</span></span><br><span class="line">args = p.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户视角:</span></span><br><span class="line">&gt; python a.py <span class="number">1</span> -a <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 传递后, args.position_name1== &#x27;1&#x27;、args.p_name2 == &#x27;3&#x27;、args.aaa == &#x27;2&#x27;</span></span><br><span class="line"><span class="comment"># args.a不存在, 因为提供了全称aaa</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>type</code></strong>：上述例子中，传递后的属性均为字符串，因为解析器会<strong>默认将输入视为字符串</strong>
可以用<code>type=otherType</code>让解析器进行类型转换，其中<code>otherType</code>应是一个<strong>类型转换的函数指针</strong>
其<strong>默认可以选择<code>int</code>、<code>float</code></strong>并在参数<strong>不合法时抛出<code>argparse.ArgumentTypeError</code></strong>
开发者<strong>可以自定义</strong>类型转换用于处理传入的字符串，记得在参数不合法时手动<code>raise argparse.ArgumentTypeError</code>
也可以把该参数看作一种对用户输入的类型限制</p></li>
<li><p><strong><code>choices:list</code></strong>：用于限定输入的值(必须是列表内的值)，注意<strong>列表元素的类型应与<code>type</code>一致</strong></p></li>
<li><p><strong><code>dest</code></strong>：用于限定输入值存储于指定属性(属性名必须符合规范)；默认为本条<code>argument</code>的名称
这样就<strong>可以随意命名选项名</strong>了，可以不符合命名规范</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  p.add_argument(<span class="string">&#x27;-a&#x27;</span>) <span class="comment"># 用户输入-&gt;args.a</span></span><br><span class="line">  p.add_argument(<span class="string">&#x27;-a&#x27;</span>, dest=<span class="string">&#x27;b&#x27;</span>) <span class="comment"># 用户输入-&gt;args.b</span></span><br><span class="line">  p.add_argument(<span class="string">&#x27;-a--abc&#x27;</span>, dest=<span class="string">&#x27;b&#x27;</span>) <span class="comment"># 用户输入-&gt;args.b</span></span><br><span class="line"></span><br><span class="line">- **`default`**：设置`default`参数后，用户可以选择**不输入该项(包括选项名)**并以`default`的值作为用户输入</span><br><span class="line"></span><br><span class="line">- `const`：设置`const`参数后，用户可以选择**不输入该项的实际参数**并以`const`的值作为用户输入</span><br><span class="line">  要使用`const`，必须同时**设置`nargs=<span class="string">&#x27;?&#x27;</span>`**、或者**设置`action`为常量相关行为**</span><br><span class="line"></span><br><span class="line">- **`nargs`**：指定用户输入的数量</span><br><span class="line"></span><br><span class="line">  - 非负整数`N`：指定用户必须输入`N`个值</span><br><span class="line"></span><br><span class="line">  - `<span class="string">&#x27;?&#x27;</span>`：用户可以输入零/一个值</span><br><span class="line"></span><br><span class="line">  - `<span class="string">&#x27;*&#x27;</span>`：用户可以输入零/多个值，存储为列表，用户可以用显式分隔符`--`分割不同参数项</span><br><span class="line"></span><br><span class="line">  - `<span class="string">&#x27;+&#x27;</span>`：用户可以输入一/多个值，存储为列表</span><br><span class="line"></span><br><span class="line">  设置为收集为列表的选项时，自动设置`action=<span class="string">&#x27;extend&#x27;</span>`</span><br><span class="line"></span><br><span class="line">- **`action:<span class="built_in">str</span>=<span class="string">&#x27;store&#x27;</span>`**：用于解析器对用户输入**最初的行为**</span><br><span class="line">  **视`action`的值，其它参数可能不允许设置**</span><br><span class="line">  一些常见的`action`：</span><br><span class="line"></span><br><span class="line">  - **`store`**：默认值，存储用户输入</span><br><span class="line"></span><br><span class="line">  - `store_true/store_false`：将本`argument`**视作布尔值**，仅在本条参数为可选参数时有效</span><br><span class="line">    用户只需要指出这个可选项的名称(缩写或全称)，**后面不允许接任何参数**</span><br><span class="line">    当`action`设置为`store_true`时，用户指出这个可选项则本条参数设置为`true`</span><br><span class="line">    `store_false`同理</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    p.add_argument(<span class="string">&#x27;-c&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 用户视角:</span></span><br><span class="line">    &gt; python a.py -c <span class="number">1</span>  <span class="comment"># 出错, -c后不允许跟参数(除非有其它位置参数在后面)</span></span><br><span class="line">    &gt; python a.py -c  <span class="comment"># 正常, 且args.c == True</span></span><br><span class="line">    &gt; python a.py   <span class="comment"># 正常, 且args.c == False</span></span><br></pre></td></tr></table></figure>
<p>因其特性，<strong><code>nargs、type、choices</code>不允许设置</strong></p>
<ul>
<li><p><strong><code>append</code></strong>：允许<strong>多次使用本选项</strong>(而不是一个选项名后接若干个参数)，并将所有参数全部收集成为列表类型</p></li>
<li><p><code>store_const</code>：行为类似于<code>store_true</code>，用户不允许提供实际参数，并使用<code>const</code>参数的值作为属性值；仍不允许设置<code>nargs、type、choices</code>
<code>append_const</code>：在<code>store_const</code>的基础上增加了<code>append</code>的特性，其它参数的限制同上</p></li>
<li><p>也可以继承<code>Action</code>类自定义行为，有兴趣可以了解<a
href="https://www.cnblogs.com/xueweihan/p/11415703.html">Python
命令行之旅_博客园</a></p></li>
</ul></li>
</ul></li>
<li><p><code>parse_args()</code>：返回一个命名空间，其中存储用户输入的各个参数值</p></li>
</ul>
<h3 id="其它api了解即可">其它<code>API</code>(了解即可)</h3>
<ul>
<li><p><code>parse_known_args()</code>：在<code>parse_args()</code>的基础上，收集用户多余的输入(不报错)；返回二元组，前者为<code>parse_args()</code>的返回值、后者为收集到的多余输入(列表)</p></li>
<li><p><code>add_argument_group()</code>：返回一个参数分组，用法和解析器对象一致，方便将用户输入分给多个解析器对象管理，适用于维护大型命令行工具
参数分组只能添加参数/添加参数分组，其本身及其子分组收集到的参数均上交给解析器，并由<code>parse_args()</code>展现给开发者</p></li>
<li><p><code>add_mutually_exclusive_group()</code>：在<code>add_argument_group()</code>的基础上，限制用户一次命令只能输入组内的其中一个参数</p></li>
<li><p><code>add_subparsers()</code>：返回子解析器，并允许开发者设置子命令，当主解析器遇到子命令时，将解析任务交给子解析器
<code>add_parsers(name:str)</code>：子解析器可以调用该方法返回一个子命令参数解析器，必须指定子命令的名称<code>name</code>，其它参数和<code>ArgumentParser()</code>构造方法一致
拥有多个子解析器是没有意义的，一个子解析器足矣，正确用法是<strong>通过这个子解析器调用多次<code>add_parsers()</code>返回多个参数解析器对象</strong>，这些对象的<code>API</code>和之前学过的常用<code>API</code>一致
可以将子解析器看作一个中间件</p>
<p>```python p = argparse.ArgumentParser() subp = p.add_subparsers()
subp1 = subp.add_parsers(name=‘init’) subp1.add_argument(‘-a’)</p>
<h1 id="用户视角">用户视角</h1>
<blockquote>
<p>python a.py init 1 # 1 -&gt; subp1.parser_args().a init为子命令1</p>
</blockquote></li>
<li><p><code>error()</code>：默认的错误处理方法</p>
<p>可以将解析器的<code>error</code>函数指针替换为自定义错误处理函数</p></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
        <category>Std library</category>
      </categories>
      <tags>
        <tag>CLI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python: 使用Pandas处理数据</title>
    <url>/blogs/2025/01/18/python-pandas/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="pandas介绍"><code>pandas</code>介绍</h3>
<ul>
<li><code>pandas</code>名字来源于<code>panel datas</code>，即面板数据</li>
<li><code>pandas</code>主要用于数据分析及数据处理</li>
<li><code>pandas</code>最常用的两种数据结构是<code>Series</code>和<code>DataFrame</code>
从形状上来看，<code>DataFrame</code>是二维数据结构的封装，<code>Series</code>是<code>DataFrame</code>中的一列，是一维数据结构的封装</li>
<li><code>pandas</code>提供的更重要的<code>API</code>包括数据清洗、数据预处理、数据操作、数据读取和导出</li>
</ul>
<h3 id="pandas.series"><code>pandas.Series</code></h3>
<ul>
<li><p>可以将<code>Series</code>看作更强的字典，提供了许多类似<code>numpy</code>数组的<code>API</code></p></li>
<li><p>构造方法：<code>Series(data=None, index=None, dtype=None, name=None, copy=None)</code></p>
<ul>
<li><p><code>data</code>：数据源，可以是列表、字典、数组</p></li>
<li><p><code>index</code>：索引列表/数组</p>
<p>当<code>data</code>提供的是列表或数组时，<code>index</code>默认为以<code>0</code>开头的递增索引序列，也可以提供<strong>长度和<code>data</code>相同</strong>的一维数据结构</p>
<p>当<code>data</code>提供的是字典时，<code>index</code>若为<code>None</code>则默认<code>index</code>为该字典的键，<code>Series</code>中的值为该字典的值，若<code>index</code>不为<code>None</code>则起筛选作用，以<code>index</code>的值为索引值，若某索引值存在于<code>data</code>中则取<code>data</code>的值，否则为<code>numpy.nan</code></p>
<p>本质上是自动转换为一个<code>AxesData</code>对象(用于存储索引信息的数据对象)，可以通过自定义<code>index</code>实现类似字典的索引</p></li>
<li><p><code>name</code>：该<code>Series</code>对象的名字，可以在<code>DataFrame</code>等结构中索引</p></li>
</ul></li>
<li><p><code>Series</code>实例属性：</p>
<ul>
<li><p><code>index</code>：<code>Index</code>对象，表示索引数据</p></li>
<li><p><code>values</code>：<code>numpy</code>数组，表示其存储的数据</p></li>
<li><p><code>dtype</code>：存储数据的数据类型，可以在构造方法中指定，否则自动推断</p></li>
<li><p><code>shape</code>：<code>Series</code>对象的形状，<code>Series</code>永远将<code>data</code>视为一维结构，即使传递一个二维数组</p></li>
</ul></li>
<li><p><code>Series</code>实例方法：</p>
<ul>
<li><p><code>describe()</code>：返回<code>Series</code>对象，包含原对象的各种统计数据，包括<code>'count', 'mean', 'std', 'min', 'max'</code></p>
<p>也可以通过调用原对象的<code>count()</code>、<code>mean()</code>方法直接获取单个统计数据，其中<code>sum(), cov(), corr()</code>等是<code>describe()</code>没有涉及到的</p></li>
<li><p><code>unique()</code>：返回去重后的<code>numpy</code>数组</p></li>
<li><p><code>sort_index()</code>和<code>sort_values()</code>：返回根据索引或根据值排序后的<code>Series</code>对象</p></li>
<li><p><code>dropna()</code>：返回删除了所有<code>nan</code>后的<code>Series</code>对象</p></li>
<li><p><code>fillna(v)</code>：返回将所有<code>nan</code>用<code>v</code>填充后的<code>Series</code>对象</p></li>
<li><p><code>to_list()</code>和<code>to_frame()</code>：转化为原生列表和<code>DataFrame</code>对象</p></li>
<li><p><code>loc</code>和<code>iloc</code>：<code>pandas</code>支持切片语法，同时提供了另一种索引方法<code>loc(line of code)</code>，通过<code>loc[label]</code>或<code>iloc[index]</code>可以更清晰地表示索引，它们和原生索引的最明显<strong>区别是<code>:</code>切片符是双闭切片</strong></p>
<p>无论是原生切片符还是<code>loc</code>切片，<code>Series</code>对象都同样支持条件过滤，而且它实现了一般的运算符重载，均为逐元素运算，同<code>numpy</code>数组一样在运算时会自动对齐</p></li>
<li><p><code>cumsum(), cumprod(), cummax(), cummin()</code>：返回前缀求和/求积/取最大/取最小处理后的<code>Series</code>对象</p></li>
</ul></li>
<li><p>构造方法示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s1 = pd.Series([<span class="number">1</span>, <span class="number">2</span>])                <span class="comment"># 0:1, 1:2</span></span><br><span class="line">s2 = pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="number">2</span>, <span class="number">1</span>])  <span class="comment"># 2:1, 1:2</span></span><br><span class="line">s3 = pd.Series([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])      <span class="comment"># shape: (2,)   0:list[1,2], 1:list[3,4]</span></span><br><span class="line">s4 = pd.Series(&#123;<span class="number">1</span>:<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>&#125;)          <span class="comment"># 1:2, &#x27;a&#x27;:3</span></span><br><span class="line">s5 = pd.Series(&#123;<span class="number">1</span>:<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>&#125;, index=[<span class="number">1</span>, <span class="number">2</span>])    <span class="comment"># 1:2, 2:None</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pandas.dataframe"><code>pandas.DataFrame</code></h3>
<ul>
<li><p><code>Series</code>可以看作更强的字典，而<code>DataFrame</code>则可以看作值全为<code>Series</code>对象的字典，因此它是二维数据结构</p>
<p>与<code>Series</code>不同的是，<code>DataFrame</code>有行索引和列索引</p></li>
<li><p>构造方法：<code>DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)</code></p>
<ul>
<li><p><code>data</code>：可以是列表、数组、字典，<code>DataFrame</code>永远将<code>data</code>视为二维数据结构来解析</p>
<p>当<code>data</code>提供的是字典，则使用字典的键作为<code>columns</code>(列索引)，用字典的值作为列，要求每一列结构相同，索引统一为<code>index</code>参数(行索引)</p>
<p>此外，<code>DataFrame</code>将<code>Series</code>看作一列，将二维数组的第一维看作行、第二维看作列</p></li>
<li><p><code>index</code>和<code>columns</code>参数分别为行索引和列索引</p></li>
</ul></li>
<li><p><code>DataFrame</code>实例方法：</p>
<ul>
<li><p>大多数方法和<code>Series</code>的实例方法一致，此外详细介绍<code>loc</code>系列索引方法</p>
<p><code>loc[x][y]</code>：按照先列再行的顺序索引，和原生的切片符不同，本质是先通过列索引取得<code>Series</code>再用<code>Series.loc</code></p>
<p><code>loc[x, y]</code>：取<code>x</code>行<code>y</code>列，和原生的切片符一致</p>
<p><code>loc[[x1, x2, ...], [y1, y2, ...]]</code>：选取第<code>x1, x2, ...</code>行、第<code>y1, y2, ...</code>列的元素并返回<code>DataFrame</code>，其中这些值是离散的，不能用<code>:</code></p>
<p><code>loc[[x1, x2, ...]]</code>：相当于在上述方法的基础上，默认选择全部列，只选择<code>x1, x2, ...</code>行的元素</p></li>
<li><p>类型转换方法：<code>to_csv(), to_excel(), to_json(), to_sql()</code></p></li>
<li><p><code>transpose()</code>或<code>T</code>：返回转置后的<code>DataFrame</code></p></li>
</ul></li>
</ul>
<h3 id="读取数据">读取数据</h3>
<ul>
<li><p>读取<code>csv</code>文件：<code>pandas.read_csv(filepath_or_buffer, sep, head, names, dtype, index_col)</code></p></li>
<li><p>读取<code>excel</code>文件：<code>pandas.read_excel(io, sheet_name, header, names, index_col, usecols, dtype, engine, ...)</code></p></li>
<li><p>读取数据库文件：<code>pandas.read_sql(query, conn_obj)</code></p></li>
<li><p>读取网页文件：<code>pandas.read_html(url)</code></p></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
        <category>Data Science Utils</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch: Tensor(张量)</title>
    <url>/blogs/2025/01/15/pytorch-tensor/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="tensor张量"><code>Tensor</code>(张量)</h3>
<ul>
<li><p>张量源于数学，并在微分几何中得到应用，其实早在线性代数中就已经学过，向量(一维张量)可以通过线性变换(乘上坐标变换矩阵，即一个二维张量)，在不同的坐标系下表示同一个坐标
在物理中，张量的特性与相对论假设一拍即合，用于描述多个物理量的排列组合，并可以通过线性变换在不同参考系下保持不变，看过广义相对论的科普视频可以知道，这种帮助其它张量线性变换的张量还叫度规张量，并且非常常用
在机器学习中，张量就是一个多维数组，整个张量是表示数据的基本单位，如果具体到数组中的每一个元素，可能它们并没有什么实际意义
引入张量是为了提供一个便于用户计算的接口：例如前向传播中，每一步都要进行矩阵运算，如果只提供一个一维数组，那功能也太弱了；更何况，图片、音频、视频等数据在编码后也需要更高维的数组进行存储</p></li>
<li><p><code>torch</code>是在神经网络领域上能够完全替代<code>numpy</code>的库，除了一些小众的数学计算，许多数学函数、多维数组操作<code>torch</code>都能提供，并在此基础上添加了便于深度学习的函数
如果你学过<code>numpy</code>，可以跳过一大部分这里介绍的方法和机制，很多时候将<code>np.</code>换成<code>torch.</code>其效果是一样的</p></li>
<li><p>张量的属性：</p>
<ul>
<li><p><code>dtype</code>：一个张量的所有元素类型必须是一致的，被封装为<code>torch.dtype</code>，支持各种位数的整数、浮点数等类型
只能通过张量的实例属性<code>dtype</code>访问该张量的元素类型，因为当你试图通过索引访问张量的元素时，返回的仍是<code>torch.Tensor</code>(即使只访问一个元素)，<code>type()</code>是看不到内部的元素属性的
很多深度学习相关方法要求张量的<code>dtype</code>为浮点类型</p></li>
<li><p><strong><code>device</code></strong>：<code>device</code>对象，标记张量部署的设备，如<code>cpu、cuda</code>等</p></li>
<li><p><code>shape</code>：返回<code>torch.Size</code>对象，是封装后的元组，表示张量的尺寸
元组的长度表示张量的维度，元组的第<code>i</code>个元素表示这个维度上的元素个数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor(<span class="number">1</span>)   <span class="comment"># Size([])  元组为空, 表示标量</span></span><br><span class="line">tensor([<span class="number">1</span>])   <span class="comment"># Size([1])  元组长1, 表示一维、1个元素</span></span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># Size([2])  元组长1, 表示一维、2个元素</span></span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>]]) <span class="comment"># Size([1, 2]) 元组长2, 表示二维、一行两列</span></span><br></pre></td></tr></table></figure>
<p>可以用切片符获取<code>Size</code>元组的信息，和内置元组操作一致
实例方法<code>size()</code>返回值和<code>shape</code>一致、<code>size(dim=num)</code>和<code>shape[num]</code>一致
<img src="torch_Tensor_size.png" alt="torch_Tensor_size" style="zoom:40%;" />
顺便提一下<code>ndim</code>属性，即维度大小</p></li>
<li><p><strong><code>requires_grad</code></strong>：布尔值，标记这个张量是否需要梯度；要想让<code>torch</code>在反向传播中自动跟踪并计算梯度，就必须使<code>requires_grad=True</code>
后续，所有基于<code>requires_grad=True</code>的张量运算而得的张量，<code>requires_grad</code>自动设置为<code>True</code>
梯度会被保存在<code>grad</code>属性中(如果是叶子张量)
需要注意，只有浮点类型的张量才允许需要梯度</p></li>
<li><p><code>is_leaf</code>：布尔值，标记这个张量是否为叶子张量
在创建的一瞬间，如果这个张量不需要梯度，或者需要梯度但由用户直接创建，则为叶子张量
否则，如果这个张量需要梯度、并且由其它张量运算得出，则不是叶子张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1</span>])      <span class="comment"># 默认不需要梯度</span></span><br><span class="line">b = torch.tensor([<span class="number">1</span>], requires_grad=<span class="literal">True</span>) <span class="comment"># 需要梯度</span></span><br><span class="line">aa = a * <span class="number">2</span></span><br><span class="line">bb = b * <span class="number">2</span>  <span class="comment"># requires_grad自动设置为True</span></span><br><span class="line"><span class="comment"># obj   is_leaf</span></span><br><span class="line"><span class="comment"># a    True</span></span><br><span class="line"><span class="comment"># b    True 需要梯度, 且由用户直接创建, 为叶子张量</span></span><br><span class="line"><span class="comment"># aa   True 不需要梯度, 为叶子张量</span></span><br><span class="line"><span class="comment"># bb   False 需要梯度, 但不由用户创建, 而是运算得出, 不是叶子张量</span></span><br></pre></td></tr></table></figure>
<p>开发者不需要过于关心<code>is_leaf</code>的值，但要知道，<strong>只有<code>is_leaf=True</code>的张量的梯度会被保留</strong>
<strong><code>requires_grad</code>决定是否计算该张量的梯度、<code>is_leaf</code>决定一个张量的梯度是否释放</strong>
这是理所当然的，一般我们只需要权重、偏置张量的梯度，而不需要中间结点值的梯度
<img src="Tensor_is_leaf.png" alt="Tensor_is_leaf" style="zoom:50%;" /></p></li>
<li><p><code>grad_fn</code>：布尔值，标记创建该张量的函数对象，所有叶子张量的<code>grad_fn</code>均为<code>None</code>
如果这个张量需要梯度，且由其它张量运算得出，则<code>grad_fn</code>指向这个运算函数</p></li>
<li><p><code>layout</code>：<code>layout</code>对象，表示张量的内存布局，默认<code>strided</code>(密集张量)、可选<code>aparse_coo</code>(<code>COO</code>格式的<a
href="https://www.cnblogs.com/xbinworld/p/4273506.html">稀疏矩阵</a>
<code>stride</code>(步长)表明，无论维度如何，所有数据的物理地址是连续的，通过步长来访问维度
例如对于三行三列的二维张量，当用户访问第三行第三列的元素(第<code>9</code>个元素)时，指针(初始指向第<code>1</code>个元素)先增加两次第一维度的步长<code>3</code>、再增加两次第二维度的步长<code>1</code>，找到目标的实际物理地址
实际上，张量在实现上就是用步长元组<code>stride</code>和一维列表<code>UntypedStorage</code>存储的
你可以用<code>untyped_storage()</code>返回张量的一维映射，用于理解其实现</p></li>
</ul></li>
<li><p><strong>创建张量</strong>：</p>
<ul>
<li><p>深拷贝：使用工厂函数<strong><code>torch.tensor(data)</code></strong>
通过<strong>创建副本</strong>的方式返回<code>Tensor</code>对象
<code>data</code>可以是列表、元组、<code>np</code>数组等，由<code>tensor()</code>挑选一个最适合的<code>dtype</code>作为元素类型
如果将元组传递给<code>tensor()</code>，后续修改张量也没有影响，因为会转换为可读写张量
允许用户自定义<code>dtype、device、requires_grad</code>，默认不需要梯度</p></li>
<li><p>浅拷贝：使用工厂函数<code>torch.as_tensor(data)</code>
默认情况下，对于除<code>np</code>数组、张量以外的对象，和<code>tensor()</code>一致，<strong>对于<code>np</code>数组以及张量，通过浅拷贝返回张量(前者调用<code>from_numpy()</code>)</strong>
但用户可以指定<code>dtype、device</code>，如果指定的这两个属性和<code>np</code>数组、张量这些默认进行浅拷贝行为的数据不一致，则进行深拷贝而不是浅拷贝
<img src="Tensor_as_tensor.png" alt="Tensor_as_tensor" style="zoom:35%;" /></p></li>
<li><p>其它特殊的方式：</p>
<ul>
<li><p><strong><code>torch.detach(Tensor)</code>或<code>self.detach()</code></strong>：产生和原张量共享内存的新张量，这个新张量的<code>requires_grad=False</code>，但是对其数据的改动会影响原张量</p></li>
<li><p><code>zeros(Seq)、ones(Seq)、empty(Seq)、full(Seq, fill_val)</code>：创建全为零、全为一、未初始化、全为指定值的张量
其中<code>Seq</code>是表示其维度的序列
其它参数的使用与<code>tensor()</code>类似</p></li>
<li><p><code>rand(Seq)、randn(Seq)</code>：创建其值的分布满足<span
class="math inline"><em>U</em>(0,1)、<em>N</em>(0,1)</span>的张量
<code>self.uniform_(beg, end)、normal(size、mean、std)</code>：创建其值的分布满足<span
class="math inline">$U({\rm beg,\ end})、N({\rm
mean、std^2})$</span>的张量，前者是张量的实例方法(依赖已有张量的尺寸)、后者是工厂函数(用户指定尺寸)</p></li>
<li><p><code>arange()、linspace()、logspace()</code>：用法和内置方法差不多，返回值变成张量而已</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># beg-&gt;(endnum&lt;end)的间隔为step的等差数列</span></span><br><span class="line">torch.arange(beg=<span class="number">0</span>, end, step=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># beg-&gt;end的元素个数为steps的等差数列</span></span><br><span class="line">torch.linspace(beg, end, steps)</span><br><span class="line"><span class="comment"># 以base为底, 以linspace(b,e,steps)返回的序列作为幂, 得到的张量</span></span><br><span class="line">torch.logspace(b, e, steps, base)</span><br></pre></td></tr></table></figure></li>
<li><p><code>eye()、diag()、triu()、tril()</code>：创建单位、对角、上三角、下三角矩阵</p></li>
</ul></li>
<li><p>其它功能有限但也有人用的方式：
<code>Tensor()</code>：构造方法，使用<code>float32</code>作为<code>dtype</code>，且用户不能指定
各种指定类型的构造方法，如<code>FloatTensor、BoolTensor</code>，可能有人喜欢用
<code>from_numpy()</code>：只能传递<code>np</code>数组作为<code>data</code>，与<code>as_tensor(np)</code>效果一致</p></li>
</ul></li>
<li><p>张量的梯度相关操作：</p>
<ul>
<li><p><code>backward()</code>：对该张量所在计算图进行反向传播，计算所有前置结点的梯度
当张量为标量时，无需提供任何参数
当张量不为标量时，需要提供<code>gradient:Tensor</code>表示求和时的权重系数
两者其实没什么区别；例如，在多输出神经网络中，习惯对各个输出结点产生的损失进行求和得到总损失再向前求梯度，此时相当于手动地进行了<code>gradient=ones(n)</code>的求和，让损失从向量变成了标量，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出结果相同</span></span><br><span class="line">b = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], requires_grad=<span class="literal">True</span>, dtype=torch.float32)</span><br><span class="line">c = b.<span class="built_in">pow</span>(<span class="number">4</span>) <span class="comment"># 向量</span></span><br><span class="line">c.backward(torch.ones(c.shape)) <span class="comment"># 初始权重系数全为1, 等效于单纯的求和</span></span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br><span class="line">b.grad = <span class="literal">None</span></span><br><span class="line">d = b.<span class="built_in">pow</span>(<span class="number">4</span>).<span class="built_in">sum</span>() <span class="comment"># 标量, 原向量单纯的求和</span></span><br><span class="line">d.backward()</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br></pre></td></tr></table></figure>
<p>自动求导的好处是，不用再计算什么<span
class="math inline"><strong>δ</strong></span>，只需要调用<code>backward()</code>即可</p></li>
<li><p><code>requires_grad_()</code>：设置张量为需要梯度(是原位赋值方法)</p></li>
<li><p><code>with torch.inference_mode():</code>：创建不追踪梯度的上下文环境，在其下的代码块中所有的张量运算不记录到计算图里
是新版本中<code>with torch.no_grad():</code>的上位替代</p></li>
<li><p><code>retain_grad()</code>：之前学过<code>is_leaf</code>，所有该属性为<code>False</code>的张量的梯度不会被保留
使用该方法可以在计算后保留非叶子结点的梯度</p></li>
<li><p><code>detach()</code>：产生张量的一个映射，该映射不需要梯度，不再赘述</p></li>
<li><p>关于梯度清零：在若干次计算后，历史梯度会直接累加，应该尝试对梯度清零，不过这是优化器的事了</p></li>
</ul></li>
<li><p>张量的类<code>numpy</code>操作：具体的参数都不重要，看到别人代码能看懂即可</p>
<ul>
<li><p><strong>切片索引符</strong>：基于内置列表的切片索引符，用逗号来分隔不同维度的切片，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a是二维张量</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="number">3</span>]   <span class="comment"># 第一维度切0:2, 第二维度切0:3, 所以返回前两行、前三列围成的张量</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>add()、sub()、mul()、div()</code>对应<code>+、-、*、/</code>，为张量逐元素加减乘除
<code>matmul()</code>对应<code>@</code>，为二维张量的矩阵相乘
<code>exp()、log()、pow()</code>：逐元素<code>e</code>的指数、<code>e</code>的对数、幂运算
<code>t()</code>对应属性<code>T</code>，返回二维张量的转置(和原张量共享内存)
所有上述方法都有方法名末尾加后缀<code>'_'</code>的实例方法版本，它们不创建新张量对象而是直接修改原有张量，称为<strong>原位赋值</strong>；之前的<code>zeros()</code>等也有原位赋值版本</p></li>
<li><p><strong>条件操作</strong>：张量配合条件运算符(例如比较运算符)，将逐元素判断并返回<code>dtype=bool</code>的张量
这个布尔张量可以用作掩码并经过索引符来筛选并返回一维张量，按顺序存储通过筛选的元素
<strong><code>torch.where(cond,input,other)</code>或<code>self.where(cond,other)</code></strong>则是更通用的方法，类似于<code>C</code>的<code>?:</code>三元运算符的多维数组版本，<code>cond</code>是一个布尔张量，逐元素判断，当条件满足时返回<code>input</code>在该位置的值、不满足时返回<code>other</code>在该位置上的值
<code>torch.where(cond,self,other)</code>和<code>self.where(cond,other)</code>效果一致</p>
<p>```python a = torch.tensor([[1, 2],[3,4]]) m = a &gt; 1 # 布尔张量
Tensor([[False,True],[True,True]]) a[m] # 一维张量 Tensor([2, 3, 4])
a[m] = 1 # 支持原位赋值, 现在a为Tensor([[1,1],[1,1]]) #
a[m]=1和a=torch.where(a&gt;1,1,a)效果一致,区别在于前者是原位赋值</p></li>
<li><p><code>sum()、max()、min()、mean()、std()、var()</code>求张量的和、最大值、最小值、均值、标准差、方差</p></li>
<li><p><code>dot()、cross()</code>：一维张量的点积、叉积</p></li>
<li><p><code>self.view(Size)、reshape(Size)</code>：改变张量的<code>shpae</code>并返回新张量
这个新张量和原有张量共享内存，<code>reshape()</code>在<code>view()</code>的基础上添加了保底(无法共享内存时进行深拷贝创建新张量)</p></li>
<li><p>广播机制：当张量运算时，如果维度不相符，并且符合广播的要求，则会根据广播机制扩展某一方的维度
其实和<code>numpy</code>的广播机制一个样：<a
href="https://numpy.org/doc/stable/user/basics.broadcasting.html"><code>Broadcasting — NumPy</code></a></p></li>
<li><p><code>save()、load()</code>：张量的序列化、反序列化，人话说就是内存存到外存、外存加载到内存</p></li>
<li><p><code>to()</code>：可以修改张量的类型、部署的设备，返回一个对原数据进行深拷贝后的新张量</p></li>
<li><p>更多矩阵操作(例如求秩)在<code>torch.linalg</code>中</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux: 高效地监控操作系统</title>
    <url>/blogs/2025/01/11/linux-infos/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="bash-shell命令"><code>Bash Shell</code>命令</h1>
<h2 id="进程">进程</h2>
<h3 id="获取进程信息">获取进程信息</h3>
<p>跟进进程(<code>process</code>)是很重要的任务，包括查看、终止、执行者和执行时间等等…</p>
<p><code>ps</code>命令就是用来获得进程信息的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不带选项情况下,获得当前终端、在当前瞬间、且进程属主为当前用户的进程的:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PID  TTY(所处终端) TIME(占用的CPU时间)  CMD(命令名)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps</span></span><br><span class="line">ps options:</span><br><span class="line"> -A/-e  # 获取所有进程</span><br><span class="line"> -a   # 获取除无终端进程、控制进程外的所有进程</span><br><span class="line"> -f   # 获取详细信息,以Unix风格输出</span><br><span class="line"> -u   # 获取详细信息,以BSD风格输出</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="监测进程信息">监测进程信息</h3>
<p><code>ps</code>用于获取瞬时的进程信息，而<code>top</code>用于监测一个时段的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top  # 实时获取进程信息,每过一段时间会更新</span><br></pre></td></tr></table></figure>
<h3 id="结束进程">结束进程</h3>
<p>用<code>kill</code>来杀死进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill PID # 杀死PID指向的进程</span><br><span class="line"></span><br><span class="line">pkill CMD # 杀死命令名为CMD的进程,支持正则表达式</span><br></pre></td></tr></table></figure>
<h2 id="磁盘空间">磁盘空间</h2>
]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
        <category>Administrator cmds</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论: 公平组合游戏</title>
    <url>/blogs/2025/01/07/algo-game-fairgames/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="公平组合游戏">公平组合游戏</h3>
<ul>
<li><p>一个博弈游戏是公平组合游戏意味着，场上所有物品对于所有玩家都是可操作的，且玩家们必须遵循同样的操作规则；即对于操作(无论是操作规则还是操作对象)来说是公平的
但玩家总会有操作的顺序，事实上许多游戏先手和后手的胜利期望是不同的，博弈论研究的就是，当场上所有玩家都作出最“合理”的操作时，某个玩家必胜/必输的情况；不难得到，一个玩家在一局游戏里，<strong>要么必胜、要么必输</strong>
这里的合理，意味着玩家总是枚举完所有的结局，再选出最有利的那个选择；这里有一个很直观的结论就是，如果后续所有结局都是输，那么此时一定是必输的；否则，此时一定是必胜的
那么有没有办法，不需要枚举所有的结局，而只需要知道后续状态的必胜、必输，就可以递推出当前的必胜/必输呢？当然是可以的</p></li>
<li><p>实际上，对于双人的游戏而言，先手必胜意味着后手必输，因此我们只讨论<strong>先手必胜/先手必输</strong>的情况
一个约定：先手必胜/先手必输此后<strong>简称必胜/必输</strong>；能使<strong>先手必胜/必输的操作对象的初始状态</strong>(例如数量为<span
class="math inline"><em>n</em></span>)此后简称<strong>必胜/必输状态</strong>
对操作规则不会因操作对象状态改变的游戏而言，必胜、必输只和操作对象的状态有关，那么一个脑筋急转弯的思考就是：</p>
<ul>
<li>一个状态是必胜状态，当且仅当存在一个后续状态是必输状态(这里的<strong>后续</strong>指的是<strong>只通过一次操作</strong>转移到的状态)
充分性：如果存在一个后续的必输状态，那么此时先手可以选择转移到这个状态，此时后手变成了“先手”，于是必输
必要性显然</li>
<li>一个状态是必输状态，当且仅当没有后续状态、或所有后续状态是必胜状态
这个命题的一部分是上述命题的逆否命题；特别地，如果没有后续状态，说明此时的先手已经无法再操作了，意味着先手必输</li>
</ul></li>
<li><p>对于博弈问题，可以将上述状态视作结点，并画成一个<strong>有向无环图</strong>，标记所有无出度的节点为必输结点，然后经过一次<code>dfs</code>即可得到所有结点的必胜/必输性质
而在一些简单的脑筋急转弯题目中更常见的做法是，对所有状态进行归纳，即找到一个特征<span
class="math inline"><em>A</em></span>，使该特征<strong>满足<span
class="math inline"><em>A</em></span>无论如何都无法变为<span
class="math inline"><em>A</em></span>、而<span
class="math inline"><em>Ā</em></span>总存在一种操作使得<span
class="math inline"><em>Ā</em></span>变为<span
class="math inline"><em>A</em></span></strong></p></li>
<li><p>巴什博弈：有<span
class="math inline"><em>n</em></span>个物品，两个人轮流取物，每次只能取<span
class="math inline">[1,<em>m</em>]</span>个物品，最后取光者胜利</p>
<ul>
<li>结论：在巴什博弈中，这个特征是<span
class="math inline">(<em>m</em>+1)|<em>n</em></span></li>
<li>一个结点<span
class="math inline"><em>n</em> = <em>k</em></span>的所有前置状态为<span
class="math inline"><em>n</em> ∈ [<em>k</em>+1,<em>k</em>+<em>m</em>]</span>、所有后置状态为<span
class="math inline"><em>n</em> ∈ [<em>k</em>−<em>m</em>,<em>k</em>−1]</span>
很明显，只有一个出度为零的状态，即<span
class="math inline"><em>n</em> = 0</span>时，先手必输 因此<span
class="math inline"><em>n</em> = 0</span>的所有前置状态<span
class="math inline"><em>n</em> ∈ [1,<em>m</em>]</span>均为必胜状态<span
class="math inline"> ⇒ <em>n</em> = <em>m</em> + 1</span>是必输状态、所有<span
class="math inline"><em>n</em> ∈ [<em>m</em>+2,2<em>m</em>+1]</span>是必胜的(因为后续状态包含<span
class="math inline"><em>n</em> = <em>m</em> + 1</span>)
递推得到，所有<span
class="math inline"><em>n</em> = <em>k</em>(<em>m</em>+1), <em>k</em> ∈ <em>N</em></span>均为必输状态，其余为必胜状态</li>
<li>如果先手必胜，那么先手的操作就应是：使操作后<span
class="math inline"><em>n</em> = <em>k</em>(<em>m</em>+1)</span>，即取<span
class="math inline"><em>n</em>%(<em>m</em>+1)</span>个</li>
</ul></li>
<li><p><code>Nim</code>游戏：共<span
class="math inline"><em>n</em></span>堆物品，每堆有<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>个，两个玩家轮流取<strong>任意一堆</strong>的<strong>任意数量个</strong>物品，最后取光者胜利</p>
<ul>
<li><p>在<code>Nim</code>游戏中，这个特征是各堆数量的<strong>异或和(也称<code>Nim</code>和)为零</strong>，<code>Nim</code>和定理：若<span
class="math inline">$\begin{align}\bigoplus_{1\le i\le
n}a_i=0\end{align}$</span>，则先手必输；否则先手必胜(其中<span
class="math inline">⊕</span>表异或)
证明这个定理，需要证明当异或和为<span
class="math inline">0</span>时，不存在任何操作使其异或和仍未<span
class="math inline">0</span>；且当异或和不为<span
class="math inline">0</span>时，总是存在操作使其异或和变为<span
class="math inline">0</span></p>
<ul>
<li>对于第一个命题：假设玩家将<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>改为<span
class="math inline"><em>a</em><sub><em>i</em></sub>′</span>，那么由异或操作可以得出<span
class="math inline"><em>a</em><sub><em>i</em></sub> = <em>a</em><sub><em>i</em></sub>′</span>，即不取，明显不符合规则，因此不存在这样的操作</li>
<li>对于第二个命题：假设当前异或和为<span
class="math inline"><em>k</em></span>，那么异或上<span
class="math inline"><em>k</em></span>即为<span
class="math inline">0</span>，我们取合适的<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>，使其变为<span
class="math inline"><em>a</em><sub><em>i</em></sub> ⊕ <em>k</em></span>即可
假设<span class="math inline"><em>k</em></span>的最高的为<span
class="math inline">1</span>的位是第<span
class="math inline"><em>j</em></span>位，那么至少存在一个<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>，它的第<span
class="math inline"><em>j</em></span>位也为<span
class="math inline">1</span>，选取这个<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>，可以得到<span
class="math inline"><em>a</em><sub><em>i</em></sub> ⊕ <em>k</em> &lt; 2<sup><em>j</em></sup> ≤ <em>a</em><sub><em>i</em></sub></span>，因此这个操作是合法的</li>
</ul>
<p>先手必胜的操作就是，不断地使操作后的<code>Nim</code>和为<span
class="math inline">0</span>，此时后手的任何操作只会让<code>Nim</code>和再变为非<span
class="math inline">0</span>，直到最后一次使<code>Nim</code>和为<span
class="math inline">0</span>，此时所有堆的数量均为<span
class="math inline">0</span>，先手玩家得到胜利 也就是检查所有<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>(或检查所有满足第<span
class="math inline">__<em>l</em><em>g</em>(<em>k</em>)</span>位为<span
class="math inline">1</span>的)，找到任意一个异或<span
class="math inline"><em>k</em></span>后不超过<span
class="math inline"><em>a</em><sub><em>i</em></sub></span>的，取<span
class="math inline"><em>a</em><sub><em>i</em></sub> − (<em>a</em><sub><em>i</em></sub>⊕<em>k</em>)</span>即可</p></li>
</ul></li>
<li><p><a
href="https://www.luogu.com.cn/problem/P4018"><code>Roy&amp;October之取石子</code></a>
<a
href="https://www.luogu.com.cn/problem/P4860"><code>Roy&amp;October之取石子II</code></a></p>
<ul>
<li>可以发现，<span class="math inline">0</span>是必输的，而<span
class="math inline"><em>n</em> ∈ [1,5]</span>是必胜的，然后<span
class="math inline"><em>n</em> = 6</span>是必输的
然后我们假设特征是<span class="math inline">6|<em>n</em></span>，即<span
class="math inline"><em>n</em> = 6<em>k</em></span></li>
<li>它是否无论如何都无法使下一个状态为<span
class="math inline">6|<em>n</em></span>：这需要证明任意质数的幂<span
class="math inline"><em>p</em><sup><em>k</em></sup></span>不是<span
class="math inline">6</span>的倍数 除了<span
class="math inline">2</span>以外的质数，它们的幂都是奇数，因此不可能是<span
class="math inline">6</span>的倍数 <span
class="math inline">2</span>的幂不含<span
class="math inline">3</span>的因子，因此也不可能是<span
class="math inline">6</span>的倍数，得证</li>
<li>它的补，即<span
class="math inline">6 ∤ <em>n</em></span>是否总存在一种取法使得下一个状态为<span
class="math inline">6|<em>n</em></span>：因为<span
class="math inline">6 ∤ <em>n</em></span>，我们取<span
class="math inline"><em>n</em>%6</span>即可</li>
<li>因此答案是：若<span
class="math inline">6|<em>n</em></span>，则先手必输；否则先手必胜</li>
<li>后题与前题类似，只不过特征变成了<span
class="math inline">4|<em>n</em></span></li>
</ul></li>
<li><p><a
href="https://www.luogu.com.cn/problem/P1290"><code>欧几里德的游戏</code></a>：有些时候，答案不能简单地归纳，而<strong>必须通过递归</strong>得到</p>
<ul>
<li>取<span class="math inline"><em>m</em></span>为两数中较小者，<span
class="math inline"><em>n</em></span>为较大者，并改写为<span
class="math inline"><em>n</em> = <em>k</em><em>m</em> + <em>r</em></span>，<span
class="math inline"><em>r</em></span>为<span class="math inline">$n\
{\rm mod}\ k$</span> 可以得到退出递归的情况：<span
class="math inline"><em>r</em> =  = 0</span>或<span
class="math inline"><em>k</em> ≥ 2</span>，此时操作者必胜
前者显然，而后者总是可以一步(直接减去<span
class="math inline"><em>k</em><em>m</em></span>)或两步(先减去<span
class="math inline">(<em>k</em>−1)<em>m</em></span>，此时数对为<span
class="math inline">(<em>m</em>,<em>m</em>+<em>r</em>)</span>，后手只能减去<span
class="math inline"><em>m</em></span>)使数对变为<span
class="math inline">(<em>m</em>,<em>r</em>)</span>；由于<span
class="math inline">(<em>m</em>,<em>r</em>)</span>一定是必胜或必败的，它必胜就两步变换、必败就一步变换，就能保证数对为<span
class="math inline">(<em>m</em>,<em>n</em>)</span>时的操作者必胜了</li>
<li>否则，只能进行递归：<span
class="math inline"><em>f</em>(<em>m</em>,<em>n</em>,<em>p</em><em>l</em><em>a</em><em>y</em><em>e</em><em>r</em>) =  = <em>f</em>(<em>r</em>,<em>m</em>,¬ <em>p</em><em>l</em><em>a</em><em>y</em><em>e</em><em>r</em>)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Game Theory</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>图的算法: 最小生成树</title>
    <url>/blogs/2024/12/09/algo-graph-minimum-spanning-tree/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="最小生成树">最小生成树</h1>
<h2 id="概述">概述</h2>
<p>一个连通图的生成树是最简单的连通子图，它连通了图的所有节点，并且只含有<strong>节点数减一</strong>条边，即没有环</p>
<p>最小生成树是指，假设原图的每条边都含有权重，它的最小生成树的权重和是所有生成树中权重和最小的那棵</p>
<p>能解决的问题：</p>
<ul>
<li>如结构所描述的那样，多个节点可以互相连通，但最终需要将图化为生成树，则可以用最小生成树算法解决最优问题</li>
</ul>
<h2 id="图论基础">图论基础</h2>
<h3 id="图的概念">图的概念</h3>
<ul>
<li>图是非线性的数据结构，可用于表示诸如网络、社会关系、地图、电路图等</li>
<li>称图中任意一对节点的关系为<strong>边</strong>，如果所有边不强调方向，则称为无向图，否则为有向图</li>
<li>称一个节点的边数为它的<strong>度</strong></li>
<li>若无向图中任意两点<strong>有且仅有</strong>一条边，则称其为无向完全图；若有向图中任意两点<strong>有且仅有</strong>两条方向相反的边，则称其为有向完全图</li>
<li>若在图中能沿着边从一个节点找到另一节点，则称两点连通；若<strong>无向图中</strong>任意两点都连通，则称其为<strong>连通图</strong>；若<strong>有向图中</strong>任意两节点互相连通，则称其为<strong>强连通图</strong></li>
<li>若两点互相连通且最短路径没有其它节点，则称这两点互为邻接节点</li>
</ul>
<h3 id="邻接矩阵">邻接矩阵</h3>
<p>最简单的图的存储结构就是邻接矩阵，一个无向图需要存储节点间的关系，即边，且边是双向的，这是多对多的逻辑结构</p>
<p>假设图的总结点数为<code>n</code>，其中两个节点为<code>i</code>和<code>j</code>，用一个邻接矩阵就可以简单表示两者关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arcs[n][n] &#123;&#125;;</span><br><span class="line">arcs[i][j] = <span class="number">1</span>; <span class="comment">// 数组表示节点i与节点j是否邻接(01).</span></span><br><span class="line"><span class="comment">// 如要存储权重,则应用inf表示不邻接.</span></span><br><span class="line"><span class="comment">// 无向图矩阵是对称矩阵.</span></span><br></pre></td></tr></table></figure>
<p>在有向图中，需定义行数为边的箭头或边的结尾，以表示方向的信息</p>
<p>通过下标映射，数组表示法能够快速查询两点是否邻接，并取得这条边的权重，但有许多缺点：</p>
<ul>
<li>节点数量较多时，花费空间巨大</li>
<li>无法得知跨节点是否连通，也难以快速求出路径</li>
<li>无法直接取得节点的度，需要遍历一维数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Note, <span class="keyword">typename</span> Weight, <span class="type">bool</span> Dir=<span class="literal">false</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Graph &#123; <span class="comment">// Note表示节点类型,Weight表示权重类型,Dir表示有/无向(默认).</span></span><br><span class="line">    <span class="type">static</span> W MAX = INT_MAX; <span class="comment">// 无穷表示不连通.</span></span><br><span class="line">    Note* notes; <span class="comment">// 一维数组存储节点信息.</span></span><br><span class="line">    W** edges; <span class="comment">// 邻接数组存储边信息.</span></span><br><span class="line">    map&lt;Note, <span class="type">int</span>&gt; Map; <span class="comment">// 为了通过节点地址而不是整型下标来访问图, 需要构建映射.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表">邻接表</h3>
<p>邻接表使用链表而不是数组来存储边的信息，将边和权重压缩成边节点，将一个数据节点的所有边用边链表表示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要无穷,因为不会存储不邻接节点.</span></span><br><span class="line">    Weight w;</span><br><span class="line">    <span class="type">int</span> connect; <span class="comment">// 这条边的终点下标.</span></span><br><span class="line">    Edge&lt;Weight&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Note, <span class="keyword">typename</span> Weight, <span class="type">bool</span> Dir=<span class="literal">false</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Graph &#123;</span><br><span class="line">    Note* notes; <span class="comment">// 存储数据节点.</span></span><br><span class="line">    Edge&lt;Weight&gt;* edges; <span class="comment">// 存储边链表的头结点.</span></span><br><span class="line">    map&lt;Note, <span class="type">int</span>&gt; Map; <span class="comment">// 为了通过节点地址而不是整型下标来访问图, 需要构建映射.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有向图需要维护两个边链表，分别表示出/入方向的边</p>
<h2 id="最小生成树实现">最小生成树实现</h2>
<h3 id="prim算法"><code>Prim</code>算法</h3>
<p>首先初始化最小生成树，它只有一个节点，基于贪心，每轮外层循环中，通过内层循环遍历所有<strong>以这棵树中节点为起点</strong>、<strong>以未加入节点为终点</strong>的边，取最小，并将终点拉入最小生成树，过程中外层一共循环<code>n-1</code>次，可以顺便维护最小路径值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">Prim</span><span class="params">(<span class="type">const</span> Graph&amp; _g)</span> </span>&#123; <span class="comment">// 伪代码.</span></span><br><span class="line">    Edge* tmp, head;</span><br><span class="line">    Graph ans &#123;_g[<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">for</span> ( i= <span class="number">0</span> : _g.<span class="built_in">size</span>()<span class="number">-1</span> ) &#123;</span><br><span class="line">        head = _g.<span class="built_in">edge</span>(i); <span class="comment">// 取得生成树第i节点的边链表.</span></span><br><span class="line">        tmp = head;</span><br><span class="line">        <span class="keyword">for</span> ( j= i : <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (head : end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans.<span class="built_in">find</span>(head.connect) == <span class="number">-1</span>) <span class="comment">// 终点未加入生成树.</span></span><br><span class="line">                    tmp = tmp-&gt;w &lt; head-&gt;w ? tmp : head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = _g.<span class="built_in">edge</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">addNote</span>(_g[tmp-&gt;connect]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Graph Algo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理: 算术运算</title>
    <url>/blogs/2024/12/06/coa-arithmetic-operations/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="计算机的算术运算">计算机的算术运算</h1>
<h2 id="数据的表示与存储">数据的表示与存储</h2>
<h3 id="计算机码">计算机码</h3>
<ul>
<li>真值：符合人类习惯的十进制数字；机器数：数字化后的以机器码存储的数字；常用<span
class="math inline">$8421\ \rm BCD$</span>有权码</li>
<li>其它编码：
<ul>
<li>余三码：在<span class="math inline">8421</span>基础上，添加<span
class="math inline">011</span>的偏置量，是无权码</li>
<li><span class="math inline">2421</span>：权值不同的有权码</li>
<li><code>ASCII</code>：编码英文字符</li>
</ul></li>
<li><code>IEEE</code>标准规定计算机内的<strong>有符号定点数</strong>都以<strong>补码形式存储</strong>，且使用<span
class="math inline">$8421\ \rm BCD$</span>码</li>
</ul>
<h3 id="定点数表示">定点数表示</h3>
<ul>
<li><p>仅有符号定点数有原、反、补码的定义</p></li>
<li><p>有符号定点数视<strong>最高位为符号位</strong>，假设<span
class="math inline"> − 2<sup><em>n</em></sup> ≤ <em>x</em> &lt; 2<sup><em>n</em></sup></span>(<span
class="math inline"><em>n</em> ≥ 0</span>，即只表示纯整数或纯小数)：</p>
<ul>
<li><p>正数的原码、反码、补码相同：</p></li>
<li><p>原码：由<strong>符号位</strong>和<strong>尾数</strong>组成，对人来说是<strong>最直观</strong>的机器数</p>
<ul>
<li>不需要记住原码的计算公式，只需记住<strong>原码无法表示最小值<span
class="math inline"> − 2<sup><em>n</em></sup></span></strong>(<span
class="math inline">0</span>有两个原码)</li>
<li>数值部分位数恰好为<span class="math inline"><em>n</em></span></li>
</ul></li>
<li><p>反码：对原码的<strong>尾数按位取反</strong>后的码值(仍无法表示最小值)</p></li>
<li><p>补码的定义：</p>
<ul>
<li><p>计算公式(负数)：<span
class="math inline">[<em>x</em>]<sub><em>补</em></sub> = 2<sup><em>n</em> + 1</sup> + <em>x</em></span>，当要通过补码计算原值时，<span
class="math inline"><em>n</em></span>恰为数值部分位数</p></li>
<li><p>简单理解：可看作相同位数无符号定点数中<strong>最高位的权值改为<span
class="math inline"> − 2<sup><em>n</em></sup></span></strong>，使相同位数无符号定点数表示范围<span
class="math inline">0 ≤ <em>x</em> &lt; 2<sup><em>n</em> + 1</sup></span>中<span
class="math inline"> ≥ 2<sup><em>n</em></sup></span>的部分能一一映射到负数集合里(最高位权值由<span
class="math inline">2<sup><em>n</em></sup></span>变为<span
class="math inline"> − 2<sup><em>n</em></sup></span>，即这部分定点数均减去<span
class="math inline">2<sup><em>n</em> + 1</sup></span>来对应负数)</p>
<p>不难理解为何正数的补码为其本身，实际上真正的计算公式中加上<span
class="math inline">2<sup><em>n</em> + 1</sup></span>后需要模<span
class="math inline">2<sup><em>n</em> + 1</sup></span>，这个公式是正负数补码通用的，化简模运算后得到正负数补码不同的计算方式</p>
<p>由于一个数加一个负数<span
class="math inline"><em>x</em></span>等价于加其补码后模<span
class="math inline">2<sup><em>n</em> + 1</sup></span>，故设计运算时只需自然舍去最高位进位即可统一加减法</p>
<ul>
<li>证明：<span
class="math inline"><em>A</em> + <em>x</em> = (<em>A</em>+2<sup><em>n</em> + 1</sup>+<em>x</em>) mod  2<sup><em>n</em> + 1</sup> = (<em>A</em>+[<em>x</em>]<sub><em>补</em></sub>)<sub><em>取</em><em>n</em> + 1<em>位</em></sub></span></li>
</ul></li>
<li><p>当补码符号位为<span
class="math inline">1</span>，数值部分全为<span
class="math inline">0</span>时，达到能表示的最小值<span
class="math inline"> − 2<sup><em>n</em></sup></span>，此时原码不存在</p></li>
</ul></li>
<li><p>补码的快捷计算(<strong>原码存在时</strong>)：<strong>反码加<span
class="math inline">1</span></strong>，最高位自然舍去</p></li>
</ul></li>
<li><p>移码：定义为在补码的基础上，符号位翻转一次；其意义为偏移了<span
class="math inline">2<sup><em>n</em></sup></span>，使比较正负数补码的大小时符合直观判断；可在浮点数中判机器零</p></li>
</ul>
<h3 id="浮点数表示">浮点数表示</h3>
<ul>
<li>可将任意分子为纯整数、分母为<span
class="math inline">2</span>的次幂的有理数<span
class="math inline">$\begin{align}\frac{x}{2^y}\end{align}$</span>表示小数为<span
class="math inline">2<sup>−<em>y</em></sup> × (<em>x</em>)<sub>2</sub></span>；称<span
class="math inline"> − <em>y</em></span>为阶码(含阶符)、纯整数<span
class="math inline"><em>x</em></span>为尾数(含数符)，就是一般的浮点数表示形式</li>
<li>规格化： 使整数<span
class="math inline"><em>x</em></span>变为纯小数，且使其大于<span
class="math inline">2<sup>−<em>k</em></sup></span>(按<span
class="math inline">2<sup><em>k</em></sup></span>规格化)，尾数左移阶码减一，反之加一</li>
<li>机器零：当阶码小于等于其能表示的最小值、或尾数为零时，将该数当作零(而实际不是)</li>
</ul>
<h3 id="浮点数ieee标准">浮点数<code>IEEE</code>标准</h3>
<ul>
<li><p><code>IEEE</code>浮点数：阶码、尾数均为补码，数符在最前，阶码添加偏移量，规格化使尾数为<span
class="math inline">1 ∼ 2</span>间的小数且整数部分省略(隐藏位)，如下：</p>
<p><span
class="math inline"><em>数</em><em>符</em>  <em>阶</em><em>码</em>(<em>含</em><em>阶</em><em>符</em>)  <em>尾</em><em>数</em>(<em>省</em><em>略</em><em>最</em><em>高</em><em>位</em><em>的</em>1)</span></p></li>
<li><p>有如下类型及其对应位数，其中临时实数不使用隐藏位：</p>
<p><span
class="math inline">$\begin{matrix}&amp;数符&amp;阶码&amp;尾数&amp;总位数&amp;阶码偏移量\\短实数&amp;1&amp;8&amp;23&amp;32&amp;\rm
7FH\\长实数&amp;1&amp;11&amp;52&amp;64&amp;\rm
3FFH\\临时实数&amp;1&amp;15&amp;64&amp;80&amp;\rm
3FFFH\end{matrix}$</span></p></li>
</ul>
<h3 id="校验码">校验码</h3>
<ul>
<li>奇偶校验码：给有效信息额外添加<span
class="math inline">1</span>位校验码，使整体<span
class="math inline">1</span>的个数为奇数(奇校验)或偶数(偶校验)
<ul>
<li>求<strong>偶校验位</strong>值的过程就是让<strong>所有有效信息位进行异或</strong></li>
<li><strong>偶校验信息</strong>的过程就是让<strong>整条信息的各位异或</strong>，此时正确信息中<strong>各位的异或结果为<span
class="math inline">0</span></strong></li>
<li>检错能力为<span class="math inline">1</span>位，没有纠错能力</li>
</ul></li>
<li>海明校验码：检错能力为<span
class="math inline">2</span>位，纠错能力为<span
class="math inline">1</span>位
<ul>
<li>使用多个校验位，并采用<strong>偶校验</strong>，每个校验位被分配到不同组，分组进行偶校验，按顺序排列为整数<span
class="math inline"><em>k</em></span>，则<span
class="math inline">$\begin{cases}k=0&amp;无错\\k\ne0&amp;出错,且该值指明了出错的位置序号\end{cases}$</span></li>
<li>各校验位的位置为<span
class="math inline"><em>P</em><sub><em>i</em></sub> = 2<sup><em>i</em> − 1</sup></span>处，信息位<span
class="math inline"><em>D</em><sub><em>i</em></sub></span>按顺序排放在其余位置，位置序号为<span
class="math inline"><em>p</em></span></li>
<li>分组：将所有<span
class="math inline"><em>p</em></span>用二进制数表示，则校验位<span
class="math inline"><em>P</em><sub><em>i</em></sub></span>将和<strong>所有第<span
class="math inline"><em>i</em></span>位为<span
class="math inline">1</span>的<span
class="math inline"><em>p</em></span>所指向的信息位</strong>分为一组，例如<span
class="math inline"><em>P</em><sub>1</sub></span>将和<span
class="math inline"><em>p</em> = 3(011)、5(101)、7(111)⋯</span>上的信息位分为一组</li>
<li>检错：再添加一位<strong>全校验位</strong>，对整体进行偶校验，可判断<span
class="math inline">1</span>位错或<span
class="math inline">2</span>位错：<span
class="math inline">$全校验位=\begin{cases}\times&amp;其它校验位全为0时,无错\\1&amp;1位出错\\0&amp;2位出错\end{cases}$</span></li>
<li>纠错：若<span class="math inline">2</span>位出错，需重传；若<span
class="math inline">1</span>位出错，则对第<span
class="math inline"><em>k</em></span>位取反即可</li>
</ul></li>
</ul>
<h2 id="定点数运算">定点数运算</h2>
<h3 id="移位">移位</h3>
<p>最快的运算</p>
<ul>
<li><p>针对无符号定点数，采用<strong>逻辑移位</strong>，即在缺失位处补<span
class="math inline">0</span>，所有位均参与移位</p></li>
<li><p>针对有符号补码，采用<strong>算术移位</strong>：符号位不参与移位，在缺失位处补<strong>原符号位</strong></p></li>
<li><p>乘以<span
class="math inline">2<sup><em>n</em></sup></span>幂：<code>C++</code>编译器将采用左移运算符而不是乘号</p></li>
<li><p>除以<span
class="math inline">2<sup><em>n</em></sup></span>幂：<code>C++</code>编译器将采用右移运算符而不是除号</p>
<ul>
<li><p>对<strong>无符号整数</strong>，均直接<strong>逻辑右移</strong>，结果均为<strong>向下舍入</strong>(即向更小的数字舍入)</p>
<ul>
<li>向下舍入原因：二进制串的最低位会被覆盖，右移时最低位的产生的正小数部分丢失</li>
</ul></li>
<li><p>对<strong>有符号负数</strong>，需要进行<strong>偏置</strong>：</p>
<ul>
<li><p>向下舍入的特性会导致负数舍入后离<span
class="math inline">0</span>更远，而我们希望除法后的舍入应该离<span
class="math inline">0</span>更近，例如<span
class="math inline"> − 3/2 =  − 1</span>而不是<span
class="math inline"> − 2</span>，这种舍入是不合适的</p></li>
<li><p>最简单的想法是先转化为正数，再右移，再转化为负数：<span
class="math inline">⌈<em>x</em>/2<sup><em>k</em></sup>⌉ =  − ((−<em>x</em>)&gt;&gt;<em>k</em>)</span></p></li>
<li><p>通过<strong>偏置进行向上舍入</strong>是最常用的办法，即在右移之前加上偏置量<span
class="math inline">(1&lt;&lt;<em>k</em>) − 1</span></p>
<p>偏置量证明：假设需要右移<span
class="math inline"><em>k</em></span>位，那么容易得到<span
class="math inline">$\begin{cases}前k位为0,&amp;不需要舍入\\前k位大于0,&amp;需要舍入\end{cases}$</span></p>
<p>若增加该偏置量，在不需要舍入的情况下，<strong>不改变结果</strong></p>
<p>在需要舍入的情况下，添加后将进位，使<strong>结果加<span
class="math inline">1</span></strong>，即<span
class="math inline">⌈<em>x</em>/2<sup><em>k</em></sup>⌉ = ⌊<em>x</em>/2<sup><em>k</em></sup>⌋ + 1</span></p></li>
</ul></li>
<li><p>由于向下舍入是更简单的方式，一些语言不采用向零舍入</p></li>
</ul></li>
</ul>
<h3 id="按位运算和逻辑运算及加减法">按位运算和逻辑运算及加减法</h3>
<p><strong>按位与</strong>运算可用于截取前<span
class="math inline"><em>k</em></span>位二进制串</p>
<p>加减法稍慢，减法需要先将后者的补码算术取反</p>
<ul>
<li><p>采用高速并行加法器，也称超前进位加法器(<code>CLA</code>)：</p>
<ul>
<li><p>回顾一位加法器的最少逻辑门实现：<span
class="math inline">$\begin{matrix}{\rm S_i}=A\oplus B\oplus
C_{i-1}\\{\rm C_i}=(A\oplus
B)C_{i-1}+AB\end{matrix}$</span>，即最低位的进位有<span
class="math inline">5<em>T</em></span>的时延</p></li>
<li><p>串行加法器：由于来自低位的进位参与高位进位的计算时不用通过异或门，故每个高位进位又有<span
class="math inline">2<em>T</em></span>的时延，综合下来一个串行加法器的时延与位数<span
class="math inline"><em>n</em></span>线性正相关</p></li>
<li><p><code>CLA</code>的思路就是，首先一次性、同时计算出各位的进位，由于<span
class="math inline">${\rm C_i}=AB+(A+B)C_{i-1}$</span>，将<span
class="math inline"><em>C</em><sub><em>i</em> − 1</sub></span>展开即可得到<span
class="math inline">$\begin{cases}G_i=A_iB_i\\P_i=A_i+B_i\\\rm
{C_i}=G_i+P_iG_{i-1}+P_iP_{i-1}G_{i-1}+\cdots+(P_iP_{i-1}···P_1G_0)+(P_iP_{i-1}···P_0C_0)\end{cases}$</span></p>
<pre><code>所有进位的时延都为$3T$</code></pre></li>
<li><p><code>CLA</code>的问题在于，位数越高所需逻辑电路越复杂，因此通常采用<span
class="math inline">8</span>位<code>CLA</code>串行连接产生非完全超前进位的更高位加法器</p></li>
</ul></li>
<li><p>有符号整数的<strong>算术取反</strong>(取相反数)为<strong>整体按位取反后末位加<span
class="math inline">1</span></strong>：</p>
<ul>
<li><span
class="math inline">$\begin{align}&amp;设有n+1位以补码存储的二进制有符号正数\\&amp;证明正\rightarrow负:最高位表示0,其余位最多表示2^n-1,当前数值为A\\&amp;整体取反后,最高位表示-2^n,其余位变为2^n-1-A,加一后等于2^{n-1}-A\\&amp;易得0+A=-(-2^n+2^n-A)\\&amp;反之同理\end{align}$</span></li>
</ul></li>
<li><p>加减法溢出位判断：当且仅当两操作数符号相同时可能溢出</p>
<ul>
<li><p>一位判断：结果符号位和原符号位不同时溢出</p></li>
<li><p>二位判断：结果的两个符号位不同时溢出</p></li>
<li><p>证明两个负数补码的数值部分相加后，若不溢出，最高位一定有进位：</p>
<p><span
class="math inline">$\begin{align}&amp;证:设两负数原值为x、y,[x]_{补}=1,X、[y]_{补}=1,Y;其中X、Y都为n位\\&amp;由[x]_{补}=x+2^{n+1}、[y]_{补}=y+2^{n+1}\\&amp;若x+y不溢出,即x+y\ge-2^n\\&amp;\Rightarrow[x]_{补}+[y]_{补}-2^{n+2}\ge-2^n\\&amp;\Rightarrow[x]_{补}+[y]_{补}=X+Y+2^{n+1}\ge3·2^n\\&amp;\Rightarrow
X+Y\ge2^n\Rightarrow X+Y最高位一定有进位\end{align}$</span></p></li>
</ul></li>
</ul>
<h3 id="乘法">乘法</h3>
<p>比加法更慢</p>
<ul>
<li><p>原码一位乘：因计算机是定长机，因此将笔算乘法中被乘数左移转换成部分积右移，并使其高位和被乘数相加(因乘数最低位可舍去，因此同时右移即可)；假设两个数值为<span
class="math inline"><em>n</em></span>位的数相乘：</p>
<ul>
<li>符号位单独处理得到，乘法过程为绝对值相乘</li>
<li>注意使用<strong>逻辑右移</strong>，因为最高位本质上是数值位，总共需要移<span
class="math inline"><em>n</em></span>位</li>
<li>部分积寄存器<span
class="math inline"><em>n</em> + 1</span>位，多出的一位存假溢出</li>
</ul></li>
<li><p>原码两位乘：将两次一位乘化为一次两位乘，其有五种情况</p>
<ul>
<li><p><span class="math inline">00</span>：直接右移两位</p>
<p><span class="math inline">01</span>：加一次被乘数后右移两位</p>
<p><span
class="math inline">10</span>：加两倍的被乘数(左移一次)后右移两位</p>
<p><span
class="math inline">11</span>：因很难计算三倍，故先减一倍被乘数后<strong>记账一次</strong>(在右移两位后高位加一倍等价于移位前加四倍)</p>
<p>​ 借位初始为<span class="math inline">0</span>，每次都需要参与运算</p>
<p><span
class="math inline">100</span>：因有借位的参与，此时直接加四倍的被乘数(左移两次)后右移两位</p></li>
<li><p>因涉及到减法，故需要真符号位，又被乘数最多可能左移两位，因此需要在<strong>被乘数前补三位</strong></p>
<p>并采用<strong>算术右移</strong></p></li>
<li><p>因涉及到借位，为防止最后借位仍为<span
class="math inline">1</span>，需在<strong>乘数前补位</strong>(偶补两位、奇补一位，由于是绝对值，补的是<span
class="math inline">0</span>，因此奇数位只需补<span
class="math inline">1</span>位而最后不会出现<span
class="math inline">11 1</span>的情况)，用于处理该借位</p></li>
<li><p>总共需要右移<span
class="math inline">$\begin{align}\left\lfloor\frac{乘数}2\right\rfloor\end{align}$</span>次两位，若乘数位数为奇数最终需再移一位</p></li>
</ul></li>
<li><p>补码一位乘(校正法)：被乘数符号任意、乘数取绝对值后，进行原码一位乘的过程，最后进行校正</p>
<ul>
<li><p>由于是补码，采用<strong>算术右移</strong>，且部分积寄存器需补一位真符号位</p></li>
<li><p>若乘数本身为负数，需在移位完成后<strong>减去一倍的乘数</strong>，减后不需要移位</p></li>
</ul></li>
<li><p>补码一位乘(比较法/<code>Booth</code>算法)：在对校正法公式整理后，依据最后两位(需补附加位)有四种情况(后一位减前一位有三种情况)：</p>
<ul>
<li><p><span class="math inline">00/11</span>：直接右移一位</p>
<p><span class="math inline">01</span>：加一倍乘数后右移一位</p>
<p><span class="math inline">10</span>：减一倍乘数后右移一位</p></li>
<li><p>乘数寄存器需补附加位(初始为零)</p></li>
<li><p><strong>注意最后一次比较后不移位</strong>，总共只移<span
class="math inline"><em>n</em></span>位</p></li>
</ul></li>
<li><p>补码两位乘：将两次<code>Booth</code>乘法步骤合为一次，有八种情况：</p>
<ul>
<li><p><span class="math inline">000</span>：直接算术右移两位</p>
<p><span class="math inline">001</span>：加一倍乘数后右移两位</p>
<p><span
class="math inline">010</span>：减一倍右移再加一倍右移，整理得<strong>加一倍后右移两位</strong></p>
<p><span class="math inline">011</span>：加两倍后右移两位</p>
<p><span class="math inline">100</span>：减两倍后右移两位</p>
<p><span
class="math inline">101</span>：加一倍右移再减一倍右移，整理得<strong>减一倍后右移两位</strong></p>
<p><span class="math inline">110</span>：减一倍后右移两位</p>
<p><span class="math inline">111</span>：直接右移两位</p></li>
<li><p>因此部分积需补三位、乘数需补一位附加位</p></li>
<li><p>此外，乘数算上附加位需补成奇数位，且最后一次比较后不移位</p></li>
</ul></li>
<li><p>快速幂算法：</p>
<ul>
<li><p><span
class="math inline"><em>N</em> = (<em>a</em><sub><em>n</em></sub>,<em>a</em><sub><em>n</em> − 1</sub>,⋯,<em>a</em><sub>0</sub>)<sub>2</sub></span>，计算<span
class="math inline"><em>b</em><sup><em>a</em><sub><em>n</em></sub>2<sup><em>n</em></sup></sup> · ... · <em>b</em><sup><em>a</em><sub>0</sub> · 1</sup></span>即可</p></li>
<li><p>或者，当<span
class="math inline"><em>N</em></span>为偶数时使其自乘，为奇数时记录多余的<span
class="math inline"><em>b</em></span>，在最后相乘：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_power</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = b, tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123; <span class="comment">// 奇数时抽出一份 b, 记录在 tmp 中.</span></span><br><span class="line">   tmp *= b;</span><br><span class="line">            --N;  <span class="comment">// 幂数减1.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">// 偶数时自乘, 幂数减半.</span></span><br><span class="line">            ans *= ans;</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="除法和取模">除法和取模</h3>
<p>极慢，取模和除法是同时进行，同时完成的</p>
<ul>
<li><p>恢复余数法：因定长机，将笔算过程中除数右移改为使余数和商左移，根据余数和除数的大小来上商</p>
<ul>
<li>预处理：被除数和除数先转换成其<strong>绝对值</strong>，计算结果的符号位需单独处理</li>
<li>若减除数后，新余数为负数，则要恢复余数，即加上除数，并在商的末位商<span
class="math inline">0</span></li>
<li>否则直接在商的末位商<span class="math inline">1</span></li>
<li>两种情况均需使余数和商同时<strong>逻辑左移</strong></li>
</ul></li>
<li><p>原码的加减交替法(不恢复余数法)：</p>
<ul>
<li><p>每次减除数后，根据余数：<span
class="math inline">$\begin{cases}正数商1左移减\\负数商0左移加\end{cases}$</span></p></li>
<li><p>共移<span
class="math inline"><em>n</em></span>次，最后一次移位后仍需继续运算一次</p></li>
</ul></li>
<li><p>补码的加减交替法：</p>
<ul>
<li><p>取两位符号位，每次运算前比较余数和除数的符号位：<span
class="math inline">$\begin{cases}同号商1减除数\\异号商0加除数\end{cases}$</span></p></li>
<li><p>共移<span
class="math inline"><em>n</em></span>次，最后一次移位后恒商<span
class="math inline">1</span>，因此会导致些许误差</p></li>
</ul></li>
<li><p>快速模幂算法：为了减小因幂运算导致的数字极大，产生额外空间、时间消耗，故通过以下定理将其变为<strong>模数相乘再取模</strong>，数字会小很多</p>
<ul>
<li><p>前置定理：<span class="math inline">$(a_1·a_2){\rm mod}\
n=((a_1{\rm mod}\ n)·(a_2{\rm mod}\ n)){\rm mod}\ n$</span></p></li>
<li><p>推论：<span class="math inline">$a^N{\rm mod}\ n=(a{\rm\ mod}\
n)^N{\rm mod}\ n$</span></p></li>
<li><p>假设计算<span class="math inline">$b^N{\rm mod}\
n$</span>，为快速计算幂，这里复用<strong>快速幂</strong>算法，将<span
class="math inline"><em>N</em></span>化为二进制<span
class="math inline">(<em>a</em><sub><em>n</em></sub>,<em>a</em><sub><em>n</em> − 1</sub>,⋯,<em>a</em><sub>0</sub>)<sub>2</sub></span>，按权值展开后，<span
class="math inline"><em>b</em><sup><em>N</em></sup> = <em>b</em><sup><em>a</em><sub><em>n</em></sub>2<sup><em>n</em></sup> + ⋯ + <em>a</em><sub>0</sub> · 1</sup> = <em>b</em><sup><em>a</em><sub><em>n</em></sub>2<sup><em>n</em></sup></sup> · ... · <em>b</em><sup><em>a</em><sub>0</sub> · 1</sup></span></p></li>
<li><p><span
class="math inline"><em>b</em><sup>2<sup><em>n</em></sup></sup></span>虽然比<span
class="math inline"><em>b</em><sup><em>N</em></sup></span>小，但还是较大，因此要证明每次迭代时，取模不影响结果，递归套用推论易证：<span
class="math inline">$b^{2^n}{\rm mod}\ n=(b^{2^{n-1}}·b^{2^{n-1}}){\rm
mod}\ n=(b^{2^{n-1}}{\rm mod}\ n)^2{\rm mod}\ n$</span></p>
<p>所以计算<span
class="math inline"><em>n</em></span>次幂的模时，可计算<span
class="math inline"><em>n</em> − 1</span>次幂的模的平方的模</p></li>
<li><p>```c++ int quick_power_mod(int b_mod_n, int N, int n) { int ans =
1; b_mod_n %= n; // 预处理, (b^N)%n = ((b%n)^N)%n. while (N) { //
取N的二进制表示中的第一位,如果为1,则计算 (ans<em>(b^{权值}%n)) mod n. if
(N &amp; 1) { // 为保证数字始终较小,迭代 ans 时要再mod n. ans = (ans
</em> b_mod_n) % n; } // 为保证数字始终较小,迭代 b的幂 时要再mod n,
使数字&lt;n^2. b_mod_n = (b_mod_n * b_mod_n) % n; N &gt;&gt;= 1; }
return ans; } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 模数为$2$的$n$次幂($n&gt;1$)：直接用位运算**截取前$n-1$位**即可</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    int mod_2_power(int b, int n) &#123;</span><br><span class="line">        // 若n为2^k,则二进制表示为00...010...00, 唯一的1在第k+1位上.</span><br><span class="line">        // 则n-1为00...01...11, 最高位的1在第k位上.</span><br><span class="line">        // 故 b % n = b &amp; (n-1);</span><br><span class="line">        return b &amp; (n - 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h3 id="定点数运算总结">定点数运算总结</h3>
<h2 id="浮点数运算">浮点数运算</h2>
<h2 id="alu设计"><code>ALU</code>设计</h2>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>COA</category>
      </categories>
      <tags>
        <tag>COA</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛: 离线查询</title>
    <url>/blogs/2024/11/26/algo-trick-offline-query/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="离线查询">离线查询</h3>
<ul>
<li>离线查询，即将题目问的多组问题缓存下来，再进行一定顺序的求解
通常用于，一些查询的<strong>结果是另一些查询结果的一部分</strong>的情况；甚至于<strong>如果先求解后者，反而很难得到前者</strong>的情况
具有这些性质的查询，在离线下来后通常要按某个查询属性进行排序，然后迭代求解
它类似一个小技巧，很难总结出一些模板，或者方法论，所以下面给出一些例题帮助理解：</li>
</ul>
<h4 id="gzoi2017-配对统计"><a
href="https://www.luogu.com.cn/problem/P5677">[GZOI2017]
配对统计</a></h4>
<ul>
<li>问题可以抽象成，给你一堆二元组<span
class="math inline">[<em>x</em>,<em>y</em>], <em>x</em> &lt; <em>y</em></span>(原题通过排序可以轻松求出所有符合要求的数对)，你需要在每次<strong>区间<span
class="math inline">[<em>l</em>,<em>r</em>]</span>查询</strong>后，给出满足<span
class="math inline"><em>l</em> ≤ <em>x</em>, <em>y</em> ≤ <em>r</em></span>的数对的个数
<ul>
<li>由于是区间查询，考虑用树状数组或线段树；在本题，用权值树状数组<span
class="math inline"><em>t</em><em>r</em>[<em>i</em>]</span>维护左值<span
class="math inline"><em>x</em> =  = <em>i</em></span>的数对个数；但是，树状数组只能保证维护左值在区间当中，不关心数对的右值</li>
<li>因此通过离线查询，对所有二元组、待查询区间的<strong>右值/右端点大小</strong>进行排序，因此查询区间的右端点是单调递增的；对每个查询，将所有右值不超过该查询区间右端点的数对插入到树状数组中
这样，树状数组中所有数对对应的右值都不会超过当前查询的右端点<span
class="math inline"><em>r</em></span>
那么如何使数对的左值处于当前查询区间中呢？通过权值树状数组查询<span
class="math inline">[<em>l</em>,<em>r</em>]</span>元素和即可(即左值在<span
class="math inline">[<em>l</em>,<em>r</em>]</span>区间内的数对个数)；同时由于<span
class="math inline"><em>y</em> &gt; <em>x</em></span>，因此也满足了使数对的右值不小于左端点<span
class="math inline"><em>l</em></span></li>
</ul></li>
<li>```c++ #define lbit(x) (x - (x &amp; (x - 1))) #include
&lt;bits/stdc++.h&gt; using namespace std; int n, m, tr[300006], cnt;
long long ans; void add(int x) { while (x &lt;= n) { ++tr[x]; x +=
lbit(x); } } int query(int x) { int ans = 0; while (x) { ans += tr[x]; x
-= lbit(x); } return ans; } int query(int l, int r) { return query(r) -
query(l - 1); } struct Info{ int a, id; bool operator&lt;(const
Info&amp; oth) const { return a &lt; oth.a; } }a[300006]; struct Pair{
int l, r, id; bool operator&lt;(const Pair&amp; oth) const { return r
&lt; oth.r; } }p[300006], goodp[300006 &lt;&lt; 1]; int main() { cin
&gt;&gt; n &gt;&gt; m; if (n == 1) { cout &lt;&lt; 0; return 0; } for
(int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i].a; a[i].id = i + 1; }
sort(a, a + n); goodp[cnt++] = {min(a[0].id, a[1].id), max(a[0].id,
a[1].id)}; goodp[cnt++] = {min(a[n - 1].id, a[n - 2].id), max(a[n -
1].id, a[n - 2].id)}; for (int i = 1; i &lt; n - 1; ++i) { if
(abs(a[i].a - a[i - 1].a) == abs(a[i].a - a[i + 1].a)) { goodp[cnt++] =
{min(a[i].id, a[i + 1].id), max(a[i].id, a[i + 1].id)}; goodp[cnt++] =
{min(a[i].id, a[i - 1].id), max(a[i].id, a[i - 1].id)}; } else if
(abs(a[i].a - a[i - 1].a) &lt; abs(a[i].a - a[i + 1].a)) { goodp[cnt++]
= {min(a[i].id, a[i - 1].id), max(a[i].id, a[i - 1].id)}; } else {
goodp[cnt++] = {min(a[i].id, a[i + 1].id), max(a[i].id, a[i + 1].id)}; }
} sort(goodp, goodp + cnt); for (int i = 0; i &lt; m; ++i) { cin
&gt;&gt; p[i].l &gt;&gt; p[i].r; p[i].id = i + 1; } sort(p, p + m); int
j = 0; for (int i = 0; i &lt; m; ++i) { while (j &lt; cnt &amp;&amp;
goodp[j].r &lt;= p[i].r) { add(goodp[j].l); ++j; } ans += 1ll *
query(p[i].l, p[i].r) * p[i].id; } cout &lt;&lt; ans; }</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Trick</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>trick</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构: 哈希表</title>
    <url>/blogs/2024/11/16/algo-hashmap/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="哈希表">哈希表</h1>
<h2 id="概述">概述</h2>
<p>在<code>FTP</code>与<code>HTTPS</code>中，粗略介绍了哈希算法加密数据的概念；它用哈希算法将无限的数据转换成唯一的、用数字描述的值；对一个合格的哈希函数而言：</p>
<ul>
<li>哈希函数尽可能是单射，但哈希冲突不可避免</li>
<li>哈希函数不能是双射，即不可逆</li>
</ul>
<p>在哈希表这种数据结构中，利用了哈希函数的转换，使传入的每一个键都对应一个<strong>唯一的值</strong>，便可以通过键快速地查找到数组中的存储的数据，它的应用场景很多：</p>
<ul>
<li>检索：键可以是多样的，例如纯数字的学号、纯字符串的姓名等，在开发中不能让用户通过数组下标来访问数据，就需要哈希表；在程序上的哈希表结构使用的算法一般较简单，不追求加密功能</li>
<li>文件加密：目前有特定的哈希算法，例如<code>MD5,SHA-256</code>等，算法复杂，但能生成更具有唯一性的摘要</li>
</ul>
<p>它的特点有：</p>
<ul>
<li>哈希表的优势在于，只要不发生哈希冲突，就可以靠快速的哈希函数，取得映射的下标，直接访问地址，达到查找、插入、删除的复杂度都为<code>O(1)</code></li>
<li>然而任何哈希函数都可能造成哈希冲突，即传入不同数据却生成相同的值</li>
<li>哈希表是通过数组实现的，因此需要大容量的数组，且数据量大于数组容量后，效率急速下降</li>
<li>通常需要将大范围的键值缩小映射到小范围内</li>
</ul>
<h2 id="实现哈希算法">实现哈希算法</h2>
<p>对键进行<code>hash</code>的过程，相当于给数组的整型索引添加更高级的信息，使索引不再是单纯的数字</p>
<h3 id="设计原则">设计原则</h3>
<ul>
<li>唯一性：不同的键映射后的值尽可能不同</li>
<li>简单性：计算过程应尽可能简单</li>
<li>均匀性：不同的键映射后的值应均匀分布在数组中</li>
</ul>
<h3 id="算法分类">算法分类</h3>
<p>哈希算法需要对输入数据有足够的敏感度，在许多做法中，通常会选择将输入的所有数据进行充分混合</p>
<p>一般来说，哈希算法有以下类型的实现：</p>
<ul>
<li>位运算(常用移位和异或，用于混合整数的部分信息)</li>
<li>加法、乘法、除法(通常选择一个素数，例如<code>(prime * x)%size</code>对<code>x</code>进行哈希)</li>
<li>取模(通常是必要的)</li>
</ul>
<h3 id="整数键">整数键</h3>
<p>这种情况很少，也较为简单，通常为了节省空间，不会采用直接取址，而是混合位运算、乘法、素数、模运算来实现，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> _val, <span class="type">size_t</span> _scope)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="built_in">size_t</span>(_val) &gt;&gt; <span class="number">16</span>) ^ _val) * <span class="number">0x5F58E29</span>) % _scope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>0x5f58e29</code>是任取的素数，<code>_scope</code>是映射的范围</p>
<p>位运算的选择(右移和异或搭配)原理：</p>
<ul>
<li>一般来说，预设的存储空间相对于无穷的数据来说，是较小的一方；因此在直接取模法中，高位的信息将丢失，哈希结果出现聚集现象(例如存储空间为<code>5</code>，<code>11%5=21%5=1</code>，十位的数据未参与哈希运算)</li>
<li>为了使高位信息参与运算，采用右移运算符</li>
<li>异或运算的结果集中，<code>1</code>和<code>0</code>是平均分配的(分别占一半)，比其它位运算更能保证高低位信息均匀混合</li>
</ul>
<p>指针类型的数据实际上以十六进制整数存储，可以通过整数的逻辑设计哈希函数，只需要在计算时通过<code>reinterpret_cast&lt;size_t&gt;</code>(重新解释转换，较底层，有风险)强制类型转换即可</p>
<h3 id="字符串键">字符串键</h3>
<p>字符串所带信息更多，例如长度、下标、字符本身，每个字符都是一个整数</p>
<p>最简单的字符串哈希：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">char</span>* _val, <span class="type">size_t</span> _scope)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(_val); ++i) &#123;</span><br><span class="line">        ans += (i + <span class="number">1</span>) * _scope[i]; <span class="comment">// 混合了下标和字符.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % _scope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的字符串哈希算法：</p>
<ul>
<li><p><code>BKDR Hash</code>(<code>Java</code>采用)：将字符串视为<code>P</code>进制数，转换成十进制后取模即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">131</span>; <span class="comment">// 通常取13/31/131/13131..., 实验证明它们最合适.</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">char</span>* _val, <span class="type">size_t</span> _scope)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(_val); ++i) &#123;</span><br><span class="line">        <span class="comment">// 采用从高位到低位的转换方式, 运算更快.</span></span><br><span class="line">        ans = ans * P + _val[i]; <span class="comment">// 隐含自然溢出,即超出ull范围后自动取模</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % _scope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过位运算进行哈希：<code>RS、AP、FNV</code>等算法</p></li>
<li><p>在算法竞赛中，单哈希也许是不够的，常见的解决办法是进行双哈希(分别有不同的<code>P</code>和模数)，组成序偶</p></li>
</ul>
<p><code>BKDR</code>算法还能快速地得到子串的哈希值(需要存储每一步的计算结果)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hash</span><span class="params">(<span class="type">char</span>* _val, <span class="type">size_t</span> _scope, <span class="type">size_t</span> _left, <span class="type">size_t</span> _right)</span> </span>&#123;</span><br><span class="line"> <span class="type">size_t</span> hashCode[_right + <span class="number">1</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; _right + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        hashCode[i] = hashCode[i - <span class="number">1</span>] * P + _val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相减后可能是负数, 加上一周进行补偿.</span></span><br><span class="line">    <span class="keyword">return</span> (hashCode[_right] - hashCode[_left - <span class="number">1</span>] * <span class="built_in">power</span>(P, _right - _left + <span class="number">1</span>) + _scope) % _scope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点数键">浮点数键</h3>
<h3 id="自定义键">自定义键</h3>
<p>在<code>C++</code>中，默认提供的哈希函数只有以上几种，如果希望能在<code>unordered_map</code>等<code>std</code>的哈希结构中使用自定义类型，那么该类型应满足：</p>
<ul>
<li>实现哈希函数<code>hash()</code></li>
<li>实现重载运算符<code>==</code>(便于处理哈希冲突)</li>
</ul>
<p>实现哈希函数并不难，通常使能进行哈希运算的成员数据的哈希结果互相进行位运算而得，依靠<code>std</code>中的哈希结构解决哈希冲突</p>
<h2 id="处理哈希冲突">处理哈希冲突</h2>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理: 量子力学</title>
    <url>/blogs/2024/11/15/physics-quantum/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="量子物理">量子物理</h1>
<h2 id="旧量子论">旧量子论</h2>
<h3 id="黑体辐射">黑体辐射</h3>
<ul>
<li><p>热辐射是<strong>由温度决定</strong>的<strong>电磁辐射</strong></p></li>
<li><p>任何物体、在任何温度下都有热辐射，且波长范围由零连续延伸到无穷大</p></li>
<li><p>物体辐射本领越大、吸收本领越大</p></li>
<li><p>辐射和吸收达到平衡时，物体温度不变</p></li>
<li><p>单色辐射出射度(单色辐出度)：<span
class="math inline">$\begin{align}&amp;M_\lambda(T)=\frac{\mathrm
dM_\lambda}{\mathrm
d\lambda}\end{align}$</span>，表示<strong>一定温度</strong>下，物体表面<strong>单位面积</strong>、<strong>单位时间</strong>内、发出的辐射能对电磁波波长的一阶导；单位<span
class="math inline">$\rm J·m^{-3}·s^{-1}$</span></p></li>
<li><p><strong>辐出度</strong>：<span
class="math inline">$\begin{align}M(T)=\int_0^{\infty}M_\lambda(T)\mathrm
d\lambda\end{align}$</span>，表示一定温度下，物体表面单位面积单位时间内的总辐射能</p>
<p>能表示一个物体的<strong>辐射本领</strong>，单位<span
class="math inline">$\rm J·m^{-2}·s^{-1}$</span></p>
<ul>
<li>辐出度和温度、材料有关</li>
</ul></li>
<li><p><strong>单色吸收比</strong>：<span
class="math inline">$\begin{align}a_\lambda(T)\end{align}$</span>，能表示一个物体的<strong>吸收本领</strong>，其值为吸收辐射能和全部入射能量的比值</p></li>
<li><p>黑体：单色吸收比为一的物体</p>
<ul>
<li><p>基尔霍夫定律：在同一温度下，各种材料的单色辐出度和单色吸收比的比值相等</p>
<p>因此，研究各种材料的辐射吸收本领等价于研究黑体的辐射本领</p></li>
<li><p>黑体不反射、不透射，能将入射光全部吸收</p></li>
<li><p>黑体模型：不透明介质空腔上的小孔，小孔表面是黑体</p></li>
</ul></li>
<li><p>斯特藩——玻尔兹曼定律：黑体辐出度<span
class="math inline"><em>M</em><sub><em>B</em></sub>(<em>T</em>) = <em>σ</em><em>T</em><sup>4</sup></span>，其中<span
class="math inline">$\sigma=5.67\times10^{-8}{\rm
W·m^{-2}·K^{-4}}$</span></p></li>
<li><p>维恩位移定律：单色辐出度最大时对应波长<span
class="math inline">$\begin{align}\lambda_m=\frac
bT\end{align}$</span>，其中<span
class="math inline">$b=2.897\times10^{-3}{\rm m·K}$</span></p></li>
<li><p>普朗克黑体辐射公式：<span
class="math inline">$\begin{align}M_v(T)=\frac{2\pi
h}{c^2}\frac{v^3}{e^{\large\frac{hv}{kT}}-1}\end{align}$</span>，其中普朗克常量<span
class="math inline">$h=6.626\times10^{-34}{\rm J·s}$</span></p></li>
<li><p>普朗克能量子假说：辐射体由带电谐振子组成，频率为<span
class="math inline"><em>v</em></span>的谐振子最小能量为能量子<span
class="math inline"><em>ε</em> = <em>h</em><em>v</em></span>，所有谐振子只能吸收或辐射<span
class="math inline"><em>ε</em></span>的整数倍</p></li>
</ul>
<h3 id="光电效应">光电效应</h3>
<ul>
<li><p>以是否有光电子溢出作为光电效应现象是否发生的标准</p></li>
<li><p>爱因斯坦光电效应方程：光子能量<span
class="math inline"><em>h</em><em>v</em> = <em>E</em><sub><em>m</em></sub> + <em>A</em></span>，<span
class="math inline"><em>E</em><sub><em>m</em></sub></span>为光电子最大初动能，<span
class="math inline"><em>A</em></span>为金属逸出功</p></li>
<li><p>红线频率：<span
class="math inline"><em>h</em><em>v</em><sub>0</sub> = <em>A</em></span>，<span
class="math inline"><em>v</em><sub>0</sub></span>是能让光电子溢出的最小频率</p></li>
<li><p>遏止电压：<span
class="math inline">$\begin{align}eU=E_m=hv-A\end{align}$</span>，<span
class="math inline"><em>U</em></span>是能使动能最大的光电子也无法到达阳极的反向电压</p></li>
<li><p>饱和光电流：和单位时间内入射光子数<span
class="math inline"><em>N</em></span>相关，由光强<span
class="math inline"><em>I</em> = <em>N</em><em>h</em><em>v</em></span></p>
<p>当入射光<strong>频率一定</strong>时，饱和光电流才和光强成正比</p></li>
</ul>
<h3 id="康普顿效应">康普顿效应</h3>
<ul>
<li>散射光的特点：出现新的、波长更长的散射光，随散射角增大而增大</li>
<li>光子理论：光子和核外电子弹性碰撞
<ul>
<li>和外层电子相碰撞，光子将部分能量传给电子，使散射光波长变长</li>
<li></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Physics</category>
      </categories>
  </entry>
  <entry>
    <title>MATLAB: 基本语法</title>
    <url>/blogs/2024/11/14/matlab-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1
id="matlab基本语法及矩阵算术操作"><code>MATLAB</code>基本语法及矩阵算术操作</h1>
<h2 id="基本语法">基本语法</h2>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>创建变量无需显式声明数据类型，会自动隐式推断</li>
<li>数据类型分为：
<ul>
<li>数值：整型、长整型、单双精度、复数等</li>
<li>数组：索引<strong>从<code>1</code>开始</strong>
<ul>
<li>结构体数组：类似<code>C</code>的结构体</li>
<li><strong>向量与矩阵</strong>：信息的基本单位，用于<strong>存储数值数据</strong></li>
<li>字符串：实际上是字符型向量</li>
<li><strong>元胞数组(<code>cell array</code>)</strong>：每个元胞<strong>允许存储不同类型、不同维度</strong>的数据，例如变量、数值、字符串等</li>
</ul></li>
<li>自定义类</li>
<li>其它，如布尔、字符、函数指针、内置类等</li>
</ul></li>
<li>约定：数组将泛指所有数组类型，涉及区分矩阵、元胞数组和结构体数组时不使用数组称呼</li>
</ul>
<h3 id="运算符">运算符</h3>
<ul>
<li>加减乘幂(<code>+-*^</code>)：矩阵的加减乘幂</li>
<li>左除(<code>\</code>)、右除(<code>/</code>)：矩阵的除法(或矩阵方程的求解)
<ul>
<li><code>X\Y</code>返回<span
class="math inline"><em>X</em><sup>−1</sup><em>Y</em></span>，<code>X/Y</code>返回<span
class="math inline"><em>X</em><em>Y</em><sup>−1</sup></span></li>
<li>即左除为左操作数的逆<strong>左乘</strong>右操作数，右除为右操作数的逆<strong>右乘</strong>左操作数</li>
<li>单个数被视作一行一列的矩阵，一定可逆且逆等于其倒数，数的右除即符合习惯的数值除法</li>
</ul></li>
<li>前接点运算符(<code>.*  .^  .\  ./</code>)：<strong>对同型矩阵按元素</strong>求乘、幂、左除、右除</li>
<li>方括号(<code>[]</code>)：创建向量或矩阵</li>
<li>百分号(<code>%</code>)：后接注释</li>
<li>关系运算：
<ul>
<li>大多运算符与<code>C</code>相同，其中不等号为<code>~=</code>，均为<strong>对同型矩阵按元素</strong>比较，<strong>返回布尔矩阵</strong></li>
<li><code>isequal</code>：对整体比较，<strong>返回布尔值</strong>，且认为<code>NaN != NaN</code></li>
<li><code>isequaln</code>：认为<code>NaN == NaN</code></li>
</ul></li>
<li>逻辑运算：与<code>C</code>不同，单个<code>&amp;、|</code>表示逻辑与和逻辑或</li>
<li>按位运算：位运算都通过函数进行，函数名通常为<strong><code>bit + 位运算</code></strong>的形式</li>
</ul>
<h3 id="特殊变量常量">特殊变量、常量</h3>
<ul>
<li>对大小写敏感</li>
<li><code>ans</code>：最近计算过的表达式的结果</li>
<li><code>Inf</code>：数值量，无穷</li>
<li><code>NaN</code>：数值量，<code>not a num</code></li>
<li><code>pi</code>：数值量，<span
class="math inline"><em>π</em></span></li>
<li><code>i、j</code>：数值量，<span
class="math inline">$\sqrt{-1}$</span></li>
</ul>
<h3 id="条件语句">条件语句</h3>
<ul>
<li>条件表达式将隐式调用<code>logical()</code>，不需要用括号包围条件表达式</li>
<li><code>if、elseif、else</code></li>
<li><code>switch、case、otherwise</code>：<code>otherwise</code>对应<code>default</code>，在匹配到唯一的<code>case</code>并执行对应语句块后，立刻跳出<code>switch</code>块</li>
<li><code>for、while、continue、break</code>：<code>break</code>专用于循环语句，不属于<code>switch</code>语句</li>
<li><code>end</code>：所有<code>if、for、while</code>等条件语句都应匹配一个<code>end</code>，用于终止块
<ul>
<li><code>end</code>在数组变量的括号内时，<strong>表示数组结尾的索引</strong></li>
<li>为增加可读性，函数一般也添加<code>end</code>表示终止</li>
</ul></li>
</ul>
<h2 id="常用命令或函数">常用命令或函数</h2>
<p><code>MATLAB</code>是脚本语言，所有脚本语句都可在命令行运行，语句分为表达式和命令，常用命令如下：</p>
<h3 id="脚本数据相关">脚本数据相关</h3>
<ul>
<li><code>who</code>：返回多行一列的<strong>元胞数组</strong>，储存所有定义过的变量，单独使用时作为一条命令而不是表达式执行</li>
<li><code>whos</code>：返回<strong>结构体数组</strong>，存储更多信息如长度、所占字节、类型等，单独使用时作为一条命令执行</li>
<li><code>format</code>：<strong>改变精度</strong>，默认<code>format</code>为<code>short</code>，默认精度为<code>4</code>位小数，只能作为命令
<ul>
<li><code>format long</code>：显示<code>16</code>位小数</li>
<li><code>format bank</code>：四舍五入后显示<code>2</code>位小数</li>
<li><code>format short/default</code>：改为默认精度</li>
<li><code>format rat(ional)</code>：返回最接近的形如两个整数除法的表达式</li>
</ul></li>
<li><code>clc</code>：<strong>清屏</strong>，只能作为命令</li>
<li><code>clear</code>：<strong>删除所有变量</strong>，只能作为命令</li>
<li><code>global</code>：声明<strong>全局变量</strong></li>
</ul>
<h3 id="输入输出相关">输入输出相关</h3>
<ul>
<li><code>disp(arr|str)</code>：显示数组或字符串</li>
<li><code>input("提示",format)</code>：输出提示，等待输入，返回输入</li>
<li><code>;</code>：取消打印</li>
</ul>
<h3 id="向量及矩阵">向量及矩阵</h3>
<ul>
<li><p>方括号<code>[]</code>用于创建向量，其中若使用<strong>空格或逗号</strong>作分隔即为<strong>行向量</strong>，使用<strong>分号</strong>作分隔即为<strong>列向量</strong>，向量为一维数组</p></li>
<li><p>仍用方括号创建矩阵，用空格或逗号区分列，用分号区分行，要求不同行向量的列数一致，矩阵为二维数组</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">     <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></li>
<li><p>特殊矩阵创建：</p>
<ul>
<li><code>rand(m, n)</code>：创建<span
class="math inline"><em>m</em> × <em>n</em></span>随机数矩阵，每个元素介于<code>0</code>和<code>1</code>之间</li>
<li><code>ones|zeros</code>：单独时为一阶值为<code>1|0</code>的矩阵，参与运算时自动计算行列数</li>
<li><code>ones(m, n)|zeros(m,n)</code>：全为<code>1|0</code>的<span
class="math inline"><em>m</em> × <em>n</em></span>矩阵</li>
<li><code>eye</code>：单独时为一阶单位矩阵，参与运算时将被视为<code>ones</code></li>
<li><code>eye(n)</code>：<code>n</code>阶<strong>单位矩阵</strong></li>
<li><code>eye(n,m)</code>：<code>m</code>列的<strong>标准型矩阵</strong></li>
<li><code>diag(x,n=0)</code>：必须提供参数，其中<code>x</code>为指定的对角元素<strong>向量</strong>，<code>n</code>为对角线编号，<span
class="math inline">$\begin{cases}n&gt;0&amp;主对角线向上数第n条\\n=0&amp;主对角线\\n&lt;0&amp;主对角线向下数第|n|条\end{cases}$</span>，返回<strong><code>size(M)+n</code>阶</strong>的三角型矩阵</li>
<li><code>diag(A,n=0)</code>：必须提供参数，其中<code>A</code>为指定<strong>矩阵</strong>，返回由该矩阵的第<code>n</code>条对角线元素构成的列向量</li>
<li><code>magic(n)</code>：<code>n&gt;2</code>时产出魔方矩阵，即用<span
class="math inline">1 ∼ <em>n</em><sup>2</sup></span>生成所有行和、列和相等的矩阵</li>
</ul></li>
<li><p>批量创建向量或矩阵：</p>
<ul>
<li>冒号(<code>:</code>)表达式：
<ul>
<li>创建的矩阵占有新的内存，而抽取出的矩阵相当于引用</li>
<li><code>Begin:End-&gt;</code>创建从<code>Begin</code>到<code>End</code>的<strong>等距行向量</strong>，距离为<code>1</code></li>
<li><code>Begin:dist:End-&gt;</code>创建从<code>Begin</code>到<code>End</code>的<strong>等距行向量</strong>，<strong>距离为<code>dist</code></strong></li>
<li><code>数组(代表行索引的向量)</code>：抽取<strong>第一列</strong>的部分元素</li>
<li><code>数组(代表行索引的向量, 代表列索引的向量)</code>：抽取由这些行列构成的<strong>子阵</strong></li>
<li><code>数组(:,j)</code>：抽取第<code>j</code>列所有元素，抽取行向量同理</li>
<li><code>数组(:)-&gt;</code>用<strong>所有元素</strong>构成一个列向量</li>
</ul></li>
<li><code>linspace(Begin, End, count=100)</code>：返回从<code>Begin</code>到<code>End</code>的具<strong>有指定个数</strong>的<strong>等距行向量</strong></li>
<li>其它：<img src="1_space.png" alt="1_space" style="zoom:50%;" /></li>
</ul></li>
<li><p>矩阵的算术运算：</p>
<ul>
<li><code>transpose()</code>：返回转置后的数组</li>
<li><code>inv()</code>：如果可逆，返回逆</li>
<li><code>rank()</code>：返回秩</li>
<li><code>det()</code>：如果可求行列式，返回行列式</li>
<li><code>rref()</code>：返回行最简型</li>
<li><code>poly()</code>：返回由特征方程<span
class="math inline">det (<em>λ</em><em>E</em>−<em>A</em>) = 0</span>的系数构成的行向量</li>
<li><code>eig()</code>：
<ul>
<li><code>e=eig(A)</code>：返回由特征值构成的列向量</li>
<li><code>[V,D]=eig(A)</code>：返回对角为特征值的对角型矩阵<code>D</code>，且<code>V</code>满足<code>AV=VD</code>，即<code>V</code>的每列是右特征向量</li>
<li><code>[V,D,W]=eig(A)</code>：额外返回每列为左特征向量的满矩阵<code>W</code></li>
</ul></li>
<li><code>istriu()|istril()</code>：判断矩阵是否为上三角或下三角型</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>math</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>具体数学: 特殊系数</title>
    <url>/blogs/2024/11/01/concreteMath-special-coefficient/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="二项式系数">二项式系数</h2>
<ul>
<li><p>定义：<span
class="math inline">$\begin{align}(x+y)^n=\sum_{k=0}^n\left(\begin{matrix}n\\k\end{matrix}\right)x^ky^{n-k}\end{align}$</span></p></li>
<li><p>下指数一定为整数，当其为负数时，二项式系数为零，否则：</p>
<ul>
<li>当上指数为整数时，<span
class="math inline">$\begin{align}\left(\begin{matrix}n\\k\end{matrix}\right)=\frac{n!}{k!(n-k)!}\end{align}$</span>，具有组合意义</li>
<li>上指数可推广为实数，此时<span
class="math inline">$\begin{align}\left(\begin{matrix}n\\k\end{matrix}\right)=\frac{n^{\underline
k}}{k!}\end{align}$</span>，可视为<span
class="math inline"><em>n</em></span>的<span
class="math inline"><em>k</em></span>次多项式(<span
class="math inline">(1+<em>r</em>)<sup><em>k</em></sup></span>泰勒展开的系数)</li>
</ul></li>
<li><p>当上指数为<strong>正整数</strong>时：</p>
<ul>
<li><span
class="math inline">$\begin{align}\sum_{k=0}^n\left(\begin{matrix}n\\k\end{matrix}\right)=2^n\end{align}$</span>、<span
class="math inline">$\begin{align}\sum_{k=0}^n(-1)^k\left(\begin{matrix}n\\k\end{matrix}\right)=0\end{align}$</span>，均可通过定义证明</li>
<li>下指数任意，<span
class="math inline">$\begin{align}\left(\begin{matrix}n\\k\end{matrix}\right)=\left(\begin{matrix}n\\n-k\end{matrix}\right)\end{align}$</span></li>
</ul></li>
<li><p>当上指数为<strong>任意实数</strong>时：</p>
<ul>
<li>下指数不为零时，<span
class="math inline">$\begin{align}\left(\begin{matrix}n\\k\end{matrix}\right)=\frac
nk\left(\begin{matrix}n-1\\k-1\end{matrix}\right)\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}\left(\begin{matrix}n\\k\end{matrix}\right)=\left(\begin{matrix}n-1\\k\end{matrix}\right)+\left(\begin{matrix}n-1\\k-1\end{matrix}\right)\end{align}$</span></li>
</ul></li>
<li><p>特殊值：</p>
<ul>
<li><span
class="math inline">$\left(\begin{matrix}n\\0\end{matrix}\right)=1$</span></li>
<li><span
class="math inline">$\left(\begin{matrix}n\\1\end{matrix}\right)=n$</span></li>
<li><span
class="math inline">$\left(\begin{matrix}n\\n\end{matrix}\right)=1$</span></li>
</ul></li>
<li><p>序列构造母函数：<span
class="math inline"> &lt; <em>a</em><sub>0</sub>, ⋯, <em>a</em><sub><em>n</em></sub>&gt;</span>的母函数为<span
class="math inline"><em>A</em>(<em>x</em>) = <em>a</em><sub>0</sub> + <em>a</em><sub>1</sub><em>x</em> + <em>a</em><sub>2</sub><em>x</em><sup>2</sup> + ⋯ + <em>a</em><sub><em>n</em></sub><em>x</em><sup><em>n</em></sup></span></p></li>
<li><p>母函数乘积的系数：若<span
class="math inline"><em>C</em>(<em>x</em>) = <em>A</em>(<em>x</em>)<em>B</em>(<em>x</em>)</span>，则<span
class="math inline">$\begin{align}c_n=\sum_{k=0}^na_kb_{n-k}\end{align}$</span></p>
<ul>
<li><p>证明范德蒙德卷积：由<span
class="math inline">(1+<em>x</em>)<sup><em>a</em> + <em>b</em></sup> = (1+<em>x</em>)<sup><em>a</em></sup>(1+<em>x</em>)<sup><em>b</em></sup></span>，设为<span
class="math inline"><em>C</em>(<em>x</em>) = <em>A</em>(<em>x</em>)<em>B</em>(<em>x</em>)</span>
由<span
class="math inline">$\begin{align}&amp;C(x)=\sum_{k=0}^n\left(\begin{matrix}a+b\\k\end{matrix}\right)x^k\\&amp;A(x)=\sum_{k=0}^n\left(\begin{matrix}a\\k\end{matrix}\right)x^k\\&amp;B(x)=\sum_{k=0}^n\left(\begin{matrix}b\\k\end{matrix}\right)x^k\end{align}$</span></p>
<p>得<span
class="math inline">$\begin{align}c_n=\left(\begin{matrix}a+b\\n\end{matrix}\right)=\sum_{k=0}^n\left(\begin{matrix}a\\k\end{matrix}\right)\left(\begin{matrix}b\\n-k\end{matrix}\right)\end{align}$</span></p></li>
</ul></li>
<li><p>常见母函数：</p>
<ul>
<li><span
class="math inline">$\begin{align}(1+x)^n=\sum_{k=0}^n\left(\begin{matrix}n\\k\end{matrix}\right)x^k\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}\frac1{1-x}=\sum_{k\ge0}x^k、\frac1{1+x}=\sum_{k\ge0}(-1)^kx^k\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}\frac1{(1-x)^{n+1}}=\sum_{k\ge0}\left(\begin{matrix}n+k\\k\end{matrix}\right)x^k\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}\frac{x^n}{(1-x)^{n+1}}=\sum_{k\ge0}\left(\begin{matrix}k\\n\end{matrix}\right)x^k\end{align}$</span>，通过上式移项换元得到</li>
</ul></li>
</ul>
<h2 id="第二类斯特林数">第二类斯特林数</h2>
<ul>
<li>定义：<span
class="math inline">$\begin{align}x^{n}=\sum_{k}\left\{\begin{matrix}n\\k\end{matrix}\right\}x^{\underline
k}\end{align}$</span>，组合意义为将<span
class="math inline"><em>n</em></span>个元素分为<span
class="math inline"><em>k</em></span>个无区别的非空集合</li>
<li>递推式：<span
class="math inline">$\begin{align}\left\{\begin{matrix}n\\k\end{matrix}\right\}=k\left\{\begin{matrix}n-1\\k\end{matrix}\right\}+\left\{\begin{matrix}n-1\\k-1\end{matrix}\right\}\end{align}$</span>
组合意义：将第<span class="math inline"><em>n</em></span>个元素分到<span
class="math inline"><em>k</em></span>个原有盒子的方案为第一项，将它单独作为一个集合的方案数为第二项</li>
<li>特殊值：
<ul>
<li><span
class="math inline">$\left\{\begin{matrix}n\\0\end{matrix}\right\}=\begin{cases}1,&amp;n=0\\0,&amp;n\ne0\end{cases}$</span></li>
<li><span
class="math inline">$\left\{\begin{matrix}n\\1\end{matrix}\right\}=1$</span></li>
<li><span
class="math inline">$\begin{align}\left\{\begin{matrix}n\\2\end{matrix}\right\}=\frac{\sum_\limits{k=1}^{n-1}\left(\begin{matrix}n\\k\end{matrix}\right)}2=2^{n-1}-1\end{align}$</span></li>
<li><span
class="math inline">$\left\{\begin{matrix}n\\n-1\end{matrix}\right\}=\left(\begin{matrix}n\\2\end{matrix}\right)=\frac{n(n-1)}2$</span></li>
<li><span
class="math inline">$\left\{\begin{matrix}n\\n\end{matrix}\right\}=1$</span></li>
</ul></li>
</ul>
<h2 id="第一类斯特林数">第一类斯特林数</h2>
<ul>
<li><p>定义：<span class="math inline">$x^{\overline
n}=\sum_{k\ge0}\left[\begin{matrix}n\\k\end{matrix}\right]x^k$</span>，组合意义为将<span
class="math inline"><em>n</em></span>个元素分为<span
class="math inline"><em>k</em></span>个<strong>轮换</strong></p></li>
<li><p>递推式：<span
class="math inline">$\left[\begin{matrix}n\\k\end{matrix}\right]=(n-1)\left[\begin{matrix}n-1\\k\end{matrix}\right]+\left[\begin{matrix}n-1\\k-1\end{matrix}\right]$</span></p>
<p>组合意义为将第<span
class="math inline"><em>n</em></span>个元素插入到已有划分的<span
class="math inline"><em>n</em> − 1</span>个位置上(第一项)，或作为单独一个轮换(第二项)</p></li>
<li><p>特殊值：</p>
<ul>
<li><span
class="math inline">$\left[\begin{matrix}n\\0\end{matrix}\right]=\begin{cases}0,&amp;n\ne0\\1,&amp;n=0\end{cases}$</span></li>
<li><span
class="math inline">$\left[\begin{matrix}n\\1\end{matrix}\right]=(n-1)!$</span></li>
<li><span
class="math inline">$\left[\begin{matrix}n\\n-1\end{matrix}\right]=\left(\begin{matrix}n\\2\end{matrix}\right)=\frac{n(n-1)}2$</span></li>
<li><span
class="math inline">$\left[\begin{matrix}n\\n\end{matrix}\right]=1$</span></li>
<li>一般来说，第一类斯特林数大于第二类斯特林数，当<span
class="math inline"><em>k</em> = 0, <em>n</em> − 1, <em>n</em></span>时两者相等</li>
<li><span
class="math inline">$\sum_{k=0}^n\left[\begin{matrix}n\\k\end{matrix}\right]=n!$</span></li>
</ul></li>
</ul>
<h2 id="调和数">调和数</h2>
<ul>
<li><p>定义：<span
class="math inline">$\begin{align}H_n=\sum_{k=1}^n\frac1{k}\end{align}$</span></p></li>
<li><p>和第一类斯特林数关系：<span
class="math inline">$n!H_n=\left[\begin{matrix}n+1\\2\end{matrix}\right]$</span></p>
<p>证：<span
class="math inline">$\begin{align}&amp;\left[\begin{matrix}n+1\\2\end{matrix}\right]=n\left[\begin{matrix}n\\2\end{matrix}\right]+(n-1)!\\&amp;\Rightarrow\frac1{n!}\left[\begin{matrix}n+1\\2\end{matrix}\right]=\frac1{(n-1)!}\left[\begin{matrix}n\\2\end{matrix}\right]+\frac1n,由递推式\\&amp;\Rightarrow\frac1{n!}\left[\begin{matrix}n+1\\2\end{matrix}\right]=H_n\end{align}$</span></p></li>
</ul>
<p><span class="math inline">$\begin{align}&amp;当2^k\le
n&lt;2^{k+1}时,只需证明n=2^k时H_n&gt;\frac{\lfloor\lg
n\rfloor+1}2\\&amp;且n=2^{k-1}-1时H_n\le\lfloor\lg
n\rfloor+1即可\\&amp;(1)当n=2^k时,右式=\frac{k+1}2\\&amp;H_n=\sum_{i=0}^k\sum_{j=2^{i-1}}^{2^i}\frac1j&gt;\sum_{i=0}^k\frac{2^{j-1}}{2^j}&gt;\frac{k+1}2\\&amp;(2)当n=2^{k+1}-1时,右式=k+1\\&amp;H_n=\sum_{i=0}^k\sum_{j=i}^{2^{i+1}-1}\frac1j\le\sum_{i=0}^k\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Concrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串算法: KMP匹配</title>
    <url>/blogs/2024/10/23/algo-string-kmpmatch/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="kmp算法"><code>KMP</code>算法</h2>
<h3 id="暴力算法的不足">暴力算法的不足</h3>
<p>假设主串为<code>T</code>，模式串为<code>P</code>，要找出第一个/共有多少个<code>P</code>子串，最简单的办法是暴力搜索</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> string&amp; t, <span class="type">const</span> string&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, tl = t.<span class="built_in">length</span>(), pl = p.<span class="built_in">length</span>();</span><br><span class="line"> <span class="keyword">while</span> (i &lt; tl &amp;&amp; j &lt; pl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == pl ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易算出，该回溯算法的时间复杂度为<code>O(pl*tl)</code>，算法慢在每次的回溯点为<code>i-j+1</code>，而事实上若能找到一个更合适的位置回溯，就能减少重复比较</p>
<h3 id="同一个串的前缀和后缀">同一个串的前缀和后缀</h3>
<p>定义一个字符串的前缀为<code>s[0:i),i&lt;end</code>，即在末尾至少删除一个字符后剩下的子串</p>
<p>后缀同理，为在开头至少删除一个字符后剩下的子串；规定两种子串不为空串</p>
<p>例如字符串<code>abcd</code>的前缀集合为<code>{a,ab,abc}</code>，后缀集合为<code>{d,cd,bcd}</code></p>
<p>如果同一个串的某一前缀和某一后缀相匹配，就可以将前缀平移至后缀，如<span
class="math inline">$\begin{align}&amp;abc\underline {ab}\\&amp;\ \ \ \
\ \ \underline {ab}cab\end{align}$</span>(前后缀<span
class="math inline"><em>a</em><em>b</em></span>匹配)</p>
<p><code>KMP</code>算法的核心思想就是<strong>同一个串的前后缀匹配</strong>，实现<strong>忽略</strong>掉<strong>匹配失败部分</strong>的效果</p>
<p>将上方看作主串<code>T=="abcabeeee"</code>的子串，下方看作模式串<code>P=="abcabf"</code></p>
<p>在暴力算法中，当遍历到<span
class="math inline">$\begin{align}&amp;abcab\underline
eeee\\&amp;abcab\underline
f\end{align}$</span>的最后一个字符<code>f</code>时，需要回溯到<span
class="math inline">$\begin{align}&amp;a\underline bcabeeee\\&amp;\ \
\underline abcabf\end{align}$</span></p>
<p>但如果应用上前后缀匹配，<strong>已匹配串</strong>为<span
class="math inline"><em>a</em><em>b</em><em>c</em><em>a</em><em>b</em></span>，前后缀<span
class="math inline"><em>a</em><em>b</em></span>匹配，直接回溯到<span
class="math inline">$\begin{align}&amp;abc\textcolor{red}{ab}\underline
eeee\\&amp;\ \ \ \ \ \ \textcolor{red}{ab}\underline
cabf\end{align}$</span></p>
<p>实际情况中，需要取<strong>最长</strong>公共前后缀(取最长，匹配失败时仍可以继续遍历较短的情况；而不取最长，就会漏掉最长的情况)</p>
<p>假设提前知道了所有子串的最长公共前后缀的长度，可将暴力算法改写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> string&amp; t, <span class="type">const</span> string&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; tl &amp;&amp; j &lt; pl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">// j回溯到0, 且和i不匹配, 则i肯定不是答案</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            j = 子串的最长公共前后缀的长度; <span class="comment">// 直接回溯到最长前缀子串的后一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == pl ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该过程时间复杂度为<code>O(tl)</code></p>
<h3
id="求出每个前缀子串的最长公共前后缀长">求出每个前缀子串的最长公共前后缀长</h3>
<p>要使用上述算法，需要提前知道<strong>所有子串<code>p[0:j)</code>的</strong>最长公共前后缀长，即预处理</p>
<p>这里的子串刚好是模式串的前缀子串，共有<code>pl</code>个(长度从零到<code>pl-1</code>)，故用<code>next[pl]</code>数组存储</p>
<p><code>KMP</code>算法的一大妙处为快速求出子串的公共前后缀长，实现<code>O(pl)</code>的预处理时间</p>
<p>核心为模式串的子串<strong>自己和自己匹配</strong>，对于子串<code>s=p[0:j)</code>，新主串为<code>s[end-k:end)</code>，新模式串为<code>s[0,k)</code></p>
<p>这里用到动态规划思想(<code>KMP</code>算法的精髓)，回溯时要用到已求的最长公共前后缀长</p>
<p>基础情况为<code>next[0]=next[1]=0</code>(长度为<code>0</code>和<code>1</code>的字符串，没有前后缀子串，故长度为零)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> string&amp; t, <span class="type">const</span> string&amp; p)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> next[pl] &#123;&#125;;<span class="comment">// 除next[0,1]==0外, 其它也置为0, 没有公共前后缀时就不需要修改</span></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; pl - <span class="number">1</span>) &#123; <span class="comment">// 遍历剩下的前缀子串, 因为j一定小于i, 循环条件简化</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j]) &#123;</span><br><span class="line">            next[++i] = ++j; <span class="comment">// 数组索引为子串长度, 值为该子串的最长公共前后缀的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            j = next[j]; <span class="comment">// 回溯到已求出的最长公共前后缀长</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了代码简洁，将下标和长度混用了</p>
<p>事实上整部分就是主算法的翻版，只不过需要存储最长公共前后缀长、主串偏移一个字符，可以说会写主算法就会写预处理</p>
<h3 id="最终代码">最终代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> string&amp; t, <span class="type">const</span> string&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> next[<span class="number">10000</span>]; <span class="comment">// 实际为了更快，不采用变长数组而是静态定长数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, tl = t.<span class="built_in">length</span>(), pl = p.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; pl - <span class="number">1</span>) &#123;<span class="comment">// 如果需要算出p自身的最长前后缀长, 这里不用减1, 然而该算法不需要该信息</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j]) &#123;</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                next[++i] = <span class="number">0</span>; <span class="comment">// 采用静态数组, 因此需手动置0</span></span><br><span class="line">            &#125;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; tl &amp;&amp; j &lt; pl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if (j == pl) &#123; // 如果需要求出所有匹配成功的p串, 在j满时j回溯</span></span><br><span class="line">        <span class="comment">//    // 回溯前记录i - j</span></span><br><span class="line">        <span class="comment">//     j = next[j]; // while条件可删去j &lt; pl</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == pl ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>String Algo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>string</tag>
        <tag>match</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理: 相对论</title>
    <url>/blogs/2024/10/19/physics-relativity/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="狭义相对论">狭义相对论</h2>
<h3 id="经典力学伽利略变换">经典力学伽利略变换</h3>
<ul>
<li>在经典力学中，首先认为时间、质量、作用力是绝对的</li>
<li>在伽利略变换中，假定惯性系<span
class="math inline"><em>S</em>′</span>相对于另一个惯性系<span
class="math inline"><em>S</em></span>以<span
class="math inline"><em>u</em></span>速度匀速直线运动，且设<strong>运动方向为<span
class="math inline"><em>x</em></span>方向</strong>、两惯性系在初始时刻原点在同一位置</li>
<li>则有伽利略(逆)变换：<span
class="math inline">$\begin{cases}x=x'+ut'\\y=y'\\z=z'\\t=t'\end{cases}$</span></li>
<li>推广到牛顿运动定律，<span
class="math inline"><strong>v</strong> = (<em>v</em><sub><em>x</em></sub>′+<em>u</em>, <em>v</em><sub><em>y</em></sub>′, <em>v</em><sub><em>z</em></sub>′) = <strong>v</strong>′ + <em>u</em><strong>i</strong></span>，<span
class="math inline"><strong>a</strong> = (<em>a</em><sub><em>x</em></sub>′,<em>a</em><sub><em>y</em></sub>′,<em>a</em><sub><em>z</em></sub>′) = <strong>a</strong>′</span>，即<strong>一切力学定律在任何惯性系中形式相同</strong></li>
<li>依据上述变换，在绝对时空观中，空间间隔、时间间隔、时间、质量、一切力学定律都是绝对的，而速度是相对的</li>
</ul>
<h3 id="相对论实验基础">相对论实验基础</h3>
<ul>
<li><p>首先，依据电磁学理论的广泛应用，证明真空中的光速<span
class="math inline">$\begin{align}c=\frac1{\sqrt{\varepsilon_0\mu_0}}\end{align}$</span>，和伽利略变换中速度的相对性不符</p></li>
<li><p>迈克尔逊莫雷干涉实验：其本意为了验证绝对静止的惯性系——以太的存在，结果证明以太是不存在的</p>
<p>即<strong>任何惯性系都是等价的</strong>，不存在任何一个惯性系优于其它惯性系</p>
<ul>
<li>实验内容：</li>
</ul></li>
</ul>
<h3 id="洛伦兹变换">洛伦兹变换</h3>
<ul>
<li><p>无论是经典力学还是狭义相对论，讨论的时空坐标变换都是关于惯性系的</p></li>
<li><p>两条基本假设：</p>
<ul>
<li>爱因斯坦相对性原理：<strong>一切物理规律在所有的惯性系中形式相同</strong>
<ul>
<li>对照伽利略变换中的结论，可知相对性原理是其推广而不是其简单否定</li>
</ul></li>
<li>光速不变原理：在<strong>任何惯性系</strong>中，<strong>真空</strong>中的<strong>光速不变</strong>；即光速和光源的运动状态无关
<ul>
<li><p>光速不变原理可视为一种物理规律，而经典力学中质量绝对等观念并不是物理规律</p></li>
<li><p>另一表述：真空中的光速率是一切物体运动速率的极限</p>
<p>注意是物体的速率，而非相对速率，相对速率可超过<span
class="math inline"><em>c</em></span></p></li>
</ul></li>
</ul></li>
<li><p>一切假设与伽利略变换相同，则有洛伦兹变换：<span
class="math inline">$\begin{cases}x=\frac{\large
x'+ut'}{\sqrt{1-\left(\Large\frac
uc\right)^2}}\\y=y'\\z=z'\\t=\frac{\large t'+{\Large\frac u{c\normalsize
^2}}x'}{\sqrt{1-\left(\Large\frac uc\right)^2}}\end{cases}$</span></p>
<ul>
<li><p>推导：根据相对论假设，<span
class="math inline">$\begin{cases}x=k'(x'+ut')\\x'=k(x-ut)\\k=k'\end{cases}$</span>，且在初始时刻<span
class="math inline"><em>x</em> = <em>c</em><em>t</em>, <em>x</em>′ = <em>c</em><em>t</em>′</span>
故<span
class="math inline"><em>x</em><em>x</em>′ = <em>k</em><sup>2</sup>(<em>x</em>′+<em>u</em><em>t</em>′)(<em>x</em>−<em>u</em><em>t</em>) = <em>k</em><sup>2</sup>(<em>c</em><em>t</em>′+<em>u</em><em>t</em>′)(<em>c</em><em>t</em>−<em>u</em><em>t</em>) = <em>k</em><sup>2</sup><em>t</em><em>t</em>′(<em>c</em>+<em>u</em>)(<em>c</em>−<em>u</em>) = <em>c</em><sup>2</sup><em>t</em><em>t</em>′</span></p>
<p>解得<span
class="math inline">$\begin{align}k=\sqrt\frac{c^2}{c^2-u^2}=\frac1{\sqrt{1-\left({\Large\frac
uc}\right)^2}}\end{align}$</span></p></li>
<li><p>当<span
class="math inline"><em>u</em> &lt;  &lt; <em>c</em></span>时，洛伦兹变换将退化成伽利略变换，即日常生活中的低速惯性系</p></li>
</ul></li>
<li><p>在相对时空观中，时间与<strong>运动方向上的空间位置</strong>有关，时间、时间间隔、空间间隔、质量等都是相对的，而一切物理规律、光速是绝对的</p></li>
</ul>
<h3 id="相对论效应">相对论效应</h3>
<ul>
<li><p>以下讨论中，取<span
class="math inline">$\begin{align}\gamma=\frac1{\sqrt{1-\left(\large\frac{u}{c}\right)^2}}\end{align}$</span></p></li>
<li><p><strong>相对论中的速度</strong>和<strong>相对速度</strong>的区别：</p>
<ul>
<li><p>沿惯性系相对运动方向上，给定<span
class="math inline">$\begin{align}\frac{\mathrm dx}{\mathrm
dt}=v_x\end{align}$</span>，则有<span
class="math inline">$\begin{align}v_x'=\frac{\mathrm dx'}{\mathrm
dt'}=\frac{\mathrm dx'}{\mathrm dt}\frac{\mathrm dt}{\mathrm
dt'}=\gamma^2(v_x-u)\left(1+\frac
u{c^2}v_x'\right)\end{align}$</span></p>
<p>整理得<span
class="math inline">$\begin{align}v_x'=\frac{\gamma^2(v_x-u)}{1-{\large\frac{\gamma^2
u(v_x-u)}{c^2}}}=\frac{v_x-u}{1-{\large\frac{u}{c^2}}v_x}\end{align}$</span></p>
<p>逆变换同理<span
class="math inline">$\begin{align}v_x=\frac{v_x'+u}{1+{\large\frac{u}{c^2}}v_x'}\end{align}$</span></p></li>
<li><p>一：在任意惯性系中测量任意物体的<strong>绝对速率</strong>，不可能超过<span
class="math inline"><em>c</em></span>
二：而<strong>相对速度</strong>是在<strong>同一惯性系</strong>中观测<strong>不同事件的速度差</strong>，只是简单的<strong>速度叠加</strong>，可能超过<span
class="math inline"><em>c</em></span></p>
<p>因速度有相对性，相对速度自然也是相对的，在不同惯性系中观测会有不同</p>
<p>讨论两个惯性系的相对运动速度<span
class="math inline"><em>u</em></span>时，相当于物体一静止，故<span
class="math inline"><em>u</em></span>等同于物体二的绝对速度，根据第一条，<span
class="math inline"><em>u</em></span>是不可能超过<span
class="math inline"><em>c</em></span>的(虽然它是相对速度)</p></li>
<li><p>例如：两相对地面系<span
class="math inline"><em>S</em></span>以速率<span
class="math inline"><em>u</em><sub>1, 2</sub> ≤ <em>c</em></span>相向运动的惯性系<span
class="math inline"><em>S</em><sub>1, 2</sub></span>，讨论<span
class="math inline"><em>S</em><sub>1, 2</sub></span>原点的运动速度：</p>
<p><span
class="math inline">$\begin{align}&amp;在S系中观测,S_1系运动速度为u_1,S_2系运动速度为-u_2,S_2相对S_1速度为u_1+u_2,绝对值可能超过c\\&amp;在S_1系中观测,S_2系运动速度为u_2'=\frac{-u_2-u_1}{1-\frac{(-u_1)(-u_2)}{c^2}}=-\frac{(u_1+u_2)c}{c^2-u_1u_2}c,其绝对值不会超过c\\&amp;仍在S_1系中观测,S_1系运动速度为0,故S_2相对S_1速度就是u_2',其绝对值不会超过c\end{align}$</span></p></li>
</ul></li>
<li><p>同时性的相对性：在<span
class="math inline"><em>S</em>′</span>系中，<strong>沿<span
class="math inline"><em>u</em></span>方向上有相对位移</strong>的不同地<strong>同时发生</strong>事件时，在<span
class="math inline"><em>S</em></span>系中观测，在<span
class="math inline"><em>S</em>′</span>中沿<span
class="math inline"><em>u</em></span>方向<strong>后方的事件先发生</strong></p>
<ul>
<li><p>令<span
class="math inline"><em>Δ</em><em>k</em></span>为前方事件坐标减后方事件坐标，则有<span
class="math inline">$\begin{align}\begin{cases}\Delta t'=0\\\Delta
x'&gt;0\end{cases},\Delta t=\gamma\left(\Delta t'+\frac{u}{c^2}\Delta
x'\right)&gt;0\end{align}$</span>，因此前方事件后发生，<span
class="math inline"><em>Δ</em><em>t</em></span>即两事件在<span
class="math inline"><em>S</em></span>系中的时间间隔</p></li>
<li><p>当两个事件沿<span
class="math inline"><em>u</em></span>方向上没有相对位移时，同时性是绝对的</p>
<p>因此，不同地同时事件在另一惯性系中可能同时，也可能不同时</p></li>
<li><p>时间悖论问题：既然上述推导中，<span
class="math inline"><em>Δ</em><em>t</em> &gt; 0<em>而</em><em>Δ</em><em>t</em>′ = 0</span>，那么是否存在一种情况使<span
class="math inline"><em>Δ</em><em>t</em> &gt; 0<em>而</em><em>Δ</em><em>t</em>′ &lt; 0</span>(即颠倒时序)？</p>
<ul>
<li>因为<span
class="math inline"><em>u</em></span>和任意信号传递速度<span
class="math inline"><em>v</em></span>无法超过光速，因此<span
class="math inline">$\begin{align}\Delta t'=\gamma\left(\Delta t-\frac
u{c^2}\Delta x\right)=\gamma\Delta t\left(1-\frac u{c^2}\frac{\Delta
x}{\Delta t}\right)=\gamma\Delta
t\left(1-\frac{uv}{c^2}\right)\ge0\end{align}$</span></li>
</ul></li>
</ul></li>
<li><p>时间间隔的相对性(时间膨胀效应)：</p>
<ul>
<li><p>称在<span
class="math inline"><em>S</em></span>中<strong>相对<span
class="math inline"><em>S</em></span>静止(同地)</strong>的事件在该系中测得的时间间隔为<strong>原时</strong>，它是最短的</p></li>
<li><p>在任意其它相对<span
class="math inline"><em>S</em></span>系匀速直线运动的惯性系中观测，时间间隔会变长，称为<strong>测时</strong>，因为<span
class="math inline"><em>Δ</em><em>t</em>′ = <em>γ</em>(<em>Δ</em><em>t</em>)</span>，其中<span
class="math inline"><em>γ</em> &gt; 1</span></p></li>
<li><p>注意原时的判断，考察的<strong>不是<span
class="math inline"><em>S</em></span>系动或不动</strong>，而是该<strong>事件的空间坐标在<span
class="math inline"><em>S</em></span>系中不变</strong></p>
<p>例如在<strong>飞船上的时钟</strong>在地面观测会变慢，其中原时为在飞船系中的时间，测时为地面系中测得时间</p></li>
</ul></li>
<li><p>在运动的惯性系中，长度会收缩：</p>
<ul>
<li><p>因为时间间隔本身具有相对性，因此测量长度时要求<strong>同时测量</strong>以保证只探讨空间间隔的相对性</p></li>
<li><p>若待测量物体的各空间坐标在<span
class="math inline"><em>S</em></span>系中保持静止，则称在该惯性系中测得的长度为<strong>原长</strong>，它是最长的</p></li>
<li><p>在任意其它相对<span
class="math inline"><em>S</em></span>系匀速直线运动的惯性系中<strong>同时测量</strong>，<strong>沿运动方向</strong>上的空间间隔会变短，称为<strong>测长</strong>，因为<span
class="math inline">$\begin{align}L_x'=\frac{L_x}{\gamma}=L_x\sqrt{1-\left(\frac{u}{c}\right)^2}\end{align}$</span></p></li>
</ul></li>
<li><p>质速方程：</p>
<ul>
<li><p>在<strong>同一惯性系中</strong>观测时，运动中物体的质量比在静止时大，<span
class="math inline">$\begin{align}m=\frac{m_0}{\sqrt{1-\large\frac{v^2}{c^2}}}\end{align}$</span>，其中<span
class="math inline"><em>v</em></span>为<strong>物体的速度</strong>、<span
class="math inline"><em>m</em><sub>0</sub></span>为静止时的质量</p></li>
<li><p>相对论的动量定理：<span
class="math inline">$\begin{align}\boldsymbol{F}=\frac{\mathrm
d(m\boldsymbol{v})}{\mathrm
dt}=m_t'\boldsymbol{v}+m\boldsymbol{a}\end{align}$</span>，在经典力学中，<span
class="math inline"><em>m</em></span>为常数，第一项为<span
class="math inline">0</span></p>
<p>质速方程很好地阐明了为什么牛顿运动定律形式仍然相同而速率无法超过<span
class="math inline"><em>c</em></span></p></li>
<li><p>所有物体的能量等于静止能量加上动能，<span
class="math inline"><em>E</em> = <em>E</em><sub><em>k</em></sub> + <em>E</em><sub>0</sub></span>，且<span
class="math inline">$\begin{cases}E=mc^2&amp;相对论中的总能量\\E_0=m_0c^2&amp;静能\\E_k=\Delta
mc^2&amp;动能\end{cases}$</span></p>
<ul>
<li>推导：<span class="math inline">$\begin{align}&amp;\mathrm
dA=\boldsymbol F·\mathrm d\boldsymbol r=\frac{\mathrm d\boldsymbol
p}{\mathrm dt}·\mathrm d\boldsymbol r=\boldsymbol v·\mathrm d\boldsymbol
p\\&amp;\mathrm d\boldsymbol p=\mathrm d(m\boldsymbol v)=\boldsymbol
v\mathrm dm+m\mathrm d\boldsymbol v\\&amp;因此\mathrm
dA=\boldsymbol{v·v}\mathrm dm+m\boldsymbol {v·}\mathrm d\boldsymbol
v=v^2\mathrm dm+m\left(\sum_{i=x,y,z}v_i\mathrm
dv_i\right)\\&amp;=v^2\mathrm dm+m\left(\sum_{i=x,y,z}\mathrm
d\left(\frac{v_i^2}{2}\right)\right)=v^2\mathrm dm+mv\mathrm
dv\\&amp;由质速方程m=\frac{m_0}{\sqrt{1-\left(\large\frac{v}{c}\right)^2}}\Rightarrow
m^2c^2-m^2v^2=m_0^2c^2\\&amp;两边求全微分得2mc^2\mathrm dm-(2mv^2\mathrm
dm+2m^2v\mathrm dv)=0\\&amp;代回原式得\mathrm dA=c^2\mathrm
dm\\&amp;动能定义E_k=A=\int_1^2\mathrm dA=\int_{m_0}^mc^2\mathrm
dm=\Delta mc^2=mc^2-m_0c^2\end{align}$</span></li>
</ul></li>
</ul></li>
<li><p>相对论中能量和动量的关系：<span
class="math inline">$\begin{align}E_k=\frac{p^2}{m+m_0}、E^2=p^2c^2+E_0^2\end{align}$</span></p>
<ul>
<li><span
class="math inline">$\begin{align}&amp;由m=\frac{m_0}{\sqrt{1-\left({\large\frac
vc}\right)^2}}\Rightarrow m^2c^4-m^2v^2c^2=m_0^2c^4\\&amp;\Rightarrow
E^2=E_0^2+p^2\Rightarrow
E_k^2+2E_km_0c^2+m_0^2c^4=m_0^2c^4+p^2c^2\\&amp;\Rightarrow
E_k(mc^2-m_0c^2+2m_0c^2)=p^2c^2\\&amp;\Rightarrow
E_k=\frac{p^2}{m+m_0}\end{align}$</span></li>
</ul></li>
<li><p>光的波粒二象性：光子的速度为<span
class="math inline"><em>c</em></span>，质量为<span
class="math inline">0</span>，设光的波长为<span
class="math inline"><em>λ</em></span>，频率为<span
class="math inline"><em>v</em></span>，普朗克常量为<span
class="math inline"><em>h</em></span>，则</p>
<ul>
<li>光速<span
class="math inline"><em>c</em> = <em>λ</em><em>v</em></span></li>
<li>光子的能量<span
class="math inline"><em>E</em> = <em>m</em><em>c</em><sup>2</sup> = <em>p</em><em>c</em> = <em>h</em><em>v</em></span></li>
<li>光子的动量<span
class="math inline">$\begin{align}p=\frac{hv}c=\frac{h}{\lambda}\end{align}$</span></li>
<li>光子的质量<span class="math inline">$\begin{align}m=\frac
E{c^2}=\frac{hv}c\end{align}$</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Physics</category>
      </categories>
  </entry>
  <entry>
    <title>具体数学: 取整函数</title>
    <url>/blogs/2024/10/16/concreteMath-rounding/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<ul>
<li><p>对任意实数<span class="math inline"><em>x</em></span>，有<span
class="math inline"><em>x</em> − 1 &lt; ⌊<em>x</em>⌋ ≤ <em>x</em> ≤ ⌈<em>x</em>⌉ &lt; <em>x</em> + 1</span></p>
<ul>
<li>当<span class="math inline"><em>x</em></span>为整数时，<span
class="math inline">⌊<em>x</em>⌋ = ⌈<em>x</em>⌉</span></li>
<li>当<span class="math inline"><em>x</em></span>为小数时，<span
class="math inline">⌊<em>x</em>⌋ = ⌈<em>x</em>⌉ − 1</span></li>
</ul></li>
<li><p>两个取整函数关于原点对称：<span
class="math inline">⌈ − <em>x</em>⌉ =  − ⌊<em>x</em>⌋</span>，反之亦然</p>
<ul>
<li>回顾上阶幂和下阶幂的性质：<span
class="math inline">$(-x)^{\underline m}=(-1)^mx^{\overline
m}$</span></li>
</ul></li>
<li><p>加减法中，整数项可以随意移出取整符号，但乘除法不行</p></li>
<li><p>若<span
class="math inline"><em>f</em>(<em>x</em>)</span>是任意<strong>连续</strong>的<strong>单调上升</strong>函数，且<span
class="math inline"><em>f</em>(<em>x</em>) ∈ <em>Z</em> ⇒ <em>x</em> ∈ <em>Z</em></span>，则<span
class="math inline">⌊<em>f</em>(⌊<em>x</em>⌋)⌋ = ⌊<em>f</em>(<em>x</em>)⌋</span>(上取整亦然)</p></li>
<li><p>取整函数求区间内整数个数：</p>
<ul>
<li><span class="math inline">[<em>α</em>,<em>β</em>]</span>：<span
class="math inline">⌊<em>β</em>⌋ − ⌈<em>α</em>⌉ + 1</span></li>
<li><span class="math inline">[<em>α</em>, <em>β</em>)</span>：<span
class="math inline">⌈<em>β</em>⌉ − ⌈<em>α</em>⌉</span>，可通过上式分析</li>
<li><span class="math inline">(<em>α</em>, <em>β</em>]</span>：<span
class="math inline">⌊<em>β</em>⌋ − ⌊<em>α</em>⌋</span>，可通过上式分析</li>
<li><span class="math inline">(<em>α</em>,<em>β</em>)</span>：<span
class="math inline">⌈<em>β</em>⌉ − ⌊<em>α</em>⌋ − 1</span>，记住</li>
</ul></li>
<li><p>若<span
class="math inline">$\begin{align}\lfloor\sqrt[3]{n}\rfloor\backslash
n,n\in N^+\end{align}$</span>，则称<span
class="math inline"><em>n</em></span>为赢者数；求<strong>小于</strong>正整数<span
class="math inline"><em>N</em></span>的赢者数的个数：</p>
<p>分为两段，一段是可被取完的，另一段是无法被取完的，其分割点为<span
class="math inline"><em>k</em></span>，它满足<span
class="math inline">$\sqrt[3]{k}=\lfloor\sqrt[3]{k}\rfloor=\lfloor\sqrt[3]{N}\rfloor$</span>
令<span class="math inline">$m=\sqrt[3]{k}$</span></p>
<p><span class="math inline">$\begin{align}&amp;则有原式=\sum_{1\le
i&lt;m,n&lt;(i+1)^3}[i\backslash n]+\sum_{i=m,n&lt;N}[i\backslash
n]=\sum_{i=1}^{m-1}\left\lceil\frac{(i+1)^3-i^3}{i}\right\rceil+\left\lceil\frac{N-m^3}{m}\right\rceil\\&amp;=\sum_{i=1}^{m-1}\lceil3i+3+\frac1i\rceil+\lceil\frac{N}{m}\rceil-m^2=\sum_{i=1}^{m-1}(3i+4)+\left\lceil\frac
Nm\right\rceil-m^2\\&amp;=\frac12(7+3m+1)(m-1)+\left\lceil\frac
Nm\right\rceil-m^2=\frac12m^2+\frac52m+\left\lceil\frac
Nm\right\rceil-4\end{align}$</span></p>
<p>若允许等于<span class="math inline"><em>N</em></span>，则由<span
class="math inline">$\begin{align}\left\lceil\frac{N+1-m^3}{m}\right\rceil=\left\lceil\frac{N+1}{m}\right\rceil-m^2=\left\lfloor\frac{N}{m}\right\rfloor-m^2+1\end{align}$</span></p></li>
<li><p>(续上问)将<span
class="math inline">$\begin{align}\left\lceil\frac{n}{m}\right\rceil\end{align}$</span>替换为下取整形式(<span
class="math inline"><em>n</em>, <em>m</em></span>为任意实数)：</p>
<p><span
class="math inline">$\begin{align}&amp;令n=mq+r,其中q=\left\lfloor\frac{n}{m}\right\rfloor,0\le
r&lt;m\\&amp;则原式=\left\lceil\frac{mq+r}{m}\right\rceil=q+\left\lceil\frac{r}{m}\right\rceil,\\&amp;而\left\lfloor\frac{n+m-1}{m}\right\rfloor=\left\lfloor\frac{(q+1)m+r-1}{m}\right\rfloor=q+1+\left\lfloor\frac{r-1}{m}\right\rfloor\\&amp;无论r=0,r\ne0,两者均相等,因此原式=\left\lfloor\frac{n+m-1}{m}\right\rfloor=1+\left\lfloor\frac{n-1}{m}\right\rfloor\end{align}$</span></p></li>
<li><p>证明<span
class="math inline">$spec(\sqrt2),spec(2+\sqrt2)$</span>是对正整数集合的划分：</p>
<p><span
class="math inline">$\begin{align}&amp;先证它们中小于等于n的正整数恰好等于n:\\&amp;N(\sqrt2,n)=\sum_i[1\le
\left\lfloor i\sqrt2\right\rfloor\le
n]=\sum_{i}[0&lt;i&lt;\frac{n+1}{\sqrt2}]=\left\lceil\frac{n+1}{\sqrt2}\right\rceil-1\\&amp;2+\sqrt2的谱同理,因此N(\sqrt2,n)+N(2+\sqrt2,n)=\left\lceil\frac{n+1}{\sqrt2}\right\rceil+\left\lceil\frac{n+1}{2+\sqrt2}\right\rceil-2\\&amp;=n+1+小数部分-2\\&amp;由于分母为无理数,小数部分和必为1,因此原式=n\\&amp;下证一个元素不可能同时出现在两个谱中:\\&amp;假设有正整数\alpha,\beta,s,使\lfloor\alpha\sqrt2\rfloor=\lfloor\beta(2+\sqrt2)\rfloor=s\\&amp;则有\alpha\sqrt2-1&lt;s&lt;\alpha\sqrt2,\beta(2+\sqrt2)-1&lt;s&lt;\beta(2+\sqrt2)\\&amp;即\frac{s}{\sqrt2}&lt;\alpha&lt;\frac{s+1}{\sqrt2},\frac{s}{\sqrt2+2}&lt;\beta&lt;\frac{s+1}{\sqrt2+2}\\&amp;两式相加,得s&lt;\alpha+\beta&lt;s+1,两个相邻整数间没有整数,因此不成立,原命题成立\end{align}$</span></p></li>
<li><p><span class="math inline"><em>n</em></span>人均匀分为<span
class="math inline"><em>m</em></span>组问题：最大组含<span
class="math inline">$\begin{align}\left\lceil\frac{n}{m}\right\rceil\end{align}$</span>人，最小组含<span
class="math inline">$\begin{align}\left\lfloor\frac{n}{m}\right\rfloor\end{align}$</span></p>
<p>可证明：<span
class="math inline">$\begin{align}n=\sum_{i=0}^{m-1}\left\lceil\frac{n-i}m\right\rceil=\sum_{i=0}^{m-1}\left\lfloor\frac{n+i}m\right\rfloor\end{align}$</span></p>
<p>推广到任意实数<span
class="math inline"><em>x</em></span>(通过分析<span
class="math inline">$\begin{align}f(x)=\frac
xm\end{align}$</span>的性质可去除内部下取整符号)：<span
class="math inline">$\begin{align}\lfloor
mx\rfloor=\sum_{i=0}^{m-1}\left\lfloor
x+\frac{i}m\right\rfloor\end{align}$</span></p></li>
<li><p>平方根取整求和：<span
class="math inline">$\begin{align}\sum_{0\le k&lt;n}\lfloor\sqrt
k\rfloor\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;解一:原式=\sum_{m,k\ge0}m[k&lt;n][m\le\sqrt
k&lt;m+1]\\&amp;=\sum_{m,k\ge0}m[k&lt;n][m^2\le
k&lt;(m+1)^2]\\&amp;=\sum_{m,k\ge0}m[m^2\le k&lt;(m+1)^2\le
n]+\sum_{m,k\ge0}m[m^2\le
k&lt;n&lt;(m+1)^2]\\&amp;\xlongequal[]{m=\lfloor\sqrt
n\rfloor}\sum_{0\le
i&lt;m}i((i+1)^2-i^2)+m(n-m^2)\\&amp;=mn-m^3+\sum_{i=1}^{m-1}(2i^2+i)=mn-m^3+\sum_{1}^{m}(2i^{\underline
2}+3i^{\underline 1})\delta i\\&amp;=\frac23m^{\underline
3}+\frac32m^{\underline 2}+mn-m^3\end{align}$</span></p></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Concrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理: 电磁感应</title>
    <url>/blogs/2024/10/14/physics-elec-induction/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="电磁感应">电磁感应</h2>
<h3 id="电动势">电动势</h3>
<ul>
<li><p>电磁感应现象的本质是产生电动势来阻止磁通量的变化，若形成闭合回路，则表现出感应电流</p></li>
<li><p>电动势定义：</p>
<ul>
<li>把单位正电荷从负极板移至正极板，<strong>非静电力</strong>所做的功，是标量</li>
<li>非静电性场的场强沿从负极板到正极板的直线路径的线积分，即<span
class="math inline">$\begin{align}\mathscr E=\int_-^+\boldsymbol
E_k\boldsymbol ·\mathrm d\boldsymbol l\end{align}$</span></li>
<li>和电势差的意义完全不一样，电动势始终<strong>指向电势升高</strong>的方向</li>
<li>展开后可得，<span class="math inline">$\begin{align}\mathscr
E=-\frac{\mathrm d\left(\iint\boldsymbol {B·}\mathrm d\boldsymbol
S\right)}{\mathrm dt}\end{align}$</span></li>
</ul></li>
<li><p>法拉第电磁感应定律：<span
class="math inline">$\begin{align}\mathscr E=-\frac{\mathrm
d\phi_m}{\mathrm dt}\end{align}$</span></p>
<ul>
<li><p>感应电动势的方向和感应电流的流向相同，且总是阻碍引起感应电流的原因</p>
<p>判断时，可先判断感应电流磁场的方向，再得到感应电流的方向</p></li>
<li><p>多匝线圈的磁通量称为全磁通，若每匝磁通相同，也称磁通链数</p></li>
<li><p>其符号表示<strong>参考方向和实际方向的区别</strong>，实际方向以楞次定律判断后，若求出负值，说明参考方向和实际方向相反；以电磁感应定律求出的电动势的参考方向和原磁场方向呈右螺旋关系</p></li>
</ul></li>
<li><p>动生电动势：<span class="math inline">$\begin{align}\mathscr
E=\int_a^b(\boldsymbol{v\times B})\boldsymbol ·\mathrm d\boldsymbol
l\end{align}$</span>，由洛伦兹力充当非静电力，由<span
class="math inline"><strong>v</strong> <strong>×</strong> <strong>B</strong></span>充当非静电性场</p>
<ul>
<li>动生电动势公式在参考方向和实际方向的区别体现在线积分的方向，若线积分方向与实际方向相反，则求出的电动势为负值</li>
<li>可由<span
class="math inline"><strong>v</strong> <strong>×</strong> <strong>B</strong></span>求出电动势方向</li>
</ul></li>
<li><p>感生电动势：<span class="math inline">$\begin{align}\mathscr
E=\oint_L\boldsymbol{E_k·}\mathrm d\boldsymbol
l=-\iint_S\frac{\part\boldsymbol B}{\part t}\boldsymbol ·\mathrm
d\boldsymbol
S\end{align}$</span>，其中闭合回路方向和磁场呈右螺旋关系</p>
<ul>
<li>感生电场由变化的磁场产生，是无源有旋场，因参考方向取上述方向，故根据电磁感应定律在前面有负号</li>
</ul></li>
</ul>
<h3 id="自感和互感和磁能">自感和互感和磁能</h3>
<ul>
<li><p>磁通量出发，将所有与线圈本身有关的物理量合并成<strong>自感系数</strong><span
class="math inline">$\begin{align}L=\frac{\phi_m}{I}\end{align}$</span></p></li>
<li><p>由法拉第电磁感应定律，自感电动势<span
class="math inline">$\begin{align}\mathscr E=-L\frac{\mathrm dI}{\mathrm
dt}\end{align}$</span></p></li>
<li><p>自感系数的一种求法：假设通有电流<span
class="math inline"><em>I</em></span>，求出其磁通量；例如长直螺绕管的自感系数<span
class="math inline">$\begin{align}L=\mu n^2V\end{align}$</span></p></li>
<li><p>自感系数的三层含义：</p>
<ul>
<li>线圈自感效应大小的量度</li>
<li>线圈电磁惯性大小的量度</li>
<li>线圈储存磁能本领的量度</li>
</ul></li>
<li><p>互感系数<span
class="math inline"><em>M</em></span>比自感系数多出一种影响因素，即有效占据面积，当两线圈所围平面同轴平行时，磁通量最大</p>
<p>两线圈组成的系统中，互感系数相等</p>
<p>计算<span class="math inline">1</span>对<span
class="math inline">2</span>的互感系数时，需使用<span
class="math inline">1</span>的<span
class="math inline"><em>n</em></span>，<span
class="math inline">2</span>的<span
class="math inline"><em>I</em></span>，面积取<strong>有效占据面积</strong></p></li>
<li><p>线圈的磁能：<span
class="math inline">$\begin{align}W_m=\frac{LI^2}{2}\end{align}$</span></p></li>
<li><p>磁场任意点的磁能密度：<span
class="math inline">$\begin{align}w_m=\frac{BH}{2}=\frac{\mu
H^2}{2}=\frac{B^2}{2\mu}\end{align}$</span></p></li>
</ul>
<h3 id="麦克斯韦方程组">麦克斯韦方程组</h3>
<ul>
<li><p>位移电流：(关于电流的连续性)变化的电场在周围激发的磁场等效于电流，其定量描述为：</p>
<p>全电流安培环路定理：<span
class="math inline">$\begin{align}\oint_L\boldsymbol{H·}\mathrm
d\boldsymbol l=I_c+\iint\limits_S\frac{\part\boldsymbol D}{\part
t}\boldsymbol{·}\mathrm d\boldsymbol S\end{align}$</span>，其中<span
class="math inline"><em>I</em><sub><em>c</em></sub></span>为传导电流</p>
<ul>
<li>由平行板电容器引出，电位移通量与极板上积聚的电荷相同，且电位移通量对时间的偏导在数值上等于传导电流、方向上与其一致</li>
</ul></li>
<li><p>磁通连续定理：<span
class="math inline">$\begin{align}\int\kern{-8pt}\int_\limits
S\kern{-23mu}\bigcirc\boldsymbol{B·}\mathrm d\boldsymbol
S\equiv0\end{align}$</span></p></li>
<li><p>电场的高斯定理：<span
class="math inline">$\begin{align}\int\kern{-8pt}\int_\limits
S\kern{-23mu}\bigcirc\boldsymbol{D·}\mathrm d\boldsymbol S=\sum
q_{自由电荷}=\iiint\limits_V\rho\ \mathrm dV\end{align}$</span></p></li>
<li><p>电场的环路定理：<span
class="math inline">$\begin{align}\oint_L\boldsymbol{D·}\mathrm
d\boldsymbol l=-\iint\limits_S\frac{\part\boldsymbol H}{\part
t}\boldsymbol ·\mathrm d\boldsymbol S\end{align}$</span></p></li>
</ul>
<h3 id="电磁波">电磁波</h3>
<ul>
<li>波动方程：由麦克斯韦方程组导出，<span
class="math inline">$\begin{cases}\left(\grad^2-\varepsilon\mu\large\frac{\part^2}{\part
t^2}\right)\boldsymbol
E=0\\\left(\grad^2-\varepsilon\mu\large\frac{\part^2}{\part
t^2}\right)\boldsymbol
H=0\end{cases}$</span>的解即波动的定义，其中哈密顿算子为矢量三个二阶偏导之和</li>
<li>若以电磁波方向为<span
class="math inline"><em>x</em></span>轴正向，可以解得<span
class="math inline">$\begin{cases}\boldsymbol E=\boldsymbol
jE_0\cos(\omega t\pm\omega{\large\frac{x}{c}}+\varphi)\\\boldsymbol
H=\boldsymbol kH_0\cos(\omega
t\pm\omega{\large\frac{x}{c}}+\varphi)\end{cases}$</span>，其中<span
class="math inline">$\begin{align}\pm\omega\frac{x/y/z}{c/u}\end{align}$</span>为传播项，分子定义传播方向，分母定义波速(真空/介质中)，负号为正向传播，正号反之</li>
<li>电磁波的性质：
<ul>
<li>是横波，传播方向由传播项体现，且满足<span
class="math inline"><strong>e</strong><sub><strong>E</strong></sub> <strong>×</strong> <strong>e</strong><sub><strong>B</strong></sub> = <strong>e</strong><sub><strong>u</strong></sub></span></li>
<li>是偏振波，且<span
class="math inline"><strong>E</strong>、<strong>H</strong></span>同相，即<span
class="math inline">cos ()</span>内部完全一致</li>
<li>满足<span class="math inline">$\sqrt\varepsilon E=\sqrt\mu
H$</span>，波速<span
class="math inline">$\begin{align}u=\sqrt{\frac1{\varepsilon\mu}}\end{align}$</span></li>
</ul></li>
<li>在<span
class="math inline"><em>L</em><em>C</em></span>振荡电路中，由<span
class="math inline">$\begin{align}u=\frac qC=\mathscr E=-L\frac{\mathrm
dI}{\mathrm dt}=-L\frac{\mathrm d^2q}{\mathrm
dt^2}\end{align}$</span>，得出简谐运动方程<span
class="math inline">$\begin{align}\frac{\mathrm d^2q}{\mathrm
dt^2}+\frac1{LC}q=0\end{align}$</span>
<ul>
<li>当二阶常系数线性齐次微分方程中，若“常系数”为只与自身因素有关的正的常数，则称其为简谐运动</li>
<li>振荡角频率<span
class="math inline">$\begin{align}\omega=\sqrt\frac1{LC}\end{align}$</span></li>
</ul></li>
<li>电磁辐射能：电能和磁能之和</li>
<li>能流密度/辐射强度/坡印廷矢量：<span
class="math inline"><strong>S</strong> = (<em>ω</em><sub><em>c</em></sub>+<em>ω</em><sub><em>m</em></sub>)<strong>u</strong></span></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Physics</category>
      </categories>
  </entry>
  <entry>
    <title>大学物理: 恒定磁场</title>
    <url>/blogs/2024/10/11/physics-magnetic-field/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="恒定磁场">恒定磁场</h2>
<h3 id="电流的磁效应">电流的磁效应</h3>
<ul>
<li><p>真空磁导率：<span class="math inline">$\mu_0=4\pi\times
10^{-7}\rm\ T·m·A^{-1}$</span></p></li>
<li><p>磁感应强度：<span class="math inline">$1\rm
T=10^4Gs$</span>，定义运动正电荷所受磁力方向和其运动方向的叉乘为磁感应强度的方向</p></li>
<li><p>毕奥-萨伐尔定律：<span class="math inline">$\begin{align}\mathrm
d\boldsymbol B=\frac{\mu_0}{4\pi}\frac{I\mathrm d\boldsymbol{l\times
e_r}}{r^2}\end{align}$</span>
可配合磁场叠加原理求解场点的磁场，求解闭合回路电流产生的磁场时，需注意<strong>电流分流</strong>的影响</p>
<ul>
<li>载流直线产生磁场：<span
class="math inline">$\begin{align}B=\frac{\mu_0I}{4\pi
r}(\cos\alpha_1-\cos\alpha_2)\end{align}$</span>，其中<span
class="math inline"><em>r</em></span>为场点到直线的距离，<span
class="math inline"><em>α</em><sub>1</sub>、<em>α</em><sub>2</sub></span>分别为沿电流方向的起点、终点与场点的<strong>连线到载流直线</strong>的<strong>夹角</strong></li>
<li>无限长载流直线：<span
class="math inline">$\begin{align}B=\frac{\mu_0I}{2\pi
r}\end{align}$</span></li>
<li>圆弧电流在中心的磁场：<span
class="math inline">$\begin{align}B=\frac{\theta}{2\pi}\frac{\mu_0I}{2r}\end{align}$</span>，其中<span
class="math inline"><em>θ</em></span>为圆弧的圆心角</li>
</ul></li>
<li><p>磁场的高斯定理：<span
class="math inline">$\begin{align}\int\kern{-8pt}\int_\limits
S\kern{-23mu}\bigcirc\boldsymbol{B·}\mathrm d\boldsymbol
S\equiv0\end{align}$</span>，通过闭合曲面的磁通量为零，揭示磁场是无源场</p></li>
<li><p>磁感应线的性质：无头无尾、不相交、环绕方向和<span
class="math inline"><em>I</em></span>构成右手螺旋关系</p></li>
<li><p>安培环路定理：<span
class="math inline">$\begin{align}\oint\boldsymbol{B·}\mathrm
d\boldsymbol l=\mu_0\sum I\end{align}$</span>，其中<span
class="math inline"><em>I</em></span>为<strong>穿过</strong>闭合路径<strong>内</strong>的<strong>闭合电流</strong>
可通过它求高度对称磁场的磁感应强度</p>
<p>类比空间所有电荷对电场强度的贡献，空间任意一点的磁感应强度由空间中所有电流贡献</p>
<ul>
<li>均匀密绕长直载流螺线管：<span
class="math inline">$\begin{align}\boldsymbol
B=n\mu_0I\end{align}$</span>，其中<span
class="math inline"><em>n</em></span>为单位长度线圈匝数</li>
<li>环形螺线管：<span class="math inline">$\begin{align}\boldsymbol
B=\frac{\mu_0NI}{2\pi r}\end{align}$</span></li>
<li>无限大载流导体薄板：<span
class="math inline">$\begin{align}\boldsymbol
B=\frac{n\mu_0I}2\end{align}$</span></li>
</ul></li>
</ul>
<h3 id="磁场对实物的作用">磁场对实物的作用</h3>
<ul>
<li><p>洛伦兹力：<span
class="math inline"><strong>F</strong><sub><em>m</em></sub> = <em>q</em><strong>v</strong> <strong>×</strong> <strong>B</strong></span></p></li>
<li><p>载流子浓度：<span
class="math inline">$\begin{align}n=\frac{N}{V}\end{align}$</span>，<strong>单位体积</strong>内载流子的<strong>数目</strong></p></li>
<li><p>霍尔效应与洛伦兹公式：<span
class="math inline"><strong>F</strong> = <em>q</em><strong>E</strong> + <em>q</em><strong>v</strong> <strong>×</strong> <strong>B</strong></span>，体现在一小片半导体中时，产生的横向电场的霍尔电势差<span
class="math inline">$\begin{align}V_H=R_H\frac{IB}{b}\end{align}$</span>，其中<span
class="math inline">$\begin{align}R_H=\frac1{ne}\end{align}$</span>为霍尔系数，<span
class="math inline"><em>b</em></span>为横向宽度，特别地称<span
class="math inline">$\begin{align}K_H=\frac1{neb}\end{align}$</span>为霍尔灵敏度</p>
<ul>
<li>由<span class="math inline">$\begin{align}I=\frac{\mathrm
dQ}{\mathrm
dt}=nqvS\end{align}$</span>，即单位时间内通过横截面的电荷量(单位时间内，流向位移为<span
class="math inline"><em>v</em></span>，则<span
class="math inline"><em>v</em><em>S</em></span>这个体积块内的电荷均可通过横截面，其数目为<span
class="math inline"><em>n</em><em>v</em><em>S</em></span>，乘上<span
class="math inline"><em>q</em></span>即为总电荷量)</li>
<li>设半导体纵向(霍尔电场方向)宽度为<span
class="math inline"><em>a</em></span>，横向(磁场方向)宽度为<span
class="math inline"><em>b</em></span>，则平衡时有<span
class="math inline">$\begin{align}I=nqvab、E=vB=\frac{V_H}{a}\end{align}$</span>
整理得<span
class="math inline">$\begin{align}V_H=\frac{IB}{neb}\end{align}$</span></li>
<li>由霍尔效应可判断半导体中载流子的正负性、制造速度选择器等</li>
</ul></li>
<li><p>电流元(可视作极短直线的恒定电流)所受安培力：<span
class="math inline">d<strong>F</strong> = <em>I</em>d<strong>l</strong> <strong>×</strong> <strong>B</strong></span></p>
<ul>
<li>电流元所受安培力是<span
class="math inline"><em>N</em></span>个定向移动电荷所受<strong>洛伦兹力的分力的合力</strong>，其中<span
class="math inline">$\begin{align}N=nS\mathrm
dl\end{align}$</span>(<span
class="math inline">d<strong>l</strong></span>和<span
class="math inline"><strong>v</strong></span>方向一致)，故 <span
class="math inline">$\begin{align}\mathrm d\boldsymbol F=N\boldsymbol
F_m=qN(\boldsymbol{v\times B})=nqvS\mathrm dl(\boldsymbol{e_v\times
B})=I\mathrm d\boldsymbol {l\times B}\end{align}$</span></li>
<li>均匀磁场中，任意闭合线圈所受磁场<strong>合力为零</strong>，但作用线不在一条直线上时会产生磁力矩</li>
</ul></li>
<li><p>磁矩：<span
class="math inline"><strong>m</strong> = <em>I</em><strong>S</strong> = <em>I</em><em>S</em><strong>e</strong><sub><em>s</em></sub></span>，表示线圈电流产生磁场的能力，其中磁矩方向和电流方向符合右手螺旋定则</p></li>
<li><p>闭合带电线圈所<strong>受外磁场</strong>的<strong>合</strong>磁力矩：<span
class="math inline">$\begin{align}\boldsymbol M=\boldsymbol{m\times
B}\end{align}$</span>，和线圈旋转方向构成右手螺旋关系</p>
<ul>
<li>公式中，<span
class="math inline"><strong>B</strong></span>为外磁场，而不是线圈产生的磁场</li>
<li><span class="math inline">$\begin{align}\boldsymbol M=\oint
_L\boldsymbol{r\times F}=I\oint_L(\boldsymbol {r\times}\mathrm
d\boldsymbol{l\times B})=I\boldsymbol {S\times B}=\boldsymbol{m\times
B}\end{align}$</span></li>
</ul></li>
</ul>
<h3 id="磁力做功问题">磁力做功问题</h3>
<ul>
<li><p>首先明确，磁场是非保守力场，即磁力做功与路径有关，故一个位置相对另一个位置而言，没有固定的能量差，因此没有磁势的概念</p></li>
<li><p>洛伦兹力<strong>对电子永不做功</strong>，安培力实际上是洛伦兹力在垂直导线方向上的分力，因此<strong>会对导线做功</strong></p>
<p>实际上，<strong>安培力做功等于感应电动势做功</strong>，恒流情况下，<span
class="math inline">$\begin{align}A=I\Delta\phi_m\end{align}$</span></p></li>
<li><p>刚体力学引理：力矩做功实际上就是力做功，通过数学推导得<span
class="math inline">d<em>A</em> = <strong>F</strong><strong>·</strong>d<strong>r</strong> = <em>M</em>d<em>θ</em></span>，方便刚体转动计算</p>
<p>匀强磁场对闭合曲线的合力为零，但除去特定角度会产生磁力矩，而磁力矩会对线圈做功</p>
<p>可以发现，在匀强磁场中，磁力对闭合线圈做功<span
class="math inline">$\begin{align}A=\int_{\phi_1}^{\phi_2}I\mathrm
d\phi_m=\int_{\phi_1}^{\phi_2}I\mathrm
d(BS\cos\theta)=-\int_{\theta_1}^{\theta_2}IBS\sin\theta\mathrm
d\theta=-\int_{\theta_1}^{\theta_2}M\mathrm
d\theta\end{align}$</span></p>
<p>即，该做功只与<span
class="math inline"><em>θ</em>(<strong>m</strong>,<strong>B</strong>)</span>的<strong>始末位置</strong>有关，仿照电势能的概念，引入<strong>磁矩的势能</strong>，由上式可看出：</p>
<p>磁矩势能的减少值即为磁力矩的做功，当<strong>磁矩势能为零</strong>时，<strong>磁通量达到最大值</strong>，线圈处于<strong>稳定平衡</strong>状态</p>
<p>实际上，在一般磁场中也适用</p>
<ul>
<li>磁铁相互吸引的原理就是，磁力将磁矩势能转换为磁铁的动能，使其相互靠近</li>
</ul></li>
</ul>
<h3 id="磁介质对磁场的作用">磁介质对磁场的作用</h3>
<ul>
<li><p>相对磁导率：<span
class="math inline"><em>μ</em><sub><em>r</em></sub></span>，根据其略小于一、略大于一、远大于一分为下面三类</p></li>
<li><p>磁介质的分类：顺磁质、抗磁质、铁磁质</p></li>
<li><p>磁化机理：</p>
<ul>
<li>分子可等效为具有固有磁矩的圆电流，根据<span
class="math inline">$\begin{align}\sum\boldsymbol
m\end{align}$</span>(分子的固有磁矩)等于/不等于零，可区分抗磁质和顺磁质</li>
<li>磁介质在常态没有磁性的原因是：无规律等概率的热运动使介质的所有分子的固有磁矩和为零</li>
<li>外加磁场后，顺磁质的固有磁矩受磁场作用产生磁力矩，使所有分子电流趋向磁场方向，达到增强磁场的作用</li>
<li>所有磁介质都有抗磁能力(磁通量增大时产生的反向感应电流会产生反向磁场)，只是顺磁质的顺磁作用远强于抗磁作用</li>
<li>顺磁质、抗磁质的<span
class="math inline"><em>μ</em><sub><em>r</em></sub></span>为常数，而铁磁质的<span
class="math inline"><em>μ</em><sub><em>r</em></sub></span>不是线性的，受温度、磁化历史等影响
<ul>
<li>磁饱和：当激励电流达到一定程度时，产生的附加磁场有饱和值</li>
<li>剩磁现象：卸去磁化后的铁磁质的激励电流后，附加磁场有剩余，需加反向激励电流才能消磁</li>
<li>矫顽力：使能消磁的附加的反向磁场强度</li>
<li>磁滞现象：附加磁场从正饱和到负饱和的曲线和从负饱和到正饱和的曲线呈中心对称</li>
</ul></li>
</ul></li>
<li><p>根据铁磁质的磁滞回线形状，分为硬、软、矩磁材料：</p>
<ul>
<li>硬磁：矫顽力大，作永久磁铁</li>
<li>软磁：矫顽力小，作变压器</li>
<li>矩磁：剩磁和磁饱和近似相等，作磁盘等记忆元件</li>
</ul></li>
<li><p>磁介质中的安培环路定理：<span
class="math inline">$\begin{align}\oint_L\boldsymbol{H·}\mathrm
d\boldsymbol l=\sum I_{传导电流}\end{align}$</span>，其中<span
class="math inline"><strong>H</strong></span>为磁场强度且<span
class="math inline"><strong>B</strong> = <em>μ</em><sub>0</sub><em>μ</em><sub><em>r</em></sub><strong>H</strong></span></p>
<ul>
<li><p>推导前已知：磁化程度<span
class="math inline"><strong>M</strong></span>，且<span
class="math inline">$\begin{align}\oint_L\boldsymbol{M·}\mathrm
d\boldsymbol l=\sum I_{束缚}、\boldsymbol M=\chi_m\boldsymbol
H\end{align}$</span></p></li>
<li><p>推导：<span
class="math inline">$\begin{align}&amp;\oint_L\boldsymbol{B·}\mathrm
d\boldsymbol l=\mu_0\sum\left(I_{传导}+I_{束缚}\right)=\mu_0\sum
I_{传导}+\mu_0\oint_L\boldsymbol{M·}\mathrm d\boldsymbol
l\\&amp;\Rightarrow\oint_L\left(\frac{\boldsymbol B}{\mu_0}-\boldsymbol
M\right)\mathrm d\boldsymbol l=\sum I_{传导}\end{align}$</span></p>
<p>令<span class="math inline">$\begin{align}&amp;\boldsymbol
H=\frac{\boldsymbol B}{\mu_0}-\boldsymbol M\end{align}$</span>，则<span
class="math inline"><strong>B</strong> = <em>μ</em><sub>0</sub>(1+<em>χ</em><sub><em>m</em></sub>)<strong>H</strong></span></p>
<p>令<span
class="math inline"><em>μ</em><sub><em>r</em></sub> = 1 + <em>χ</em><sub><em>m</em></sub></span>，得<span
class="math inline"><strong>B</strong> = <em>μ</em><sub>0</sub><em>μ</em><sub><em>r</em></sub><strong>H</strong></span></p></li>
</ul></li>
</ul>
<h3 id="磁场的应用">磁场的应用</h3>
<ul>
<li>质谱仪：<span
class="math inline">$\begin{align}&amp;\frac{mv^2}{2}=qU、\frac{mv^2}{r}=qvB\\&amp;\Rightarrow
v=\sqrt{\frac{2qU}{m}}、r=\frac1B\sqrt{\frac{2mU}{q}}\end{align}$</span></li>
<li>回旋加速器</li>
<li>磁聚焦</li>
<li>霍尔效应</li>
<li>速度选择器</li>
<li>磁流体发电机</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Physics</category>
      </categories>
  </entry>
  <entry>
    <title>大学物理: 静电场</title>
    <url>/blogs/2024/10/06/physics-electrostatic-field/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="静电场">静电场</h1>
<h2 id="基本定律及常量">基本定律及常量</h2>
<ul>
<li>电荷的性质：
<ul>
<li>量子性：基本电荷<span class="math inline">$e=1.602\times10^{-19}\rm
C$</span>，所有基本粒子所带电荷均为<span
class="math inline"><em>e</em></span>的整数倍</li>
<li>电荷守恒定律：在孤立系统内发生的任何过程中，总电荷数(所有电荷代数和)不变</li>
<li>正负性、相对论不变性</li>
</ul></li>
<li>库仑定律：电荷间的相互作用力为<span
class="math inline">$\begin{align}\boldsymbol{F}=\frac1{4\pi\varepsilon_0}\frac{q_1q_2}{r^3}\boldsymbol{r}=\frac{q_1q_2}{4\pi\varepsilon_0r^2}\boldsymbol{r}_0\end{align}$</span>
<ul>
<li>其中，真空介电常量<span
class="math inline">$\varepsilon_0=8.85\times10^{-12}\rm
C^2·N^{-1}·m^{-2}$</span></li>
<li>没有合并进去的<span
class="math inline">4<em>π</em></span>是方便工程中计算球体而引入的</li>
</ul></li>
</ul>
<h2 id="场论">场论</h2>
<ul>
<li><p>场是一种中介物质，物质间的相互作用要靠场来传递</p></li>
<li><p>电磁场是量子化的，具有波粒二象性，对电场来说：</p>
<ul>
<li>相对于观察者静止的电荷产生静电场</li>
<li>电场是有能量的</li>
</ul></li>
<li><p>电场强度(场强)<span
class="math inline"><strong>E</strong></span>：</p>
<ul>
<li><p>反映了电场的固有属性，即空间中<strong>某一点的场强</strong>与在<strong>该点上的电荷无关</strong>，计算时需要剔除场点产生的场强</p></li>
<li><p>由于电场力满足叠加原理，故电场强度也满足叠加原理</p></li>
<li><p>要求某一点的场强，就是求空间中<strong>除该点外</strong>，所有电荷产生的场强的矢量和</p>
<p>场强第一种求解方式(场强叠加原理)：<span
class="math inline">$\begin{align}\boldsymbol{E}=\int\mathrm
d\boldsymbol{E}=\int\frac{\mathrm
dq}{4\pi\varepsilon_0r^3}\boldsymbol{r}=\int_\Omega\frac{\rho\
\boldsymbol{r}}{4\pi\varepsilon_0r^3}\mathrm d\Omega\end{align}$</span>
具体来说，<strong>大小通过积分</strong>来求，而<strong>方向通过划分坐标分量</strong>，各自求解并组合</p></li>
</ul></li>
<li><p>电通量<span
class="math inline"><em>𝛷</em></span>和静电场中的高斯定理：</p>
<ul>
<li>指垂直通过某面的电场强度的代数和(电场线的条数)，和电场强度、穿过的面积成正比</li>
<li><span
class="math inline">$\begin{align}\varPhi=\iint_S\boldsymbol{E}\ \mathrm
d\boldsymbol{S}=\iiint_V\div{\boldsymbol
E}\end{align}$</span>(第二型曲面积分和高斯公式)，散度<span
class="math inline">$\begin{align}\div{\boldsymbol
E}=\frac{\lambda}{\varepsilon_0}\end{align}$</span></li>
<li>高斯定理：真空中，通过封闭曲面的电通量等于<span
class="math inline">$\begin{align}\frac{\sum
q}{\varepsilon_0}\end{align}$</span>，其中<span
class="math inline"><em>q</em></span>包括所有自由、极化电荷</li>
<li>高斯定理对所有电场都成立，但只能用于求解高度对称场的场强，例如(场强第二种求解方式)：
<ul>
<li>球对称图形的外部电场：<span
class="math inline">$\begin{align}\boldsymbol
E=\frac{q}{4\pi\varepsilon_0r^2}{\boldsymbol
r_0}\end{align}$</span></li>
<li>轴对称图形的外部电场：<span
class="math inline">$\begin{align}\boldsymbol
E=\frac{\rho}{2\pi\varepsilon_0 r}\boldsymbol
r_0\end{align}$</span>，<span
class="math inline"><em>ρ</em></span>为电荷线密度</li>
<li>面对称的匀强场：<span class="math inline">$\begin{align}\boldsymbol
E=\pm\frac{\lambda}{2\varepsilon_0}\boldsymbol
n_0\end{align}$</span>，这里的面<strong>无厚度</strong></li>
</ul></li>
<li>高斯定理揭示出的<strong>电场线性质</strong>：
<ul>
<li>有头有尾，始于正电荷、终于负电荷</li>
<li>任意两电场线不相交</li>
<li>任意电场线不闭合</li>
<li>任何正电荷(包括极化电荷)都能发出电场线，即电介质中需要画两种电场线</li>
</ul></li>
<li>通过高斯定理求解步骤：
<ul>
<li>阐明对称性，选取合适高斯面以至于能快速去除积分号</li>
<li>求出电通量表达式和面内净电荷</li>
</ul></li>
</ul></li>
<li><p>电场力做功：</p>
<ul>
<li>电荷在电场中从<span class="math inline"><em>a</em></span>到<span
class="math inline"><em>b</em></span>，<span
class="math inline">$\begin{align}A=\int_a^b\boldsymbol{F·}\mathrm
d\boldsymbol{r}\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}A=q\oint_L\boldsymbol{E·}\mathrm
d\boldsymbol{r}=q\iint_S\boldsymbol{\grad\times E·}\mathrm
d\boldsymbol{S}\end{align}$</span>(斯托克斯公式)，其中<span
class="math inline">$\boldsymbol{\grad\times E}$</span>即旋度</li>
<li>电场力是保守力，做功与路径无关，沿闭合路径做功为<span
class="math inline">0</span></li>
</ul></li>
<li><p>场强环路定理：</p>
<ul>
<li>静电场是<strong>无旋场</strong>，是保守力场</li>
<li>电势能：定义电荷在<span
class="math inline"><em>a</em></span>处的电势能为<span
class="math inline">$\begin{align}W_{a}=q\int_a^{0势}\boldsymbol{E·}\mathrm
d\boldsymbol{r}\end{align}$</span></li>
<li>电势：<span class="math inline"><em>a</em></span>处电势为<span
class="math inline">$\begin{align}U_a=\int_a^{0势}\boldsymbol{E·}\mathrm
d\boldsymbol{r}\end{align}$</span>，积分上下限通常为点到对称中心的距离
<ul>
<li>电势是<strong>相对量</strong></li>
<li>电势差：定义<span class="math inline"><em>a</em></span>和<span
class="math inline"><em>b</em></span>点间的电势差为<span
class="math inline">$\begin{align}U_a-U_b=\int_a^b\boldsymbol{E·}\mathrm
d\boldsymbol{r}\end{align}$</span></li>
</ul></li>
<li>微分形式：<span class="math inline">$\grad U=-\boldsymbol
E$</span>，电场方向指向电势减小的方向
<ul>
<li>场强均匀的区域，电势不一定为定值</li>
<li>电势为定值的<strong>区域</strong>(不是等势面)，场强一定为零</li>
<li>通常作为定性考点</li>
</ul></li>
<li>常见对称电场的电势(以无穷远为零势点)：
<ul>
<li>球对称图形的外部：<span
class="math inline">$\begin{align}\frac{q}{4\pi\varepsilon
r}\end{align}$</span></li>
<li>轴对称图形的外部：<span
class="math inline">$\begin{align}\frac{\lambda}{2\pi\varepsilon}\end{align}$</span></li>
<li>无厚度面：只能求两面/两薄面的电势差</li>
</ul></li>
<li>电势两种计算方式：定义法(对称场)、叠加法</li>
</ul></li>
<li><p>导体：</p>
<ul>
<li><p>导体静电平衡条件：内部场强为零，表面附近场强处处与面元垂直</p>
<ul>
<li>若有空腔且空腔内有电荷<span
class="math inline"><em>Q</em></span>，则内表面感应出<span
class="math inline"> − <em>Q</em></span>，外表面表现为<span
class="math inline"><em>q</em> + <em>Q</em></span>，此时空腔内有电场</li>
</ul></li>
<li><p>非对称导体表面带电情况只能通过实验测量，电荷面密度与表面曲率成正比</p></li>
<li><p>导体是等势体</p></li>
</ul></li>
<li><p>电介质：</p>
<ul>
<li><p>两种分子：正负电荷中心重合/不重合<span
class="math inline">→</span>非极性分子/极性分子</p></li>
<li><p>极化方式：位移极化/取向极化，极化电场只影响电介质内部电场</p></li>
<li><p>电极化率：<span
class="math inline"><em>χ</em><sub><em>e</em></sub></span></p></li>
<li><p>电极化强度：<span
class="math inline"><strong>P</strong> = <em>α</em><strong>E</strong></span>、<span
class="math inline"><em>α</em> = <em>ε</em><sub>0</sub><em>χ</em><sub><em>e</em></sub></span>，<span
class="math inline"><em>P</em><sub><em>n</em></sub> = <em>σ</em><sub><em>极</em><em>化</em><em>电</em><em>荷</em></sub></span></p></li>
<li><p>相对介电常量：<span
class="math inline"><em>ε</em><sub><em>r</em></sub> = 1 + <em>χ</em><sub><em>e</em></sub></span>，无量纲；一般大于<span
class="math inline">1</span>，因此往电容两极板间加入电介质将增大电容</p></li>
<li><p>绝对介电常量：<span
class="math inline"><em>ε</em> = <em>ε</em><sub>0</sub><em>ε</em><sub><em>r</em></sub></span>，有量纲</p></li>
<li><p>电位移矢量：<span
class="math inline"><strong>D</strong> = <em>ε</em><strong>E</strong></span></p></li>
<li><p>电介质的高斯定理：<span
class="math inline">$\begin{align}\oint_S\boldsymbol{D·}\mathrm
d\boldsymbol S=\sum
q_{自由电荷}\end{align}$</span>，因此电位移线由正自由电荷发出</p>
<ul>
<li><p>推导：<span
class="math inline">$\begin{align}&amp;\oint_S\boldsymbol{P·}\mathrm
d\boldsymbol S=-\sum q_{极化电荷}\\&amp;\oint_S\boldsymbol{E·}\mathrm
d\boldsymbol S=\frac1{\varepsilon_0}\sum
(q_{极化电荷}+q_{自由电荷})\\&amp;\boldsymbol
P=\frac{\varepsilon_r-1}{\varepsilon_r}\boldsymbol
D=\varepsilon_0(\varepsilon_r-1)\boldsymbol
E\end{align}$</span></p></li>
<li><p>分别求极化电荷或自由电荷产生的场强时，不能通过电介质的高斯定理求解，该定理用于快速求解电介质中的合场强</p>
<p>换句话说，不同种类电荷产生的场强和<span
class="math inline"><em>ε</em><sub><em>r</em></sub></span>无关</p>
<p>事实上，<span
class="math inline">$\begin{align}E_0=\frac{\sigma}{\varepsilon_0}、E'=\frac{\sigma'}{\varepsilon_0}\end{align}$</span></p></li>
</ul></li>
</ul></li>
<li><p>电容：</p>
<ul>
<li><span class="math inline">$\begin{align}C=\frac{Q}{\Delta
U}\end{align}$</span>，两极相距单位电势差时正极板所带的电荷</li>
<li>常见电容器的电容：
<ul>
<li>孤立导体球：<span
class="math inline">$\begin{align}C=4\pi\varepsilon
R\end{align}$</span></li>
<li>平行板电容器：<span
class="math inline">$\begin{align}C=\frac{\varepsilon
S}{d}\end{align}$</span></li>
<li>球形电容器(两同心球面)：<span
class="math inline">$\begin{align}C=\frac{4\pi\varepsilon
R_1R_2}{R_2-R_1}\end{align}$</span>(<span
class="math inline"><em>R</em><sub>2</sub> &gt; <em>R</em><sub>1</sub></span>)</li>
<li>圆筒形电容器(两同轴圆柱面)：<span
class="math inline">$\begin{align}C=\frac{2\pi\varepsilon
l}{\ln{\frac{R_2}{R_1}}}\end{align}$</span>(<span
class="math inline"><em>R</em><sub>2</sub> &gt; <em>R</em><sub>1</sub></span>)</li>
</ul></li>
<li>电容并联：<span
class="math inline"><em>C</em> = ∑<em>C</em><sub><em>i</em></sub></span>，串联：<span
class="math inline"><em>C</em><sup>−1</sup> = ∑<em>C</em><sub><em>i</em></sub><sup>−1</sup></span></li>
<li>电容率：通常指两极板间介质的相对介电常量</li>
</ul></li>
<li><p>电场能量：</p>
<ul>
<li>电场能量的性质：
<ul>
<li>只要该点存在电场，就有电场能量</li>
<li>称某电场的能量为范围内所有点电场能量的总和</li>
</ul></li>
<li>电容的能量：<span
class="math inline">$\begin{align}W_e=\frac{CU^2}{2}\end{align}$</span></li>
<li>能量密度(一般电场某点的能量)：<span
class="math inline">$\begin{align}w_e=\frac{\varepsilon
E^2}{2}\end{align}$</span></li>
<li>一般电场存储的能量：<span
class="math inline">$\begin{align}W_e=\int_Vw_e\mathrm
dV\end{align}$</span></li>
</ul></li>
</ul>
<h2 id="疑问知识点">疑问知识点</h2>
<h3 id="平行板电容器补充">平行板电容器补充</h3>
<p>易知平行板电容器的电容为<span
class="math inline">$\begin{align}C=\frac{\varepsilon
S}{d}\end{align}$</span></p>
<ul>
<li><p>一：往平行板电容器中平行于两板插入电介质和垂直于两板插入电介质的区别</p>
<p>答：前者为两电容器串联，后者为两电容器并联</p></li>
<li><p>二：插入介质后，平行板电容器间的场强在有/无电源时的区别</p>
<p>答：无电源时，电势会改变，是因为插入介质后场强改变了，<span
class="math inline">$\begin{align}E=\frac{E_0}{\varepsilon_r}\end{align}$</span></p>
<p>有电源时，电势不改变，则场强不改变(无论中间介质如何改变)，原理是由电源输送的自由电荷场强和插入介质中产生的极化电荷场强抵消</p></li>
<li><p>三：插入介质后，平行板电容器的能量在无电源时的表现</p>
<p>答：能量会减少，根据<span
class="math inline">$\begin{align}W_e=\frac{Q^2}{2C}\end{align}$</span>可知</p>
<p>原理是极化电荷削弱了电场，使其能量减少，但电容会增加</p></li>
</ul>
<h3 id="电极化强度和电位移矢量的含义">电极化强度和电位移矢量的含义</h3>
<ul>
<li>电极化强度是单位体积内的电偶极矩的矢量和，且<span
class="math inline"><em>P</em><sub><em>n</em></sub> = <em>σ</em><sub><em>极</em><em>化</em><em>电</em><em>荷</em></sub></span>；因为未极化电介质的电偶极矩矢量和为零，极化后不为零，故以此作为区分</li>
<li>电位移矢量是辅助矢量，是经数学简化后的叠加场</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Physics</category>
      </categories>
  </entry>
  <entry>
    <title>大学物理: 经典力学</title>
    <url>/blogs/2024/10/03/physics-classic-force/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="经典力学">经典力学</h2>
<h3 id="质点运动的数学解释">质点运动的数学解释</h3>
<ul>
<li>位置矢量：质点在指定参考系下的坐标向量，用<span
class="math inline"><em>r⃗</em></span>表示，简称<strong>位矢</strong></li>
<li>运动方程：位置矢量关于时间的方程，用<span
class="math inline"><em>r⃗</em> = <em>r⃗</em>(<em>t</em>)</span>表示，也称运动函数</li>
<li>速度矢量：位矢对时间的<strong>一阶导数</strong>，用<span
class="math inline"><em>v̄</em>(<em>t</em>)</span>表示，其方向与位移方向一致</li>
<li>加速度矢量：速度对时间的<strong>一阶导数</strong>，用<span
class="math inline"><em>ā</em>(<em>t</em>)</span>表示，其方向<strong>总是指向轨道曲线的内侧</strong></li>
<li>若已知质点的加速度和初始状态，求运动方程相当于解微分方程的初值问题</li>
<li>加速度可分解为<span
class="math inline"><strong>a</strong> = <em>a</em><sub><em>t</em></sub><strong>τ</strong> + <em>a</em><sub><em>n</em></sub><strong>n</strong></span>，其中：
<ul>
<li><span
class="math inline"><em>a</em><sub><em>t</em></sub></span>为切向加速度，<span
class="math inline"><em>a</em><sub><em>n</em></sub></span>为法向加速度(向心加速度)，<span
class="math inline"><strong>τ</strong></span>为速度的单位切向量，<span
class="math inline"><strong>n</strong></span>为速度的单位法向量</li>
<li><span class="math inline">$\begin{align}a_t=\frac{\mathrm
dv}{\mathrm dt}、a_n=\frac{v^2}{R}\end{align}$</span>，其中<span
class="math inline"><em>v</em></span>为速度的大小</li>
</ul></li>
</ul>
<h3 id="牛顿定律">牛顿定律</h3>
<ul>
<li>牛顿定律只对惯性系生效</li>
<li>牛顿第一定律(惯性定律)：任何不受力物体的物体保持静止或匀速直线运动状态
<ul>
<li>力是物体运动状态改变的原因</li>
<li>物体具有惯性，即保持其静止或匀速直线运动状态不变的属性</li>
</ul></li>
<li>牛顿第二定律：
<ul>
<li>动量<span
class="math inline"><strong>p</strong> = <em>m</em><strong>v</strong></span></li>
<li>力<span
class="math inline">$\begin{align}\boldsymbol{F}=\frac{\mathrm
d\boldsymbol{p}}{\mathrm dt}\end{align}$</span>，当质量为关于<span
class="math inline"><em>t</em></span>的常数时，<span
class="math inline"><strong>F</strong> = <em>m</em><strong>a</strong></span></li>
<li>力恒定时，质量越大、加速度越小、物体惯性越大</li>
</ul></li>
<li>牛顿第三定律：相互作用力总是大小相等、方向相反、作用在一条直线上</li>
</ul>
<h3 id="参考系">参考系</h3>
<ul>
<li>参考系：可以是任意物体，以该物体作为参考系原点，即称其他物体是相对于该参考系的</li>
<li>惯性系：在惯性系中，只要物体不受力，它就满足牛一；即惯性系本身不具有加速度</li>
<li>绝对时空观：
<ul>
<li>在不同参考系下(分别记为<span
class="math inline"><em>S</em>、<em>S</em>′</span>，原点为<span
class="math inline"><em>O</em>、<em>O</em>′</span>，质点为<span
class="math inline"><em>P</em></span>)，满足<span
class="math inline"><strong>O</strong><strong>′</strong><strong>P</strong> = <strong>r</strong>′(<em>t</em>)、<em>t</em> = <em>t</em>′</span></li>
<li>伽利略变换：设<span
class="math inline">$\begin{align}\boldsymbol{u}=\frac{\mathrm
d\boldsymbol{OO'}(t)}{\mathrm
dt}\end{align}$</span>，则不同参考系下同一质点：
<ul>
<li>位矢关系：<span
class="math inline"><strong>r</strong>(<em>t</em>) = <strong>r</strong>′(<em>t</em>) + <strong>O</strong><strong>O</strong><strong>′</strong>(<em>t</em>)</span>，即<span
class="math inline"><strong>O</strong><strong>P</strong> = <strong>O</strong><strong>O</strong><strong>′</strong> + <strong>O</strong><strong>′</strong><strong>P</strong></span></li>
<li>速度关系：<span
class="math inline"><strong>v</strong> = <strong>v</strong>′ + <strong>u</strong></span></li>
<li>加速度关系：<span
class="math inline">$\begin{align}\boldsymbol{a}=\boldsymbol{a}'+\frac{\mathrm
d\boldsymbol{u}}{\mathrm dt}\end{align}$</span></li>
</ul></li>
<li>伽利略坐标变换：若两<strong>惯性系</strong>在相对做<strong>匀速直线运动</strong>，则<span
class="math inline"><strong>u</strong> = <strong>C</strong></span>，有：<span
class="math inline">$\begin{cases}x=x'+ut\\y=y'\\z=z'\\t=t'\end{cases}$</span></li>
</ul></li>
<li>惯性力存在于非惯性系中，且<span
class="math inline"><strong>F</strong><sub><em>i</em></sub> =  − <em>m</em><strong>a</strong></span>，其中<span
class="math inline"><strong>a</strong></span>为非惯性系的加速度</li>
</ul>
<h3 id="关于动量">关于动量</h3>
<ul>
<li>动量是牛顿第二定律的另一种形式</li>
<li>动量定理：力是动量对时间的导数，冲量是力对时间的积分
<ul>
<li>冲量<span
class="math inline">$\begin{align}\boldsymbol{I}=\int_{t_1}^{t_2}\boldsymbol{F}(t)\mathrm
dt=\int_{t_1}^{t_2}\mathrm
d\boldsymbol{p}=\boldsymbol{p}_2-\boldsymbol{p}_1\end{align}$</span></li>
</ul></li>
<li>动量守恒定律：若某质点系所受合外力为零，则<span
class="math inline">$\sum_\limits
i\boldsymbol{p}_i=\boldsymbol{C}$</span>，例如质点系<strong>静止或做匀速直线运动</strong></li>
<li>质心运动定理：
<ul>
<li>质心坐标<span
class="math inline">$\begin{align}\boldsymbol{r}_c=\frac{\int_\Omega\rho\
\boldsymbol{r}\mathrm d\Omega}{m}\end{align}$</span>，其中<span
class="math inline"><em>c</em></span>为质心这个点，<span
class="math inline"><strong>r</strong></span>为质点系中任意一点的位矢</li>
<li>若该质点系满足动量守恒定律，则<span
class="math inline">$\sum_\limits
i\boldsymbol{F}_i=m\boldsymbol{a}_c$</span></li>
</ul></li>
</ul>
<h3 id="关于角动量">关于角动量</h3>
<ul>
<li>设质点<span class="math inline"><em>P</em></span>相对于<span
class="math inline"><em>O</em></span>的位矢为<span
class="math inline"><strong>r</strong></span>，且所受外力为<span
class="math inline"><strong>F</strong></span>，则定义<span
class="math inline"><strong>F</strong></span>对<span
class="math inline"><em>O</em></span>的力矩为<span
class="math inline"><strong>M</strong> = <strong>r</strong> <strong>×</strong> <strong>F</strong></span></li>
<li>力矩由力的大小、方向、作用点以及某固定点生成</li>
<li>角动量(动量矩)：与力矩的定义方式类似，<span
class="math inline"><strong>L</strong> = <strong>r</strong> <strong>×</strong> <strong>p</strong></span>，它包含动量对某固定点的角度信息</li>
<li>角动量定理：力矩是角动量对时间的导数</li>
<li>角动量守恒定律：若某质点系所受<strong>合外力矩</strong>为零，则<span
class="math inline">$\sum_\limits
i\boldsymbol{L}_i=\boldsymbol{C}$</span>，例如质点系<strong>做直线运动</strong>或<strong>做匀速圆周运动</strong></li>
</ul>
<h3 id="关于功和功率">关于功和功率</h3>
<ul>
<li>力做功<span
class="math inline">$\begin{align}A=\int_L\boldsymbol{F}\mathrm
d\boldsymbol{r}=\int_L\boldsymbol{F·v}\ \mathrm
dt\end{align}$</span>，恒力做功<span
class="math inline"><em>A</em> = <strong>F</strong> <strong>·</strong> <strong>Δ</strong><strong>r</strong></span></li>
<li>根据格林公式及斯托克斯公式，将做功与路径无关，即<span
class="math inline"><strong>F</strong></span>的雅可比行列式为<span
class="math inline">0</span>的力称为保守力</li>
<li>功率<span class="math inline">$\begin{align}P=\frac{\mathrm
dA}{\mathrm dt}=\boldsymbol{F·v}\end{align}$</span></li>
<li>动能定理：<span
class="math inline">$\begin{align}E_k=\frac12mv^2\end{align}$</span>，<span
class="math inline"><em>A</em> = <em>Δ</em><em>E</em><sub><em>k</em></sub></span></li>
<li><strong>保守内力</strong>做功<span
class="math inline"><em>A</em> =  − <em>Δ</em><em>E</em><sub><em>p</em></sub></span></li>
<li>机械能守恒定律：如果系统只有保守内力做功，则<span
class="math inline"><em>E</em><sub><em>M</em></sub> = <em>E</em><sub><em>k</em></sub> + <em>E</em><sub><em>p</em></sub> = <em>C</em></span></li>
</ul>
<h3 id="碰撞问题">碰撞问题</h3>
<ul>
<li>完全非弹性碰撞：动量守恒，但有非保守内力做功，只满足<span
class="math inline"><em>m</em><sub><em>合</em></sub><strong>v</strong><sub><em>合</em></sub> = <em>m</em><sub>1</sub><strong>v</strong><sub>1</sub> + <em>m</em><sub>2</sub><strong>v</strong><sub>2</sub></span></li>
<li>完全弹性碰撞：动量守恒且机械能守恒
<ul>
<li>矢量式：<span
class="math inline"><em>m</em><sub>1</sub><strong>v</strong><sub>10</sub> + <em>m</em><sub>2</sub><strong>v</strong><sub>20</sub> = <em>m</em><sub>1</sub><strong>v</strong><sub>1</sub> + <em>m</em><sub>2</sub><strong>v</strong><sub>2</sub></span></li>
<li><span
class="math inline">$\begin{align}\frac{m_1v_{10}^2}2+\frac{m_2v_{20}^2}2=\frac{m_1v_{1}^2}2+\frac{m_2v_{2}^2}2\end{align}$</span></li>
<li>若<span
class="math inline"><em>m</em><sub>2</sub></span>初速度为<span
class="math inline">0</span>，则<span
class="math inline">$\begin{align}\boldsymbol{v}_1\boldsymbol{·v}_2=\frac{m_1-m_2}{2m_1}v_2^2\end{align}$</span>，即<span
class="math inline">$\begin{align}\cos&lt;\boldsymbol{v}_1,\boldsymbol{v}_2&gt;=\frac{m_1-m_2}{2m_1}\frac{v_2}{v_1}\end{align}$</span></li>
<li>若为对心碰撞，则可总结出更一般的速度式，因为此时<span
class="math inline">cos  &lt; <strong>v</strong><sub>1</sub>, <strong>v</strong><sub>2</sub> &gt;  =  − 1</span>，动量守恒式变成标量式：<span
class="math inline">$\begin{align}\begin{cases}v_1=\frac{\large(m_1-m_2)v_{10}+2m_2
v_{20}}{\large
m_1+m_2}\\v_2=\frac{\large2m_1v_{10}+(m_2-m_1)v_{20}}{\large
m_1+m_2}\end{cases}\end{align}$</span>(借助平方差公式推导)</li>
</ul></li>
</ul>
<h3 id="刚体力学">刚体力学</h3>
<ul>
<li><p>角速度大小：<span
class="math inline">$\begin{align}\omega=\frac{\mathrm d\theta}{\mathrm
dt}=\frac1r\frac{\mathrm dl}{\mathrm dt}=\frac
vr\end{align}$</span></p></li>
<li><p>角速度方向：<span
class="math inline"><strong>v</strong> = <strong>ω</strong> <strong>×</strong> <strong>r</strong></span></p></li>
<li><p>角加速度和加速度的关系：</p>
<ul>
<li><span class="math inline">$\begin{align}a_t=\frac{\mathrm
dv}{\mathrm dt}=r\frac{\mathrm d\omega}{\mathrm
dt}=r\alpha\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}a_n=\frac{v^2}{r}=r\omega^2\end{align}$</span></li>
<li><span class="math inline">$\begin{align}\boldsymbol{a}=\frac{\mathrm
d(\boldsymbol{\omega\times r})}{\mathrm dt}=\boldsymbol{\alpha\times
r}+\boldsymbol{\omega\times v}\end{align}$</span></li>
</ul></li>
<li><p>刚体绕定轴转动时，轴向动量和位矢垂直，故轴向角动量的大小<span
class="math inline"><em>L</em><sub><em>i</em></sub> = |<strong>r</strong> <strong>×</strong> <strong>p</strong><sub><em>i</em></sub>| = <em>m</em><em>r</em><sub><em>i</em></sub><em>v</em><sub><em>i</em></sub> = <em>m</em><em>r</em><sub><em>i</em></sub><sup>2</sup><em>ω</em><sub><em>i</em></sub></span></p>
<p>定义刚体绕某轴旋转的<strong>转动惯量</strong>为<span
class="math inline">$\begin{align}J=mr_i^2=\int_\Omega \rho\
r_i^2\mathrm d\Omega\end{align}$</span>，则轴向角动量的大小为<span
class="math inline"><em>L</em><sub><em>i</em></sub> = <em>J</em><em>ω</em></span>，轴向力矩大小为<span
class="math inline"><em>M</em><sub><em>i</em></sub> = <em>J</em><em>α</em></span></p></li>
<li><p>刚体定轴转动定律：刚体绕定轴的<strong>角加速度</strong>和<strong>轴向力矩</strong>成正比，类比加速度和力的关系<span
class="math inline"><em>F</em> = <em>m</em><em>a</em></span></p></li>
<li><p>转动问题中，<span
class="math inline">$\begin{align}A=\int_{\theta_1}^{\theta_2}M_i\mathrm
d\theta\end{align}$</span>，即外力做的功等于轴向力矩和角位移的积</p></li>
<li><p>转动动能：<span
class="math inline">$\begin{align}E_k=\frac12J\omega^2\end{align}$</span></p></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Physics</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构: 并查集</title>
    <url>/blogs/2024/10/02/algo-ufs/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="并查集">并查集</h1>
<h2 id="概述">概述</h2>
<p>并查集用于解决<strong>不相交集合</strong>的问题，高效地提供两种方法：</p>
<ul>
<li><strong>合并</strong>：用于将两个不相交集合合并</li>
<li><strong>查询</strong>：用于查询一个元素在哪个集合里</li>
</ul>
<p>基于上述操作，并查集这种数据结构可用于解决许多问题，例如：</p>
<ul>
<li>查询两个元素是否在同一集合，也即用于判断两个元素<strong>是否相通</strong></li>
<li>合并两个不相交元素所在集合</li>
<li>找出集合的总个数</li>
<li>找出一个集合的元素总个数</li>
</ul>
<p>但这种结构是有局限的，不能通过它来解决诸如以下的问题：</p>
<ul>
<li>分离集合问题，并查集中的集合只并不分，也不能删除元素</li>
<li>不会保存节点间的关系，只会保存集合与节点的关系；这种问题应依靠图来解决</li>
</ul>
<h2 id="结构与简单实现">结构与简单实现</h2>
<h3 id="具体结构">具体结构</h3>
<p>并查集是一种<strong>树状结构</strong>，对于一个集合，只选出一个元素作为代表元素，用它来标识一个集合；代表元素指向它自己，至于集合内的其它元素，或直接或间接地，最后都将指向这个代表元素</p>
<p>在没有任何优化的并查集中，并和查是这样实现的：</p>
<ul>
<li>查：递归搜索节点的父节点，直到找到祖宗节点(指向自己的节点)，则它属于这个祖宗节点所代表的集合</li>
<li>并：寻找两元素的祖宗节点，让其中之一指向另外的节点即可</li>
</ul>
<h3 id="初始化">初始化</h3>
<p>并查集最浅显的实现方法是普通数组，下标代表元素编号，数组存储的是元素的父节点下标，初始化时，让所有元素指向自己：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fa[n] = &#123;<span class="number">0</span>,<span class="number">1</span>,...,n<span class="number">-1</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="find"><code>find()</code></h3>
<p>查询操作最简单的方法是递归(无优化)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123; <span class="comment">// 找到祖宗节点,递归结束.</span></span><br><span class="line">    <span class="keyword">return</span> number == fa[number] ? number : <span class="built_in">find</span>(fa[number]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="union"><code>Union()</code></h3>
<p>合并操作需要借助查询(无优化)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> num_1, <span class="type">int</span> num_2)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(num_1)] = <span class="built_in">find</span>(num_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法优化">方法优化</h2>
<h3 id="路径压缩">路径压缩</h3>
<p>对查询来说，由于每次合并后都将使树深度加一，故递归层数加一，则可以采取<strong>路径压缩</strong>方法，即沿途让每个元素直接指向父节点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[number] = number == fa[number] ? number : <span class="built_in">find</span>(fa[number]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法有极大可能缩短搜索路径，但第一次搜索依然有可能递归多层；对于最后一个节点来说，只要一直不对它进行查询，它所在路径深度仍然较大</p>
<p>需要注意的是，这种优化会覆盖节点与父节点间的信息，如果实际问题中需要维护中间节点，就不应该采用这种优化方法</p>
<h3 id="按秩合并">按秩合并</h3>
<p>对合并来说，每次合并应该让深度小的集合指向深度大的集合，这能够使新集合的秩(即深度)不增大(否则会加一)，这种优化需要额外维护一个<code>rank</code>数组，该数组下标表示元素编号，只存储祖宗节点所在集合的深度(未进行路径压缩)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rank[n] &#123;<span class="number">1</span>,<span class="number">1</span>,...,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> num_1, <span class="type">int</span> num_2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> head_1 = <span class="built_in">find</span>(num_1), head_2 = <span class="built_in">find</span>(num_2);</span><br><span class="line">    <span class="keyword">if</span> (rank[head_1] &lt; rank[head_2]) &#123;</span><br><span class="line">        fa[head_1] = head_2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank[head_1] == rank[head_2]) &#123;</span><br><span class="line">  ++rank[head_1];  <span class="comment">// 相等时树深仍加1.</span></span><br><span class="line">    &#125;</span><br><span class="line">    fa[head_2] = head_1; <span class="comment">// 1树更深或深度相同,都让2树指向1树.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果希望同时进行路径压缩和按秩合并优化，那么可能需要维护全局的<code>rank</code>防止树深的随意变化</p>
<p>或者更改秩的定义，在上述定义中，秩是树的绝对深度，如果要进行路径压缩：</p>
<ul>
<li>定义秩为树深的上界</li>
<li>定义秩为元素个数，因为元素多的树倾向于更深，同时还能存储元素个数</li>
</ul>
<p>所有这些定义方法都只是尝试不增加树深，不一定合并出更浅的树</p>
<h3 id="管理非整型数据">管理非整型数据</h3>
<p>上述并查集的节点数据都是基础类型的，如果需要管理其它类型，可以尝试让数组存储该类对象指针的结构体，在查询时，不采取递归而是循环的方式，返回头结点指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Struct</span> &#123;</span><br><span class="line">    Class* me;</span><br><span class="line">    <span class="type">int</span> father;</span><br><span class="line">&#125;;</span><br><span class="line">Struct fa[n] &#123;&#123;&amp;Obj0,<span class="number">0</span>&#125;,&#123;&amp;Objn_1,n<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> Class* <span class="title">find</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index != fa[index].father) &#123; <span class="comment">// 较难直观地进行路径压缩,除非允许再循环一次.</span></span><br><span class="line">        index = fa[index].father;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[index].me;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的并查集编号都为整型，实际问题中很难知道一个对象的具体编号，这时可通过指针查询：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span> &#123; <span class="comment">// 需要该类含有指向父节点的指针.</span></span><br><span class="line">    Class* fa;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Class* <span class="title">find</span><span class="params">(<span class="type">const</span> Class* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;fa = p == p-&gt;father ? p : <span class="built_in">find</span>(p-&gt;father);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际情况中，通过整型数组与哈希表映射(键为<code>value_type</code>，值为整型)相结合来实现更为有效</p>
<h2 id="代码"><a href="./1附_Union_Find_Set.h">代码</a></h2>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>具体数学: 和式</title>
    <url>/blogs/2024/10/02/concreteMath-summation/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="和式">和式</h2>
<h3 id="表达方式">表达方式</h3>
<ul>
<li>一般形式：<span
class="math inline">$\begin{align}\sum_{\rho(k)}a_k\end{align}$</span>，用于简略描述和式，方便推导和理解</li>
<li>定界形式：<span
class="math inline">$\begin{align}\sum_{k=lower}^{upper}a_k\end{align}$</span>，用于表示最终结果</li>
<li><span class="math inline">$\rm Iverson$</span>约定：<span
class="math inline">$\begin{align}\sum_{k}a_{k}·[\rho(k)]\end{align}$</span>，即遍历<span
class="math inline"><em>k</em></span>，若满足命题<span
class="math inline"><em>ρ</em>(<em>k</em>)</span>则加和，否则不加</li>
</ul>
<h3 id="求解和式">求解和式</h3>
<ul>
<li><p>清单法：因和式能很简单地写成递推式<span
class="math inline">$\begin{cases}S_0=0\\S_n=S_{n-1}+a_n\end{cases}$</span>，因此可使用清单法</p></li>
<li><p>求和因子法：适用于求解形如<span
class="math inline">$\begin{cases}S_0\\a_nS_n=b_nS_{n-1}+c_n\end{cases}$</span>的递推式</p>
<ul>
<li><p><span
class="math inline">$\begin{align}&amp;两边乘s_n,得s_na_nS_n=s_nb_nS_{n-1}+s_nc_n\\&amp;其中s_n满足s_nb_n=s_{n-1}a_{n-1}&amp;(1)\\&amp;因此T_n=s_na_nS_n=T_{n-1}+s_nc_n\Rightarrow
T_n=s_0a_0S_0+\sum_{k=1}^ns_kc_k\\&amp;其中s_0a_0只是为了满足(1)式假想的,故S_n=\frac1{s_na_n}\left(s_1b_1S_0+\sum_{k=1}^ns_kc_k\right)\\&amp;因为求和式中只用到s(1\sim
n),现根据(1)式求出s_n,不难得到s_n=\frac{a_{n-1}\cdots a_1}{b_n\cdots
b_2}s_1\\&amp;为方便求解,一般令s_1=1\\&amp;观察式子可知a_n和b_n不允许有零项\end{align}$</span></p></li>
<li><p>当<span
class="math inline"><em>s</em><sub><em>n</em></sub><em>c</em><sub><em>n</em></sub></span>是较好求的式子时，可用求和因子法</p>
<p>事实上求和因子法大多数情况下无法求给定数列的和，只能解上述<span
class="math inline"><em>a</em><sub><em>n</em></sub></span>和<span
class="math inline"><em>b</em><sub><em>n</em></sub></span>满足特定性质的递推式</p>
<p>因为给定数列<span
class="math inline"><em>a</em><sub><em>n</em></sub></span>，写成和式的递推式<span
class="math inline"><em>S</em><sub><em>n</em></sub> = <em>S</em><sub><em>n</em> − 1</sub> + <em>a</em><sub><em>n</em></sub></span>，会发现<span
class="math inline"><em>s</em><sub><em>n</em></sub> = <em>s</em><sub>1</sub></span>，最终仍无法求<span
class="math inline"><em>a</em><sub><em>n</em></sub></span>的和</p></li>
</ul></li>
<li><p>扰动法：取出首项或尾项，构造出一个等式，并使两部分的和式都和<span
class="math inline"><em>S</em><sub><em>n</em></sub></span>套上关系即可</p>
<ul>
<li><p>例如给定数列<span
class="math inline"><em>a</em><sub><em>n</em></sub></span>，有<span
class="math inline">$\begin{align}S_{n+1}=S_n+a_n=a_1+\sum_{k=2}^{n+1}a_k\end{align}$</span></p>
<p>扰动法的目的是将<span
class="math inline">$\begin{align}\sum_{k=2}^{n+1}a_k=\sum_{k=1}^na_{k+1}\end{align}$</span>分解为<span
class="math inline"><em>S</em><sub><em>n</em></sub></span>和一个相对好求的和式</p></li>
<li><p>例求<span
class="math inline">$\begin{align}\sum_{k=0}^nkx^k\end{align}$</span>：</p>
<p><span
class="math inline">$\begin{align}&amp;解:S_{n+1}=S_n+(n+1)x^{n+1}=0+\sum_{k=1}^{n+1}kx^k\\&amp;=xS_n+\sum_{k=0}^nx^{k+1}=xS_n+\frac{x^{n+1}-x}{x-1}\\&amp;\Rightarrow
S_n=\frac{(n+1)x^{n+1}(x-1)-x-x^{n+1}}{(x-1)^2}\end{align}$</span></p></li>
</ul></li>
<li><p>例如快速排序的平均比较次数(具体数学上和数据结构里不同，这里以具体数学为例)：</p>
<p><span
class="math inline">$C_n=\begin{cases}0,&amp;n=0\\n+1+\frac2n\sum_\limits{i=0}^{n-1}C_i,&amp;n&gt;0\end{cases}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;即nC_n=2\sum_{i=0}^{n-1}C_i+n^2+n\\&amp;(n-1)C_{n-1}=2\sum_{i=0}^{n-2}C_i+(n-1)^2+n-1\\&amp;得nC_n-(n-1)C_{n-1}=2C_{n-1}+2n\\&amp;即nC_n=(n+1)C_{n-1}+2n\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;求和因子为s_n=\frac{a_{n-1}\cdots
a_1}{b_n\cdots
b_2}s_1=\frac{(n-1)!}{(n+1)\cdots3}s_1=\frac{2}{(n+1)n},(令s_1=1)\\&amp;s_nnC_n=s_n(n+1)C_{n-1}+2ns_n=s_{n-1}(n-1)C_{n-1}+\frac4{n+1}\\&amp;因此s_nnC_n=s_1b_1C_0+4\sum_{i=1}^{n}\frac1{i+1}=4(H_{n+1}-1)\\&amp;C_n=2(n+1)(H_{n+1}-1)=2(n+1)(H_n+\frac1{n+1}-1)=2(n+1)H_n-2n\end{align}$</span></p></li>
</ul>
<h3 id="多重和式">多重和式</h3>
<ul>
<li><span
class="math inline">[1≤<em>i</em>&lt;<em>j</em>≤<em>n</em>] + [1≤<em>k</em>&lt;<em>j</em>≤<em>n</em>] = [1≤<em>j</em>,<em>k</em>≤<em>n</em>] − [1≤<em>i</em>=<em>j</em>≤<em>n</em>]</span></li>
<li>切比雪夫单调不等式：若两序列是单调的：<span
class="math inline">$\begin{align}\begin{cases}单调性相同,&amp;\left(\sum_\limits{k=1}^na_k\right)\left(\sum_\limits{k=1}^nb_k\right)\le
n\sum_\limits{k=1}^n
a_kb_k\\单调性不同,&amp;上式为大于等于\end{cases}\end{align}$</span></li>
<li>应用于<span
class="math inline"><em>n</em><sup><em>k</em></sup></span>前<span
class="math inline"><em>n</em></span>项和公式：
<ul>
<li>摄动求和：应对<span
class="math inline"><em>n</em><sup><em>k</em> + 1</sup></span>摄动</li>
<li>清单求和：令<span
class="math inline"><em>R</em><sub><em>n</em></sub> = 1, <em>n</em>, <em>n</em><sup>2</sup>, ⋯, <em>n</em><sup><em>k</em> + 1</sup></span></li>
<li>积分替换：求积分和求和的误差，并通过其递推式求解误差</li>
</ul></li>
<li><strong>下阶幂定义</strong>(<span
class="math inline"><em>x</em></span>为实数，<span
class="math inline"><em>m</em></span>为整数)：<span
class="math inline">$x^{\underline
m}=\begin{cases}x(x-1)\cdots(x-m+1),&amp;m&gt;0\\1,&amp;m=0\\\frac1{(x+1)\cdots(x-m)},&amp;m&lt;0\end{cases}$</span></li>
<li><strong>下阶幂的差分</strong>：<span
class="math inline">$\Delta(x^{\underline
m})=(x+1)^{\underline{m}}-x^{\underline
m}=mx^{\underline{m-1}}$</span></li>
<li>定和分：<span class="math inline">$\begin{align}\sum_a^bg(x)\delta
x=\sum_{k=a}^{b-1}g(k)=f(x)\Bigg|_a^b,其中g(x)=\Delta
f(x)\end{align}$</span></li>
<li>下阶幂的定和分可配合第二类斯特林数的原始定义，求解<span
class="math inline"><em>x</em><sup><em>k</em></sup></span>的和(<span
class="math inline"><em>k</em></span>为常数)</li>
<li>指数函数的差分：<span
class="math inline"><em>Δ</em>(<em>c</em><sup><em>x</em></sup>) = <em>c</em><sup><em>x</em> + 1</sup> − <em>c</em><sup><em>x</em></sup> = (<em>c</em>−1)<em>c</em><sup><em>x</em></sup></span>，因此<strong><span
class="math inline">2<sup><em>x</em></sup></span>的差分等于其自身</strong></li>
<li>和分求指数函数和：<span
class="math inline">$\begin{align}\sum_{k=0}^nc^k=\sum_{0}^{n+1}c^x\delta
x=\frac{c^{n+1}-1}{c-1}\end{align}$</span></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Concrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>summation</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学: 近世代数（群、环、域）</title>
    <url>/blogs/2024/09/27/discreteMath-abstract-algebra/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="近世代数">近世代数</h1>
<h2 id="群">群</h2>
<h3 id="半群定义">半群定义</h3>
<ul>
<li>群和半群是特殊的代数，都只含一个非空集合和一个二元运算，因此元素运算时可省略运算符号
给定代数<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>：</li>
<li>半群：若<span
class="math inline">∘</span>可结合，称该代数为半群</li>
<li>可交换半群：在半群基础上，<span
class="math inline">∘</span>可交换</li>
<li>独异点/含幺半群/拟半群：在半群基础上，<span
class="math inline">∘</span>有幺元</li>
<li>子半群：半群的所有子代数都是半群，称为前者的子半群</li>
<li>循环半群：给定半群<span
class="math inline"><em>M</em>, ∘</span>，元素<span
class="math inline"><em>a</em> ∈ <em>M</em></span>，由<span
class="math inline"><em>a</em></span>自身进行<span
class="math inline"><em>n</em></span>次运算得到的集合为<span
class="math inline"><em>S</em> : {<em>a</em><sup><em>k</em></sup>|<em>k</em> ∈ <em>Z</em>}</span>，称：
<ul>
<li><span class="math inline"><em>a</em></span>生成了循环半群<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>，<span
class="math inline"><em>a</em></span>为生成元</li>
<li><span class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>为<span
class="math inline"> &lt; <em>M</em>,  ∘ &gt;</span>的循环子半群</li>
</ul></li>
<li>生成集：给定集合<span
class="math inline"><em>G</em> ⊆ <em>S</em></span>，若所有<span
class="math inline"><em>S</em></span>的元素可由<span
class="math inline"><em>G</em></span>中元素及其相互运算后得到，则称<span
class="math inline"><em>G</em></span>为生成集</li>
<li>积半群：两个半群的积代数为积半群</li>
</ul>
<h3 id="群的性质">群的性质</h3>
<ul>
<li>群：若<strong>独异点</strong>中的每个元素<strong>都有逆元</strong>，称该独异点为群</li>
<li>基本性质：
<ul>
<li>封闭性：群作为一个代数拥有的性质</li>
<li>结合律：群作为一个半群拥有的性质</li>
<li>存在单位元：群作为一个独异点拥有的性质</li>
<li>所有元素作为逆元：群拥有的性质</li>
</ul></li>
<li>幂运算规则：
<ul>
<li><span
class="math inline">$a^n=\begin{cases}e,&amp;n=0\\aa^{n-1},&amp;n&gt;0\\(a^{-1})^{-n},&amp;n&lt;0\end{cases}$</span></li>
<li><span
class="math inline">(<em>a</em><em>b</em>)<sup>−1</sup> = <em>b</em><sup>−1</sup><em>a</em><sup>−1</sup></span>，利用可约律证</li>
</ul></li>
<li>每个非零元素都是可约元，因此方程有唯一解</li>
<li>元素的阶：
<ul>
<li>使<span
class="math inline"><em>a</em><sup><em>r</em></sup> = <em>e</em></span>的最小的正整数<span
class="math inline"><em>r</em></span>，记为<span
class="math inline">|<em>a</em>| = <em>r</em></span></li>
<li>若存在<span
class="math inline"><em>a</em><sup><em>k</em></sup> = <em>e</em></span>，则必有<span
class="math inline">$k\equiv0(\rm{mod}\ r)$</span></li>
<li><span
class="math inline">|<em>a</em><sup>−1</sup>| = |<em>a</em>|</span></li>
</ul></li>
<li><span class="math inline">$\rm Abel$</span>群：即可交换群，满足<span
class="math inline">(<em>a</em><em>b</em>)<sup><em>n</em></sup> = <em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span>；证明一个群为可交换群最简单的方法为证明<span
class="math inline"><em>a</em><em>b</em><em>a</em><em>b</em> = <em>a</em><sup>2</sup><em>b</em><sup>2</sup></span></li>
</ul>
<h3 id="子群">子群</h3>
<ul>
<li>若群<span class="math inline"><em>G</em></span>的非空子集<span
class="math inline"><em>H</em></span>关于<span
class="math inline"><em>G</em></span>的运算构成群，称其为子群，根据集合关系有真子群之分，通过<span
class="math inline">≤</span>、<span
class="math inline">&lt;</span>说明其关系</li>
<li>判定方法：
<ul>
<li><span
class="math inline">∀<em>a</em>∀<em>b</em>(<em>a</em>,<em>b</em>∈<em>H</em>→<em>a</em><em>b</em>∈<em>H</em>∧<em>a</em><sup>−1</sup>∈<em>H</em>)</span>，即同时满足子代数、所有元素有逆元的性质
<ul>
<li>只需证明含幺元，<span
class="math inline"><em>a</em><em>a</em><sup>−1</sup> = <em>e</em> ∈ <em>H</em></span></li>
</ul></li>
<li><span
class="math inline">∀<em>a</em>∀<em>b</em>(<em>a</em>,<em>b</em>∈<em>H</em>→<em>a</em><em>b</em><sup>−1</sup>∈<em>H</em>)</span>
<ul>
<li><span class="math inline">$\begin{align}(a,b\in H\rightarrow
ab^{-1}\in H)\Rightarrow(a,a)\rightarrow e\in H\Rightarrow
(e,a)\rightarrow a^{-1}\Rightarrow(a,b^{-1})\rightarrow ab\in
H\end{align}$</span></li>
</ul></li>
<li><span
class="math inline"><em>H</em></span><strong>有穷</strong>，且<span
class="math inline">∀<em>a</em>∀<em>b</em>(<em>a</em>,<em>b</em>∈<em>H</em>→<em>a</em><em>b</em>∈<em>H</em>)</span>
<ul>
<li><span class="math inline">$\begin{align}有穷\Rightarrow(\exist
k)a^k=e\in H\wedge aa^{k-1}=e\in H\Rightarrow a^{-1}=a^{k-1}\in
H\end{align}$</span></li>
</ul></li>
</ul></li>
<li>生成的子群：设<span
class="math inline"><em>a</em> ∈ <em>G</em></span>，则由<span
class="math inline"><em>a</em></span>生成的群<span
class="math inline">{<em>a</em><sup><em>k</em></sup>|<em>k</em> ∈ <em>Z</em>}</span>是<span
class="math inline"><em>G</em></span>的子群，记作<span
class="math inline"> &lt; <em>a</em>&gt;</span></li>
<li>中心子群：称<span
class="math inline">{<em>a</em> ∈ <em>G</em> | ∀<em>x</em>(<em>x</em>∈<em>G</em>∧<em>a</em><em>x</em>=<em>x</em><em>a</em>)}</span>为<span
class="math inline"><em>G</em></span>的中心</li>
<li>子群的并和交：若<span
class="math inline"><em>H</em>, <em>K</em> ≤ <em>G</em></span>
<ul>
<li><span
class="math inline"><em>H</em> ∩ <em>K</em> ≤ <em>G</em></span></li>
<li><span
class="math inline"><em>H</em> ∪ <em>K</em> ⇔ (<em>H</em>⊆<em>K</em>) ∨ (<em>K</em>⊆<em>H</em>)</span></li>
</ul></li>
<li>子群格：偏序集<span
class="math inline"> &lt; {<em>H</em> | <em>H</em> ≤ <em>G</em>},  ⊆ &gt;</span>为<span
class="math inline"><em>G</em></span>的子群格</li>
<li>陪集：<span class="math inline"><em>H</em></span>为<span
class="math inline"><em>G</em></span>的子群，左陪集定义为<span
class="math inline"><em>a</em><em>H</em> = {<em>a</em> ∘ <em>h</em> | <em>h</em> ∈ <em>H</em>}</span>，其中<span
class="math inline"><em>a</em> ∈ <em>G</em></span>
<ul>
<li>陪集相当于<span class="math inline"><em>H</em></span>在<span
class="math inline"><em>G</em></span>中的扩充，陪集通常<strong>不一定是<span
class="math inline"><em>G</em></span>的子群</strong></li>
<li>存在陪集<span
class="math inline"><em>e</em><em>H</em> = <em>H</em></span></li>
<li>所有陪集的阶相等，等于<span
class="math inline">|<em>H</em>|</span></li>
<li>若左陪集和右陪集总相等，称该子群为正规子群</li>
</ul></li>
<li>左陪集关系：<span
class="math inline"><em>C</em><sub><em>H</em></sub> = { &lt; <em>a</em>, <em>b</em>&gt; | <em>a</em>, <em>b</em> ∈ <em>G</em> ∧ <em>b</em><sup>−1</sup><em>a</em> ∈ <em>H</em>}</span>
<ul>
<li><p>陪集关系是一种等价关系</p></li>
<li><p><span
class="math inline"><em>a</em><em>H</em> = [<em>a</em>]<sub><em>C</em><sub><em>H</em></sub></sub></span>，即<span
class="math inline"><em>G</em></span>中任意元素在<span
class="math inline"><em>H</em></span>上的陪集等于该元素所属的等价类</p>
<ul>
<li><span class="math inline">$\begin{align}&amp;充分性:\forall h\in
H,a、ah\in aH;令b=ah,即h=ba^{-1}\Rightarrow a,b\in G\wedge ba^{-1}\in
H\\&amp;必要性:a,b\in G\wedge ba^{-1}=h\in H\Rightarrow b=ah\in
aH\end{align}$</span></li>
</ul></li>
<li><p>意义：在找出任意一个子群后，可通过陪集(扩充)来找到其余的所有陪集，而由陪集关系导出的等价类和陪集的对应关系，可得<strong><span
class="math inline"><em>H</em></span>的不相同陪集个数等于总等价类个数</strong></p></li>
<li><p>所有陪集的并集等于<span
class="math inline"><em>G</em></span>，任意两个不相等陪集完全不相交</p></li>
</ul></li>
<li>拉格朗日定理：<strong>有限群</strong>的阶一定能被任意子群<span
class="math inline"><em>H</em></span>的阶整除，且商等于等价类的个数
<ul>
<li><span
class="math inline"><em>存</em><em>在</em><em>a</em><em>是</em><em>k</em><em>阶</em><em>元</em> ⇔ <em>k</em><em>整</em><em>除</em>|<em>G</em>|</span></li>
</ul></li>
</ul>
<h3 id="循环群">循环群</h3>
<ul>
<li>若<span class="math inline"><em>G</em></span>中任意元素能由<span
class="math inline"><em>a</em> ∈ <em>G</em></span>的任意次幂表示，则称<span
class="math inline"><em>G</em> =  &lt; <em>a</em>&gt;</span>，<span
class="math inline"><em>a</em></span>为生成元</li>
<li>找出循环群<span class="math inline"><em>G</em></span>的生成元：
<ul>
<li>若<span
class="math inline"><em>G</em></span>为无限循环群，则只有<span
class="math inline"><em>a</em>, <em>a</em><sup>−1</sup></span>是生成元</li>
<li>若<span class="math inline"><em>G</em></span>为<span
class="math inline"><em>n</em></span>阶循环群，则<span
class="math inline"><em>a</em><sup><em>k</em></sup></span>是生成元，其中<span
class="math inline"><em>k</em></span>小于<span
class="math inline"><em>n</em></span>且与<span
class="math inline"><em>n</em></span>互素，因此共有<span
class="math inline"><em>φ</em>(<em>n</em>)</span>个生成元</li>
</ul></li>
<li>循环群的子群仍是循环群，无限循环群的子群除平凡群外都是无限循环群</li>
<li><span class="math inline"><em>n</em></span>阶循环群<span
class="math inline"><em>G</em> =  &lt; <em>a</em>&gt;</span>的子群：若<span
class="math inline"><em>n</em></span>有<span
class="math inline"><em>k</em></span>个正因子，则恰有<span
class="math inline"><em>k</em></span>个子群，每个正因子<span
class="math inline"><em>d</em></span>唯一对应一个<span
class="math inline"><em>d</em></span>阶子群，且<span
class="math inline">$\begin{align}a^{\large\frac{|G|}{d}}\end{align}$</span>为该子群的生成元</li>
</ul>
<h2 id="环域格">环、域、格</h2>
<h3 id="环">环</h3>
<ul>
<li>具有两个二元运算的群，通常定义为<span
class="math inline"> &lt; <em>R</em>, +, × &gt;</span>，其中：
<ul>
<li><span class="math inline"> &lt; <em>R</em>,  + &gt;</span>构成<span
class="math inline">$\rm Abel$</span>群</li>
<li><span
class="math inline"> &lt; <em>R</em>,  × &gt;</span>构成乘法半群</li>
<li><span class="math inline">×</span>对<span
class="math inline">+</span>满足分配律</li>
<li>称<strong>加法幺元</strong>为<strong>环的零元</strong></li>
</ul></li>
<li>可交换环、含幺环、无零因子环：乘法半群满足交换律、含幺元、若两数乘积为零元则必有一项为零元</li>
<li>布尔环：乘法半群满足等幂律</li>
<li>整环：同时满足可交换环、含幺环、无零因子环的性质</li>
</ul>
<h3 id="域">域</h3>
<ul>
<li>域的定义：
<ul>
<li><span
class="math inline"><em>R</em></span>是整环的基础上，乘法群中任意元素有其逆元</li>
<li><span
class="math inline"><em>R</em></span>是环的基础上，乘法群是<span
class="math inline">$\rm Able$</span>群</li>
</ul></li>
</ul>
<h3 id="格">格</h3>
<ul>
<li>偏序格：任意有两元素的子集都在整个集合中存在最小上界和最大下界的偏序集</li>
<li>代数格：代数<span
class="math inline"> &lt; <em>L</em>, ∘, × &gt;</span>，且<span
class="math inline">∘,×</span>满足交换律、结合律、等幂律、吸收律
<ul>
<li>其中，定义每个元素的<span
class="math inline">∘</span>运算为其最大下界，<span
class="math inline">×</span>运算为其最小上界</li>
</ul></li>
<li>偏序格和代数格等价</li>
<li>完全格：每个非空子集均有上下确界</li>
<li>有界格：有上下确界，完全格一定是有界格</li>
<li>分配格：两运算满足分配律</li>
<li>有补格(有余格)：对任意两元素的最小上界等于整个格的上确界，最大下界等于整个格的下确界</li>
</ul>
<p><a
href="https://www.cnblogs.com/gonghr/p/15474256.html#偏序格">离散数学（格与布尔代数）
- gonghr - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Discrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>具体数学: 递归</title>
    <url>/blogs/2024/09/21/concreteMath-recursion/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="递归问题分析">递归问题分析</h2>
<h3 id="递归函数定义">递归函数定义</h3>
<ul>
<li>递归被用于<strong>定义数学函数</strong>或<strong>归纳证明</strong></li>
<li>递归的数学模型分为<strong>基础</strong>和<strong>递归</strong>两部分</li>
<li>通过递归证明命题被称为数学归纳法，以正确的最小命题为基础，分为<strong>递归基础、递归假设、递归步骤</strong>三部分</li>
</ul>
<h3 id="汉诺塔问题">汉诺塔问题</h3>
<ul>
<li><p>问题描述：将<span
class="math inline"><em>n</em></span>个从上到下大小依次递增的盘片将<span
class="math inline"><em>A</em></span>柱借助<span
class="math inline"><em>B</em></span>柱移到<span
class="math inline"><em>C</em></span>柱，其中不允许大盘片在小盘片上，求解移动次数</p></li>
<li><p>问题分析：将<span class="math inline"><em>n</em></span>盘从<span
class="math inline"><em>A</em></span>柱移到<span
class="math inline"><em>C</em></span>柱，需先将<span
class="math inline"><em>n</em> − 1</span>盘通过<span
class="math inline"><em>C</em></span>柱移到<span
class="math inline"><em>B</em></span>柱，再将第<span
class="math inline"><em>n</em></span>盘片直接移到<span
class="math inline"><em>C</em></span>柱，然后将<span
class="math inline"><em>n</em> − 1</span>盘通过<span
class="math inline"><em>A</em></span>柱移到<span
class="math inline"><em>C</em></span>柱；若只剩一盘，则可直接移动</p></li>
<li><p>递归式：<span
class="math inline">$\begin{cases}T(1)=1\\T(n)=2T(n-1)+1\end{cases}$</span>，即移动两次<span
class="math inline"><em>n</em> − 1</span>盘，一次直接移动</p></li>
<li><p>通项式：<span
class="math inline"><em>T</em>(<em>n</em>) = 2<sup><em>n</em></sup> − 1</span>，可证明其是最优解</p></li>
<li><p>代码求解移动过程：</p>
<p>```c++ void RecursionSolution(int n, int from, int use, int to) { if
(n == 1) { // from -&gt; to directly cout &lt;&lt; from &lt;&lt; “-&gt;”
&lt;&lt; to &lt;&lt; endl; return; } RecursionSolution(n - 1, from, to,
use); cout &lt;&lt; from &lt;&lt; “-&gt;” &lt;&lt; to &lt;&lt; endl;
RecursionSolution(n - 1, use, from, to); } int HanoiTower(int n) {
RecursionSolution(n, 0, 1, 2); // 输出移动过程 return (1 &lt;&lt; n) -
1; // 返回移动次数 }</p></li>
</ul>
<h3 id="直线划分平面问题">直线划分平面问题</h3>
<ul>
<li><p>问题描述：用<span
class="math inline"><em>n</em></span>条直线划分一个平面，求出能划出的最多的部分数</p></li>
<li><p>问题分析：<span
class="math inline"><em>S</em>(0) = 1, <em>S</em>(1) = 2</span>；<span
class="math inline"><em>n</em> ≥ 2</span>时，每次使其和剩下<span
class="math inline"><em>n</em> − 1</span>条直线都有交点，则划分部分最多</p></li>
<li><p>递归式：<span
class="math inline">$\begin{cases}S(0)=1\\S(n)=S(n-1)+n\end{cases}$</span></p></li>
<li><p>通项式：<span
class="math inline">$\begin{align}S(n)=\frac{n(n+1)}2+1\end{align}$</span></p></li>
<li><p>证明其必定能做到上述操作：将<span
class="math inline"><em>n</em> − 1</span>次划分后的交点用圆围起来，用直径<span
class="math inline"><em>l</em></span>划分该圆，使交点平均地分布在圆的两部分(若交点数为奇数，则让<span
class="math inline"><em>l</em></span>穿过一点后再平均分配)，则在<span
class="math inline"><em>l</em></span>划分的两个部分中，这些直线在圆外是<strong>不相交</strong>(交点在圆内)且<strong>不为同一直线</strong>(同一直线被<span
class="math inline"><em>l</em></span>划分在其两边)，平移<span
class="math inline"><em>l</em></span>至圆外，则必定能交到<span
class="math inline"><em>n</em> − 1</span>个交点</p></li>
<li><p>推广：平面角划分平面问题</p>
<p>分析：使角始终处于上次划分后区域最大的部分，延长角的两条射线，则转换为<span
class="math inline">2<em>n</em></span>条直线划分平面问题</p>
<p>递归式：<span
class="math inline">𝒮(<em>n</em>) = <em>S</em>(2<em>n</em>) − 2<em>n</em></span></p>
<p>通项式：<span
class="math inline">𝒮(<em>n</em>) = 2<em>n</em><sup>2</sup> − <em>n</em> + 1</span></p></li>
<li><p>圆划分平面问题：</p>
<p>每增加一个圆，新增圆与其余所有圆都相交且有两个交点，新增部分数目与新增交点数目相同，即：</p>
<p><span
class="math inline">$T_n=\begin{cases}2,&amp;n=1\\T_{n-1}+2(n-1),&amp;n&gt;1\end{cases}$</span>
因此<span
class="math inline">$\begin{align}T_n=T_1+2\sum_{i=1}^{n-1}i=2+n(n-1)\end{align}$</span></p></li>
</ul>
<h3 id="约瑟夫问题">约瑟夫问题</h3>
<ul>
<li><p>问题描述：使编号依次递增(编号从<span
class="math inline"><em>i</em></span>开始)的人(共有<span
class="math inline"><em>n</em></span>人)按顺序围成一圈，每<span
class="math inline"><em>m</em></span>次报数后踢出该人，求幸存者的编号</p></li>
<li><p>问题分析：要知道<span
class="math inline"><em>f</em>(<em>n</em>,<em>m</em>)</span>，就需要先知道<span
class="math inline"><em>f</em>(<em>n</em>−1,<em>m</em>)</span>，但后者从<span
class="math inline"><em>i</em></span>开始，为了使前者能转换成后者，每次踢出后，需要找出其编号对应关系，若用<span
class="math inline">[<em>k</em>]</span>表示下一轮报数从<span
class="math inline"><em>k</em></span>开始，则：<span
class="math inline">$\begin{cases}f(n,m)踢出一人:i,i+1,\cdots,i+m-2,[i+m],\cdots,i+n\\f(n-1,m):[i],i+1,\cdots,i+n-1\end{cases}$</span></p>
<p>当<span
class="math inline"><em>i</em> = 0</span>时，可找到对应关系：<span
class="math inline"><em>f</em>(<em>n</em>,<em>m</em>) = <em>f</em>(<em>n</em>−1,<em>m</em>)% <em>n</em></span></p>
<p>使<span
class="math inline">[]</span>括起的编号一一对应后，可找到如下关系：<span
class="math inline"><em>f</em>(<em>n</em>,<em>m</em>) = (<em>f</em>(<em>n</em>−1,<em>m</em>)+<em>m</em>−<em>i</em>)% <em>n</em> + <em>i</em></span></p>
<p>其中<span class="math inline"><em>i</em></span>为偏移量，减去<span
class="math inline"><em>i</em></span>即转换成编号从<span
class="math inline">0</span>开始的情况，最后加上<span
class="math inline"><em>i</em></span>得到原问题从<span
class="math inline"><em>i</em></span>开始的情况</p>
<p>上述情况假设<span
class="math inline"><em>m</em> &lt; <em>n</em></span>，实际上<span
class="math inline"><em>m</em> ≥ <em>n</em></span>的情况下，踢出一人后报数从<span
class="math inline"><em>i</em> + (<em>m</em>% <em>n</em>)</span>开始，因模运算的性质也满足上述递归式</p></li>
<li><p>递归式：<span
class="math inline">$\begin{cases}f(1,m)=i\\f(n,m)=(f(n-1,m)+m-i)\%\
n+i\end{cases}$</span>，从<span
class="math inline"><em>i</em></span>开始编号</p>
<p>若要求从<span
class="math inline"><em>j</em>(<em>i</em>≤<em>j</em>≤<em>i</em>+<em>n</em>)</span>开始报数，可先求从<span
class="math inline"><em>i</em></span>开始报数，然后增加<span
class="math inline"><em>j</em> − <em>i</em></span>(注意模<span
class="math inline"><em>n</em></span>)</p></li>
<li><p>递归求解代码：</p>
<p>```c++ int Solution(int n, int m, int i) { // 从i开始编号,
从i开始报数 return n == 1 ? i : (Solution(n - 1, m, i) + m - i) % n + i;
} int Josephus(int n, int m, int i, int j) { // 从i开始编号, 从j开始报数
return (Solution(n, m, i) - i) % n + j - i; }</p></li>
</ul>
<h3 id="fn2及推广的通项式求解"><span
class="math inline"><em>f</em>(<em>n</em>,2)</span>及推广的通项式求解</h3>
<p>上述过程实际只给出了递归式，实际上当<span
class="math inline"><em>m</em> = 2</span>时，原问题是以下问题的一个特例：</p>
<ul>
<li><p>给出递归式<span
class="math inline">$\begin{cases}f(j)=\alpha_j,&amp;0\lt j\lt
m\\f(mn+j)=cf(n)+\beta_j,&amp;0\le j\lt
m,n&gt;0\end{cases}$</span>，求出<span
class="math inline"><em>f</em>(<em>x</em>), <em>x</em> ∈ <em>N</em><sup>+</sup></span></p></li>
<li><p>清单法(猜证法)：即给定<span
class="math inline"><em>f</em>(<em>n</em>)</span>可能的形式，通过给定特定的<span
class="math inline"><em>f</em>(<em>n</em>) = <em>X</em>(<em>n</em>)</span>(要求<span
class="math inline"><em>X</em>(<em>n</em>)</span>能求出唯一对应的<span
class="math inline">(<em>α</em><sub><em>j</em></sub>,<em>β</em><sub><em>j</em></sub>)</span>值)，反过来推出<span
class="math inline"><em>f</em>(<em>n</em>)</span>中各系数的值</p>
<p>容易得到，如果递推式中含<span
class="math inline"><em>k</em></span>个变量，则至少需要找出<span
class="math inline"><em>k</em></span>个上述函数</p></li>
<li><p>当<span
class="math inline"><em>m</em> = <em>c</em> = 2</span>时，即所谓<span
class="math inline"><em>f</em>(<em>n</em>,2)</span>，可很容易地找到三个函数：</p>
<p>猜测</p>
<p>令<span
class="math inline">$f(n)=1,解得\begin{cases}\alpha_1=1\\\beta_0=\beta_1=-1\end{cases}$</span>，即<span
class="math inline"><em>A</em> − <em>B</em> − <em>C</em> = 1</span></p>
<p>令<span
class="math inline">$f(n)=n,解得\begin{cases}\alpha_1=\beta_1=1\\\beta_0=0\end{cases}$</span>，即<span
class="math inline"><em>A</em> + <em>C</em> = <em>n</em></span></p>
<p>令<span
class="math inline">$f(n)=2^k(其中n=2^k+l),解得\begin{cases}\alpha_1=1\\\beta_0=\beta_1=0\end{cases}$</span>，即<span
class="math inline"><em>A</em> = 2<sup><em>k</em></sup></span></p>
<p>联立得<span
class="math inline">$\begin{cases}A=2^k\\B=2^{k+1}-n-1=2^k-l-1\\C=n-2^k=l\end{cases}$</span>，即<span
class="math inline"><em>f</em>(<em>n</em>) = 2<sup><em>k</em></sup><em>α</em><sub>1</sub> + (2<sup><em>k</em></sup>−<em>l</em>−1)<em>β</em><sub>0</sub> + <em>l</em><em>β</em><sub>1</sub></span></p>
<ul>
<li>当<span
class="math inline"><em>α</em><sub>1</sub> = 1、<em>β</em><sub>0</sub> =  − 1、<em>β</em><sub>1</sub> = 1</span>时，正是<span
class="math inline"><em>f</em>(<em>n</em>,2) = 2<em>l</em> + 1</span></li>
</ul></li>
<li><p>很不幸，无法给出如此多的函数来使用清单法求出一般形式的通解，但能根据递推式给出如下关系：</p>
<p>令<span
class="math inline"><em>n</em> = (<em>n</em>)<sub><em>m</em></sub> = <em>b</em><sub><em>k</em></sub><em>b</em><sub><em>k</em> − 1</sub>⋯<em>b</em><sub>0</sub></span>，每右移一位相当于取<span
class="math inline"><em>n</em><em>m</em> + <em>j</em></span>中的<span
class="math inline"><em>n</em></span>，原本的末位则是<span
class="math inline"><em>j</em></span>：</p>
<p><span
class="math inline">$\begin{align}&amp;f((n)_m)=cf((n)_m&gt;&gt;1)+\beta_{b_0}=c(cf((n)_m&gt;&gt;2)+\beta_{b_1})+\beta_{b_0}=\cdots\\&amp;=c^kf(b_k)+c^{k-1}\beta_{b_{k-1}}+\cdots+c\beta_{b_1}+\beta_{b_0},其中b_k&lt;m,故f(b_k)=\alpha_{b_k}\end{align}$</span></p>
<p>因此对任何<span class="math inline"><em>n</em></span>，将其写成<span
class="math inline"><em>m</em></span>进制，则<span
class="math inline"><em>f</em>(<em>n</em>)</span>等于<span
class="math inline">(<em>α</em><sub><em>b</em><sub><em>k</em></sub></sub><em>β</em><sub><em>b</em><sub><em>k</em> − 1</sub></sub>⋯<em>β</em><sub><em>b</em><sub>0</sub></sub>)<sub><em>c</em></sub></span></p>
<p>当限定为约瑟夫问题<span
class="math inline"><em>f</em>(<em>n</em>,2)</span>时，<span
class="math inline"><em>f</em>(<em>n</em>) = (<em>n</em>)<sub>2</sub><em>循</em><em>环</em><em>左</em><em>移</em><em>一</em><em>位</em></span></p></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Concrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算: 基本知识</title>
    <url>/blogs/2024/09/19/algo-bin-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="硬件加速的二进制算法">硬件加速的二进制算法</h2>
<h3 id="求最高有效位">求最高有效位</h3>
<ul>
<li><p>定义末位为第零位</p></li>
<li><p><code>__builtin_clz()</code>：原理<code>bsr(bit scan reserve,逆向位扫描)</code>，可视作<code>O(1)</code>，能求出前导零个数</p>
<p>参数为零时返回结果未定义</p>
<p>最高有效位为<code>31-__builtin_clz()</code></p></li>
<li><p><code>__lg()</code>：直接给出，实际上编译后代码与上述方法一致</p>
<p>且该方法是<code>log2()</code>的优替，快速返回一个整数的以<span
class="math inline">2</span>为底对数的下取整</p></li>
</ul>
<h2 id="与运算">与运算</h2>
<h3 id="基本性质">基本性质</h3>
<ul>
<li>与运算只保留两个操作数共同拥有的<span
class="math inline">1</span></li>
</ul>
<h3 id="掩码">掩码</h3>
<ul>
<li><p>判奇偶性：<span
class="math inline"><em>A</em>&amp;1 = 1?<em>奇</em> : <em>偶</em></span></p></li>
<li><p>模<span class="math inline">2<sup><em>n</em></sup></span>：<span
class="math inline"><em>A</em>%2<sup><em>n</em></sup> = <em>A</em>&amp;((1&lt;&lt;<em>n</em>)−1)</span></p></li>
<li><p>判断二进制码子集：若<span
class="math inline"><em>B</em></span>是<span
class="math inline"><em>A</em></span>的子集，则<span
class="math inline"><em>A</em>&amp;<em>B</em> = <em>B</em></span></p></li>
</ul>
<h3 id="计1的个数">计<span class="math inline">1</span>的个数</h3>
<ul>
<li><p>调用库函数：<code>C++:__builtin_popcount()、Java:Integer.bitCount()</code></p></li>
<li><p>暴力算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      ans += x &amp; <span class="number">1</span>;</span><br><span class="line">      x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- `Brian Kernighan`算法：跳过最右$<span class="number">1</span>$和末位中间的零，直接对该一计数</span><br><span class="line"></span><br><span class="line">  $k=x\&amp;(x<span class="number">-1</span>)$的性质是：$k$和$x$相差最右边的$<span class="number">1</span>$</span><br><span class="line"></span><br><span class="line">  迭代直到$x=<span class="number">0</span>$，循环次数即一的个数</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      x &amp;= x - <span class="number">1</span>;</span><br><span class="line">      ++ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分治算法(<code>Java bitCount()</code>所用方法)：</p>
<ul>
<li><p>问题难点在于不知道哪里有<span
class="math inline">1</span>，也就无从统计</p>
<p>暴力算法是<strong>遍历所有位</strong>(优化后的<code>BK</code>算法也是<code>O(n)</code>)使<span
class="math inline">1</span>加起来，换言之，就是<strong>将<span
class="math inline"><em>n</em></span>位数分成<span
class="math inline"><em>n</em></span>组</strong></p>
<p>那么，分治算法的思想是<strong>遍历</strong>所有<strong>两位</strong>，将其<strong>分为<span
class="math inline">$\frac n2$</span>组</strong>，使<span
class="math inline">1/2</span>加起来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">    <span class="comment">// 这里需要先以每两位为一组, 求得1的个数, 覆盖回x</span></span><br><span class="line">    ans += x &amp; <span class="number">3</span>; <span class="comment">// 3 == 0b0000....0011</span></span><br><span class="line">    x &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么首先就要知道每个组是<span
class="math inline">0/1/2</span>中的哪个数：</p></li>
<li><p>将整数以<strong>每两位为一组</strong>划分，要求出每组的<span
class="math inline">1</span>的个数，就是要求每组中<strong>所有位的加和</strong></p>
<p>其对应关系为<span
class="math inline">$\begin{matrix}原码&amp;(1的个数)_2\\00&amp;00\\01&amp;01\\10&amp;01\\11&amp;10\end{matrix}$</span>，那么如何将这个计量关系快速算出，且每组间互不影响？</p>
<p>首先，取掩码<span class="math inline">$\rm
0b0101..0101$</span>，即<span class="math inline">$\rm
0x55..5$</span>，相与后能将每组中位于奇位置的<span
class="math inline">1</span>保留，偶位置全为零</p>
<p>让原整数<strong>右移一位</strong>，则原本处于偶位置的<span
class="math inline">1</span>移到奇位置，原本处于奇位置的<span
class="math inline">1</span>移位相与后为零(故不影响其它组)</p>
<p>将两次相与的结果相加，每组中<span
class="math inline">1</span>的个数就得到了，因为<strong>加和最大为<span
class="math inline">2</span></strong>，故<strong>每组是独立</strong>的</p></li>
<li><p>当然，分治算法不能满足于如此，这样还需遍历<span
class="math inline">$\frac n2$</span>次</p>
<p>既然一次合并就能降低一半复杂度了，尝试继续合并，最后<span
class="math inline"><em>a</em><em>n</em><em>s</em> = <em>x</em>&amp;(<em>全</em>1) = <em>x</em></span></p>
<p>重复上述过程，但以<strong>每四位为一组</strong>划分：</p>
<p>类似上述掩码，取<span class="math inline">$\rm
0b0011..0011$</span>，即<span class="math inline">$\rm
0x33..3$</span>，结果为<span
class="math inline"><em>x</em>&amp;<em>M</em> + (<em>x</em>&gt;&gt;2)&amp;<em>M</em></span></p>
<p>形象表达：将<span
class="math inline"><em>x</em></span>看作四进制数，每两位四进制数(即每四位为一组)为一组，求每组<strong>所有位的加和</strong>；即<span
class="math inline">$\begin{matrix}(原码)_4&amp;(所有位的加和)_4\\00&amp;00\\01/10&amp;01\\02/20/11&amp;02\\21/12&amp;03\\22&amp;10\end{matrix}$</span>，因为加和最大为<span
class="math inline">4</span>，故每组间独立计算，互不影响</p>
<p>重复每<span
class="math inline">2<em>n</em></span>一组的划分，直到<strong>只剩下一组</strong>，对这一组完成最后的统计后，则剩余整数就是所求</p>
<p>以<span
class="math inline">32</span>位整数为例，最终一次运算应以<span
class="math inline">32</span>位为一组，<span class="math inline">$M={\rm
0x0000ffff}、x=x\&amp;M+(x&gt;&gt;16)\&amp;M$</span>，此时<span
class="math inline"><em>x</em></span>就是所求</p></li>
<li><p>```c++ // 对int/unsigned int 32位整数: x = (x &amp; 0x55555555) +
((x &gt;&gt; 1) &amp; 0x55555555); x = (x &amp; 0x33333333) + ((x
&gt;&gt; 2) &amp; 0x33333333); x = (x &amp; 0x0f0f0f0f) + ((x &gt;&gt;
4) &amp; 0x0f0f0f0f); x = (x &amp; 0x00ff00ff) + ((x &gt;&gt; 8) &amp;
0x00ff00ff); x = (x &amp; 0x0000ffff) + ((x &gt;&gt; 16) &amp;
0x0000ffff); // 此时x为所求 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 分治算法在位运算上的优化(我也没想到这还能优化)：</span><br><span class="line"></span><br><span class="line">  - 对第一步：每组中原码和统计后码值的关系可优化为**原码减去偶数位值**：节省一次与运算</span><br><span class="line"></span><br><span class="line">    $\begin&#123;matrix&#125;原码&amp;计算过程&amp;1的个数\\00&amp;00-0&amp;00\\01&amp;01-0&amp;01\\10&amp;10-1&amp;01\\11&amp;11-1&amp;10\end&#123;matrix&#125;$，即`x -= (x &gt;&gt; 1) &amp; 0x55555555`</span><br><span class="line"></span><br><span class="line">  - 对第三步：因为经过前两步后，以每$8$位为一组时，组中所有位加和最多为$8$，最多占四位，因此可以先让高位和低位相加后再相与(**相与**为了**去除组间**的影响)：</span><br><span class="line"></span><br><span class="line">    `x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f`</span><br><span class="line"></span><br><span class="line">    根据这个思路，第一、二步无法通过这种方法优化，第一步最多占两位，第二步最多占三位，因此不能先加再与；第三步以后均可通过该方法优化</span><br><span class="line"></span><br><span class="line">  - 对更后面的步骤(第四步及以后)：每组加和的最大值所需位数远小于每组位数的一半，例如第四步中，每组加和最大为$16$，占五位；而每组位数的一半为$8$</span><br><span class="line"></span><br><span class="line">    因此从上一个组移到下一个组的位不会有影响，例如：</span><br><span class="line"></span><br><span class="line">    ​ 第三步后：$\rm0x\ 0a_0\ 0a_0..0a_0$，$a_0\le1000$，若后续**不和掩码相与**</span><br><span class="line"></span><br><span class="line">    ​ 第四步后：$\rm0x\ 0a_0bb_0\ aa_1bb_0..aa_1bb_0$</span><br><span class="line"></span><br><span class="line">    ​ $bb_0=a_&#123;0h&#125;+a_&#123;0l&#125;\le10000、aa_1=a_&#123;0up&#125;+a_&#123;0h&#125;\le10000$</span><br><span class="line"></span><br><span class="line">    ​ 第五步后：$\rm0x\ 0a_0bb_0\ aa_2cc_0\ aa_3cc_0..aa_3cc_0$</span><br><span class="line"></span><br><span class="line">    ​ $cc_0=bb_&#123;0h&#125;+bb_&#123;0l&#125;\le100000、aa_2=0a_0+aa_1\le11000、aa_3=aa_1+aa_1\le100000$</span><br><span class="line"></span><br><span class="line">    ​ 若和掩码相与：第四步$\rm0x00bb00bb..00bb$、第五步$\rm0x000000cc..000000cc$</span><br><span class="line"></span><br><span class="line">    上述$cc$(有效位)只要在八位之内，多余位就可在最后一步和掩码相与后除去</span><br><span class="line"></span><br><span class="line">    换言之，只要在计数之前除去多余位即可；由于$32$位整数本就**只用$6$位**，因此第四、五步可以不与：</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    x -= (x &gt;&gt; 1) &amp; 0x55555555;</span><br><span class="line">    x = (x &amp; 0x33333333) + ((x &gt;&gt; 2) &amp; 0x33333333);</span><br><span class="line">    x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br><span class="line">    x += x &gt;&gt; 8;</span><br><span class="line">    x += x &gt;&gt; 16;</span><br><span class="line">    x &amp;= 0x3f; // 最后保留末6位即可</span><br><span class="line">    // 推广到64位, 因为有效位为7, 故:</span><br><span class="line">    // (在第五步之后)</span><br><span class="line">    x += x &gt;&gt; 32;</span><br><span class="line">    x &amp;= 0x7f;</span><br></pre></td></tr></table></figure></p></li>
<li><p>和乘法的结合：和上述思想类似，因为有效位只有六位，在第三步后每组八位，就可在<strong>第三步后</strong>将末三组移到最高八位相加(末三组总和不超过六位，故不会影响最高组)</p>
<p>即：<span
class="math inline">(<em>x</em>+<em>x</em>&lt;&lt;8+<em>x</em>&lt;&lt;16+<em>x</em>&lt;&lt;24) &gt;  &gt; 24</span>，分配律到乘法</p>
<p>即：<span
class="math inline">$(x\cross\rm0x1010101)&gt;&gt;24$</span>，乘法得出的高位应强制转换成<code>int</code>来舍去它们</p>
<p>乘法效率其实不如上述优化强，但代码更简洁：</p>
<p>```c++ unsigned int y = x; y -= (y &gt;&gt; 1) &amp; 0x55555555; y =
(y &amp; 0x33333333) + ((y &gt;&gt; 2) &amp; 0x33333333); y = (((y
&gt;&gt; 4) &amp; 0x0f0f0f0f) * 0x1010101) &gt;&gt; 24;</p></li>
</ul></li>
</ul>
<h2 id="异或运算">异或运算</h2>
<h3 id="基本性质-1">基本性质</h3>
<ul>
<li><p>异或运算后，两操作数相同位得零、不同位得一</p></li>
<li><p>异或运算是一种对称加密：<span
class="math inline"><em>A</em> = (<em>A</em>⊕<em>B</em>) ⊕ <em>B</em>、<em>B</em> = (<em>A</em>⊕<em>B</em>) ⊕ <em>A</em></span></p>
<ul>
<li>不通过第三个变量交换两个整数：<span
class="math inline"><em>A</em> ⊕ <em>B</em> → <em>A</em>、<em>A</em> ⊕ <em>B</em> → <em>B</em>、<em>A</em> ⊕ <em>B</em> → <em>A</em></span></li>
<li><span
class="math inline"><em>A</em> ⊕ <em>Ā</em> = <em>全</em>1、<em>A</em> ⊕ <em>A</em> = 0</span></li>
</ul></li>
<li><p>满足差分性质：</p></li>
</ul>
<h3 id="汉明距离">汉明距离</h3>
<ul>
<li><p>汉明距离：两个整数中不同位的个数</p></li>
<li><p>计算一：调用库函数</p>
<p>```c++ __builtin_popcount(x ^ y);</p></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Trick</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim: 极其高效的编辑器</title>
    <url>/blogs/2024/09/07/vim/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="vim"><code>Vim</code></h1>
<h2 id="介绍">介绍</h2>
<ul>
<li><code>Vim</code>的前身是<code>Vi</code>，是类<code>Unix</code>系统下一个很高效的文本编辑器</li>
<li><code>Vi</code>本身<strong>舍弃了许多需要借助鼠标、<code>Ctrl</code>与<code>Alt</code>键</strong>的快捷键，转而设计了若干种模式以使双手尽可能的保持在键盘上的<code>asdf</code>与<code>jkl;</code>四个打字键上</li>
<li><code>Vim</code>则是<code>Vi</code>的扩展，不过许多功能默认被设置为禁用，许多功能需要在<code>.vimrc</code>文件中启用</li>
<li><code>Vim</code>内置了<code>vimtutor</code>命令，键入该命令会使用<code>vim</code>进入其教程文件，建议先熟悉一遍该教程，然后在平时编码中强迫使用<code>Vim</code></li>
</ul>
<h2 id="基本用法">基本用法</h2>
<h3 id="各种模式概览">各种模式概览</h3>
<ul>
<li><code>Vim</code>有多种模式，包括正常模式、写入模式、命令模式、选择模式等</li>
<li>正常模式是进入<code>Vim</code>后的初始模式，在其它模式下键入<code>Esc</code>可回到正常模式</li>
<li>写入模式是向文件中写入的主要模式，在正常模式下键入<code>i</code>、<code>I</code>、<code>o</code>、<code>O</code>、<code>a</code>、<code>A</code>、<code>r</code>、<code>R</code>可按不同方式进入写入模式
<ul>
<li>插入模式：插入模式指插入的字符不会覆盖已有的字符，而是插在光标上
按下<code>i</code>会在光标左侧进入插入模式(<code>insert</code>)
按下<code>I</code>会在行首进入插入模式
按下<code>o</code>会在光标下新开一行，在新行中进入插入模式
按下<code>O</code>会在光标上新开一行，在新行中进入插入模式
按下<code>a</code>会在光标右侧进入插入模式(<code>append</code>)
按下<code>A</code>会在行末进入插入模式</li>
<li>替换模式：替换模式指写入的字符会覆盖原本在光标上的字符
按下<code>r</code>仅替换一个字符，随后自动退回正常模式
按下<code>R</code>会进入替换模式，直至用户主动返回</li>
</ul></li>
<li>命令模式可以运行<code>Vim</code>内置的命令、外部提供的命令等
<ul>
<li>调用内置命令：键入<code>:</code>
例如键入<code>:help</code>用<code>Vim</code>进入帮助文档</li>
<li>调用外部提供的命令，需要键入<code>:!</code></li>
</ul></li>
<li>选择模式可以配合移动选择一块文本，随后键入其它和正常模式一致的动作命令对选中的代码块进行操作
<ul>
<li>键入<code>v</code>可切换(进入或退出)选择模式</li>
<li>键入<code>V</code>可切换(进入或退出)行选择模式</li>
</ul></li>
</ul>
<h3 id="光标移动">光标移动</h3>
<ul>
<li><strong><code>hjkl</code></strong>：分别为左下上右方向键</li>
<li><strong><code>0</code></strong>：等价于<code>Home</code>，此外<code>|</code>和<code>^</code>也是<code>Home</code></li>
<li><strong><code>$</code></strong>：等价于<code>End</code></li>
<li><strong><code>G</code></strong>：移动到文件的最后一行</li>
<li><code>gg</code>：移动到文件的第一行</li>
<li><code>正整数+G</code>：移动到第<code>正整数</code>行</li>
<li><code>&lt;Enter&gt;</code>：向下移动一行</li>
<li><code>w</code>：跳转到下一个单词的开始，针对英文而言<code>W</code>与<code>w</code>没有区别，对中文可能有些许不同，但总而言之<code>W</code>并不常用</li>
<li><strong><code>e</code></strong>：跳转到当前单词的结尾，若已处于当前单词结尾则跳转到下一单词结尾</li>
<li><code>b</code>：跳转到上一单词的开始</li>
<li><code>%</code>：匹配到光标所属的左/右括号，使光标在左/右括号间切换</li>
<li><code>Ctrl+f</code>与<code>Ctrl+b</code>：<code>Page Down</code>与<code>Page Up</code></li>
<li><code>Ctrl+d</code>与<code>Ctrl+u</code>：向下/向上移动半页</li>
<li><strong><code>正整数+上述移动命令</code></strong>：重复执行<code>正整数</code>次该移动命令</li>
</ul>
<h3 id="撤销与恢复">撤销与恢复</h3>
<ul>
<li><strong><code>u</code></strong>：撤销上一次修改命令造成的影响</li>
<li><code>U</code>：撤销该行内所有的命令</li>
<li><strong><code>Ctrl+r</code></strong>：撤销上一次“撤销”操作，即“恢复”</li>
</ul>
<h3 id="删除或粘贴字">删除或粘贴字</h3>
<ul>
<li><strong><code>x</code></strong>：删除光标所在的字符</li>
<li><code>X</code>：删除光标的前一个字符</li>
<li><code>d?</code>：其中<code>?</code>是移动命令，配合移动命令可快速删除字符</li>
<li><strong><code>dd</code></strong>：删除光标所在行</li>
<li><code>D</code>：删除至行尾，等价于<code>d0</code></li>
<li><code>s</code>：等价于<code>x</code>后键入<code>i</code></li>
<li><code>S</code>：等价于<code>dd</code>后键入<code>i</code></li>
<li><code>c?</code>：等价于<code>d?</code>后键入<code>i</code></li>
<li><code>cc</code>：等价于<code>dd</code>后键入<code>i</code></li>
<li><code>C</code>：等价于<code>D</code>后键入<code>i</code></li>
<li><code>y</code>：复制光标所在的字符、或复制选中的内容</li>
<li><strong><code>Y</code>或<code>yy</code></strong>：复制光标所在行</li>
<li><strong><code>p</code></strong>：将上一次删除或复制的内容粘贴在光标的右侧(若为一整行则会在光标下方开启新行)</li>
<li><code>P</code>：将上一次删除或复制的内容粘贴在光标的左侧(若为一整行则会在光标下方开启新行)</li>
</ul>
<h3 id="搜索与替换">搜索与替换</h3>
<ul>
<li><code>Vim</code>中的搜索默认是正则表达式匹配(<code>magic</code>模式)，可以切换为<code>nomagic</code>与<code>very magic</code>模式</li>
<li><strong><code>/</code></strong>：进入向后搜索模式，键入需要搜索的内容后键入回车即可</li>
<li><code>?</code>：进入向前搜索模式</li>
<li><strong><code>n</code></strong>：在搜索模式中，跳转到下一个匹配项</li>
<li><code>N</code>：在搜索模式中，跳转到上一个匹配项</li>
<li><code>:set ic</code>：等价于<code>:set ignorecase</code>，设置搜索时无视大小写</li>
<li><strong><code>:set hls</code></strong>：等价于<code>:set hlsearch</code>，设置搜索结果高亮</li>
<li><strong><code>:set is</code></strong>：等价于<code>:set incsearch</code>，设置在搜索过程中搜索结果高亮</li>
<li><code>:s/old/new</code>：将<strong>本行第一个<code>old</code></strong>替换为<code>new</code></li>
<li><code>:s/old/new/g</code>：将<strong>本行的所有<code>old</code></strong>替换为<code>new</code></li>
<li><strong><code>:%s/old/new/g</code></strong>：将<strong>所有的<code>old</code></strong>替换为<code>new</code></li>
<li><code>:%s/old/new/gc</code>：在<code>:%s/old/new/g</code>的基础上，每次替换前向用户发出确认(<code>confirm</code>)</li>
</ul>
<h3 id="分页">分页</h3>
<ul>
<li><code>:sp</code>：使当前文件上下分页</li>
<li><code>:sp 文件名</code>：打开新文件并上下分页，空格等特殊字符需反斜杠转义</li>
<li><code>:vsp</code>与<code>:vsp 文件名</code>：与上述命令类似，但是左右分页</li>
<li><code>Ctrl+w w</code>：切换到下一个分页</li>
<li><code>Ctrl+w hjkl</code>：切换到左、下、上、右分页</li>
<li><code>Ctrl+w c</code>：关闭当前分页</li>
<li><code>Ctrl+w o</code>：关闭其它所有分页</li>
</ul>
<h3 id="其它常用命令">其它常用命令</h3>
<ul>
<li><code>:help</code>：用<code>Vim</code>打开教程文件</li>
<li><strong><code>:w</code></strong>：保存文件</li>
<li><code>:q</code>：退出文件</li>
<li><code>:wq!</code>：强制地保存并退出</li>
<li><code>:!cmd</code>：运行一个由外部提供的名为<code>cmd</code>的命令</li>
<li><code>:set nu</code>：显示行号</li>
<li><code>:set noxxx</code>：取消某设置，例如<code>:set nonu</code></li>
<li><code>&gt;&gt;</code>与<code>&lt;&lt;</code>：缩进与反缩进</li>
</ul>
<h2 id="自定义命令">自定义命令</h2>
<ul>
<li><p>之前说过在<code>VS Code</code>中使用<code>json</code>数据格式配置<code>Vim</code>的扩展功能，实际上在<code>.vimrc</code>文件配置才是最原始的方法，因为原生的<code>Vim</code>没有<code>VS Code</code>的<code>editor</code>那样默认有丰富的配置</p></li>
<li><p><code>Vim</code>配置包含系统配置与用户配置，系统配置位于<code>/usr/share/vim/vimXX/vimrc_example.vim</code>，其中<code>XX</code>为版本，用户配置应位于<code>~/.vimrc</code>文件中，且用户配置优先于系统配置</p></li>
<li><p>一份常用的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set encoding=utf-8    # 编码</span><br><span class="line">syntax on             # 语法高亮</span><br><span class="line">set ruler             # 显示光标所在行号与列号</span><br><span class="line">set nu                # 显示行号</span><br><span class="line">set cursorline        # 高亮光标所在行</span><br><span class="line">set cursorcolumn      # 高亮光标所在列</span><br><span class="line">set autowrite         # 自动保存</span><br><span class="line">set is                # 搜索时立刻执行而不等`&lt;Enter&gt;`</span><br><span class="line">set nocompatible      # 不兼容`Vi`</span><br><span class="line">set showmatch         # 高亮显示光标所在括号对</span><br><span class="line">set tabstop=4         # 设置\t的空格数</span><br><span class="line">set shiftwidth=4      # 设置缩进的空格数</span><br><span class="line">set noexpandtab       # 设置按下Tab时不用空格替代\t</span><br><span class="line">set laststatus=2      # 始终在下方显示文件名</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Tools &amp; Utilities</category>
        <category>editor</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学: 代数系统</title>
    <url>/blogs/2024/08/07/discreteMath-algebra-system/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="代数系统">代数系统</h1>
<h2 id="定义">定义</h2>
<ul>
<li><span class="math inline"><em>S</em></span>上的<span
class="math inline"><em>n</em></span>元运算是一个特殊的函数<span
class="math inline"><em>f</em> : <em>S</em><sup><em>n</em></sup> → <em>S</em></span>，具有<strong>封闭性</strong></li>
<li>代数系统：由非空集合<span
class="math inline"><em>S</em></span>和<span
class="math inline"><em>S</em></span>上的运算组成的系统，记作<span
class="math inline"> &lt; <em>S</em>, <em>f</em><sub>1</sub>, <em>f</em><sub>2</sub>, ⋯, <em>f</em><sub><em>n</em></sub>&gt;</span>，简称代数</li>
<li>代数的基数等于<span
class="math inline"><em>S</em></span>的基数(因为运算具有封闭性)</li>
<li>同类型的代数：要求一一对应的各个运算的元数相同，和<span
class="math inline"><em>S</em></span>无关</li>
<li>子代数：给定代数<span
class="math inline"> &lt; <em>S</em>, <em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>&gt;</span>，若非空集合<span
class="math inline"><em>T</em> ⊆ <em>S</em></span>，且<span
class="math inline"><em>T</em></span>和<span
class="math inline"><em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>n</em></sub></span>能够组成代数(即<span
class="math inline"><em>f</em></span>在<span
class="math inline"><em>T</em></span>上封闭)，则<span
class="math inline"> &lt; <em>T</em>, <em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>&gt; ⊆  &lt; <em>S</em>, <em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>&gt;</span></li>
</ul>
<h2 id="代数运算">代数运算</h2>
<h3 id="代数运算的性质">代数运算的性质</h3>
<p>设在<span class="math inline"><em>S</em></span>上的二元运算<span
class="math inline">∘</span>满足：</p>
<ul>
<li><strong>结合律</strong>：<span
class="math inline">∀<em>x</em>∀<em>y</em>∀<em>z</em>(<em>x</em>,<em>y</em>,<em>z</em>∈<em>S</em>→(<em>x</em>∘<em>y</em>)∘<em>z</em>=<em>x</em>∘(<em>y</em>∘<em>z</em>))</span></li>
<li><strong>交换律</strong>：<span
class="math inline">∀<em>x</em>∀<em>y</em>(<em>x</em>,<em>y</em>∈<em>S</em>→<em>x</em>∘<em>y</em>=<em>y</em>∘<em>x</em>)</span>
<ul>
<li>若同时满足结合律和交换律，则表达式可任意调换次序</li>
</ul></li>
<li><strong>分配律</strong>：设<span class="math inline">∘</span>对<span
class="math inline"><em>S</em></span>上的另一个运算<span
class="math inline">×</span>满足：
<ul>
<li>左分配律：<span
class="math inline">∀<em>x</em>∀<em>y</em>∀<em>z</em>(<em>x</em>,<em>y</em>,<em>z</em>∈<em>S</em>→<em>x</em>∘(<em>y</em>×<em>z</em>)=(<em>x</em>∘<em>y</em>)×(<em>x</em>∘<em>z</em>))</span></li>
<li>右分配律：<span
class="math inline">∀<em>x</em>∀<em>y</em>∀<em>z</em>(<em>x</em>,<em>y</em>,<em>z</em>∈<em>S</em>→(<em>x</em>×<em>y</em>)∘<em>z</em>=(<em>x</em>∘<em>z</em>)×(<em>y</em>∘<em>z</em>))</span></li>
<li>注意运算的对应关系，<span class="math inline">∘</span>对<span
class="math inline">×</span>满足，则左式<span
class="math inline">∘</span>在括号外</li>
<li>同时满足左右分配律，才能称<span class="math inline">∘</span>对<span
class="math inline">×</span>满足分配律</li>
<li>若<span class="math inline">∘</span>满足交换律，且对<span
class="math inline">×</span>满足左或右分配律，则可证明它对<span
class="math inline">×</span>满足分配律</li>
</ul></li>
<li><strong>吸收律</strong>：类似于分配律的左右定义方式，<span
class="math inline">∘</span>对<span
class="math inline">×</span>满足<strong>左吸收律</strong><span
class="math inline"> ⇒ ∀<em>x</em>∀<em>y</em>(<em>x</em>,<em>y</em>∈<em>S</em>→<em>x</em>∘(<em>x</em>×<em>y</em>)=<em>x</em>)</span></li>
<li><strong>幺元</strong>(单位元)：有左右幺元之分，若<span
class="math inline"><em>e</em></span>是关于<span
class="math inline">∘</span>的左幺元，则<span
class="math inline">∀<em>x</em>(<em>x</em>∈<em>S</em>→<em>e</em>∘<em>x</em>=<em>x</em>)</span></li>
<li><strong>零元</strong>：有左右零元之分，若<span
class="math inline">$\O$</span>是关于<span
class="math inline">∘</span>的左零元，则<span
class="math inline">$\forall x(x\in S\rightarrow \O\circ x=\O)$</span>
<ul>
<li>如果一个运算的左右幺元/零元存在，则左右分别相等，且这个幺元/零元是<strong>唯一</strong>的</li>
<li>如果一个运算同时存在幺元和零元，则它们不相等</li>
</ul></li>
<li><strong>等幂律</strong>：<span
class="math inline">∀<em>x</em>(<em>x</em>∈<em>S</em>→<em>x</em>∘<em>x</em>=<em>x</em>)</span>，并定义<span
class="math inline"><em>x</em></span>为<span
class="math inline">∘</span>的<strong>等幂元</strong>
<ul>
<li>若满足，则所有元素都为等幂元</li>
<li>一个运算的幺元和零元一定是等幂元</li>
</ul></li>
<li><strong>逆元</strong>：若<span
class="math inline"><em>e</em></span>为<span
class="math inline">∘</span>的幺元，有左右逆元之分，且有两种对应关系
<ul>
<li><span class="math inline"><em>x</em></span>是关于<span
class="math inline">∘</span>的左逆元：<span class="math inline">$\exist
y(y\in S\wedge x\circ y=e)$</span></li>
<li>称存在的这个<span class="math inline"><em>y</em></span>为<span
class="math inline"><em>x</em></span>的右逆元，即<span
class="math inline"><em>x</em> ∘ <em>y</em> = <em>e</em></span></li>
<li>如果<span class="math inline"><em>x</em></span>和<span
class="math inline"><em>y</em></span>互逆(<span
class="math inline"><em>x</em></span>为<span
class="math inline"><em>y</em></span>的左右逆元)，则<span
class="math inline"><em>x</em></span>和<span
class="math inline"><em>y</em></span>都是关于<span
class="math inline">∘</span>的逆元</li>
<li>一个运算的幺元一定是逆元</li>
</ul></li>
<li><strong>可约律</strong>：有左右可约律，若<span
class="math inline">$\O$</span>为<span
class="math inline">∘</span>的零元，则<span
class="math inline">∘</span>是左可约的<span
class="math inline">$\Rightarrow\forall x\forall y\forall z((x,y,z\in
S\wedge x\ne\O\wedge x\circ y=x\circ z)\rightarrow y=z)$</span>
<ul>
<li>定义<span class="math inline"><em>x</em></span>为<span
class="math inline">∘</span>的<strong>左可约元</strong></li>
<li>如果一个运算是可约的，那么所有非零元的元素都为可约元</li>
<li>存在一个可约元，不代表一个运算是可约的</li>
<li>！如果<span class="math inline">∘</span>满足结合律，同时<span
class="math inline">$x\ne\O$</span>且<span
class="math inline"><em>x</em></span>是<span
class="math inline">∘</span>的逆元，则<span
class="math inline"><em>x</em></span>是<span
class="math inline">∘</span>的可约元</li>
<li>一个运算的幺元一定是可约元</li>
</ul></li>
</ul>
<h3 id="性质在运算表上的体现">性质在运算表上的体现</h3>
<p>将二元运算的左元、右元分别作为行、列，将运算结果作为表中数据，生成的运算表(方阵)中：</p>
<ul>
<li>封闭性：表中数据一定都属于<span
class="math inline"><em>S</em></span>，否则该运算不是<span
class="math inline"><em>S</em></span>上的运算</li>
<li>可交换：该方阵是对称的</li>
<li>等幂：主对角线上元素和行头元素相等</li>
<li>左/右零元：左/右零元所在行/列元素和该元素相等</li>
<li>左/右幺元：左/右幺元所在行/列元素和对应的列/行元素相等</li>
<li>左/右逆元：左/右逆元所在行/列元素中必定有一个幺元</li>
<li>！两元素互为逆元：两元素所在行和列的元素都是幺元</li>
</ul>
<p>以上冒号左右两边的描述是等价的</p>
<h2 id="常见代数运算的性质">常见代数运算的性质</h2>
<table align="center" border="2">
<tbody align="center">
<tr>
<th>
集合
</th>
<th>
运算
</th>
<th>
幺元
</th>
<th>
零元
</th>
<th>
等幂元
</th>
<th>
逆元
</th>
<th>
可约元
</th>
</tr>
<tr>
<td rowspan="2" style="display:table-cell; vertical-align:middle">
R
</td>
<td>
加法
</td>
<td>
0
</td>
<td>
无
</td>
<td>
0
</td>
<td>
相反数
</td>
<td>
任意元素
</td>
</tr>
<tr>
<td style="display:table-cell; vertical-align:middle">
乘法
</td>
<td style="display:table-cell; vertical-align:middle">
1
</td>
<td style="display:table-cell; vertical-align:middle">
0
</td>
<td style="display:table-cell; vertical-align:middle">
1和0
</td>
<td>
除0外的<br>数的倒数
</td>
<td>
除0外的<br>任意元素
</td>
</tr>
<tr>
<td rowspan="2" style="display:table-cell; vertical-align:middle">
P(S)
</td>
<td>
并集
</td>
<td>
空集
</td>
<td>
S
</td>
<td>
任意元素
</td>
<td>
空集
</td>
<td>
空集
</td>
</tr>
<tr>
<td>
交集
</td>
<td>
S
</td>
<td>
空集
</td>
<td>
任意元素
</td>
<td>
S
</td>
<td>
S
</td>
</tr>
<tr>
<td rowspan="2" style="display:table-cell; vertical-align:middle">
命题
</td>
<td>
析取
</td>
<td>
F
</td>
<td>
T
</td>
<td>
任意元素
</td>
<td>
F
</td>
<td>
F
</td>
</tr>
<tr>
<td>
合取
</td>
<td>
T
</td>
<td>
F
</td>
<td>
任意元素
</td>
<td>
T
</td>
<td>
T
</td>
</tr>
<tr>
<td>
集合上的<br>所有关系<br>构成集合
</td>
<td style="display:table-cell; vertical-align:middle">
合成
</td>
<td style="display:table-cell; vertical-align:middle">
恒等关系
</td>
<td style="display:table-cell; vertical-align:middle">
空关系
</td>
<td style="display:table-cell; vertical-align:middle">
恒等关系
</td>
<td style="display:table-cell; vertical-align:middle">
关系矩阵可逆<br>的所有关系
</td>
<td style="display:table-cell; vertical-align:middle">
关系矩阵可逆<br>的所有关系
</td>
</tr>
<tr>
<td>
f:S-&gt;S<br>所有双射函数<br>构成的集合
</td>
<td style="display:table-cell; vertical-align:middle">
合成
</td>
<td style="display:table-cell; vertical-align:middle">
恒等函数
</td>
<td style="display:table-cell; vertical-align:middle">
无
</td>
<td style="display:table-cell; vertical-align:middle">
恒等函数
</td>
<td style="display:table-cell; vertical-align:middle">
所有元素
</td>
<td style="display:table-cell; vertical-align:middle">
所有元素
</td>
</tr>
</tbody>
</table>
<p>最后两条：</p>
<ul>
<li>一个集合上的所有双射函数都有其对应的反函数，且反函数也是该集合上的双射函数</li>
<li>一个集合上的双射函数和其反函数合成的结果是恒等函数</li>
<li>一个集合上的双射函数构成集合，是所有关系构成集合的子集</li>
</ul>
<h2 id="同类型的代数">同类型的代数</h2>
<p>以下关系，要求<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>和<span
class="math inline"> &lt; <em>T</em>,  × &gt;</span>是同类型的</p>
<h3 id="同态关系">同态关系</h3>
<ul>
<li>记号：记<span
class="math inline"> &lt; <em>S</em>,  ∘  &gt;  ≃  &lt; <em>T</em>,  × &gt;</span>表示前者同态于后者</li>
<li>定义：上式<span class="math inline">$\Rightarrow\exist f(f\in
T^S\wedge\forall x\forall y(x,y\in S\rightarrow f(x\circ y)=f(x)\times
f(y)))$</span>，其中称<span
class="math inline"><em>f</em> : <em>S</em> → <em>T</em></span>为<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>到<span
class="math inline"> &lt; <em>T</em>,  × &gt;</span>的同态映射
<ul>
<li>即先通过运算映射再通过<span
class="math inline"><em>f</em></span>映射等于先通过<span
class="math inline"><em>f</em></span>映射再通过运算映射</li>
<li><span class="math inline"><em>f</em></span>不唯一</li>
<li>在代数有多个二元运算时，要求<span
class="math inline"><em>f</em></span>是同一个</li>
<li>由<span class="math inline"><em>f</em></span>的值域<span
class="math inline"><em>R</em>(<em>f</em>) ⊆ <em>T</em></span>，易得<span
class="math inline"> &lt; <em>R</em>(<em>f</em>),  ×  &gt;  ⊆  &lt; <em>T</em>,  × &gt;</span></li>
</ul></li>
</ul>
<h3 id="同态映射的分类">同态映射的分类</h3>
<p>根据<span
class="math inline"><em>f</em></span>的性质，对该映射进行分类：</p>
<ul>
<li><span class="math inline"><em>f</em></span>为满射<span
class="math inline">⇒</span>从前者到后者的满同态映射</li>
<li><span class="math inline"><em>f</em></span>为单射<span
class="math inline">⇒</span>从前者到后者的单一同态映射</li>
<li><span class="math inline"><em>f</em></span>为双射<span
class="math inline">⇒</span>从前者到后者的同构映射</li>
</ul>
<h3 id="满同态映射的运算继承性质">满同态映射的运算继承性质</h3>
<p>只要<span
class="math inline"><em>f</em></span>是满射的(包括同构关系)，就有以下性质：</p>
<ul>
<li>两代数的对应运算的结合、交换、分配、等幂律等性质是一致的</li>
<li>前代数中运算的幺元、零元、逆元经<span
class="math inline"><em>f</em></span>后，等于后代数中对应运算的幺元、零元、逆元</li>
</ul>
<h3 id="同构关系">同构关系</h3>
<ul>
<li>记号：<span
class="math inline"> &lt; <em>S</em>,  ∘  &gt;  ≅  &lt; <em>T</em>,  ×  &gt; ⇒</span>前者同构于后者</li>
<li>同构意味着，每个<span
class="math inline"><em>f</em>(<em>x</em>)</span>有其唯一对应的原像，因此两个代数可以<strong>互相映射</strong>，即同时存在同构关系<span
class="math inline"> &lt; <em>T</em>,  ×  &gt; ≅<sub><em>f</em><sup>−1</sup></sub> &lt; <em>S</em>,  ∘ &gt;</span>；而不是像同态一样，只能单向地映射系统</li>
<li>代数间的同构关系是等价关系
<ul>
<li>可通过同构关系，将所有代数形成的集合按其分类</li>
<li>同态、同构关系指的不是<span
class="math inline"><em>f</em></span>这个函数关系，而是由两代数作为第一、二元素的二元关系</li>
</ul></li>
<li>称从<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>到自身的同态、同构关系为自同态、自同构关系</li>
</ul>
<h2 id="代数间的运算">代数间的运算</h2>
<h3 id="同余关系">同余关系</h3>
<ul>
<li>定义：若<span class="math inline"><em>E</em></span>是<span
class="math inline"><em>S</em></span>上的等价关系，且满足<span
class="math inline">∀<em>x</em><sub>1</sub>∀<em>y</em><sub>1</sub>∀<em>x</em><sub>2</sub>∀<em>y</em><sub>2</sub>((<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>,<em>x</em><sub>2</sub>,<em>y</em><sub>2</sub>∈<em>S</em>∧<em>x</em><sub>1</sub><em>E</em><em>y</em><sub>1</sub>∧<em>x</em><sub>2</sub><em>E</em><em>y</em><sub>2</sub>)→(<em>x</em><sub>1</sub>∘<em>x</em><sub>2</sub>)<em>E</em>(<em>y</em><sub>1</sub>∘<em>y</em><sub>2</sub>))</span>，则称<span
class="math inline"><em>E</em></span>是<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>上的同余关系
<ul>
<li>称由<span
class="math inline"><em>E</em></span>划分的等价类为同余类</li>
<li><span
class="math inline"><em>E</em></span>是<strong>特殊的等价关系</strong>，能保证元素运算后，仍能满足该关系</li>
<li><span
class="math inline"><em>E</em></span>的这种代换需要满足代数中的<strong>所有运算</strong></li>
<li>同余关系和同态、同构不是一种概念</li>
</ul></li>
<li>另一种表达：<span
class="math inline">[<em>x</em><sub>1</sub>]<sub><em>E</em></sub> = [<em>y</em><sub>1</sub>]<sub><em>E</em></sub> ∧ [<em>x</em><sub>2</sub>]<sub><em>E</em></sub> = [<em>y</em><sub>2</sub>]<sub><em>E</em></sub> → [<em>x</em><sub>1</sub>∘<em>x</em><sub>2</sub>]<sub><em>E</em></sub> = [<em>y</em><sub>1</sub>∘<em>y</em><sub>2</sub>]<sub><em>E</em></sub></span></li>
</ul>
<h3 id="商代数">商代数</h3>
<ul>
<li><p>若<span class="math inline"><em>f</em></span>是<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>到<span
class="math inline"> &lt; <em>T</em>,  × &gt;</span>的同态映射，则<span
class="math inline"><em>S</em></span>上的关系<span
class="math inline"><em>E</em><sub><em>f</em></sub></span>(满足<span
class="math inline"><em>x</em><em>E</em><sub><em>f</em></sub><em>y</em> : <em>f</em>(<em>x</em>) = <em>f</em>(<em>y</em>)</span>)一定是同余关系</p>
<ul>
<li>证明：任取<span
class="math inline"><em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>y</em><sub>2</sub> ∈ <em>S</em></span>，若有<span
class="math inline"><em>x</em><sub>1</sub><em>E</em><sub><em>f</em></sub><em>y</em><sub>1</sub> ∧ <em>x</em><sub>2</sub><em>E</em><sub><em>f</em></sub><em>y</em><sub>2</sub></span>，则<span
class="math inline"><em>f</em>(<em>x</em><sub>1</sub>) = <em>f</em>(<em>y</em><sub>1</sub>) ∧ <em>f</em>(<em>x</em><sub>2</sub>) = <em>f</em>(<em>y</em><sub>2</sub>)</span>；根据同态映射的定义，有<span
class="math inline">$\begin{cases}f(x_1)\times f(x_2)=f(x_1\circ
x_2)\\f(y_1)\times f(y_2)=f(y_1\circ
y_2)\end{cases}$</span>；三式联立得<span
class="math inline"><em>f</em>(<em>x</em><sub>1</sub>∘<em>x</em><sub>2</sub>) = <em>f</em>(<em>y</em><sub>1</sub>∘<em>y</em><sub>2</sub>)</span>，即<span
class="math inline">(<em>x</em><sub>1</sub>∘<em>x</em><sub>2</sub>)<em>E</em><sub><em>f</em></sub>(<em>y</em><sub>1</sub>∘<em>y</em><sub>2</sub>)</span>，得证</li>
<li>称<span
class="math inline"><em>E</em><sub><em>f</em></sub></span>为由<span
class="math inline"><em>f</em></span>诱导的同余关系</li>
</ul></li>
<li><p>商代数：给定<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>及其上的一个同余关系<span
class="math inline"><em>E</em></span>：</p>
<ul>
<li>以<span class="math inline"><em>E</em></span>导出的商集<span
class="math inline"><em>S</em>/<em>E</em></span>为集合，构造满足同态定义的运算<span
class="math inline">×</span>：<span
class="math inline">∀<em>x</em>∀<em>y</em> ∈ <em>S</em> → [<em>x</em>∘<em>y</em>]<sub><em>E</em></sub> = [<em>x</em>]<sub><em>E</em></sub> × [<em>y</em>]<sub><em>E</em></sub></span>，则称<span
class="math inline"> &lt; <em>S</em>/<em>E</em>,  × &gt;</span>为它的商代数</li>
<li>商代数是人为构造的，满足<span
class="math inline"> &lt; <em>S</em>,  ∘  &gt;  ≃  &lt; <em>S</em>/<em>E</em>,  × &gt;</span>，<span
class="math inline"><em>g</em><sub><em>E</em></sub>(<em>x</em>) = [<em>x</em>]<sub><em>E</em></sub></span></li>
<li>易得<span
class="math inline"><em>g</em><sub><em>E</em></sub></span>为<strong>满同态映射</strong>，因此商代数的运算继承了本代数运算的性质</li>
<li>该映射被称为<strong>正则映射</strong>、<strong>自然同态</strong></li>
</ul></li>
<li><p>设<span
class="math inline"> &lt; <em>S</em>,  ∘  &gt;  ≃  &lt; <em>T</em>,  × &gt;</span>，且<span
class="math inline"><em>f</em></span>为<strong>满同态映射</strong>，则<span
class="math inline"> &lt; <em>T</em>,  ×  &gt;  ≅  &lt; <em>S</em>/<em>E</em><sub><em>f</em></sub>,  * &gt;</span>(后者为<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>的商代数)</p>
<ul>
<li><p>证明：构造函数<span
class="math inline">$\begin{cases}h:T\rightarrow
S/E_f\\h(y)=[x]_E\end{cases}$</span>，其中<span
class="math inline"><em>y</em> = <em>f</em>(<em>x</em>)</span></p></li>
<li><p>证其为同态映射</p>
<p><span
class="math inline"><em>h</em>(<em>y</em><sub>1</sub>×<em>y</em><sub>2</sub>) = <em>h</em>(<em>f</em>(<em>x</em><sub>1</sub>∘<em>x</em><sub>2</sub>)) = [<em>x</em><sub>1</sub>∘<em>x</em><sub>2</sub>]<sub><em>E</em></sub></span>，由<strong>商集定义</strong>，上式<span
class="math inline"> = [<em>x</em><sub>1</sub>]<sub><em>E</em></sub> * [<em>x</em><sub>2</sub>]<sub><em>E</em></sub></span></p>
<p><span
class="math inline"> ⇒ ∀<em>y</em><sub>1</sub>∀<em>y</em><sub>2</sub>(<em>y</em><sub>1</sub>,<em>y</em><sub>2</sub>∈<em>T</em>→[<em>x</em><sub>1</sub>]<sub><em>E</em></sub>*[<em>x</em><sub>2</sub>]<sub><em>E</em></sub>=<em>h</em>(<em>y</em><sub>1</sub>×<em>y</em><sub>2</sub>))</span></p>
<p><span
class="math inline"> ⇒  &lt; <em>T</em>,  ×  &gt;  ≃  &lt; <em>S</em>/<em>E</em><sub><em>f</em></sub>,  * &gt;</span>，<span
class="math inline"><em>h</em></span>为其同态映射</p></li>
<li><p>证其为满射：<span
class="math inline"><em>f</em>、<em>g</em><sub><em>E</em><sub><em>f</em></sub></sub></span>为满射<span
class="math inline"> ⇒ <em>h</em></span>为满射</p></li>
<li><p>证其为单射：若<span
class="math inline"><em>h</em>(<em>y</em><sub>1</sub>) = <em>h</em>(<em>y</em><sub>2</sub>)</span></p>
<p><span
class="math inline"> ⇒ [<em>x</em><sub>1</sub>]<sub><em>E</em></sub> = [<em>x</em><sub>2</sub>]<sub><em>E</em></sub> ⇒ <em>x</em><sub>1</sub><em>E</em><sub><em>f</em></sub><em>x</em><sub>2</sub> ⇒ <em>f</em>(<em>x</em><sub>1</sub>) = <em>f</em>(<em>x</em><sub>2</sub>) ⇒ <em>y</em><sub>1</sub> = <em>y</em><sub>2</sub></span></p>
<p>得证</p></li>
</ul></li>
</ul>
<h3 id="积代数">积代数</h3>
<p>设有同类型的代数<span
class="math inline"> &lt; <em>S</em>,  ∘ &gt;</span>和<span
class="math inline"> &lt; <em>T</em>,  × &gt;</span>，则定义运算<span
class="math inline">⊗</span>：<span
class="math inline">∀<em>x</em><sub>1</sub>∀<em>x</em><sub>2</sub>∀<em>y</em><sub>1</sub>∀<em>y</em><sub>2</sub>(<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>∈<em>S</em>∧<em>y</em><sub>1</sub>,<em>y</em><sub>2</sub>∈<em>T</em>→&lt;<em>x</em><sub>1</sub>∘<em>x</em><sub>2</sub>,<em>y</em><sub>1</sub>×<em>y</em><sub>2</sub>&gt;=&lt;<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>&gt;⊗&lt;<em>x</em><sub>2</sub>,<em>y</em><sub>2</sub>&gt;)</span></p>
<p>称<span
class="math inline"> &lt; <em>S</em> × <em>T</em>,  ⊗ &gt;</span>为上述两个代数的<strong>积代数</strong>；上述两个代数为该积代数的<strong>因子代数</strong></p>
<ul>
<li>上述为两因子代数形成的积代数，多因子代数形成的积代数可递归定义</li>
<li>积代数和因子代数是同类型的</li>
<li>积代数的运算包含了所有因子代数的运算及其笛卡尔积顺序的信息</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Discrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习: 基本概念</title>
    <url>/blogs/2024/08/04/deeplearning-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="机器学习基础">机器学习基础</h2>
<h3 id="模型评价标准">模型评价标准</h3>
<ul>
<li><p>模型超参数：指模型的较高维度的由<strong>人工调整</strong>的参数</p></li>
<li><p>模型参数：指由模型自主学习并调整的学习函数的参数，例如权重、偏置等</p></li>
<li><p>模型容量：用于描述模型的复杂程度，数学定义是模型的假设空间(所有可选函数的集合)的大小</p></li>
<li><p>经验误差(训练误差)：指模型在训练集上的预测能力，模型在训练集上的预测能力越强，训练误差越小</p></li>
<li><p>泛化误差(测试误差)：指模型在经过样本集训练后，对<strong>未知数据集</strong>进行预测的能力</p>
<p>对未知数据的预测结果越准确，称泛化误差越小，泛化能力强</p></li>
<li><p>过拟合：模型的训练误差很小，但泛化误差大，以至于显得像在对样本集死记硬背，称为过拟合</p>
<p>原因：样本过少、样本噪音过大、模型容量过大</p></li>
<li><p>欠拟合：模型的训练误差很大，导致泛化误差也很大，连给定的样本集都没学明白</p>
<p>原因：模型容量过小而无法学习复杂的问题</p></li>
<li><p>学习过程就是调整模型容量的过程，我们需要找到一个最优容量，使得泛化误差最小</p></li>
<li><p>没有免费午餐(<code>No Free Lunch</code>，<code>NFL</code>)定理：没有一个算法能在所有的问题上都优于其它算法</p></li>
</ul>
<h3 id="数据集">数据集</h3>
<ul>
<li><p>数据集(或样本集)是样本的集合，样本是特征的集合</p></li>
<li><p>通常，可以用<strong>设计矩阵</strong>来表示数据集，在本系列笔记中，约定样本是由若干特征值构成的<strong>列向量</strong>，而每一行对应不同样本在同一个特征上的值</p></li>
<li><p>根据用处的不同，数据集可以分为训练集、验证集、测试集</p>
<ul>
<li><p>训练集：用于训练模型的数据集</p></li>
<li><p>验证集：用于初步评估模型的泛化能力，不直接调整模型参数，但可帮助开发者<strong>调整超参数</strong></p>
<p>每过一个训练周期，进行一次对验证集的计算</p>
<p>当然，模型可以对训练集过拟合，肯定也有对验证集过拟合的情况</p></li>
<li><p>测试集：模型定型后，用于检查它的最终泛化能力，必须保证计算过程不进行任何对模型的调整</p>
<p>测试集必须是大量的、能反映真实环境复杂性的样本集</p>
<p>在模型任何参数不变、输入的样本集也不变的情况下，结果理应是一样的，是可以完全复现的</p></li>
</ul></li>
<li><p>数据生成过程(<code>Data Generating Process</code>，<code>DGP</code>)：指数据从其来源到被收集、存储的整个过程</p></li>
<li><p>数据集的假设：尽管上述训练集、验证集、测试集的用处不同，但通常遵循一些假设能使算法效果更好</p>
<ul>
<li>每个数据集中的不同样本是<strong>相互独立</strong>的</li>
<li>不同数据集是同分布的，即采样来自相同的分布，这个潜在的分布被称为<strong>数据生成分布</strong>(通常不能被精确表示)</li>
</ul></li>
</ul>
<h3 id="学习算法">学习算法</h3>
<ul>
<li><p>机器学习(<code>ML</code>)是实现人工智能的一种方法</p></li>
<li><p>按结构特点可分为<strong>传统机器学习</strong>和<strong>深度学习</strong>(<code>DL</code>)</p></li>
<li><p>按算法特点可分为无监督学习、监督学习、半监督学习、强化学习</p>
<ul>
<li><p><strong>监督学习</strong>指样本集被人工贴上标签(<code>label</code>)，在模型得出预测值后和标签比较并反过来调整模型，即为有监督的学习过程</p>
<p>监督学习中，一条样本拥有一个标签，所有样本的标签组成该数据集的标签向量<span
class="math inline"><strong>y</strong></span></p>
<p>监督学习常用于分类、回归任务</p></li>
<li><p><strong>无监督学习</strong>指样本集没有提前贴上标签，完全靠分析(寻找隐藏的)数据集合的内部特点/结构来确定它们的标签，这类模型虽然没有样本集的指示，但仍然依赖梯度下降法</p>
<p>无监督学习常用于聚类任务</p></li>
<li><p><strong>半监督学习</strong>指样本集中的部分样本点拥有标签，模型通过对有标签数据的学习后完成对剩下无标签数据贴标签的任务</p>
<p>相比无监督学习，它通过消耗少部分人力，得到更好的预测效果</p></li>
<li><p><strong>强化学习</strong>的样本集同样没有标签，但它不倾向于分析样本集，而是<strong>由反馈信号引导</strong>(反馈信号由环境给出)，模型追求奖励最大化，最终得出全局的策略</p></li>
</ul></li>
</ul>
<h3 id="开发模型的过程">开发模型的过程</h3>
<ul>
<li>训练模型的目标：调整模型的参数以及超参数，使其泛化误差最小</li>
<li>数据准备：
<ul>
<li>数据收集</li>
<li>数据清洗：处理缺失、损坏、重复数据</li>
<li>特征化：将数据整合为样本集，每条样本包括选定的特征</li>
<li>数据划分：将数据集划分为训练集、验证集、测试集</li>
</ul></li>
<li>设计模型：
<ul>
<li>选择使用的模型，包括设定模型某层类型、模型层数等</li>
<li>根据不同的任务选择合适的<strong>损失函数</strong></li>
<li>选择合适的<strong>优化算法</strong></li>
</ul></li>
<li>反复地训练模型、验证并调整超参数</li>
</ul>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>DL</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML: 基本语法</title>
    <url>/blogs/2024/08/04/html-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="html"><code>HTML</code></h1>
<h2 id="简介">简介</h2>
<h3 id="标记语言">标记语言</h3>
<p><code>HTML</code>(超文本标记语言)，它不是一种编程语言，而是使用一个个标签来构建一个网页的框架，一个<code>HTML</code>文档就是一个<code>WEB</code>网页(而浏览器内含解析其内容的解析器)；<code>CSS</code>负责网页的美化，<code>JS</code>负责网页的动态交互，而它负责网页的架构，<code>CSS</code>以及脚本都要在这个框架里定义</p>
<h3 id="和编程语言的区别">和编程语言的区别</h3>
<p><code>Markdown</code>就是一种标记语言，它们只是把一份文档通过标记来增加一些细节，然后展示出来，因此没有复杂的语法，只是定义了一个文档的结构、排布等。文档本身并没有实现部分，需要<strong>由解释器渲染</strong>才能有效展示。只有<code>HTML</code>代码的文档就是一静态网页，不会因为用户输入而发生实时变化(但可以将输入信息传输给服务器，及时更换一个新的网页，达到实时的效果)</p>
<p>而编程语言有更复杂的语法来实现更高效、多样的逻辑与功能，例如最基本的输入输出、计算、内存管理等。源文件本身包含许多底层的实现，经过翻译后可<strong>由系统执行</strong></p>
<h2 id="基本内容">基本内容</h2>
<h3 id="输出标签">输出标签</h3>
<p><code>HTML</code><strong>不区分大小写</strong>，使用一条条元素来构建网页，每条元素一般由一对标签作为头尾，标签夹着的文本为内容，而标签内部的参数对为属性(其值一般不会显示)，解释器通过标签及其属性来展现不同样式的内容；很多属性都与样式有关，这里尽量只介绍框架有关的属性。以下是常用标签：</p>
<ul>
<li><strong><code>&lt;!DOCTYPE html&gt;</code></strong>：这是一条声明，用于告诉浏览器使用特定的<code>HTML</code>版本解释器，这一条声明的是<code>html5</code></li>
<li><code>&lt;!-- message --&gt;</code>：用于注释，<code>message</code>只会在源代码中被看见</li>
<li><code>&lt;html&gt;&lt;/html&gt;</code>：这是一份<code>html</code>文档的开头与结尾，定义了一整个<code>html</code>文档</li>
<li><code>&lt;head&gt;&lt;/head&gt;</code>：定义文档的头部内容，包括编码方式(<code>meta</code>)、文档标题(<code>title</code>)、插入脚本(<code>scripts</code>块，可以在<code>&lt;body&gt;</code>中定义，但习惯在<code>&lt;head&gt;</code>中)、文档样式等，它们不呈现在网页主体中，而会被解释器接受。以下是常用的只在<code>&lt;head&gt;</code>中定义的元素
<ul>
<li><code>&lt;title&gt;&lt;/title&gt;</code>：定义了在浏览器顶部的网页名称</li>
<li><strong><code>&lt;meta&gt;</code></strong>：定义了文档信息的信息(即元数据)，例如属性<code>charset</code>指定了浏览器的编码方式，常见<code>&lt;meta charset="UTF-8"&gt;</code>指定编码方式保证中文不会出现乱码</li>
<li><strong><code>&lt;base&gt;</code></strong>：定义基准链接，即其它所有使用相对链接的元素都会相对基准链接，只能定义一次</li>
<li><code>&lt;link&gt;</code>：定义文档与外部资源的联系，例如链接外部<code>CSS</code></li>
</ul></li>
<li><code>&lt;body&gt;&lt;/body&gt;</code>：定义网页主体，其中内容将会展现给用户
<ul>
<li><code>&lt;header&gt;&lt;/header&gt;</code>：定义文档简介</li>
<li><strong><code>&lt;h&gt;&lt;/h&gt;</code></strong>：定义一行标题，从<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>标题等级递减，体现在文字加粗放大以及目录索引上</li>
<li><code>&lt;p&gt;&lt;/p&gt;</code>：定义一片段落文字，前后会添加换行</li>
<li><strong><code>&lt;a&gt;&lt;/a&gt;</code></strong>：定义一个链接，<code>href</code>属性指示链接地址<a href="https://www.baidu.com">链接</a>
<ul>
<li>链接可以是一个网页、锚点、本地文件、图片等，锚点链接即’#’开头的一串标记，类似于<code>Markdown</code>，这个标记可以是<code>id</code>或<code>name</code>属性的值</li>
</ul></li>
<li><strong><code>&lt;img&gt;&lt;/img&gt;</code></strong>：定义一张图片，<code>src</code>属性指示图片地址，<code>alt</code>属性指示当图片无法显示时的可作替换的文本内容</li>
<li><strong><code>&lt;table&gt;&lt;/table&gt;</code></strong>：定义一个表格，<code>border</code>属性指示其边框样式
<ul>
<li><code>&lt;tr&gt;&lt;/tr&gt;</code>：定义表格的一行(table row)
<ul>
<li><code>&lt;th&gt;&lt;/th&gt;</code>：定义表格的表头单元格(table
header)</li>
<li><code>&lt;td&gt;&lt;/td&gt;</code>：定义表格一般数据的单元格(table
data)</li>
</ul></li>
</ul></li>
<li><strong><code>&lt;ul&gt;&lt;/ul&gt;、&lt;ol&gt;&lt;/ol&gt;、&lt;dl&gt;&lt;/dl&gt;</code></strong>：定义无序(unordered)、有序(ordered)、自定义列表(definition)
<ul>
<li><code>&lt;li&gt;&lt;/li&gt;</code>：定义列表中的一项()</li>
<li><code>&lt;dt&gt;&lt;/dt&gt;</code>：定义自定义列表中的一项(definition
term)</li>
<li><code>&lt;dd&gt;&lt;/dd&gt;</code>：定义列表上一项的注释(definition
description)</li>
</ul></li>
<li>文本格式化的常用标签有如下：
<ul>
<li><code>&lt;br&gt;</code>：定义一次换行，可在<code>&lt;p&gt;</code>等内容中使用</li>
<li><code>&lt;hr&gt;</code>：定义一条水平分割线</li>
<li><code>&lt;b&gt;&lt;/b&gt;</code>与<code>&lt;i&gt;&lt;/i&gt;</code>：定义文字的<strong>粗体</strong>与<em>斜体</em>，它们是样式标签，属于无意义的文字加粗与倾斜，两者应作为最后的选择</li>
<li><strong><code>&lt;strong&gt;&lt;/strong&gt;</code>与<code>&lt;em&gt;&lt;/em&gt;</code></strong>：语义化标签，分别为<strong>特别强调</strong>与<em>一般强调</em>，可以做到<code>&lt;b&gt;</code>与<code>&lt;i&gt;</code>的效果，且在非视觉上(例如大声朗读)也有强调效果，这两者更常用</li>
<li><code>&lt;mark&gt;&lt;/mark&gt;</code>：定义<mark>高亮强调</mark>文字</li>
<li><code>&lt;small&gt;&lt;/small&gt;</code>：定义<small>小号</small>字体</li>
<li><code>&lt;sub&gt;&lt;/sub&gt;</code>与<code>&lt;sup&gt;&lt;/sup&gt;</code>：定义<sub>下标</sub>与<sup>上标</sup>字体</li>
<li><code>&lt;del&gt;&lt;/del&gt;</code>：定义<del>划线字</del></li>
</ul></li>
<li>其它类型字体渲染如下：
<ul>
<li><code>&lt;pre&gt;&lt;/pre&gt;</code>与<code>&lt;code&gt;&lt;/code&gt;</code>：定义<code>代码</code>字体，前者不会忽视制表符和回车</li>
<li><code>&lt;abbr&gt;&lt;/abbr&gt;</code>：定义缩略词，赋予<code>title</code>属性后当光标悬浮其上时将会显示出来<abbr title="缩略词">abbr</abbr></li>
<li><code>&lt;address&gt;&lt;/address&gt;</code>：其中应包含文档作者的相关信息如联系方式等，通常表现为斜体</li>
<li><code>&lt;blockquote&gt;&lt;/blockquote&gt;、&lt;q&gt;&lt;/q&gt;、&lt;cite&gt;&lt;/cite&gt;</code>：分别定义长(一个段落)、短(一句话)引用内容、引用来源。<q>&lt;q&gt;</q>、<cite>&lt;cite&gt;</cite>，前两种标签含<code>cite</code>属性，用于指示引用来源(链接)</li>
</ul></li>
</ul></li>
</ul>
<p>早期<code>html</code>标准存在一些无需加上关闭标签的元素，这在之后的<code>XHTML</code>标准(参考<code>XML</code>)中变为例如<code>&lt;br /&gt;</code>的自我封闭元素，而<code>HTML5</code>对<code>XHTML</code>兼容，所以<code>&lt;br&gt;、&lt;br/&gt;</code>都可以使用</p>
<p>这些元素可以被分为<strong>区块元素</strong>与<strong>内联元素</strong>，前者与后者相比，会在内容开头加上换行符表示这是新的区块；为了更好地排版和优化框架，有如下标签：</p>
<ul>
<li><strong><code>&lt;div&gt;&lt;/div&gt;</code></strong>：定义一块元素，即将其中的所有内容归纳为一个区块来管理，可以配合样式表进行整块的修饰</li>
<li><strong><code>&lt;span&gt;&lt;/span&gt;</code></strong>：定义一个内联元素，即将其中的所有内容归纳为一个内联元素来管理，样式由内容决定</li>
</ul>
<h3 id="输入标签">输入标签</h3>
<p><code>html</code>用表单来收集用户输入的信息，需要注意的是，<code>html</code>文档和解释器并不会处理这些信息，而是发送给服务器处理，处理后服务器会发送一个<strong>新的<code>html</code>文档</strong>给浏览器</p>
<ul>
<li><strong><code>&lt;form&gt;&lt;/form&gt;</code></strong>：定义一个收集信息的区域，含有些许控件用于检测事件后传输收集到的表单，<code>action</code>属性指定<strong>目标地址</strong>，<code>method</code>属性指定传输的方法
<ul>
<li><code>&lt;fieldset&gt;&lt;/fieldset&gt;</code>：定义表单的边框
<ul>
<li><code>&lt;legend&gt;&lt;/legend&gt;</code>：定义边框的标题</li>
</ul></li>
<li><strong><code>&lt;input&gt;</code></strong>：定义一个<strong>输入控件</strong>，<code>type</code>属性指定其类型，<code>id</code>属性指定其关联的<code>label</code>元素，<code>name</code>属性指定这个表单项的名字，<code>value</code>指定这个选项的内容</li>
<li><code>&lt;label&gt;&lt;/label&gt;</code>：定义一个表单项的标签，<code>for</code>属性指定这个表单项的<code>id</code></li>
<li><code>&lt;select&gt;&lt;/select&gt;</code>：定义一个<strong>可下拉选项</strong>，<code>name</code>属性指定这个表单项的名字
<ul>
<li><code>&lt;option&gt;&lt;/option&gt;</code>：定义一个选项，<code>value</code>属性指定这个选项的内容，<code>selected</code>属性指定这个下拉选项的预先选好的选项(否则为第一个<code>option</code>元素)</li>
</ul></li>
<li><code>&lt;textarea&gt;&lt;/textarea&gt;</code>：定义一个用于输入多行文本的控件，<code>cols</code>和<code>rows</code>分别定义其宽高</li>
</ul></li>
</ul>
<p><code>html5</code>提供的一些新控件如下：</p>
<ul>
<li><code>&lt;button&gt;&lt;/button&gt;</code>：定义一个按钮控件，其与<code>&lt;input type="button"&gt;</code>的区别为支持更丰富的内容(例如图像)。不要随意将<code>button</code>元素放在表单里，因为它相当于<code>&lt;input type="submit"&gt;</code>(提交按钮)</li>
</ul>
<h3 id="属性的值">属性的值</h3>
<ul>
<li><strong><code>id</code></strong>：每个<code>html</code>元素只有唯一的<code>id</code>，因此这个属性用于查找唯一值、设置锚点等</li>
<li><strong><code>name</code></strong>：<code>name</code>属性的一个值可以复用到多个<code>html</code>元素上，且会将它们绑定为一个整体传输数据；例如，单选框的所有选项的<code>name</code>属性应当一致，才能达到单选的效果。<code>name</code>属性是输入控件必不可少的一项，提交数据时只会提交含有<code>name</code>选项的元素</li>
<li><strong><code>value</code></strong>：指定该元素的内容，方便传输数据，有时可以改变；一些控件会显示它的值</li>
<li><code>&lt;option&gt;</code>的属性位：有<strong><code>selected</code></strong>(默认选中)、<code>disabled</code>(无法选中)、<code>hidden</code>(不显示该选项)</li>
<li><code>&lt;input&gt;</code>的<code>type</code>：其值有<code>text</code>(一般文本)、<code>submit</code>(提交按钮)、<code>radio</code>(单选框)、<code>checkbox</code>(复选框)、<code>reset</code>(重置按钮)、<code>button</code>(一般按钮)、<code>password</code>(密码文本，即隐藏文本)</li>
<li><code>&lt;input&gt;</code>的<code>checked</code>位：置位表示选中</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Markup Languages</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp: Effective Modern C++阅读笔记</title>
    <url>/blogs/2024/07/15/cpp-effective-moderncpp-reaction/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="effective-modern-c"><code>Effective Modern C++</code></h1>
<h2 id="关于类">关于类</h2>
<h3 id="初始化">初始化</h3>
<p><code>C++</code>丰富的语法中提供了三种对象的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>一般来说，对数组的初始化通常只用花括号，忽略等号</p>
<p>这样的初始化会带来对类类型的疑惑，这里复习一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class a = ClassObj;	<span class="comment">// 调用复制构造函数.</span></span><br><span class="line">a = ClassObj;		<span class="comment">// 调用重载赋值运算符.</span></span><br></pre></td></tr></table></figure>
<p><code>C++</code>通过花括号来实现统一初始化，只有花括号能在任何地点使用，既不会被看作函数声明，也可用在不可拷贝类上，你也可以自定义初始化列表构造函数，编译器会优先调用它而不是其它构造函数，只有在这种情况下，可以考虑使用圆括号调用其它构造函数，但如果需要自定义，一定需要三思，因为用户可能因这个自定义而疑惑</p>
<p>一种边缘情况是，在一个类既有默认<code>ctor</code>又有自定义初始化列表<code>ctor</code>的时候，传递空花括号时编译器会选择默认<code>ctor</code></p>
<p>使用花括号唯一的限制是不能对内部表达式进行变窄转换(而其它两种因向下兼容问题不会检查这种转换)</p>
<p>总而言之，无论是作为库开发者还是库使用者，应该注意是否含有初始化列表<code>ctor</code>，事实上<code>()</code>与<code>{}</code>各有优劣，但后者使用更广</p>
<h3 id="成员函数的引用限定符">成员函数的引用限定符</h3>
<p>在<code>C++11</code>中，增加了两种限制调用成员函数的情况，即调用左/右值的成员函数，与<code>const</code>一样，可以作为签名区分两个重名函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">// 这两个限定符要放在const后.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;	<span class="comment">// 左值限定符,只有左值能够调用它.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member</span><span class="params">()</span> <span class="type">const</span> &amp;&amp;</span>;	<span class="comment">// 右值限定符,只有右值能够调用它.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3
id="对于容器优先使用常量迭代器和非成员迭代器函数">对于容器优先使用常量迭代器和非成员迭代器函数</h3>
<p>优先考虑常量迭代器不难理解，优先使用非成员迭代器函数的原因是：</p>
<ul>
<li>原生<code>C</code>数组不能使用成员函数，可能还有更多情况</li>
<li>自由函数拥有更大的通用性，因为可以随时添加对某个特定容器的特例化版本，而不用对这个数据结构进行改动</li>
</ul>
<h3
id="构造函数析构函数虚函数赋值运算符">构造函数、析构函数、虚函数、赋值运算符</h3>
<ul>
<li><p>多态性决定了，可以通过用基类指针来使用子类方法，对于这种基类，应将析构函数声明为虚拟的；因为使用的是子类的数据，就应该使用子类的析构函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Son</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* Obj = <span class="keyword">new</span> Son;	<span class="comment">// 应该调用Son的析构函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不在构造、析构函数中使用虚函数，原因很简单，编译器会先构造父类，再构造子类，而一旦在构造父类对象时调用虚函数，那么就会调用一个尚未构造的子类对象的成员函数，这是危险的；析构函数同理，先析构子类对象再析构父类对象，在调用虚函数时子类对象早已销毁了</p></li>
<li><p>永不从析构函数中抛出异常，就算需要抛出异常，也应由析构函数捕获并终止程序</p></li>
<li><p>在实现使用堆内存类的赋值运算符重载时，需要考虑自我赋值的情况，一般不能先释放自身内存再拷贝右值资源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  Class&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Class&amp; rhs) &#123;</span><br><span class="line">      <span class="comment">// delete data;	// 错误!万一rhs是自己呢?</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (rhs == <span class="keyword">this</span>) &#123;<span class="keyword">return</span> *<span class="keyword">this</span>; &#125;	<span class="comment">// 正确做法一:检查,但会使代码量增加.</span></span><br><span class="line">      </span><br><span class="line">      Class* tmp &#123;data&#125;;	<span class="comment">// 正确做法二:先记住原先data,不会增加代码,但有暂时空间开销.</span></span><br><span class="line">      data = <span class="keyword">new</span> <span class="built_in">type</span>(rhs.data);	<span class="comment">// 复制,这里已经创建新副本.</span></span><br><span class="line">      <span class="keyword">delete</span> tmp;		<span class="comment">// 删除原先data.</span></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 保证常成员函数的线程安全</span><br><span class="line"></span><br><span class="line">线程安全是指，需要在并发环境下，保证获取、改变资源的安全：</span><br><span class="line"></span><br><span class="line">- 一般来说，同时调用多个**只有读操作**的常成员函数不会造成线程安全问题</span><br><span class="line">- 当多线程同时工作时，如果含有写线程，则可能引起**数据竞争**，即有不同线程同时修改共享数据，这破坏了线程安全，例如：</span><br><span class="line">- 多窗口同时售票情景，需要保证已取走的共享资源不会被其它线程访问</span><br><span class="line">- `C+<span class="number">+11</span>`引入`<span class="keyword">mutable</span>`，它只能修饰成员变量，表示数据一直可变(**即使在`<span class="type">const</span>`成员函数中**)。例如，它可用于缓存已计算的值，这使得`<span class="type">const</span>`成员函数只需要计算第一次，而在之后都访问这个结果。由于它能在常成员函数中被改变，所以即使是`<span class="type">const</span>`成员函数，也引发了线程安全问题</span><br><span class="line"></span><br><span class="line">有以下几种方式保证线程安全：</span><br><span class="line"></span><br><span class="line">- 使用`std::mutex`，即互斥量：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">          <span class="function">lock_guard&lt;mutex&gt; <span class="title">lg</span><span class="params">(m)</span></span>;	<span class="comment">// 锁住互斥量m,使其它线程无法访问.</span></span><br><span class="line">          <span class="keyword">if</span> (!Value) &#123;	<span class="comment">// 如果没有记录.</span></span><br><span class="line">              Compute;	<span class="comment">// 计算并记录.</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Value;	<span class="comment">// 返回结果.</span></span><br><span class="line">      &#125;	<span class="comment">// 解锁m.</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">mutable</span> mutex m;	<span class="comment">// 由于lock_guard调用非常成员函数,所以要声明multable.</span></span><br><span class="line">      <span class="keyword">mutable</span> Type Value;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用互斥量开销较大，可使用<code>std::atomic</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">mutable</span> atomic&lt;<span class="type">unsigned</span>&gt; cnt;	<span class="comment">// 只是用于记录调用次数.</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">当然，如果能保证一个常成员函数不会发生在并发环境或者不会发生写操作，那么它的线程安全是无关紧要的</span><br><span class="line"></span><br><span class="line">### 为类型信息添加类型萃取类`type_traits`</span><br><span class="line"></span><br><span class="line">假设需要统一不同类的接口，而这些类的一些类型在实现上有区别，最好使用类型萃取来管理这些类型信息</span><br><span class="line"></span><br><span class="line">例如，`C++ STL`的迭代器类型就依靠这种技术：</span><br><span class="line"></span><br><span class="line">- 链表与数组的迭代器是不同的，前者是一个具体类，而后者只是原生指针</span><br><span class="line">- 使用部分模板特化，对类型信息进行萃取，并使算法端通过这个萃取类来访问迭代器</span><br><span class="line">- 萃取类尝试获取容器的迭代器类，如果没有，则返回原生指针</span><br><span class="line">- 这样就分开了算法与容器，使得算法不用考虑迭代器的实现，而总是获取到想要的迭代器</span><br><span class="line"></span><br><span class="line">使不同的类型包括自定义类、基础数据类型等有统一的类型名，实现统一的接口，这就是类型萃取的任务</span><br><span class="line"></span><br><span class="line">## 智能指针</span><br><span class="line"></span><br><span class="line">使用智能指针需要包含头文件`&lt;memory&gt;`</span><br><span class="line"></span><br><span class="line">### `std::unique_ptr`管理独占资源</span><br><span class="line"></span><br><span class="line">在以前的`C++`版本中，智能指针由`std::auto_ptr`担任，但`auto_ptr`是在`C+<span class="number">+11</span>`之后被废弃的，它有如下问题：</span><br><span class="line"></span><br><span class="line">- 智能指针是类，设计原意为拥有原生指针的功能，并且能避开原生指针的坑，例如使用的是栈空间还是堆空间？如果使用堆空间，那么它是单个对象还是数组(决定使用`<span class="keyword">delete</span>`还是`<span class="keyword">delete</span>[]`)？</span><br><span class="line">- 用拷贝方法来实现资源转移，但为了保证资源所有权唯一，**原本的副本会被赋值`<span class="literal">nullptr</span>`**，对于其它指向这块副本的智能指针来说是危险的；在语义上，给人<span class="string">&quot;拷贝&quot;</span>的错觉，但其实并非拷贝</span><br><span class="line">- 仍然需要手动`<span class="keyword">delete</span>`</span><br><span class="line"></span><br><span class="line">而`unique_ptr`拥有如下优势：</span><br><span class="line"></span><br><span class="line">- 用移动方法来实现资源转移，不允许拷贝，这在语义上是很清晰的</span><br><span class="line">- 与智能指针的初衷一样，每个`unique_ptr`拥有唯一的资源(除非它是`<span class="literal">nullptr</span>`)，每份资源对应唯一的`unique_ptr`，不会导致多次`<span class="keyword">delete</span>`</span><br><span class="line">- 非`<span class="literal">nullptr</span>`指针析构时自动释放指向的资源，能安全地`<span class="keyword">delete</span>`</span><br><span class="line"></span><br><span class="line">所以对于独占资源，最好使用`unique_ptr`来管理，如果使用原生指针，则很有可能因多次`<span class="keyword">delete</span>`而出错</span><br><span class="line"></span><br><span class="line">### `std::shared_ptr`管理共享资源</span><br><span class="line"></span><br><span class="line">通过`shared_ptr`，`C++`拥有一套自动垃圾回收，且可预测回收时机的系统。它使用的垃圾回收策略是**引用计数**，事实上很多语言并不使用这套策略，因为它有一些问题：</span><br><span class="line"></span><br><span class="line">- 只有在最后一个引用对象析构时，`shared_ptr`会`<span class="keyword">delete</span>`掉这部分资源，但对循环引用的资源无效</span><br><span class="line">- 性能上的问题：它需要同时维护一个引用计数，而且这个引用计数是动态分配的</span><br><span class="line">- 每个`shared_ptr`只对应一个控制块，即一份资源，但每个`shared_ptr`控制块互相不关联，这导致下面这个问题：</span><br><span class="line">  - 通过原始指针创建一个`shared_ptr`，将同时**创建一个控制块**，接下来正常应该只通过它来管理，但如果再次用**同一原始指针**创建新的`shared_ptr`，**尽管它们指向的内存相同**，它依旧会创建一个**新的控制块**，这将导致重复`<span class="keyword">delete</span>`</span><br><span class="line">- 用`shared_ptr`管理的资源应该在堆上，因为它总想使用`<span class="keyword">delete</span>`来释放这份资源</span><br><span class="line"></span><br><span class="line">尽量养成以下习惯：</span><br><span class="line"></span><br><span class="line">- 使用`make_shared`来创建控制块而不是传递一个原始指针，它保证在堆上创建新对象，而这个新对象肯定不会与其它控制块关联</span><br><span class="line">- 通过传递`shared_ptr`或`weak_ptr`来创建新引用，这样不会创建新的控制块</span><br><span class="line">- 由于有额外开销，尽量只在共享资源上使用它</span><br><span class="line">- 使用`weak_ptr`辅助可能悬空的`shared_ptr`</span><br><span class="line">  - ``weak_ptr`是`shared_ptr`的升级，当它悬空时，`expired`函数返回`<span class="number">1</span>`，但是，它无法解引用，通常来说，`weak_ptr`用于观测一份资源，或用在循环引用中打破循环的引用计数</span><br><span class="line">- 不混用智能指针和原始指针</span><br><span class="line"></span><br><span class="line">### 使用`make`函数而不是`<span class="keyword">new</span>`</span><br><span class="line"></span><br><span class="line">常用的`make`函数有`make_unique`(`C+<span class="number">+14</span>`)和`make_shared`(`C+<span class="number">+11</span>`)，这有以下好处：</span><br><span class="line"></span><br><span class="line">- 两种方式的区别：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">  <span class="keyword">auto</span> upObj&#123;std::<span class="built_in">make_unique</span>&lt;Class&gt;()&#125;;	<span class="comment">// 调用函数申请一份Class资源.</span></span><br><span class="line">  std::unique_ptr&lt;Class&gt; upObj &#123;<span class="keyword">new</span> Class&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>光是这样看似乎没有区别，但后者隐含了<strong>异常安全</strong>问题，因为在调用<code>new</code>和调用<code>unique_ptr</code>构造函数间有一层空隙，如果在这时出现异常，那么已<code>new</code>的资源无法被<code>unique_ptr</code>管理，造成<strong>内存泄漏</strong>；而前者安全性更高</p></li>
<li><p>但是，<code>make</code>函数不支持自定义删除器和花括号初始化，在这些情况下<code>make</code>函数不好用</p></li>
</ul>
<h2 id="优先考虑的关键字与场景">优先考虑的关键字与场景</h2>
<h3
id="优先使用nullptr而不是0或null">优先使用<code>nullptr</code>而不是<code>0</code>或<code>NULL</code></h3>
<ul>
<li><code>NULL</code>是<code>0LL</code>的宏定义，与<code>0</code>都被看作数值，只有在必须转换成指针时才会转换，这样的优先度使得当遇到重载的数值参数函数和指针参数函数时，调用<code>func(NULL)</code>可能不是你想要的</li>
<li><code>nullptr</code>增加了类型安全的保险，它只能隐式转换成任意的指针类型，编译器不会将它视为数值</li>
<li><code>nullptr</code>是向后兼容的，可以完美替换掉老代码中的<code>NULL</code></li>
<li><code>nullptr</code>可以直接使用，那么应该是某种类型的实例化，标准定义为<code>decltype(nullptr)=std::nullptr_t</code></li>
</ul>
<h3
id="优先使用using而不是typedef进行重命名">优先使用<code>using</code>而不是<code>typedef</code>进行重命名</h3>
<ul>
<li><p><code>typedef TypeName OtherName</code>与<code>using OtherName = TypeName</code>都是将<code>TypeName</code>重命名为<code>OtherName</code>，某些情况下<code>using</code>可读性更高，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*OtherName)</span><span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;	<span class="comment">// 将这个函数指针类型重命名为OtherName.</span></span><br><span class="line"><span class="keyword">using</span> OtherName = <span class="built_in">void</span> (*)<span class="built_in">func</span>(<span class="type">int</span>);<span class="comment">// 效果相同.</span></span><br></pre></td></tr></table></figure></li>
<li><p>在模板类型的重命名上，<code>using</code>更简洁实用，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">basic_List</span>&lt;T, Alloc&lt;T&gt;&gt; &#123;&#125;;</span><br><span class="line">  <span class="comment">// 为了让用户声明List&lt;T&gt;时就像声明basic_List&lt;T, Alloc&lt;T&gt;&gt;时一样.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	<span class="comment">// typedef是做不到的,最多只能嵌套在结构体内.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListType</span> &#123;</span><br><span class="line">      <span class="keyword">typedef</span> basic_List&lt;T, Alloc&lt;T&gt;&gt; type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 并且由于这个类依赖于T, 在其它模板类使用时需要在前面加typename让编译器将它视为类型.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">UseList</span> &#123;</span><br><span class="line">  	<span class="keyword">typename</span> ListType&lt;T&gt;::type _M_List;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 而using则简单很多.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">using</span> List = basic_List&lt;T, Alloc&lt;T&gt;&gt;;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">UseList</span> &#123;</span><br><span class="line">  	List&lt;T&gt; _M_List;	<span class="comment">// 正常使用,达成目的.</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">### 优先使用限域`<span class="keyword">enum</span>`而不是非限域</span><br><span class="line"></span><br><span class="line">非限域`<span class="keyword">enum</span>`指，一个枚举类型的所有内含名在这个`<span class="keyword">enum</span>`所在的作用域都不可再使用，如果没有限定在命名空间里或限域，这些内含名就会泄露到整个文件中</span><br><span class="line"></span><br><span class="line">限域指`C+<span class="number">+11</span>`的一个新特性：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ENUM</span> &#123; A, B, C &#125;;<span class="comment">// 在枚举类型前加class,将枚举名限定在花括号内,且总可以前置声明.</span></span><br><span class="line"><span class="keyword">auto</span> a = ENUM::A;	<span class="comment">// 通过枚举类型访问枚举名.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优先考虑auto而不是显式声明类型"><a
href="#auto">优先考虑<code>auto</code>而不是显式声明类型</a></h3>
<h3
id="优先使用delete而不是未定义的私有函数">优先使用<code>delete</code>而不是未定义的私有函数</h3>
<p>当不希望用户使用一个类的构造函数，而编译器又会偷偷提供时，以前的做法是在私有域内声明，且不定义它们，但这样会使友元或成员函数有潜在的使用风险，道理很简单，应该使用<code>delete</code>关键字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>delete</code>不止可用于成员函数，它能用于任何函数以处理隐式转换的弊端：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">// 如果希望只接受int,而不是char,bool,double,就删除它们.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;	<span class="comment">// float会先转换成double,所以这条同时删除了float.</span></span><br></pre></td></tr></table></figure>
<p>它也能用于删除特化模板的实例化</p>
<h3
id="优先使用noexcept只要函数不抛出异常">优先使用<code>noexcept</code>只要函数不抛出异常</h3>
<p><code>C++11</code>引入的<code>noexcept</code>在以前是<code>throw()</code>，但拥有更多的优化灵活</p>
<p>对于一个绝对不会抛出异常的函数来说，可以在后面添加<code>noexcept</code>来承诺，允许编译器<strong>极尽所能优化</strong>生成的代码</p>
<p>而且，<code>noexcept</code>可视条件优化，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>;</span><br></pre></td></tr></table></figure>
<p>即只要提供不抛异常的<code>swap(*,*)</code>，那么<code>swap(&amp;,&amp;)</code>就是不抛异常的</p>
<p>使用<code>except</code>需要考虑改动，因为只要承诺了，就要考虑用户的使用，未来一旦改动，那么向下的代码都有可能出现问题，一般而言，<strong>移动、交换、内存释放</strong>等相关函数能靠<code>noexcept</code>得到相当大的优化</p>
<h3 id="尽可能使用constexpr">尽可能使用<code>constexpr</code></h3>
<p><code>constexpr</code>是<code>C++11</code>引入的关键字，从文字上来看，是<code>const</code>与<code>expr</code>的组合，即常量表达式：</p>
<ul>
<li>对于<code>constexpr</code>对象而言，与<code>const</code>对象不同的是它需要在编译期就决定，即编译期常量</li>
<li>对于<code>constexpr</code>函数而言，如果传递<code>constexpr</code>对象，函数会返回一个编译期常量，否则将在运行时计算；注意这不表示函数返回一个<code>const</code>值，而是”如果传递编译期常量参数，则返回值可作为编译期常量”</li>
<li>注意在<code>C++11</code>中，只能用<code>1</code>条<code>return</code>语句，而在<code>C++14</code>中限制减小了</li>
<li>注意<code>constexpr</code>与<code>const</code>、<code>noexcept</code>同为接口的一部分，如果未来可能修改，那么最好不要使用它们</li>
</ul>
<h2 id="类型推导细则">类型推导细则</h2>
<h3 id="模板类型推导">模板类型推导</h3>
<p>通常通过定义模板类或模板函数来减少代码量，使用模板所要求的是，每个使用过它的<code>.cpp</code>都能直接看见它的定义，即声明与定义应该放在同一份头文件内</p>
<p>因为不同参数类型的模板作为头文件在展开时需要实例化，而展开过程在预处理期，所以当声明与定义分开时，将因头文件找不到定义而展开失败，导致无法编译</p>
<p>而一般头文件的展开只是复制粘贴而已，不影响编译，那么整个过程就不会出错</p>
<p>放在一起时编译器会丢弃重复的实例化，最后随机保留一份；事实上<code>inline</code>、<code>module</code>等新特性正在致力于将所有定义放进头文件内或直接不使用头文件</p>
<p>通常来说，对于一个模板，编译器会对<code>T</code>与<code>ParamType</code>推导类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(ParamType Param)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>ParamType</code>可以有一些修饰符，但终究<code>ParamT</code>会被推导为非引用非指针类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; Param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里函数签名内的<code>T</code>会推导成模板参数<code>T</code>，这是最简单的情形：当传入的<code>ParamType</code>是一个指针或一个非通用引用时(只能作为左值或右值之一的引用)，<code>T</code>就会是非引用非指针类型</p>
<p>如果<code>ParamType</code>为通用引用(既可能是左值，也可能是右值)，在作为右值时当然与上述情况相符，但作为左值时，考虑以下模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; Param)</span></span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">func</span>(x);	<span class="comment">// 此时Param为左值,推导出不正常的T = int&amp;.</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>);	<span class="comment">// 此时Param为右值,推导出T为正常的T = int, ParamType为int&amp;&amp;.</span></span><br></pre></td></tr></table></figure>
<p>只有在引入了右值引用的<code>C++11</code>中才出现通用引用，在类型推导时会区分引用的左值与右值</p>
<h3 id="auto类型推导"><code>auto</code>类型推导<a id="auto"></a></h3>
<p>一般进行<code>auto</code>的情况有例如申请迭代器等场合，事实上除了推导花括号的初始化外，其它情况均与模板推导相同，而对于内部元素类型相同的花括号，<code>auto</code>能够成功推出它是一个初始化列表，以及它的模板参数</p>
<p><code>auto</code>声明变量一定要求初始化，这在很多情况下比不用<code>auto</code>要<strong>安全</strong>；除此之外，使用它也可以解决某些<strong>移植性问题</strong></p>
<p><code>auto</code>也可用于函数返回类型的自动推导，但单独使用<code>auto</code>推导返回类型比较少用，由于与模板推导是及其类似的，推出的类型大部分情况下是<strong>非引用非指针</strong>类型的，这在很多情况下会造成麻烦</p>
<p>使用<code>auto</code>时需注意一些特殊情况，例如隐藏的代理类调用：</p>
<p>例如对一个<code>vector</code>容器，它在实现<code>bool</code>时<strong>采取<code>1</code>位存储</strong>，由于<code>C++</code>不允许对位的引用，导致<code>vector&lt;bool&gt;</code>的<code>operator[]</code>只能返回一个代理类<code>vector&lt;bool&gt;::reference</code>对象来模仿引用的行为，这时使用<code>auto</code>推导出的对象是实实在在会改变容器的(而不像其它类型返回的是值)</p>
<p>在上述情况下，可以考虑使用显式类型转换器，这能保证既进行了初始化，又进行了类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> value = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(vec[<span class="number">0</span>]);	<span class="comment">// 结果为bool.</span></span><br><span class="line"><span class="keyword">auto</span> reference = vec[<span class="number">0</span>];	<span class="comment">// 结果为vector&lt;bool&gt;::reference.</span></span><br></pre></td></tr></table></figure>
<p>当然，一般的<code>bool</code>空间是八位，一个字节，可以用<code>bool&amp;</code></p>
<h3 id="decltype"><code>decltype</code></h3>
<p><code>decltype</code>是<code>C++11</code>新增的关键字，用于在编译期推导出表达式内的类型，并用这个类型作为后面变量的类型</p>
<p>它与<code>auto</code>强制要求初始化不同，它只是帮你推导出你提供的表达式最终的类型而已，而且它与模板类型推导规则是不同的，对非直接变量名进行<code>decltype</code>，通常<strong>返回它的引用</strong></p>
<p><code>decltype</code>通常与尾置返回类型相匹配使用，尾置返回类型这个<code>C++11</code>引入的新特性在声明复杂函数时有奇效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义返回一个一维数组类型的函数.</span></span><br><span class="line"><span class="built_in">int</span> (* <span class="built_in">func</span>(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n) )[<span class="number">3</span>];	<span class="comment">// 一般声明.</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[3]</span>;	<span class="comment">// 尾置返回类型声明.</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>auto</code>不代表让编译器自动推导类型，而是告诉编译器使用尾置类型</p>
<p>但当函数复杂度极高时，例如定义一个返回上述<code>func()</code>的指针的函数时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ptf</span><span class="params">()</span> -&gt; <span class="title">int</span> <span class="params">(*func(<span class="type">int</span>[][<span class="number">3</span>],<span class="type">int</span>))</span>[3]</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ptf</span><span class="params">()</span> -&gt; <span class="title">decltype</span><span class="params">(func)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这并没有快捷多少，所以<code>decltype</code>就派上用场了</p>
<p>还有一个场景，设想一个<code>operator[]</code>函数，我们需要它返回元素的引用：</p>
<ul>
<li><code>auto</code>会去除引用</li>
<li><code>decltype</code>将推导出引用类型</li>
</ul>
<p>那么组合起来，就像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> -&gt; <span class="title">decltype</span><span class="params">(arr[n])</span></span>;</span><br><span class="line"><span class="comment">// 或:</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>decltype(auto)</code>是指，让编译器自动推导类型，并且使用<code>decltype</code>的规则</p>
<p>将数组推广为容器，那么通常传的是它的引用，这意味着只能传左值引用，事实上，虽然传入临时对象返回它的元素的引用是未定义的，但极限情况是有用的，如果需要支持它，可以使用通用引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">func</span><span class="params">(Container&amp;&amp; c, Index i)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Programming</category>
        <category>C/Cpp</category>
      </categories>
      <tags>
        <tag>reaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt: 数据库连接</title>
    <url>/blogs/2024/06/30/cpp-qt-database/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="数据库">数据库</h1>
<h2 id="介绍">介绍</h2>
<p>数据库分两种，关系型(<code>Relational Database</code>)和非关系型(<code>Not Only SQL</code>)，它们的区别：</p>
<ul>
<li><code>RDBMS</code>：使用表格存储数据；具有强大的查询性能；但只能存储在硬盘，读写性能较差</li>
<li><code>NoSQL</code>：提供多种存储数据的结构；不支持<code>SQL</code>，查询方面差；但可使用<code>RAM</code>，数据量大时有优势</li>
</ul>
<p>数据库必须符合<code>ACID</code>：</p>
<ul>
<li><code>Atomicity</code>：事务若执行失败，数据库能恢复到事务开始前的状态</li>
<li><code>Consistency</code>：写入的数据必须符合预设规则，否则事务执行失败</li>
<li><code>Isolation</code>：允许并发事务的存在，是线程安全的</li>
<li><code>Durability</code>：数据及其修改是永久存在的(体现在保存于硬盘上)</li>
</ul>
<p><code>SQL</code>(<code>Structured Query Language</code>，结构化查询语言)是用于操作数据库的语言</p>
<p>不同数据库提供的<code>SQL</code>不一样，所以常出现在数据库的名字里</p>
<p>目前常用的开源数据库有：</p>
<ul>
<li><code>SQLite</code>：轻量的数据库</li>
<li><code>MySQL</code></li>
<li><code>PostegreSQL</code></li>
</ul>
<p><a
href="https://blog.csdn.net/qq_54621492/article/details/139901605"><code>Navicat</code></a>是一款能直观地操作数据库的应用</p>
<h2 id="sql标准"><code>SQL</code>标准</h2>
<h3 id="杂碎知识">杂碎知识</h3>
<ul>
<li>虽然不同数据库的<code>SQL</code>语法有差别(实现上也不同)，但它们都遵循<code>SQL</code>标准</li>
<li><code>SQL</code>是不区分大小写的</li>
<li>称表的一行为一条记录</li>
<li>通过<code>CREATE DATABASE dbName</code>创建数据库</li>
<li>文本数据需要添加单引号或双引号；当文本数据是一个数字时，需要仔细检查</li>
</ul>
<h3 id="常用数据类型">常用数据类型</h3>
<ul>
<li>文本类型：
<ul>
<li><code>CHAR(N)</code>：长度固定为<code>N</code>的字符串，文本长度不足则用空格补充，<code>N</code>最长一般为<code>65535</code></li>
<li><code>VARCHAR(N)</code>：长度可变的字符串，最长为<code>N</code></li>
<li><code>TEXT</code>：适用于长文本</li>
</ul></li>
<li>数值类型：
<ul>
<li><code>INT/INTEGER</code>：<code>4</code>字节整型</li>
<li><code>SMALLINT</code>：<code>2</code>字节整型</li>
<li><code>BIGINT</code>：<code>8</code>字节整型</li>
<li><code>FLOAT(D)</code>：小数位最多为<code>D</code>的浮点数</li>
<li><code>DECIMAL(M, D)</code>：总位数为<code>M</code>，小数位数为<code>D</code>的浮点数</li>
</ul></li>
<li>时间类型：
<ul>
<li><code>DATE</code>：存储日期<code>YYYY-MM-DD</code></li>
<li><code>TIME</code>：存储时间<code>HH:MM:SS</code></li>
<li><code>DATETIME</code>：存储日期时间<code>YYYY-MM-DD HH:MM:SS</code></li>
</ul></li>
<li>其它：
<ul>
<li><code>BLOB</code>：存储大量二进制数据(如图片、音频等)</li>
<li><code>ENUM</code>：枚举类型</li>
</ul></li>
</ul>
<h3 id="查询语句">查询语句</h3>
<p>查询结果是类似于表的结构，对数据库的许多操作需要配合查询语句一起使用</p>
<p><strong><code>SELECT</code>系列语句用于确定列，<code>WHERE</code>系列语句用于确定行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询列</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tableName;    # 查询整个表</span><br><span class="line"><span class="keyword">SELECT</span> columnNameList <span class="keyword">FROM</span> tableName; # 查询特定列, 列间用逗号隔开</span><br><span class="line"></span><br><span class="line"># 查询时过滤记录</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ... ;     # <span class="keyword">DISTINCT</span>: 查询后,自动去除完全重复的记录</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> <span class="keyword">condition</span>;    # <span class="keyword">WHERE</span> <span class="keyword">condition</span>: 按<span class="keyword">condition</span>过滤记录</span><br><span class="line"></span><br><span class="line"># <span class="keyword">condition</span>的编写: 在查询时, 若表达式返回真, 则加入查询结果</span><br><span class="line"># 格式          返回真的情况</span><br><span class="line">columnName <span class="operator">&gt;</span><span class="operator">/</span><span class="operator">=</span><span class="operator">/</span><span class="operator">&lt;</span> <span class="keyword">value</span>     # 和值比较</span><br><span class="line">columnName <span class="keyword">IS</span> <span class="keyword">NULL</span>      # 空值</span><br><span class="line">columnName <span class="keyword">BETWEEN</span> val1 <span class="keyword">AND</span> val2  # 介于val1, val2间的值</span><br><span class="line">columnName <span class="keyword">IN</span> (val1, ...)    # 等于括号内任意值</span><br><span class="line">columnName <span class="keyword">LIKE</span> val      # <span class="keyword">LIKE</span>模糊查询</span><br><span class="line">columnName REGEXP val     # 正则表达式匹配</span><br><span class="line">columnName GLOB val      # SQLite支持GLOB匹配</span><br><span class="line"></span><br><span class="line"># <span class="keyword">condition</span>语句编写</span><br><span class="line"># 括号优先级最高; 若不熟悉运算符的优先级, 可以直接打括号</span><br><span class="line">exp1 <span class="keyword">AND</span> exp2       # 逻辑与</span><br><span class="line">exp1 <span class="keyword">OR</span> exp2       # 逻辑或</span><br><span class="line"><span class="keyword">NOT</span> exp         # exp的否定</span><br><span class="line"></span><br><span class="line"># 在<span class="keyword">condition</span>后可添加<span class="keyword">ORDER</span> <span class="keyword">BY</span>语句, 表示按列排序</span><br><span class="line"># 默认为<span class="keyword">ASC</span>(上到下升序), <span class="keyword">DESC</span>为上到下降序</span><br><span class="line"># 若有复数个列, 则按顺序排序(可认为是先排最后列, 再排第一列)</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> columnNames <span class="keyword">ASC</span> <span class="operator">/</span> <span class="keyword">DESC</span>;</span><br><span class="line"># 例: 对下表查询<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, id; (先排id, 再排name)</span><br><span class="line">id <span class="operator">|</span> name <span class="comment">---&gt; id | name ---&gt; id | name</span></span><br><span class="line"><span class="number">3</span>  a    <span class="number">1</span>  b    <span class="number">2</span>  a</span><br><span class="line"><span class="number">1</span>  b    <span class="number">2</span>  a    <span class="number">3</span>  a</span><br><span class="line"><span class="number">2</span>  a    <span class="number">3</span>  a    <span class="number">1</span>  b</span><br><span class="line"></span><br><span class="line"># 起别名:</span><br><span class="line"># 在查询语句中, 所有涉及表名、列名的语句, 可在名字后添加 <span class="keyword">AS</span> 别名, 查询结果将使用别名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">AS</span> newName;</span><br></pre></td></tr></table></figure>
<p><code>LIKE</code>通配符：</p>
<ul>
<li><code>%</code>：匹配任意数目的字符</li>
<li><code>_</code>：匹配单个字符</li>
<li>若字段中含通配符，可通过<code>ESCAPE</code>转义字符：<code>LIKE 'a\_b' ESCAPE '\'</code></li>
</ul>
<h3 id="对表内容的操作">对表内容的操作</h3>
<p>对表内容的操作一定记得联合查询语句一起使用，否则可能会修改所有记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 更改记录内容</span><br><span class="line"># <span class="keyword">WHERE</span>指定要修改的行, <span class="keyword">SET</span>指定要修改的列</span><br><span class="line"><span class="keyword">UPDATE</span> tableName <span class="keyword">SET</span> column1<span class="operator">=</span>value1,...,columnN<span class="operator">=</span>valueN <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"># 删除具体记录(配合查询语句)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tableName <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"># 插入新记录</span><br><span class="line"><span class="keyword">INSERT</span> tableName (columnList) <span class="keyword">VALUES</span> (valueList);</span><br><span class="line"></span><br><span class="line"># 以上为对列进行修改的语句, 而更新表的列需要用到<span class="keyword">ALTER</span>系列语句</span><br><span class="line"># 添加列</span><br><span class="line"><span class="keyword">ALTER TABLE</span> tableName <span class="keyword">ADD</span> columnName valueType</span><br><span class="line"></span><br><span class="line"># 删除列(SQLite不支持)</span><br><span class="line"><span class="keyword">ALTER TABLE</span> tableName <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> columnName</span><br><span class="line"></span><br><span class="line"># 更改列的数据类型及其约束</span><br><span class="line"><span class="keyword">ALTER TABLE</span> tableName MODIFY <span class="keyword">COLUMN</span> columnName valueType</span><br><span class="line"></span><br><span class="line"># 修改列名</span><br><span class="line"><span class="keyword">ALTER TABLE</span> tableName CHANGE columnName newName;</span><br><span class="line"></span><br><span class="line"># 需要检查的情况(需要设置主键约束):</span><br><span class="line"># 记录不存在则插入、存在则更新</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">OR</span> REPLACE <span class="keyword">INTO</span> ...  # SQLite</span><br><span class="line">REPLACE <span class="keyword">INTO</span> ...    # MySQL</span><br><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> ...   # 记录不存在则插入、存在则忽略操作</span><br></pre></td></tr></table></figure>
<h3 id="对表整体的操作">对表整体的操作</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"># 列名不是数据, 不用加引号</span><br><span class="line"><span class="keyword">CREATE TABLE</span> tableName (</span><br><span class="line"> columnName dataType,   # 列名 该列的数据类型 逗号分隔开不同列</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 用oldTable的查询结果作为内容, 创建新表</span><br><span class="line"><span class="keyword">CREATE TABLE</span> newTable <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> oldTable;</span><br><span class="line"></span><br><span class="line"># 用oldTable的查询结果作为内容, 插入 已创建 的表里</span><br><span class="line"><span class="keyword">INSERT INTO</span> exTable (columnList) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> oldTable;</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line"><span class="keyword">ALTER TABLE</span> tableName RENAME <span class="keyword">TO</span> newName;</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tableName;</span><br><span class="line"></span><br><span class="line"># 删除表的所有数据, 保留表</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tableName;   # 一次性删除所有记录</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tableName;    # 找出所有行, 逐个删除(<span class="keyword">DELETE</span>还可用于删除特定行)</span><br></pre></td></tr></table></figure>
<h3 id="部分关键字">部分关键字</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建<span class="operator">/</span>删除表时, 判断表是否不存在<span class="operator">/</span>存在:</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ...;   # 若表不存在, 才创建</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> ...;    # 若表存在, 才删除</span><br><span class="line"></span><br><span class="line"># 数据的约束(创建表时, 在数据类型后指定; 或者使用<span class="keyword">ALTER</span> ... MODIFY修改)</span><br><span class="line"><span class="keyword">NOT NULL</span>       # 该列数据一定非空</span><br><span class="line"><span class="keyword">UNIQUE</span>        # 该列数据各不相同</span><br><span class="line"><span class="keyword">PRIMARY KEY</span>       # 主键约束:该列数据各不相同, 且不为空</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">value</span>      # 插入记录时, 若未指定该列的值, 则使用默认值<span class="keyword">value</span></span><br><span class="line">AUTO_INCREMENT      # 用于整型的自动增长</span><br><span class="line">COMMENT        # 注释(放在最后)</span><br><span class="line"></span><br><span class="line"># 格式特殊的外键约束:</span><br><span class="line"># 用于绑定两表的两列, 本表是从表, otherTable是主表</span><br><span class="line"># 从表添加记录时, 外键约束列的数据必须存在于主表内</span><br><span class="line"># 从表删除记录时, 主表对应的记录不删除</span><br><span class="line"><span class="keyword">FOREIGN KEY</span> columnName <span class="keyword">REFERENCES</span> otherTable(columnName) dataType;</span><br><span class="line"># 外键约束的关键字:</span><br><span class="line">CASCADE  # 主表修改<span class="operator">/</span>删除记录时, 从表对应外键字段随之修改<span class="operator">/</span>删除, 常用</span><br><span class="line">RESTRICT # 和CASCADE相反</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">NULL</span> # 主表删除记录时, 从表对应外键字段设置为空</span><br><span class="line"># 也可将修改和删除拆开:</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="operator">/</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="operator">/</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT <span class="operator">/</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT</span><br><span class="line"></span><br><span class="line"># 可以在数据类型后指定, 也可以在后面批量设置约束:</span><br><span class="line"><span class="keyword">CREATE</span> ... (</span><br><span class="line"> ...,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">UNIQUE</span> (要添加的列)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="qt-sql"><code>Qt Sql</code></h2>
<h3 id="前言">前言</h3>
<p><code>Qt</code>提供了两种通过<code>C++</code>修改数据库的方法：一是模型/视图套件；二是提供查询接口，直接输入<code>SQL</code>语句</p>
<p>它对<code>SQLite</code>的支持是最好的，可直接使用；而有些数据库的驱动需要自行编译，例如<code>MySQL</code></p>
<p><strong><a
href="https://www.cnblogs.com/zhuchunlin/p/16485929.html"><code>MySQL</code>驱动编译</a></strong></p>
<h3 id="qsqldatabase"><code>QSqlDatabase</code></h3>
<p>该类的对象是将数据从硬盘加载到内存上的桥梁</p>
<p>连接数据库：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以连接SQLite为例</span></span><br><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>); <span class="comment">// 创建数据库对象</span></span><br><span class="line">db.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 设置主机名</span></span><br><span class="line">db.<span class="built_in">setPort</span>(<span class="number">3306</span>);    <span class="comment">// 设置端口</span></span><br><span class="line">db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);   <span class="comment">// 设置拥有者名</span></span><br><span class="line">db.<span class="built_in">setPassword</span>(<span class="string">&quot;1&quot;</span>);   <span class="comment">// 设置密码</span></span><br><span class="line">db.<span class="built_in">setDatabase</span>(<span class="string">&quot;mdb.db&quot;</span>);  <span class="comment">// 设置数据库路径; SQLite是一个.db文件</span></span><br><span class="line">db.<span class="built_in">open</span>();      <span class="comment">// 打开数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 含lastError()方法:返回该对象最近发生的错误, 若一切正常则返回空串</span></span><br></pre></td></tr></table></figure>
<h3 id="qt-query"><code>Qt Query</code></h3>
<p>在<code>Qt</code>中，可直接利用<code>QSqlQuery</code>对象操作数据库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlQuery* query &#123;<span class="keyword">new</span> <span class="built_in">QSqlQuery</span>(db)&#125;;  <span class="comment">// 绑定QSqlDatabase对象即可</span></span><br><span class="line">query-&gt;<span class="built_in">exec</span>(<span class="string">&quot;SQL语句&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历查询结果</span></span><br><span class="line"><span class="keyword">while</span> (query-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">    query-&gt;<span class="built_in">value</span>(列名);  <span class="comment">// 返回QVariant, 存储第i条记录中指定列的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也含lastError()方法</span></span><br></pre></td></tr></table></figure>
<h3 id="qt-modelviewdelegate"><code>Qt Model/View/Delegate</code></h3>
<p>模型是为了操作数据库而提供的接口，视图能让用户直观地操作数据库，有两种常用模型和视图</p>
<p>所有模型都有<code>lastError()</code>方法</p>
<p><strong>委托</strong>是模型和视图的中间层，用于<strong>渲染视图</strong>和<strong>编辑模型</strong></p>
<h4
id="qsqltablemodelqtableview"><code>QSqlTableModel/QTableView</code></h4>
<p>以表为结构的模型/以表形式展现的视图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QTableView控件一般在QD中绘制, 这里假设它是ui-&gt;tv</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备</span></span><br><span class="line">QSqlTableModel* model &#123;<span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="keyword">this</span>, db); &#125; <span class="comment">// 指定父组件和数据库</span></span><br><span class="line">model-&gt;<span class="built_in">setEditStrategy</span>(QSqlTableModel::OnManualSubmit); <span class="comment">// 一般要设置手动提交</span></span><br><span class="line">model-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;tableName&quot;</span>);  <span class="comment">// 模型要设置数据库的表的名称</span></span><br><span class="line">model-&gt;<span class="built_in">select</span>();     <span class="comment">// 将数据加载进模型</span></span><br><span class="line">ui-&gt;tv-&gt;<span class="built_in">setModel</span>(model);   <span class="comment">// 视图要绑定模型:表-&gt;模型-&gt;视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过模型修改数据库</span></span><br><span class="line">model-&gt;<span class="built_in">index</span>(<span class="type">int</span>, <span class="type">int</span>)    <span class="comment">// 返回QModelIndex对象(0开始)</span></span><br><span class="line">    <span class="built_in">rowCount</span>() / <span class="built_in">columnCount</span>() <span class="comment">// 返回当前行/列数</span></span><br><span class="line">       <span class="built_in">data</span>(QModelIndex)   <span class="comment">// 返回索引指向的数据(类型为QVariant)</span></span><br><span class="line">       <span class="built_in">removeRow</span>(<span class="type">int</span>)/<span class="built_in">removeColumn</span>(<span class="type">int</span>) <span class="comment">// 删除某行/列</span></span><br><span class="line">       <span class="built_in">submitAll</span>()     <span class="comment">// 提交所有修改(真正修改数据库)</span></span><br><span class="line">       <span class="built_in">revertAll</span>()     <span class="comment">// 撤销所有修改(停止事务)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过视图修改模型</span></span><br><span class="line">ui-&gt;tv-&gt;<span class="built_in">currentIndex</span>()    <span class="comment">// 返回QModelIndex, 表示用户选中的格子</span></span><br><span class="line">     <span class="built_in">setCurrentIndex</span>(QModelIndex)<span class="comment">// 设置选中格</span></span><br><span class="line"><span class="comment">// 模型调用方法后, 当前选中的信息可能丢失</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 关于QVariant和QModelIndex:</span></span><br><span class="line"><span class="comment">// QVariant含toString()和toInt()等方法, 能将字段转换成QString和int等数据类型</span></span><br><span class="line"><span class="comment">// QModelIndex含row()和column()方法, 返回对象包含的行/列信息</span></span><br></pre></td></tr></table></figure>
<p>关于视图单元格的选中模式(枚举<code>QAbstractItemView::SelectionMode</code>)：</p>
<ul>
<li><code>NoSelection</code>：无法选中</li>
<li><code>SingleSelection</code>：只能单选</li>
<li><code>MultiSelection</code>：允许多选</li>
<li><code>ExtendedSelection</code>：允许配合<code>Ctrl</code>或<code>Shift</code>键进行选择</li>
<li><code>ContiguousSelection</code>：允许配合<code>Ctrl+Shift</code>键进行批量选择</li>
</ul>
<p>如果需要设置某列不可选中，可使用自定义委托：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadOnlyDelegate</span>: <span class="keyword">public</span> QItemDelegate &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ReadOnlyDelegate</span>(QWidget *parent = <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Q_UNUSED</span>(parent)</span><br><span class="line">        <span class="built_in">Q_UNUSED</span>(option)</span><br><span class="line">        <span class="built_in">Q_UNUSED</span>(index)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令委托无视掉指定列的选中</span></span><br><span class="line">ReadOnlyDelegate* readOnlyDelegate = <span class="keyword">new</span> <span class="built_in">ReadOnlyDelegate</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; ++i) &#123; <span class="comment">// 无视</span></span><br><span class="line">    ui-&gt;matrixTable-&gt;<span class="built_in">setItemDelegateForColumn</span>(i, readOnlyDelegate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="qstandarditemmodelqtreeview"><code>QStandardItemModel/QTreeView</code></h4>
<p><code>QStandardItemModel</code>是以项为基础的模型，主从结构分明，很适合展示<strong>树形结构</strong></p>
<p>它的编辑要比<code>QSqlTableView</code>复杂，不能直接通过<code>select()</code>(也没有<code>setTable()</code>方法)完成数据的加载，而要使用<code>QSqlQuery</code>，因此单纯的矩阵结构应该用后者绘制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备</span></span><br><span class="line">...   <span class="comment">// 构造函数、设置手动提交、视图和模型绑定 与上述一致</span></span><br><span class="line">ManageModel-&gt;<span class="built_in">setColumnCount</span>(<span class="number">2</span>);  <span class="comment">// 设置模型共有两列</span></span><br><span class="line">ManageModel-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;用户组&quot;</span>, <span class="string">&quot;组权限&quot;</span>&#125;); <span class="comment">// 设置这两列的名称</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 例如要绘制二层的树结构, 表group和member如下:</span></span><br><span class="line">group:</span><br><span class="line">gid  grpname  power  memberCnt</span><br><span class="line">    </span><br><span class="line">member:</span><br><span class="line">uid  grp_id[含<span class="built_in">group</span>(gid)的外键约束] username pwd</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载, 假设有QStandardItemModel对象的指针model:</span></span><br><span class="line">QSqlQuery group&#123;db&#125;, member&#123;db&#125;;</span><br><span class="line">group.<span class="built_in">exec</span>(<span class="string">&quot;SELECT gid, grpname FROM group&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (group.<span class="built_in">next</span>()) &#123;</span><br><span class="line">    QList&lt;QStandardItem*&gt; rowItems; <span class="comment">// 因设置了两列, 故插入的是链表</span></span><br><span class="line">    <span class="keyword">auto</span> tmpItem &#123;<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(qroup.<span class="built_in">value</span>(<span class="string">&quot;grpname&quot;</span>).<span class="built_in">toString</span>())&#125;;</span><br><span class="line">    <span class="comment">// 树的第一层是 组名 和 组权限</span></span><br><span class="line">    rowItems &lt;&lt; tmpItem &lt;&lt; <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(group.<span class="built_in">value</span>(<span class="string">&quot;power&quot;</span>).<span class="built_in">toInt</span>());</span><br><span class="line">    <span class="comment">// 查询当前组的组员</span></span><br><span class="line">    member.<span class="built_in">exec</span>(<span class="string">&quot;SELECT username FROM member WHERE grp_id=&quot;</span> +</span><br><span class="line">                QString::<span class="built_in">number</span>(group.<span class="built_in">value</span>(<span class="string">&quot;gid&quot;</span>).<span class="built_in">toInt</span>()));</span><br><span class="line">    <span class="keyword">while</span> (member.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="comment">// 增加子项(树的第二层 用户名)</span></span><br><span class="line">        tmpItem-&gt;<span class="built_in">appendRow</span>(<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(member.<span class="built_in">value</span>(<span class="string">&quot;username&quot;</span>).<span class="built_in">toString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    model-&gt;<span class="built_in">appendRow</span>(rowItems);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 项一旦加入模型, 所有权将移交, 模型内存释放时所有项一同释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树形视图的方法:</span></span><br><span class="line">tv-&gt;<span class="built_in">expandAll</span>()    <span class="comment">// 展开所有项</span></span><br><span class="line"> <span class="built_in">collapseAII</span>()   <span class="comment">// 折叠所有项</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://blog.csdn.net/qq_40597070/article/details/131542928">树形视图的更多方法</a></p>
<p><a
href="https://www.cnblogs.com/zhuchunlin/p/16485926.html">更多模型/视图</a></p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>C/Cpp</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>databse</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt: 基本用法</title>
    <url>/blogs/2024/06/27/cpp-qt-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="qt基础"><code>Qt</code>基础</h1>
<p>在<code>Qt5</code>后，<code>Qt</code>不断开发<code>QML</code>和<code>Qt Quick</code>，同时在抛弃传统的基于<code>C++</code>的<code>Qt Widgets</code>，致力于更快捷、直观地绘制应用</p>
<p>当然，<code>Qt</code>的优势在于极致的跨平台和前后端的顺畅结合，<code>Qt Widgets</code>和<code>Qt Quick</code>的设计思路是相似的；多是<code>QML/C++</code>混合开发，纯粹的<code>Qt Widgets</code>在前端开发上是较为低效的</p>
<p>本文并不想介绍<code>QML</code>，而是介绍<code>Qt Widgets</code></p>
<h2 id="元对象系统">元对象系统</h2>
<h3 id="简介">简介</h3>
<p><a
href="https://www.cnblogs.com/WushiShengFei/p/9820835.html">元对象系统</a>(<code>Meta-Object System, MOS</code>)是<code>Qt</code>的核心机制，元对象即用于描述对象的对象；它提供以下功能：</p>
<ul>
<li>信号-槽：允许对象间安全的通信，方便响应事件</li>
<li>反射系统：允许程序自己获取(运行时获取)对象的信息，在<code>java、dotNet</code>中也有类似的概念</li>
<li>动态属性：允许程序在运行时添加属性</li>
</ul>
<p>所有继承<code>QObject</code>的类中，只要私有声明了宏<code>Q_OBJECT</code>，就可使用<code>MOS</code></p>
<h3 id="信号与槽">信号与槽</h3>
<ul>
<li><p>关键字：借助<code>MOC</code>(元对象编译器)，<code>Qt</code>为了实现信号槽机制，添加了<code>slots,signals</code>关键字(宏)</p>
<ul>
<li><p><strong>信号和槽都是成员函数</strong>，一般声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>signals</code>宏定义为<code>public QT_ANNOTATE_ACCESS_SPECIFIER(qt_signal)</code>，一定是公有的</p>
<p><code>slots</code>则可以在任意域中，但一般是保护或私有的</p></li>
<li><p>一般，每个<code>QObject</code>的子类中的信号都应该有对应的<strong>用于发送</strong>该信号的成员函数(<code>Qt</code>自带类中一般定义为公有槽函数)</p></li>
<li><p>一般控件有继承自父类的<code>Qt</code>实现的信号-槽和发送-响应机制</p></li>
</ul></li>
<li><p>自定义信号：</p>
<ul>
<li>无返回值，可以有参数</li>
<li>只需声明，无需实现(<code>MOC</code>自动实现)</li>
</ul></li>
<li><p>自定义槽：</p>
<ul>
<li>返回值及参数必须和相连接的信号一致</li>
<li>一旦声明，必须实现</li>
</ul></li>
<li><p>发送信号：</p>
<ul>
<li><p>通常在成员函数中，可以使用<code>emit</code>关键字发送<strong>自定义</strong>信号，同时传递参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">emit <span class="title">mySignal</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>需要主动发送信号时，通常调用封装好的发送函数，而不是直接使用<code>emit</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方命名习惯(例如按钮类):</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"> <span class="built_in">click</span>(); <span class="comment">// 发送信号.</span></span><br><span class="line">signals:</span><br><span class="line"> <span class="built_in">clicked</span>(); <span class="comment">// 信号.</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>连接方式：</p>
<ul>
<li><p>手动连接：调用<code>connect()</code>，四个必须填写的参数依次为发送者指针、信号、接收者指针、槽</p>
<p>有三种输入信号-槽参数的方式：</p>
<ul>
<li><p>旧版本：调用宏函数<code>SIGNAL()</code>和<code>SLOT()</code>，处理输入的函数名后返回特定字符串</p>
<p>连接失败后无反馈，例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数不用添加限定符.</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;lineEdit, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(QString)),</span><br><span class="line">        <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">doSomething</span>(QString)));</span><br></pre></td></tr></table></figure></li>
<li><p>新版本：传递函数指针，好处是连接失败后会报错，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;lineEdit, &amp;QLineEdit::textChanged,</span><br><span class="line">        <span class="keyword">this</span>, &amp;MainWindow::doSomething);</span><br></pre></td></tr></table></figure></li>
<li><p><code>lambda</code>表达式(匿名函数)：好处是不用额外声明槽函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;button, <span class="built_in">SIGNAL</span>(<span class="built_in">textChanged</span>(QString)), [<span class="keyword">this</span>](<span class="type">const</span> QString&amp;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>连接函数的第五个参数表示连接方式，默认为自动关联，常用的有：</p>
<ul>
<li><code>AutoConnection</code>：信号槽在同一线程则为<code>DirectionConnection</code>，否则为<code>QueuedConnection</code></li>
<li><code>DirectionConnection</code>：信号发射后直接调用槽，槽函数执行完毕后再执行<code>emit</code>语句后的代码</li>
<li><code>QueuedConnection</code>：槽在接收者的线程中执行(若在不同线程，则发送线程继续进行)</li>
</ul></li>
<li><p>默认连接：<code>Qt</code>编译器会尝试让所有名为<code>on_objName_signalName()</code>的槽函数进行连接</p>
<p>类似于调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(&amp;objName, &amp;SenderClass::signalName,</span><br><span class="line">        <span class="keyword">this</span>, &amp;thisClass::on_objName_signalName);</span><br></pre></td></tr></table></figure>
<p>注：<code>objName</code>命名不能太长，否则连接失败；连接失败后不会终止程序，但会打印错误信息</p></li>
</ul></li>
<li><p>常用控件的信号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">QPushButton:    <span class="comment"># 按钮</span></span><br><span class="line">    clicked()      <span class="comment"># 被点击</span></span><br><span class="line">QLineEdit:     <span class="comment"># 行编辑器</span></span><br><span class="line">    textChanged(const QString&amp;)  <span class="comment"># 文本被修改, 同时发送修改后的文本</span></span><br><span class="line">    returnPressed()     <span class="comment"># 焦点在控件上时, 按下回车</span></span><br><span class="line"> cursorPositionChanged()   <span class="comment"># 光标移动</span></span><br><span class="line">    editingFinished()    <span class="comment"># 失去焦点/焦点在该控件上时, 按下回车</span></span><br><span class="line">    selectionChanged()    <span class="comment"># 选中区域被修改</span></span><br><span class="line">QDialog:     <span class="comment"># 对话框</span></span><br><span class="line">    accepted()/rejected()   <span class="comment"># 因用户确认/拒绝对话框而被关闭</span></span><br><span class="line">    finished()      <span class="comment"># 被关闭</span></span><br><span class="line">QStackedWidget/QToolBox: <span class="comment"># 堆栈窗口(多窗口器)/工具箱</span></span><br><span class="line">    currentChanged(<span class="built_in">int</span> idx)   <span class="comment"># 当前窗口/选项修改, 同时发送新窗口的索引</span></span><br></pre></td></tr></table></figure></li>
<li><p>可能用到的控件的信号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  QSplitter:     <span class="comment"># 窗口分割器</span></span><br><span class="line">      splitterMoved(<span class="built_in">int</span> pos, <span class="built_in">int</span> idx) <span class="comment"># 分割条被移动, 同时发送移动后的位置、被移动条的索引</span></span><br><span class="line">  QAction/QToolButton:  <span class="comment"># 动作/工具按钮</span></span><br><span class="line">      triggered()      <span class="comment"># 被触发</span></span><br><span class="line">  QSpinBox/QDoubleSpinBox: <span class="comment"># 整数旋钮/浮点数旋钮</span></span><br><span class="line">      valueChanged(<span class="built_in">int</span>/double val) <span class="comment"># 值被修改, 同时发送新的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 事件系统</span></span><br><span class="line"></span><br><span class="line">事件和信号槽的区别：</span><br><span class="line"></span><br><span class="line">- 信号本身没有和底层硬件、操作系统交流的能力，部分信号还需要通过事件发出(如`clicked()`)</span><br><span class="line">- 关注点：</span><br><span class="line">  - 信号槽：发出、接收信号的**对象**</span><br><span class="line">  - 事件处理：发生的是**哪种事件**，并不关注对象间的通信</span><br><span class="line">- 来源：</span><br><span class="line">  - 信号：程序里的函数，由对象发出</span><br><span class="line">  - 事件：**系统的底层消息**</span><br><span class="line">- 本质：</span><br><span class="line">  - 信号槽：成员函数</span><br><span class="line">  - 事件：对象</span><br><span class="line"></span><br><span class="line">`Qt`的事件循环：</span><br><span class="line"></span><br><span class="line">- 产生：应用启动(`QApplication::<span class="built_in">exec</span>()`)后，`Qt`即开启事件循环，不断检测底层消息并将它们转换为事件</span><br><span class="line">- 分发：事件通过`QApplication::notify()`传入到**事件队列**，按队列的顺序取出事件，调用事件分发函数`<span class="built_in">bool</span> event(QEvent* event)`</span><br><span class="line">- 处理：`event()`会分情况调用不同的事件处理函数</span><br><span class="line">- 事件循环里，事件的产生和处理是异步的</span><br><span class="line"></span><br><span class="line">事件也可手动发送，它们不经过事件循环</span><br><span class="line"></span><br><span class="line">有些类(如按钮类)的处理函数已经封装好了，而有些类(如窗口类)的键鼠事件处理函数没有语句，因此有需要时，需要**重写**它们，一般有两种处理方式：</span><br><span class="line"></span><br><span class="line">- 发送信号，将事件的处理解耦成多个槽函数，可扩展性强，便于跨对象、跨线程通信</span><br><span class="line">- 直接在函数内部处理，可用于事件处理较为简单的情况</span><br><span class="line"></span><br><span class="line">常见的事件处理函数：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 启用某种属性的函数,某些事件需要特定属性才能产生</span></span><br><span class="line">setAttribute(Qt::WidgetAttribute, <span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下函数返回值为void</span></span><br><span class="line">键盘:</span><br><span class="line">    keyPressEvent(QKeyEvent* event)    <span class="comment"># 按键按下</span></span><br><span class="line">    keyReleaseEvent(QKeyEvent* event)   <span class="comment"># 按键松开</span></span><br><span class="line">鼠标:</span><br><span class="line">    mousePressEvent(QMouseEvent* event)   <span class="comment"># 鼠标按下</span></span><br><span class="line">    mouseReleaseEvent(QMouseEvent* event)  <span class="comment"># 鼠标松开</span></span><br><span class="line">    mouseDoubleClickEvent(QMouseEvent* event) <span class="comment"># 鼠标双击</span></span><br><span class="line"> wheelEvent(QWheelEvent* event)    <span class="comment"># 鼠标滚轮滑动</span></span><br><span class="line">    enterEvent(QEvent* event)     <span class="comment"># 鼠标移进</span></span><br><span class="line"> leaveEvent(QEvent* event)     <span class="comment"># 鼠标移出</span></span><br><span class="line">    hoverMoveEvent(QHoverEvent* event)   <span class="comment"># 鼠标悬停(需启用WA_Hover)</span></span><br><span class="line">焦点:</span><br><span class="line">    focusInEvent(QFocusEvent* event)   <span class="comment"># 获得焦点</span></span><br><span class="line"> focusOutEvent(QFocusEvent* event)   <span class="comment"># 失去焦点</span></span><br><span class="line">拖动:</span><br><span class="line">    setAcceptDrops(<span class="built_in">bool</span>)      <span class="comment"># 设置控件能否拖动</span></span><br><span class="line">    dragEnterEvent(QDragEnterEvent* event)  <span class="comment"># 被拖动的物体进入可放置区域</span></span><br><span class="line">    dragMoveEvent(QDragMoveEvent* event)  <span class="comment"># 被拖动的物体移动</span></span><br><span class="line">    dragLeaveEvent(QDragLeaveEvent* event)  <span class="comment"># 被拖动的物体离开可放置区域</span></span><br><span class="line">    dropEvent(QDropEvent* event)    <span class="comment"># 放下</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>传入的事件本身是带有信息的，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">QKeyEvent:</span><br><span class="line">    key()    <span class="comment"># 返回Qt::Key枚举值, 表示按下的是哪个键</span></span><br><span class="line">QMouseEvent:</span><br><span class="line">    pos()    <span class="comment"># 返回QPoint, 表示鼠标相对于该控件的位置</span></span><br><span class="line">    globalPos()   <span class="comment"># 返回QPoint, 表示鼠标在屏幕上的位置</span></span><br></pre></td></tr></table></figure>
<p>关于事件分发函数<code>event()</code>的重写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event()是事件分发函数, 是有返回值的(表示事件是否已处理)</span></span><br><span class="line"><span class="comment">// 重写event()的目的是实现 事件过滤 或 想在事件处理前执行一些代码 或 分发自定义事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent* event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">        <span class="comment">// 想处理的事件</span></span><br><span class="line">        <span class="keyword">case</span> QEvent::KeyPress: </span><br><span class="line">            ...</span><br><span class="line">            <span class="built_in">keyPressEvent</span>((QKeyEvent*)event);</span><br><span class="line">            <span class="comment">// 标记为已处理(Qt默认调用accepted, 可以在处理函数里手动调用ignore())</span></span><br><span class="line">            <span class="keyword">if</span> (((QKeyEvent *)event)-&gt;<span class="built_in">isAccepted</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 则不传递</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> 想忽略的事件: <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 虽然未处理, 但可以直接返回true表示已处理</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(event); <span class="comment">// 未处理, 交给父类处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目初始化">项目初始化</h2>
<p>通过项目初始化来介绍<code>Qt</code>在控件上的一些机制和默认</p>
<h3 id="ui文件"><code>.ui</code>文件</h3>
<p>在创建<code>Qt</code>项目时，应该自选生成<code>.ui</code>文件，能轻易地在<code>Qt Designer</code>中修改它，并定义窗口和控件对象、以及它们的初始化</p>
<ul>
<li><p>该文件使用<code>xml</code>语言，在<code>Qt Designer</code>上修改比直接编辑快的多</p></li>
<li><p>其能在<code>C++</code>程序中起作用的原因是，<code>Qt</code>编译器会通过<code>uic</code>(<code>ui</code>编译器)将<code>name.ui</code>翻译成头文件<code>ui_name.h</code>，其中定义了类<code>Ui_name</code>：</p>
<ul>
<li><p>该类定义了所有在<code>QD</code>设计的、除窗口类外的控件</p></li>
<li><p>定义了成员函数<code>setupUi(QMainWindow*)</code>，用于初始化各种控件</p></li>
<li><p>自动生成的项目主窗口类中，默认定义<code>Ui_name</code>类的指针<code>ui</code></p>
<p>所有构造函数的第一行应调用<strong><code>ui-&gt;setupUi(this)</code></strong>，以确保能安全调用<code>ui</code>中的控件</p></li>
</ul></li>
</ul>
<h3 id="主窗口类及内存机制">主窗口类及内存机制</h3>
<p>学习自动创建的主窗口头文件格式，便于学会自定义控件类</p>
<p>设创建项目时定义的主窗口类为<code>MainWindow</code>，则应有头文件定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Q_OBJECT</code>：<code>Qt</code>定义的宏，只有声明了它，才能使用元对象系统</p>
<p>任何继承了<code>QObject</code>类的子类都应<strong>私有声明</strong>该宏</p></li>
<li><p>简单窗口类可直接继承自<code>QWidget</code></p>
<p>复杂窗口类(如包含菜单栏、对话框)应继承<code>QMainWindow</code>，才能正常显示</p></li>
</ul>
<p>构造函数的实现至少是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget* parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line"> <span class="built_in">ui</span>(<span class="keyword">new</span> Ui_MainWindow) &#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为参数传入的<code>parent</code>和<code>this</code>是有必要的，因为<code>Qt</code>有自己的一套<strong>回收内存</strong>的机制：</p>
<ul>
<li><p>半自动回收：所有<code>QObject</code>类及其子类对象都定义了<code>parent</code>和链表(用于存储子控件的指针)</p>
<p>习惯上，所有控件类对象都使用堆内存，并在构造时指定父控件</p>
<ul>
<li><p>当释放父控件的内存时，会先释放所有子控件的内存，因此只要记得释放根控件的内存，就不会出现内存泄露</p></li>
<li><p>而释放子控件的内存后，它会从其父控件的链表中删去，因此不会出现重复释放内存的情况</p></li>
<li><p>所有这些对象都有<strong><code>QObject::setParent()</code></strong>方法，用于设置父控件</p></li>
</ul></li>
<li><p>手动释放：对于<strong>父控件在不同线程</strong>、或<strong>非<code>QObject</code>系</strong>的占用<strong>堆内存</strong>的对象，无法半自动回收，应在其所在线程里调用<strong><code>deleteLater()</code></strong>方法，调用后会在<strong>线程结束时释放其内存</strong></p></li>
</ul>
<h3 id="外部资源管理">外部资源管理</h3>
<p><code>Qt</code>中通过<code>.qrc</code>(<code>Qt Resource</code>)文件管理外部资源，该文件使用<code>xml</code>语言，在<code>QC</code>中能更直观地使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">RCC</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">&quot;/Icons&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/name.jpg<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接编码也不难理解，这些标签的含义是：</p>
<ul>
<li><code>RCC</code>：其内容会被<code>rcc</code>(<code>Qt</code>的资源编译器)识别，并把资源编译到可执行文件里</li>
<li><code>qresource</code>：用于指定其所属文件的前缀，前缀默认为<code>"/"</code></li>
<li><code>file</code>：其内容为资源的真正的路径，例如上述语句引入了处于<code>./images/name.jpg</code>路径(相对于该资源文件)的图片</li>
</ul>
<p><code>.qrc</code>文件通过独特的相对路径管理资源，即<strong>冒号+前缀+文件路径</strong>，例如通过<code>":/Icons/images/name.jpg"</code>访问上述语句中的文件</p>
<p>使用资源的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(路径)) <span class="comment">// 设置窗口图标，仅窗口类可使用</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(路径))   <span class="comment">// 设置控件图标，仅支持图标的控件可使用</span></span><br><span class="line">    </span><br><span class="line"><span class="function">QFile <span class="title">qssFile</span><span class="params">(<span class="string">&quot;:/path/name.css&quot;</span>)</span></span>; <span class="comment">// 引入外部样式表</span></span><br><span class="line">qssFile.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(qssFile.<span class="built_in">readAll</span>()); <span class="comment">// 加载到整个应用程序(所有QWidget类对象都可加载)</span></span><br><span class="line"></span><br><span class="line">QSound::<span class="built_in">play</span>(<span class="string">&quot;:/path/name.wav&quot;</span>); <span class="comment">// 播放wav音频文件(静态播放,只能在主线程中调用)</span></span><br><span class="line">QSound* musicPlayer &#123;<span class="keyword">new</span> <span class="built_in">QSound</span>(路径)&#125;; <span class="comment">// 加载进内存后播放</span></span><br><span class="line">musicPlayer-&gt;<span class="built_in">play</span>();</span><br><span class="line"></span><br><span class="line">QMediaPlayer* musicPlayer &#123;<span class="keyword">new</span> QMediaPlayer&#125;; <span class="comment">// 可播放wav、mp3、mp4等</span></span><br><span class="line">musicPlayer-&gt;<span class="built_in">setMedia</span>(QUrl::<span class="built_in">fromLocalFile</span>(路径));</span><br><span class="line">musicPlayer-&gt;<span class="built_in">play</span>();</span><br></pre></td></tr></table></figure>
<h2 id="样式">样式</h2>
<p>关于样式，推荐通过<code>QD</code>进行初始化，或一律通过外部样式表统一，而不是通过<code>C++</code>编码修改</p>
<p>如果有<code>CSS</code>基础，许多属性会很熟悉</p>
<h3 id="控件">控件</h3>
<p>所有<code>QWidget</code>系对象都有(由以下类组合而成)：</p>
<ul>
<li><p><code>font</code>：存储字体族、字体大小、粗体、斜体等(构造函数的参数就是这四个属性)</p>
<p>对象可调用<code>setFont(QFont)</code>方法修改</p></li>
<li><p><code>sizePolicy</code>：存储大小和伸缩的策略</p>
<ul>
<li><p>伸展策略：实质是枚举<code>QSizePolicy::Policy</code>，可通过<code>setSizePolicy()</code>修改</p>
<ul>
<li><p>基于<code>sizeHint</code>有不同的策略，以下称其为默认值</p></li>
<li><p><code>Fixed</code>：控件大小始终为默认值</p></li>
<li><p><code>Minimun/Maximun</code>：控件的默认值为最小/最大尺寸，大小可以大于/小于默认值</p>
<p>最小/最大尺寸可通过<code>setMinimunSize()/setMaximunSize()</code>设置</p></li>
<li><p><code>Preferred</code>：控件大小是默认值，但可以放大/缩小</p></li>
<li><p><code>Expanding</code>：控件可以随意放大/缩小</p></li>
<li><p>当<code>Preferred</code>和<code>Expanding</code>的控件同时存在于布局中时，前者会把空间让给后者且尽量保持默认值</p></li>
</ul></li>
<li><p>伸展因子：一般通过布局来管理，伸展因子越大，拉伸控件时改变的空间越多</p></li>
</ul></li>
<li><p><code>focusPolicy</code>：存储获取焦点的策略，实质是枚举<code>Qt::FocusPolicy</code></p>
<ul>
<li><code>StrongFocus</code>：默认值，也最常用，可通过鼠标点击、<code>Tab</code>键获取焦点</li>
<li><code>TabFocus/ClickFocus</code>：<code>Tab</code>键/鼠标点击获取焦点</li>
<li><code>NoFocus</code>：不可通过键鼠获取焦点</li>
</ul></li>
<li><p><code>geometry</code>：不重要，一般通过布局来控制它</p></li>
</ul>
<h3 id="布局">布局</h3>
<p><code>Qt</code>提供以下几种布局管理器：</p>
<ul>
<li><code>QHBoxLayout/QVBoxLayout</code>：水平/垂直布局</li>
<li><code>QGridLayout</code>：网格布局</li>
<li><code>QFormLayout</code>：表单布局</li>
</ul>
<p>布局有助于控件随窗口拉伸而自动拉伸，以下操作可在<code>QD</code>快速实现：</p>
<ul>
<li>窗口调用<code>setCentralWidget()</code>设置中心控件</li>
<li>该中心控件调用<code>setLayout()</code>设置布局</li>
</ul>
<h3 id="窗口">窗口</h3>
<p>如要限制窗口的放大/缩小键，可通过<code>setWindowFlags()</code>设置，参数为枚举<code>Qt::WindowType</code></p>
<ul>
<li><code>WindowMaximunButtonHint/WindowMinimunButtonHint</code>：最大化/最小化</li>
<li><code>WindowCloseButtonHint</code>：关闭键</li>
</ul>
<h2 id="更多常用方法">更多常用方法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">QWidget:</span><br><span class="line">    resize()   <span class="comment"># 重置大小</span></span><br><span class="line">    setFocus()   <span class="comment"># 主动吸引焦点</span></span><br><span class="line">    setHidden()   <span class="comment"># 设置是否隐藏控件</span></span><br><span class="line">QMainWindow:</span><br><span class="line">    setWindowTitle() <span class="comment"># 设置标题</span></span><br><span class="line">    show()    <span class="comment"># 显示窗口</span></span><br><span class="line">    close()    <span class="comment"># 关闭窗口</span></span><br><span class="line">QDoubleSpinBox:</span><br><span class="line">    setDecimals()  <span class="comment"># 设置浮点数精度(实质是字符串)</span></span><br><span class="line">文本编辑/显示器:</span><br><span class="line">    setText()   <span class="comment"># 设置文本, 会解析HTML内容</span></span><br><span class="line">    setPlainText()  <span class="comment"># 设置纯文本</span></span><br><span class="line"> text()    <span class="comment"># (QLineEdit)获取文本</span></span><br><span class="line">    toPlainText()  <span class="comment"># (其它)获取文本</span></span><br><span class="line">按钮类:</span><br><span class="line">    setEnabled()  <span class="comment"># 设置是否启用</span></span><br><span class="line">布局管理器:</span><br><span class="line">    addWidget()   <span class="comment"># 添加控件</span></span><br><span class="line">    columnCount()/rowCount() <span class="comment"># 列/行数</span></span><br><span class="line">QStackedWidget:</span><br><span class="line">    setCurrentIndex() <span class="comment"># 设置当前窗口</span></span><br><span class="line">QString:</span><br><span class="line">    number()   <span class="comment"># 静态成员, 将整型/浮点型转化为QString</span></span><br><span class="line">QMessageBox:</span><br><span class="line">    information()  <span class="comment"># 静态成员, 呼出简单的小窗口(可添加Ok/Cancel按钮并返回用户的选择)</span></span><br><span class="line"></span><br><span class="line">qDebug() &lt;&lt; Data  <span class="comment"># 打印信息</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Programming</category>
        <category>C/Cpp</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>Qt</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Git: 使用git进行版本管理</title>
    <url>/blogs/2024/06/12/git/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="使用git进行版本管理">使用<code>Git</code>进行版本管理</h1>
<h2 id="介绍">介绍</h2>
<p><code>Git</code>是一个分布式版本管理工具，它诞生的故事很有意思-&gt;[Git的历史](<a
href="https://zhuanlan.zhihu.com/p/114067067#:~:text=%5B译"
class="uri">https://zhuanlan.zhihu.com/p/114067067#:~:text=[译</a>] Git
的历史%3A 软件版本控制的统治之路 1 Git 的历史%3A
软件版本控制的统治之路,Android 采用 … 8 Microsoft 改变态度 … 更多项目)
版本控制器：当我们需要修改代码但又担心无法回退时，我们需要创建副本。当修改次数多、修改规模大时，我们很难记住这些副本实现了什么功能或是修复了哪些<code>bug</code>，也不知道改动了哪里，而这只是一人修改的情况，如果是一个需要互相沟通的团队呢？因此，版本控制器应运而生，它方便我们<strong>查看历史版本、快速回退、创建版本分支</strong>等。总而言之，一个合格的程序员应学会熟练使用<code>Git</code>这个高效强大且开源的版本控制工具
虽然<code>git</code>在对非代码文件时无法查看不同版本间的差别，但依旧是十分好用的版本管理工具</p>
<h2 id="基本使用">基本使用</h2>
<p>安装好<code>Git</code>之后，需要进行身份认证(但其实只需要提供信息，假的也可以)，在终端或虚拟终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Username&quot;</span><br><span class="line">git config --global user.email &quot;email@123.com&quot;</span><br></pre></td></tr></table></figure>
<p>如此就可以开始使用<code>Git</code>了！</p>
<h3 id="创建仓库">创建仓库</h3>
<p>打开项目文件夹，右键点击<code>Open Git Bash here</code>，便可以打开终端页面，或是打开本地终端<code>cd</code>到项目文件夹，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init    # 新建空仓库</span><br><span class="line">git init [dir]  # 指定目录作为仓库</span><br><span class="line">git clone [href]  # 克隆别人的仓库,href即资源位置</span><br></pre></td></tr></table></figure>
<p>新建后，该文件夹内就会出现<code>.git</code>隐藏文件夹，可以进行提交等操作
<code>href</code>在<code>github</code>中，你可以在一个项目的根目录下找到一个绿色的<code>Code</code>按钮，里面就有<code>url</code></p>
<h3 id="提交代码">提交代码</h3>
<p>输入以下命令来提交部分或全部文件到<strong>暂存区</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add file</span><br><span class="line">git add .     # 提交文件夹下所有文件</span><br><span class="line">git rm --cached file  # 删除暂存区指定文件</span><br></pre></td></tr></table></figure>
<p>在暂存区内，可以撤回或添加文件，确认后，输入以下命令将它们提交到仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;explanation&quot; # -m后为注释,表示这次修改改动的东西</span><br></pre></td></tr></table></figure>
<p>一般来说，每次更新或修复一个功能，就需要提交一次，因此，上述命令是很常用的</p>
<h3 id="查看日志">查看日志</h3>
<p>每次提交，就会新增一个节点，通过如下命令查看它们：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>这条命令可以查看所有历史节点详细信息如注释、修改时间、修改内容、修改人、修改行数、<code>commit id</code>等</p>
<p>可以加入其它参数查看更细致的内容，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --oneline   # 每个节点只用一行表示</span><br><span class="line">git log --stat   # 查看具体改动过的文件名和一些简略的信息</span><br><span class="line">git log --author=[name] # 只查看名为&#x27;name&#x27;作者的提交</span><br><span class="line">git log --since=[time] # 只查看&#x27;time&#x27;之后的提交</span><br></pre></td></tr></table></figure>
<p>如果窗口大小足够，它会全部印出，否则会进入<code>vim</code>查看</p>
<h3 id="版本回退">版本回退</h3>
<p>每个节点都有自己的一个<code>commit id</code>，即版本序列号，输入如下命令查看改动、回溯：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff [id]    # 查看历史版本与当前工作区的不同</span><br><span class="line">git reset --hard [id]  # 版本回退</span><br><span class="line">git checkout [id]   # 版本回退的另一种方式</span><br></pre></td></tr></table></figure>
<p>如果是在<code>VSC</code>或<code>PyCharm</code>等环境下，可以在时间线里看到更清晰的改动而无需使用命令</p>
<h3 id="版本分支">版本分支</h3>
<p>一个项目，或许有社区/专业版，或许有中文/英文版，或许有和谐/反和谐版，这种情况下，可以用到版本分支功能。分支间不具有强关联，可以有部分区别和不同的更新时间，输入以下命令查看、创建、删除版本分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch      # 查看所有分支,星号所指即当前所在分支</span><br><span class="line">git branch [branch name]   # 创建名为&#x27;branch name&#x27;的分支</span><br><span class="line">git checkout -b [branch name]  # 创建名为&#x27;branch name&#x27;的分支,并自动切换到该分支</span><br><span class="line">git branch -d [branch name]  # 删除名为&#x27;branch name&#x27;的分支</span><br></pre></td></tr></table></figure>
<p>一般来说，<code>git</code>自动创建的<code>master</code>分支用于发布版本，通常会创建一个<code>develop</code>分支进行新功能的撰写和<code>debug</code>，在开发和测试完成后，将<code>develop</code>分支和主分支进行<strong>合并</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master  # 切换到master分支</span><br><span class="line">git switch [branch name] # 同样是切换分支,效果一样</span><br><span class="line">git merge [branch name] # 将指定分支合并到当前分支下</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools &amp; Utilities</category>
        <category>manager</category>
        <category>version manager</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数: 矩阵的秩</title>
    <url>/blogs/2024/05/31/linearAlgebra-rank/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="矩阵的秩">矩阵的秩</h1>
<h2 id="矩阵判别">矩阵判别</h2>
<h3 id="秩的性质">秩的性质</h3>
<ul>
<li><span
class="math inline"><em>r</em>(<em>A</em><sub><em>m</em> × <em>n</em></sub>) ≤ min (<em>m</em>,<em>n</em>)</span>，换句话说，如果确定<span
class="math inline"><em>r</em>(<em>A</em>) ≥ <em>m</em></span>或<span
class="math inline"><em>n</em></span>，则<span
class="math inline"><em>r</em>(<em>A</em>) = <em>m</em></span>或<span
class="math inline"><em>n</em></span></li>
<li>通过将矩阵化为行阶梯型或行最简型求具体矩阵的秩，如果求线性方程组系数阵的秩，应该只进行初等行变换；有时也通过定义求解</li>
</ul>
<h3 id="秩与其它运算">秩与其它运算</h3>
<ul>
<li><span
class="math inline">$r(lA)=\begin{cases}r(A)&amp;l\ne0\\0&amp;l=0\end{cases}$</span></li>
<li><span
class="math inline">$r(A^{-1})=r(A)=n、r(A)\begin{cases}&lt;n&amp;|A|=0\\=n&amp;|A|\ne0\end{cases}$</span></li>
<li><span class="math inline"><em>P</em>、<em>Q</em></span>可逆<span
class="math inline"> ⇔ <em>r</em>(<em>P</em><em>A</em><em>Q</em>) = <em>r</em>(<em>A</em>)</span></li>
<li><span
class="math inline"><em>r</em>(<em>A</em>±<em>B</em>) ≤ <em>r</em>(<em>A</em>) + <em>r</em>(<em>B</em>)</span>，通常使用右<span
class="math inline">→</span>左限定范围</li>
<li><span class="math inline">$\begin{align}r(A)+r(B)-n\le r(A_{m\times
n}B_{n\times m})\le
\min\Big(r(A),r(B)\Big)\end{align}$</span>，乘积秩不增加</li>
<li><span
class="math inline">$r(A^*)=\begin{cases}n&amp;r(A)=n\\1&amp;r(A)=n-1\\0&amp;r(A)&lt;n-1\end{cases}$</span></li>
<li><span
class="math inline"><em>r</em>(<em>A</em><em>A</em><sup><em>T</em></sup>) = <em>r</em>(<em>A</em><sup><em>T</em></sup><em>A</em>) = <em>r</em>(<em>A</em>) = <em>r</em>(<em>A</em><sup><em>T</em></sup>)</span>
<ul>
<li><span
class="math inline"><em>A</em><sup><em>T</em></sup><em>A</em><em>x</em> = 0</span>与<span
class="math inline"><em>A</em><em>x</em> = 0</span>同解<span
class="math inline"> ⇒ <em>k</em> − <em>r</em>(<em>A</em><sup><em>T</em></sup><em>A</em>) = <em>k</em> − <em>r</em>(<em>A</em>) ⇒ <em>r</em>(<em>A</em><sup><em>T</em></sup><em>A</em>) = <em>r</em>(<em>A</em>)</span></li>
<li><span
class="math inline"><em>A</em><em>A</em><sup><em>T</em></sup><em>x</em> = 0</span>与<span
class="math inline"><em>A</em><sup><em>T</em></sup><em>x</em> = 0</span>同解<span
class="math inline"> ⇒ <em>k</em> − <em>r</em>(<em>A</em><em>A</em><sup><em>T</em></sup>) = <em>k</em> − <em>r</em>(<em>A</em><sup><em>T</em></sup>) ⇒ <em>r</em>(<em>A</em><em>A</em><sup><em>T</em></sup>) = <em>r</em>(<em>A</em><sup><em>T</em></sup>) = <em>r</em>(<em>A</em>)</span></li>
</ul></li>
<li>分块矩阵：
<ul>
<li><span
class="math inline">$r\left(\begin{matrix}A&amp;C\\O&amp;B\end{matrix}\right)\ge
r(A)+r(B)$</span>，若<span
class="math inline"><em>C</em> = <em>O</em></span>，则<span
class="math inline"> = <em>r</em>(<em>A</em>) + <em>r</em>(<em>B</em>)</span></li>
<li>增广矩阵<span
class="math inline">max (<em>r</em>(<em>A</em>),<em>r</em>(<em>B</em>)) ≤ <em>r</em>(<em>A</em>,<em>B</em>) ≤ <em>r</em>(<em>A</em>) + <em>r</em>(<em>B</em>)</span></li>
<li><span
class="math inline"><em>r</em>(<em>A</em>,<em>B</em>) = <em>r</em>(<em>B</em>,<em>A</em>)</span></li>
</ul></li>
</ul>
<h2 id="向量组">向量组</h2>
<h3 id="线性相关">线性相关</h3>
<ul>
<li>定义：若存在一组<strong>不全为<span
class="math inline">0</span></strong>的数<span
class="math inline"><em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>, ⋯, <em>k</em><sub><em>n</em></sub></span>，使<span
class="math inline">0</span>能够被向量组<span
class="math inline"><em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, ⋯, <em>α</em><sub><em>n</em></sub></span>线性表示，则称该向量组<strong>线性相关</strong></li>
<li>性质：
<ul>
<li>线性无关组<strong>删去向量仍无关</strong>、线性相关组<strong>添加向量仍相关</strong></li>
<li>线性无关组<strong>添加分量仍无关</strong>、线性相关组<strong>删去分量仍相关</strong></li>
<li>向量组<span
class="math inline"><em>A</em>(<em>α</em><sub>1</sub>,<em>α</em><sub>2</sub>,⋯,<em>α</em><sub><em>n</em></sub>)</span>线性无关，<span
class="math inline"><em>B</em>(<em>A</em>,<em>β</em>)</span>线性相关<span
class="math inline"> ⇔ <em>β</em></span>可由<span
class="math inline"><em>A</em></span><strong>唯一线性表示</strong></li>
<li>一组向量线性相关<span class="math inline">⇔</span>不满秩<span
class="math inline">⇔</span>极大无关组个数小于<span
class="math inline"><em>n</em></span><span
class="math inline">⇔</span>至少有一个向量能被其余向量表示</li>
<li>一组向量线性无关<span class="math inline">⇔</span>定义式中系数<span
class="math inline"><em>k</em></span>全为且只能为<span
class="math inline">0</span>，故可用待定系数法求解线性无关问题</li>
</ul></li>
<li>极大无关组
<ul>
<li>向量组中任意一个向量都能被极大无关组表示</li>
<li>等价矩阵的极大无关组</li>
</ul></li>
</ul>
<h3 id="秩与等价">秩与等价</h3>
<ul>
<li>秩的判别：
<ul>
<li>定义：存在<span
class="math inline"><em>r</em></span>个向量线性无关，任意<span
class="math inline"><em>r</em> + 1</span>个向量线性相关</li>
<li>极大线性无关组不唯一</li>
<li>化为矩阵判别更高效</li>
</ul></li>
<li>若两个向量组能<strong>互相线性表示</strong>，称为<strong>等价</strong>，等价性质：
<ul>
<li>等价矩阵对应的向量组也等价，且<strong>极大无关组的序号</strong>一致，<strong>线性相关性</strong>也一致</li>
<li>子向量组可由父向量组线性表示</li>
<li><strong>向量组与其极大无关组</strong>等价、<strong>向量组的两个极大无关组</strong>等价</li>
<li><span class="math inline"><em>A</em></span>可由<span
class="math inline"><em>B</em></span>线性表示<span
class="math inline"> ⇔ <em>r</em>(<em>B</em>) = <em>r</em>(<em>B</em>,<em>A</em>) ≤ <em>r</em>(<em>A</em>) + <em>r</em>(<em>B</em>) ⇔ <em>r</em>(<em>A</em>) ≤ <em>r</em>(<em>B</em>)</span><span
class="math inline">⇔</span>存在<span
class="math inline"><em>K</em></span>，使<span
class="math inline"><em>A</em> = <em>B</em><em>K</em></span>，其中设<span
class="math inline">$\begin{cases}\alpha_1=B\vec
k_1\\\cdots\\\alpha_n=B\vec k_n\end{cases}$</span>，则<span
class="math inline"><em>K</em> = (<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>, ⋯, <em>k</em><sub><em>n</em></sub>)</span>，<span
class="math inline"><em>k</em><sub><em>i</em></sub></span>为列向量</li>
<li>若<span class="math inline"><em>A</em></span>可由<span
class="math inline"><em>B</em></span>线性表示且两向量组的<strong>向量个数相同</strong>，则证明<span
class="math inline"><em>A</em> ≡ <em>B</em></span>就是证明<span
class="math inline"><em>K</em></span>可逆</li>
<li><span class="math inline"><em>A</em>、<em>B</em></span>等价<span
class="math inline"> ⇔ <em>r</em>(<em>A</em>) = <em>r</em>(<em>A</em>,<em>B</em>) = <em>r</em>(<em>B</em>)</span></li>
<li>反推，如果<span class="math inline"><em>A</em></span>不可由<span
class="math inline"><em>B</em></span>线性表示<span
class="math inline"> ⇔ <em>r</em>(<em>B</em>) &lt; <em>r</em>(<em>B</em>,<em>A</em>) ⇔ <em>r</em>(<em>B</em>) &lt; <em>r</em>(<em>A</em>)</span></li>
</ul></li>
</ul>
<h2 id="线性方程组中的应用">线性方程组中的应用</h2>
<h3 id="齐次线性方程组">齐次线性方程组</h3>
<ul>
<li>设<span
class="math inline"><em>n</em></span>为<strong>未知量的个数</strong></li>
<li>齐次线性方程组一定有解，即<span
class="math inline"><em>r</em>(<em>A</em>) ≡ <em>r</em>(<em>A</em>,<em>β</em>)</span>，<span
class="math inline">$\begin{cases}r(A)=n&amp;有唯一零解\\r(A)&lt;n&amp;有无穷解\end{cases}$</span></li>
<li>若有无穷解：
<ul>
<li>基础解系为解向量组的极大无关组，且个数为<span
class="math inline"><em>n</em> − <em>r</em>(<em>A</em>)</span></li>
<li>求基础解系的过程就是<strong>找出<span
class="math inline"><em>n</em> − <em>r</em>(<em>A</em>)</span>个线性无关的解组</strong></li>
<li>通解为<span class="math inline">$\begin{align}\sum_{i=1}^{n-r(A)}k_i
x_i\end{align}$</span></li>
<li>在齐次方程组中，找另一个基础解系的过程就是找<strong>和已知基础解系等价</strong>的向量组</li>
</ul></li>
</ul>
<h3 id="非齐次线性方程组">非齐次线性方程组</h3>
<ul>
<li><span class="math inline">$\begin{cases}r(A)\ne
r(A,\beta)&amp;无解\\r(A)=r(A,\beta)=n&amp;有唯一解\\r(A)=r(A,\beta)&lt;n&amp;有无穷解\end{cases}$</span></li>
<li>若有无穷解：
<ul>
<li>基础解系仍是解向量组的极大无关组，且个数为<span
class="math inline"><em>n</em> − <em>r</em>(<em>A</em>) + 1</span></li>
<li>对应<strong>齐次线性方程组的基础解系</strong>，再加上<strong>本身的一个特解</strong>，不是基础解系，但构成它的通解</li>
<li>由于<span
class="math inline"><em>β</em> ≠ 0</span>，方程组的<strong>两个不同解</strong>一定<strong>线性无关</strong></li>
<li>通解为<span
class="math inline">$\begin{align}X+\sum_{i=1}^{n-r(A)}k_i
x_i\end{align}$</span>，其中<span
class="math inline"><em>x</em><sub><em>i</em></sub></span>为齐次线性方程组的解</li>
</ul></li>
<li>无论<span
class="math inline"><em>A</em><em>x</em> = <em>β</em></span>是否有解，<span
class="math inline"><em>A</em><sup><em>T</em></sup><em>A</em><em>x</em> = <em>A</em><sup><em>T</em></sup><em>β</em></span>一定有解
<ul>
<li><span
class="math inline"><em>r</em>(<em>A</em><sup><em>T</em></sup><em>A</em>) ≤ <em>r</em>(<em>A</em><sup><em>T</em></sup><em>A</em>,<em>A</em><sup><em>T</em></sup><em>β</em>) = <em>r</em>(<em>A</em><sup><em>T</em></sup>(<em>A</em>,<em>β</em>)) ≤ <em>r</em>(<em>A</em><sup><em>T</em></sup>) = <em>r</em>(<em>A</em><sup><em>T</em></sup><em>A</em>)</span></li>
</ul></li>
</ul>
<h3 id="求解过程">求解过程</h3>
<ul>
<li>对一个非齐次线性方程组，有<span
class="math inline"><em>A</em><em>x</em> = <em>b</em></span>，先找<span
class="math inline"><em>A</em><em>x</em> = 0</span>的通解，再找<span
class="math inline"><em>A</em><em>x</em> = <em>b</em></span>的一个特解</li>
<li>将<span
class="math inline"><em>A</em></span>化为<strong>行最简型</strong>，找出自由变量(非阶梯处，个数一定为<span
class="math inline"><em>n</em> − <em>r</em>(<em>A</em>)</span>个)，<strong>依次令其中一个为<span
class="math inline">1</span>，同时其余自由变量为<span
class="math inline">0</span></strong>，解出<span
class="math inline"><em>n</em> − <em>r</em>(<em>A</em>)</span>个解向量，即为基础解系</li>
<li>回到<span
class="math inline"><em>A</em><em>x</em> = <em>b</em></span>，<strong>令所有自由变量为<span
class="math inline">0</span></strong>，解出的解向量即为特解</li>
<li><strong>齐次</strong>线性方程组<strong>解的线性组合</strong>仍是该方程组的解</li>
<li><strong>一个非齐次</strong>线性方程组的解和<strong>多个</strong>对应齐次线性方程组的<strong>解的线性组合</strong>仍是该<strong>非齐次</strong>线性方程组的解</li>
<li><strong>非齐次</strong>线性方程组的<strong>解的线性组合</strong>仍为该方程组的解<span
class="math inline">⇔</span><strong>系数和为<span
class="math inline">1</span></strong></li>
<li><strong>非齐次</strong>线性方程组的<strong>解的差</strong>是对应<strong>齐次</strong>线性方程组的解</li>
</ul>
<h2 id="条件推理复习">条件推理复习</h2>
<p><span
class="math inline">$\begin{align}&amp;1.由线性方程组Ax=b解的情况推出秩(共有n个未知量):\\&amp;1).无解:r(A)\ne
r(A,b)\\&amp;2).有唯一解:r(A)=r(A,b)=n\\&amp;3).有无穷解:r(A)=r(A,b)&lt;n;\
其中基础解系个数为\
n-r(A)\\\\&amp;2.三个空间平面方程的关系:\\&amp;1).重合\Rightarrow有无穷解且可化为1条方程\Rightarrow
r(A)=r(A,b)=1\\&amp;2).交于一条直线\Rightarrow有无穷解且只能化为2条方程\Rightarrow
r(A)=r(A,b)=2\\&amp;3).交于一点\Rightarrow有唯一解\Rightarrow
r(A)=r(A,b)=3\\&amp;4).平行\Rightarrow无解\Rightarrow r(A)\ne
r(A,b)\\\\&amp;3.给出齐次线性方程组的一个基础解系A,同时给出可由A表出的B,判断B是否也是一个基础解系\\&amp;-\
B可由A表出\Rightarrow
B也是解\Rightarrow当B与A等价时,也为基础解系\Rightarrow写出B=AK,K可逆时,结论成立\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>向量与解析几何入门</title>
    <url>/blogs/2024/05/20/linearAlgebra-analytic-geometry/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="向量与解析几何">向量与解析几何</h1>
<h2 id="概述">概述</h2>
<h3 id="向量的线性表示">向量的线性表示</h3>
<p>在右手空间直角坐标系中，向量可表示为<span
class="math inline"><em>a⃗</em> = <em>a</em><sub>1</sub><em>i⃗</em> + <em>a</em><sub>2</sub><em>j⃗</em> + <em>a</em><sub>3</sub><em>k⃗</em></span>或<span
class="math inline"><em>a⃗</em> = (<em>a</em><sub>1</sub>,<em>a</em><sub>2</sub>,<em>a</em><sub>3</sub>)</span></p>
<p>两点形成的向量<span class="math inline">$\overrightarrow
{PQ}=(q_1-p_1,\ q_2-p_2,\ q_3-p_3)$</span></p>
<h3 id="向量的运算与关系">向量的运算与关系</h3>
<ul>
<li>加减法：平行四边形法则，线性表示为<span
class="math inline"><em>a⃗</em> + <em>b⃗</em> = (<em>a</em><sub>1</sub>+<em>b</em><sub>1</sub>, <em>a</em><sub>2</sub>+<em>b</em><sub>2</sub>, <em>a</em><sub>3</sub>+<em>b</em><sub>3</sub>)</span></li>
<li>数乘：线性表示为<span
class="math inline"><em>λ</em><em>a⃗</em> = (<em>λ</em><em>a</em><sub>1</sub>, <em>λ</em><em>a</em><sub>2</sub>, <em>λ</em><em>a</em><sub>3</sub>)</span>，模长<span
class="math inline">|<em>λ</em><em>a⃗</em>| = |<em>λ</em>||<em>a⃗</em>|</span></li>
<li>求模：线性表示为<span class="math inline">$|\vec
a|=\sqrt{a_1^2+a_2^2+a_3^2}$</span></li>
<li>点乘(数量积)：<span
class="math inline"><em>a⃗</em> · <em>b⃗</em> = |<em>a⃗</em>||<em>b⃗</em>| · cos <em>θ</em> = <em>a</em><sub>1</sub><em>b</em><sub>1</sub> + <em>a</em><sub>2</sub><em>b</em><sub>2</sub> + <em>a</em><sub>3</sub><em>b</em><sub>3</sub></span>，点乘满足交换、数乘结合、分配律</li>
<li>平行：线性表示为<span class="math inline">$\begin{align}&amp;\vec
a//\vec b\iff
\frac{a_1}{b_1}=\frac{a_2}{b_2}=\frac{a_3}{b_3}\end{align}$</span>，即叉乘的模长等于<span
class="math inline">0</span>，由行列式知识可知，平行时两向量各坐标值成比例</li>
<li>垂直：线性表示为<span
class="math inline"><em>a⃗</em> ⊥ <em>b⃗</em> ⇔ <em>a</em><sub>1</sub><em>b</em><sub>1</sub> + <em>a</em><sub>2</sub><em>b</em><sub>2</sub> + <em>a</em><sub>3</sub><em>b</em><sub>3</sub> = 0</span>，即点乘等于<span
class="math inline">0</span></li>
<li>夹角：由点乘，<span class="math inline">$\begin{align}\cos
\theta=\frac{\vec a·\vec b}{|\vec a||\vec
b|}\end{align}$</span>。一个向量的三个方向余弦<span
class="math inline">cos<sup>2</sup><em>θ</em><sub>1</sub> + cos<sup>2</sup><em>θ</em><sub>2</sub> + cos<sup>2</sup><em>θ</em><sub>3</sub> = 1</span></li>
<li>单位向量：<span class="math inline">$\begin{align}\vec e_{\vec
a}=\frac{\vec a}{|\vec a|}\end{align}$</span>，方向余弦<span
class="math inline">$\begin{align}\cos\theta_{x,y,z}=\frac{\vec
a_{x,y,z}}{|\vec a_{x,y,z}|}\end{align}$</span></li>
<li>投影：<span class="math inline"><em>a⃗</em></span>在<span
class="math inline"><em>b⃗</em></span>上的投影为<span
class="math inline">$\begin{align}(\vec a)_{\vec b}=|\vec
a|\cos\theta\end{align}$</span>，投影向量为<span
class="math inline">$\begin{align}(\vec a)_{\vec b}\frac{\vec b}{|\vec
b|}\end{align}$</span></li>
<li>叉乘(向量积)：方向为右手四指从<span
class="math inline"><em>a⃗</em></span>到<span
class="math inline"><em>b⃗</em></span>握后大拇指的方向，模长为<span
class="math inline">|<em>a⃗</em>||<em>b⃗</em>|sin <em>θ</em></span>。叉乘满足分配、数乘结合律，交换后结果方向相反。可以视<span
class="math inline"><em>a⃗</em> × <em>b⃗</em></span>为三阶行列式<span
class="math inline">$\left|\begin{matrix}\vec i&amp;\vec j&amp;\vec
k\\a_1&amp;a_2&amp;a_3\\b_1&amp;b_2&amp;b_3\end{matrix}\right|$</span>，整理后的线性表示为按第一行展开的结果，即<span
class="math inline">$\vec a\times\vec
b=(\left|\begin{matrix}a_2&amp;a_3\\b_2&amp;b_3\end{matrix}\right|,\
\left|\begin{matrix}a_1&amp;a_3\\b_1&amp;b_3\end{matrix}\right|,\
\left|\begin{matrix}a_1&amp;a_2\\b_1&amp;b_2\end{matrix}\right|)$</span>，两个向量的叉乘的模长等于<strong>平行四边形的面积</strong></li>
<li>混合积：称<span
class="math inline">(<em>a⃗</em>, <em>b⃗</em>, <em>c⃗</em>)</span>为<span
class="math inline">(<em>a⃗</em>×<em>b⃗</em>) · <em>c⃗</em></span>或<span
class="math inline"><em>a⃗</em> · (<em>b⃗</em>×<em>c⃗</em>)</span>，叉乘运算必然优先。可表示为三阶行列式<span
class="math inline">$\left|\begin{matrix}a_1&amp;a_2&amp;a_3\\b_1&amp;b_2&amp;b_3\\c_1&amp;c_2&amp;c_3\end{matrix}\right|$</span>，由行列式性质得它等于偶数次交换行/列，或转置后的结果。混合积的几何意义为它的绝对值等于<strong>平行六面体的体积</strong></li>
<li>自乘：<span class="math inline">$\vec a·\vec a=|\vec a|^2,\ \vec
a\times\vec a=\vec0$</span></li>
<li>若<span class="math inline">$\vec a\sdot\vec
b=0$</span>，则两向量垂直；若<span
class="math inline"><em>a⃗</em> × <em>b⃗</em> = 0</span>，则两向量平行；若<span
class="math inline">(<em>a⃗</em>, <em>b⃗</em>, <em>c⃗</em>) = 0</span>，则三向量共面</li>
</ul>
<h3 id="平面方程">平面方程</h3>
<ul>
<li>点法式：<span
class="math inline">$\begin{align}\frac{x-x_0}{A}=\frac{y-y_0}{B}=\frac{z-z_0}{C}\end{align}$</span>，法向量为<span
class="math inline">(<em>A</em>,<em>B</em>,<em>C</em>)</span>，平面必过点<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,<em>z</em><sub>0</sub>)</span></li>
<li>一般式：<span
class="math inline"><em>A</em><em>x</em> + <em>B</em><em>y</em> + <em>C</em><em>z</em> + <em>D</em> = 0</span>，法向量为<span
class="math inline">(<em>A</em>,<em>B</em>,<em>C</em>)</span></li>
<li>截距式：<span class="math inline">$\begin{align}\frac xA+\frac
yB+\frac zC=1\end{align}$</span></li>
</ul>
<p>两个相交平面确定一条直线，这条直线的<strong>同轴平面束</strong>为<span
class="math inline">(<em>A</em><sub>1</sub><em>x</em>+<em>B</em><sub>1</sub><em>y</em>+<em>C</em><sub>1</sub><em>z</em>+<em>D</em><sub>1</sub>) + <em>λ</em>(<em>A</em><sub>2</sub><em>x</em>+<em>B</em><sub>2</sub><em>y</em>+<em>C</em><sub>2</sub><em>z</em>+<em>D</em><sub>2</sub>)</span></p>
<h4 id="平面与平面的关系">平面与平面的关系</h4>
<ul>
<li>两平面相交，则<span class="math inline">$\begin{align}A_1:B_1:C_1\ne
A_2:B_2:C_2\end{align}$</span></li>
<li>两平面重合，则<span
class="math inline">$\begin{align}\frac{A_1}{A_2}=\frac{B_1}{B_2}=\frac{C_1}{C_2}=\frac{D_1}{D_2}\end{align}$</span></li>
<li>两平面平行，则<span
class="math inline">$\begin{align}\frac{A_1}{A_2}=\frac{B_1}{B_2}=\frac{C_1}{C_2}\ne\frac{D_1}{D_2}\end{align}$</span></li>
<li>平行平面间的<strong>距离</strong>：将<span
class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span>化为相同后，距离为<span
class="math inline">$\begin{align}\frac{|D_2-D_1|}{\sqrt{A^2+B^2+C^2}}\end{align}$</span>，由于距离公式含绝对值，需要注意有多个解</li>
<li>两平面间夹角：求两法向量间夹角的余弦值的绝对值，得到平面间夹角的余弦值</li>
</ul>
<h3 id="空间直线方程">空间直线方程</h3>
<ul>
<li>点向式(对称式)：<span
class="math inline">$\begin{align}\frac{x-x_0}A=\frac{y-y_0}B=\frac{z-z_0}C\end{align}$</span>，方向向量为<span
class="math inline">(<em>A</em>,<em>B</em>,<em>C</em>)</span>，直线必过点<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,<em>z</em><sub>0</sub>)</span></li>
<li>参数式：<span
class="math inline">$\begin{cases}x=x_0+At\\y=y_0+Bt\\z=z_0+Ct\end{cases}$</span>，方向向量为<span
class="math inline">(<em>A</em>,<em>B</em>,<em>C</em>)</span>，直线必过点<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,<em>z</em><sub>0</sub>)</span></li>
<li>两点式：<span
class="math inline">$\begin{align}\frac{x-x_0}{x_1-x_0}=\frac{y-y_0}{y_1-y_0}=\frac{z-z_0}{z_1-z_0}\end{align}$</span>，方向向量为<span
class="math inline">$\overrightarrow{P_0P_1}$</span></li>
<li>一般式：<span
class="math inline">$\begin{cases}A_1x+B_1y+C_1z+D_1=0\\A_2x+B_2y+C_2z+D_2=0\end{cases}$</span>，即两个平面的交线，方向向量为<span
class="math inline">(<em>A</em><sub>1</sub>,<em>B</em><sub>1</sub>,<em>C</em><sub>1</sub>) × (<em>A</em><sub>2</sub>,<em>B</em><sub>2</sub>,<em>C</em><sub>2</sub>)</span></li>
</ul>
<h4 id="空间直线方程间的转换">空间直线方程间的转换</h4>
<p>由于点向式与参数式容易互相转换，在这里只讲述一般式与参数式、两点式的互换：</p>
<ul>
<li>一般式化为参数式：联立两平面，令<span
class="math inline"><em>x</em>、<em>y</em>、<em>z</em></span>任意一者为<span
class="math inline"><em>t</em></span>，即得到参数式方程</li>
<li>快捷地，如果只需求一般式直线的方向向量，只需对两平面法向量进行叉乘即可</li>
<li>一般式化为两点式：令<span
class="math inline"><em>x</em>、<em>y</em>、<em>z</em></span>任意两者为<span
class="math inline">0</span>，求出必过的两点即可</li>
<li>参数式化为一般式：三个方程两两联立除去<span
class="math inline"><em>t</em></span>，求出两条关系式即可，点向式同理等式间两两联立整理即可</li>
</ul>
<h4 id="直线与直线的关系">直线与直线的关系</h4>
<ul>
<li>两直线异面：首先判断<strong>方向向量是否平行</strong>，若平行(叉乘为<span
class="math inline">$\vec
0$</span>)则两直线共面，否则应在直线中分别找出两点，得到向量<span
class="math inline">$\overrightarrow{P_1P_2}$</span>，与叉乘结果进行点乘运算，若不为<span
class="math inline">0</span>，则为异面；完整行为是求混合积，但有时可以不求<span
class="math inline">$\overrightarrow{P_1P_2}$</span>，并更容易判断共面情况</li>
<li>两直线共面且相交：在上述混合积为<span
class="math inline">0</span>的情况下，两方向向量不平行</li>
<li>两直线平行：两方向向量平行且都不与<span
class="math inline">$\overrightarrow {P_1P_2}$</span>平行</li>
<li>两直线重合：三个向量互相平行</li>
<li>平行直线间的距离：<span
class="math inline">$\begin{align}d=\frac{|\vec
{s_1}\times\overrightarrow {P_1P_2}|}{|\vec
{s_1}|}\end{align}$</span>，其中<span
class="math inline">$\vec{s_1}$</span>为某直线的方向向量，即利用了叉乘的正弦值</li>
<li>异面直线间的距离：<span
class="math inline">$\begin{align}d=\frac{|(\vec{s_1},\vec{s_2},\overrightarrow{P_1P_2})|}{|\vec{s_1}\times\vec{s_2}|}\end{align}$</span>，即利用混合积求出垂直于两条直线的公垂线</li>
</ul>
<h4 id="直线与平面的关系">直线与平面的关系</h4>
<ul>
<li>直线平行于平面：若直线非一般式，则方向向量与法向量垂直，且直线上点不在平面上，可利用<span
class="math inline"><em>P</em><sub>0</sub></span>判断；若为一般式，可直接观察其中一条平面方程是否与该平面平行</li>
<li>直线在平面上：若直线非一般式，则方向向量与法向量垂直，且<span
class="math inline"><em>P</em><sub>0</sub></span>应在平面上；若为一般式，可直接观察其中一条平面方程是否可与该平面化为一致</li>
<li>直线与平面相交于一点：若直线非一般式，则方向向量与法向量点乘不为<span
class="math inline">0</span>；若为一般式，可直接观察两条平面方程是否都不与该平面平行</li>
<li>直线与平面的夹角：利用方向向量与法向量的点乘求出直线与平面夹角的正弦值</li>
<li>平行直线离平面的距离：任意找出直线上一点，<span
class="math inline">$\begin{align}d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}\end{align}$</span>，由于距离公式含绝对值，需要注意有<strong>多个解</strong></li>
</ul>
<h3 id="二次曲面">二次曲面</h3>
<p>一个二元函数就是一个面，若自变量与因变量均为<span
class="math inline">1</span>次，则这个面是一个平面；若含有任意一个变量为二次，则称其为二次曲面</p>
<p>类似空间直线，空间曲线由<strong>两个空间曲面相交</strong>而成，<strong>截痕法</strong>通过曲面在三个坐标平面上的空间曲线来研究曲面的形状，例如令<span
class="math inline"><em>z</em> = 0</span>，可得到平面<span
class="math inline"><em>O</em><em>x</em><em>y</em></span>上的截痕</p>
<h4 id="常用二次曲面">常用二次曲面</h4>
<ul>
<li>球面：<span
class="math inline">(<em>x</em>−<em>x</em><sub>0</sub>)<sup>2</sup> + (<em>y</em>−<em>y</em><sub>0</sub>)<sup>2</sup> + (<em>z</em>−<em>z</em><sub>0</sub>)<sup>2</sup> = <em>r</em><sup>2</sup></span>，其中球心为<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,<em>z</em><sub>0</sub>)</span>，球半径为<span
class="math inline"><em>r</em></span></li>
<li>椭球面：若球面中各系数存在不同，则为椭球面，化简为<span
class="math inline">$\begin{align}\frac{(x-x_0)^2}{a^2}+\frac{(y-y_0)^2}{b^2}+\frac{(z-z_0)^2}{c^2}=1\end{align}$</span>
<ul>
<li>在三个坐标平面上的空间曲线均为椭圆(或圆)</li>
</ul></li>
<li>柱面：柱面由母线绕<strong>定曲线(即准线)</strong>平行于<strong>定直线<span
class="math inline"><em>l</em></span></strong>移动而成，一个只有两个变量的曲面一定是柱面，且平行于缺失变量所在坐标轴，以下方程中，<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>)</span>表示准线的中心
<ul>
<li>椭圆柱面：准线为椭圆，<span
class="math inline">$\begin{align}\frac{(x-x_0)^2}{a^2}+\frac{(y-y_0)^2}{b^2}=1\end{align}$</span>表示该柱面以一个椭圆为准线、且<span
class="math inline"><em>l</em>//<em>z</em></span>轴；特别地，当<span
class="math inline"><em>a</em><sup>2</sup> = <em>b</em><sup>2</sup></span>时，表示一个圆柱面</li>
<li>双曲柱面：准线为双曲线，<span
class="math inline">$\begin{align}\frac{(x-x_0)^2}{a^2}-\frac{(y-y_0)^2}{b^2}=1\end{align}$</span>，<span
class="math inline"><em>l</em>//<em>z</em></span>轴</li>
<li>抛物柱面：准线为抛物线，<span
class="math inline">$\begin{align}(x-x_0)^2-2py=0\end{align}$</span>，<span
class="math inline"><em>l</em>//<em>z</em></span>轴</li>
</ul></li>
<li>二次锥面：<span
class="math inline">$\begin{align}\frac{(x-x_0)^2}{a^2}+\frac{(y-y_0)^2}{b^2}-\frac{(z-z_0)^2}{c^2}=0\end{align}$</span>表示在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>与<span
class="math inline"><em>y</em> = <em>y</em><sub>0</sub></span>上的截痕均为<strong>一对直线</strong>，而在<span
class="math inline"><em>z</em> = <em>z</em><sub>0</sub></span>平面上截痕为<strong>一点</strong>，该点为<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,<em>z</em><sub>0</sub>)</span>(两<span
class="math inline"> ≥ 0</span>的数相加<span
class="math inline"> = 0</span>只有一个解)</li>
<li>单叶双曲面：<span
class="math inline">$\begin{align}\frac{(x-x_0)^2}{a^2}+\frac{(y-y_0)^2}{b^2}-\frac{(z-z_0)^2}{c^2}=1\end{align}$</span>表示在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>与<span
class="math inline"><em>y</em> = <em>y</em><sub>0</sub></span>上的截痕均为<strong>双曲线</strong>，而在<span
class="math inline"><em>z</em> = <em>z</em><sub>0</sub></span>上截痕为<strong>椭圆</strong>，其中心为<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,<em>z</em><sub>0</sub>)</span></li>
<li>双叶双曲面：<span
class="math inline">$\begin{align}\frac{(x-x_0)^2}{a^2}-\frac{(y-y_0)^2}{b^2}-\frac{(z-z_0)^2}{c^2}=1\end{align}$</span>表示在<span
class="math inline"><em>y</em> = <em>y</em><sub>0</sub></span>和<span
class="math inline"><em>z</em> = <em>z</em><sub>0</sub></span>上的截痕为<strong>双曲线</strong>，<span
class="math inline">$\begin{align}\frac{(x_1-x_0)^2}{a^2}-1=1\end{align}$</span>时，在<span
class="math inline"><em>x</em> = <em>x</em><sub>1</sub></span>上的截痕为<strong>椭圆</strong>；若<span
class="math inline"><em>x</em><sub>1</sub> &gt; <em>x</em><sub>0</sub></span>，因在<span
class="math inline"><em>x</em><sub>0</sub> &lt; <em>x</em> &lt; <em>x</em><sub>1</sub></span>间<strong>没有定义</strong>，故称双叶</li>
<li>椭圆抛物面：<span
class="math inline">$\begin{align}\pm(z-z_0)=\frac{(x-x_0)^2}{a^2}+\frac{(y-y_0)^2}{b^2}\end{align}$</span>表示在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>与<span
class="math inline"><em>y</em> = <em>y</em><sub>0</sub></span>上截痕为<strong>抛物线</strong>，而在<span
class="math inline"><em>z</em> = <em>z</em><sub>0</sub></span>上截痕为<strong>椭圆</strong></li>
<li>双曲抛物面(马鞍面)：<span
class="math inline">$\begin{align}z-z_0=\frac{(x-x_0)^2}{a^2}-\frac{(y-y_0)^2}{b^2}\end{align}$</span>表示在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>与<span
class="math inline"><em>y</em> = <em>y</em><sub>0</sub></span>上截痕为<strong>抛物线</strong>，而在<span
class="math inline"><em>z</em> = <em>z</em><sub>1</sub> ≠ <em>z</em><sub>0</sub></span>上截痕为<strong>双曲线</strong>，在<span
class="math inline"><em>z</em> = <em>z</em><sub>0</sub></span>上为<strong>一对直线</strong></li>
</ul>
<p>类似的，许多常见曲面应用截痕法记忆</p>
<p>由截痕法所求的在某个平面上的截痕方程，就是曲面在这个平面上的交线</p>
<p>而求曲线在坐标平面上的投影曲线，就是<strong>消去该方向上的坐标变量</strong>而合并成一条曲面方程后，和<strong>该平面方程</strong>组合而成的曲线方程</p>
<h4 id="一般形化简为标准形">一般形化简为标准形</h4>
<p>假设一个曲面方程的一般形为<span
class="math inline"><em>a</em><sub>11</sub><em>x</em><sup>2</sup> + <em>a</em><sub>22</sub><em>y</em><sup>2</sup> + <em>a</em><sub>33</sub><em>z</em><sup>2</sup> + 2<em>a</em><sub>12</sub><em>x</em><em>y</em> + 2<em>a</em><sub>13</sub><em>x</em><em>z</em> + 2<em>a</em><sub>23</sub><em>y</em><em>z</em> + <em>b</em><sub>1</sub><em>x</em> + <em>b</em><sub>2</sub><em>y</em> + <em>b</em><sub>3</sub><em>z</em> + <em>c</em> = 0</span>，要将它化为<span
class="math inline"><em>λ</em><sub>1</sub>(<em>x</em>′−<em>x</em><sub>0</sub>)<sup>2</sup> + <em>λ</em><sub>2</sub>(<em>y</em>′−<em>y</em><sub>0</sub>)<sup>2</sup> + <em>λ</em><sub>3</sub>(<em>z</em>′−<em>z</em><sub>0</sub>)<sup>2</sup> + <em>c</em> = 0</span>的形式，需要消除<span
class="math inline"><em>x</em><em>y</em>, <em>x</em><em>z</em>, <em>y</em><em>z</em></span>项，则需：</p>
<ul>
<li>将它的系数化为<strong>对称矩阵</strong>：<span
class="math inline">$A=\left[\begin{matrix}a_{11}&amp;a_{12}&amp;a_{13}\\a_{12}&amp;a_{22}&amp;a_{23}\\a_{13}&amp;a_{23}&amp;a_{33}\end{matrix}\right]$</span>，通过<span
class="math inline"><em>λ</em><em>E</em> − <em>A</em> = 0</span>，求出它的特征值<span
class="math inline"><em>λ</em><sub>1, 2, 3</sub></span></li>
<li>若<span
class="math inline"><em>b</em><sub>1</sub> = <em>b</em><sub>2</sub> = <em>b</em><sub>3</sub> = 0</span>，则不需要作平移变换，且<span
class="math inline"><em>x</em><sub>0</sub> = <em>y</em><sub>0</sub> = <em>z</em><sub>0</sub> = 0</span></li>
<li>否则，需要平移变换，即找出正交阵<span
class="math inline"><em>X</em></span>，使<span
class="math inline">$X^TAX=\rm
diag(\lambda_1,\lambda_2,\lambda_3)$</span></li>
<li>则<span
class="math inline">$\left(\begin{matrix}b_1&amp;b_2&amp;b_3\end{matrix}\right)X=\left(\begin{matrix}d_1&amp;d_2&amp;d_3\end{matrix}\right)$</span></li>
</ul>
<h4 id="求解未知曲面方程">求解未知曲面方程</h4>
<p>在实际求解方程时，先设所求曲面上一点<span
class="math inline"><em>M</em>(<em>x</em>,<em>y</em>,<em>z</em>)</span>，然后根据条件求其一般形<span
class="math inline"><em>F</em>(<em>x</em>,<em>y</em>,<em>z</em>) = 0</span>，根据需要进行正交变换转换为标准方程，再判断其形状</p>
<p>能利用的条件有许多：</p>
<ul>
<li><span class="math inline"><em>M</em></span>距球面(球心为<span
class="math inline"><em>O</em></span>)距离：<span
class="math inline">$d=\Big||\overrightarrow{MO}|-R\Big|$</span></li>
<li>给出双参数方程，则联立消去参数，可转化为一般形</li>
<li>给出旋转轴和动曲线，先找到这条动曲线上任意点的表示形式，如<span
class="math inline"><em>M</em><sub>0</sub>(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,<em>z</em><sub>0</sub>)</span>，然后通过与旋转轴的关系(即在某一方向上，动曲线的值<span
class="math inline"><em>k</em><sub>0</sub></span>与待求曲面的值<span
class="math inline"><em>k</em></span>相同、以及<span
class="math inline"><em>M</em><sub>0</sub></span>与轴的距离不变)，求出<span
class="math inline"><em>M</em><sub>0</sub></span>与<span
class="math inline"><em>M</em></span>的关系，再由<span
class="math inline"><em>M</em><sub>0</sub></span>内部的关系得出<span
class="math inline"><em>M</em></span>内部的关系
<ul>
<li>具体来说，假设要求动直线<span
class="math inline"><em>L</em></span>绕<span
class="math inline"><em>z</em></span>轴旋转后的曲面方程，其中<span
class="math inline"><em>L</em></span>方向向量为<span
class="math inline"><em>s⃗</em></span>；<span
class="math inline">(1)</span>则<span
class="math inline"><em>M</em><sub>0</sub></span>的三个坐标值与<span
class="math inline"><em>s⃗</em></span>相关；<span
class="math inline">(2)</span>由于绕<span
class="math inline"><em>z</em></span>轴，则在<span
class="math inline"><em>z</em></span>轴方向上，<span
class="math inline"><em>z</em> = <em>z</em><sub>0</sub></span>；<span
class="math inline">(3)</span>在同一个<span
class="math inline"><em>z</em><sub>0</sub></span>上，有<span
class="math inline"><em>r</em><sup>2</sup> = <em>x</em><sup>2</sup> + <em>y</em><sup>2</sup> = <em>x</em><sub>0</sub><sup>2</sup> + <em>y</em><sub>0</sub><sup>2</sup></span>；由<span
class="math inline">(1), (2), (3)</span>得到的式子联立，可求出未知曲面方程</li>
</ul></li>
</ul>
<h2 id="练习">练习</h2>
<p><span
class="math inline">$\begin{align}&amp;1.求过点M_1(-1,0,4),且与平面\pi_1:3x-4y+z-10=0平行,又与直线L_1:\frac{x+1}3=\frac{y-3}1=\frac
z2\\&amp;相交的直线L的方程.\\&amp;解:\\&amp;设L方向向量为(A,B,C),由\pi_1法向量为(3,-4,1),得3A-4B+C=0\\&amp;又L_1的方向向量为(3,1,2),其中一点为M_2(-1,3,0),由它们相交得(\vec
{s_{L}},\vec{s_{L_1}},\overrightarrow{M_1M_2})=0\\&amp;即10A-12B-9C=0,令C=4,得A=48,B=37,即L:\frac{x+1}{48}=\frac{y}{37}=\frac{x-4}4\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;2.设两直线L_1:\begin{cases}x-3y+z=0\\2x-4y+z+1=0\end{cases};L_2:x=\frac{y+1}3=\frac{z-2}4\\&amp;(1).证明异面.(2).求距离.(3).求过L_1且平行于L_2的平面方程\\&amp;解:\\&amp;(1).令z=t,化L_1为\begin{cases}x=\frac32+\frac
t2\\y=\frac12+\frac t2\\z=t\end{cases},\vec
{s_1}=(1,1,2),过点M_1(\frac32,\frac12,0)\\&amp;则(\vec
{s_1},\vec{s_2},\overrightarrow{M_1M_2})=2\ne
0,故异面.\\&amp;(2).d=\Bigg|\frac{(\vec
{s_1},\vec{s_2},\overrightarrow{M_1M_2})}{|\vec{s_1}\times\vec{s_2}|}\Bigg|=\frac1{\sqrt3}\\&amp;(3).由两方向向量叉乘,且平面过M_1,得方程为x+y-z+2=0\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;3.已知点A,B的坐标分别为(1,0,0),(0,1,1).线段AB绕z轴旋转一周所成的曲面为S.\\&amp;求S及平面z=0,z=1围成的立体体积.\\&amp;解:\\&amp;线段AB所在直线的方向向量为(1,-1,-1),设其上任意一点为(x_0,y_0,z_0)\\&amp;则L_{AB}:x_0-1=-y_0=-z_0&amp;(1).\\&amp;设所求曲面任意一点为(x,y,z),绕z轴旋转,故z=z_0&amp;(2).\\&amp;由r^2=x^2+y^2=x_0^2+y_0^2与上式联立得,x^2+y^2=(1-z)^2+z^2\\&amp;即x^2+y^2-2z^2+2z-1=0.\\&amp;故在平行于Oxy平面上的截面面积为S=\pi(2z^2-2z+1),\\&amp;V=\int_0^1Sdz=\frac23\pi\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数: 行列式</title>
    <url>/blogs/2024/05/14/linearAlgebra-determinant/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="行列式">行列式</h1>
<h2 id="结论">结论</h2>
<ul>
<li><span
class="math inline">|<em>A</em><sup><em>T</em></sup>| = |<em>A</em>|</span></li>
<li>一般矩阵一次对调变换后，<span
class="math inline">|<em>A</em>|</span>取反</li>
<li><strong>一般矩阵或分块矩阵</strong>一次倍加变换后，<span
class="math inline">|<em>A</em>|</span>不变</li>
<li><span
class="math inline">|<em>k</em><em>A</em>| = <em>k</em><sup><em>n</em></sup>|<em>A</em>|</span></li>
<li>分块矩阵一次对调变换后，<span
class="math inline">$\left|\begin{matrix}A_{m\times j}&amp;B_{m\times
k}\\C_{n\times j}&amp;D\end{matrix}\right|=(-1)^{m\times
n}\left|\begin{matrix}C_{n\times j}&amp;D\\A_{m\times j}&amp;B_{m\times
k}\end{matrix}\right|=(-1)^{j\times k}\left|\begin{matrix}B_{m\times
k}&amp;A_{m\times j}\\D&amp;C_{n\times
j}\end{matrix}\right|$</span></li>
<li><span
class="math inline">|<em>A</em><sup>−1</sup>| = |<em>A</em>|<sup>−1</sup></span></li>
<li><span
class="math inline"><em>若</em><em>A</em>、<em>B</em><em>都</em><em>为</em><em>方</em><em>阵</em>, <em>则</em>|<em>A</em><em>B</em>| = |<em>A</em>||<em>B</em>|</span></li>
<li><span
class="math inline"><em>若</em><em>A</em><em>可</em><em>逆</em>, <em>则</em><em>A</em><sup>*</sup> = |<em>A</em>|<em>A</em><sup>−1</sup></span></li>
<li><span
class="math inline"><em>无</em><em>论</em><em>A</em><em>是</em><em>否</em><em>可</em><em>逆</em>, |<em>A</em><sup>*</sup>| = ||<em>A</em>|<em>A</em><sup>−1</sup>| = |<em>A</em>|<sup><em>n</em> − 1</sup>, (<em>方</em><em>便</em><em>记</em><em>忆</em>,<em>实</em><em>际</em><em>推</em><em>导</em><em>分</em><em>情</em><em>况</em>)</span></li>
<li><span class="math inline">$若A、C为方阵,\
则\left|\begin{matrix}A&amp;B\\O&amp;C\end{matrix}\right|=|A||C|$</span></li>
<li><span class="math inline">$若A、B为同阶方阵,\
则\left|\begin{matrix}A&amp;B\\B&amp;A\end{matrix}\right|=|A+B||A-B|$</span></li>
<li><span
class="math inline">|<em>A</em>| ≠ 0 ⇔ <em>A</em><em>可</em><em>逆</em> ⇔ <em>A</em><em>为</em><em>非</em><em>奇</em><em>异</em><em>矩</em><em>阵</em> ⇔ <em>对</em><em>应</em><em>线</em><em>性</em><em>方</em><em>程</em><em>组</em><em>有</em><em>唯</em><em>一</em><em>解</em> ⇔ <em>r</em>(<em>A</em>) = <em>n</em></span></li>
<li>上条的部分内容为<strong>克莱姆法则</strong>的一部分，若任一<span
class="math inline"><em>n</em></span>个未知量、<span
class="math inline"><em>n</em></span>条方程的线性方程组中，由系数组成的方阵的行列式<strong>不为<span
class="math inline">0</span></strong>，则有<strong>唯一解</strong>，且<span
class="math inline">$\begin{align}x=(\frac{D_1}D,\frac{D_2}D,\cdots,\frac{D_n}D)\end{align}$</span>，其中<span
class="math inline"><em>D</em><sub><em>j</em></sub></span>为将原行列式中的第<span
class="math inline"><em>j</em></span>列元素替换成列向量<span
class="math inline"><em>b</em></span>后形成的行列式</li>
<li>特别地，若<span
class="math inline"><em>b</em> = <em>O</em></span>，即<strong>齐次线性方程组</strong>中，<span
class="math inline">$\begin{cases}有唯一零解,&amp;|A|\ne0\\一定含有非零解，也即无穷多个解,&amp;|A|=0\end{cases}$</span></li>
<li>行列式某一行(列)元素与本身的代数余子式的乘积为该行列式的值，与<strong>另一行</strong>(列)<strong>对应元素的代数余子式</strong>的乘积为<span
class="math inline">0</span></li>
</ul>
<h2 id="运算技巧">运算技巧</h2>
<h3 id="特殊行列式">特殊行列式</h3>
<p><strong>对角或上三角或下三角</strong>：<span
class="math inline">$\begin{align}|A|=\prod_{n\ge
i\ge1}a_{ii}\end{align}$</span></p>
<p><strong>类对角或类上三角或类下三角</strong>：<span
class="math inline">$\begin{align}|A|=(-1)^{\frac{n(n-1)}2}\prod_{n\ge
i\ge1}a_{ii}\end{align}$</span></p>
<p><strong>范德蒙德行列式</strong>：</p>
<p><span
class="math inline">$\begin{align}\left|\begin{matrix}1&amp;\dots&amp;1\\x_1&amp;\dots&amp;x_n\\x_1^2&amp;\dots&amp;x_n^2\\\vdots&amp;&amp;\vdots\\x_1^{n-1}&amp;\dots&amp;x_n^{n-1}\end{matrix}\right|=\prod_{n\ge
i&gt;j\ge1}(x_i-x_j)\end{align}$</span></p>
<p>例：<span
class="math inline">$\begin{align}\left|\begin{matrix}1&amp;1&amp;1&amp;\dots&amp;1\\2&amp;2^2&amp;2^3&amp;\dots&amp;2^n\\3&amp;3^2&amp;3^3&amp;\dots&amp;3^n\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\n&amp;n^2&amp;n^3&amp;\dots&amp;n^n\end{matrix}\right|\end{align}$</span>，虽然不是范德蒙德行列式，但可以转化为这种形式：每行均可以提出公因子，得原式<span
class="math inline">$\begin{align}=n!\left|\begin{matrix}1&amp;1&amp;1&amp;\dots&amp;1\\1&amp;2&amp;2^2&amp;\dots&amp;2^{n-1}\\1&amp;3&amp;3^2&amp;\dots&amp;3^{n-1}\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\1&amp;n&amp;n^2&amp;\dots&amp;n^{n-1}\end{matrix}\right|=n!(n-1)!\cdots2!\end{align}$</span></p>
<h3 id="简单行列式消零">简单行列式消零</h3>
<p><strong>一</strong>：</p>
<p>大部分元素相同，而且每行、每列只有一个不同的元素，而且这些元素相同时，例如：</p>
<p><span
class="math inline">$\begin{align}\left|\begin{matrix}b&amp;a&amp;\dots&amp;a\\a&amp;b&amp;\dots&amp;a\\\vdots&amp;\vdots&amp;&amp;\vdots\\a&amp;a&amp;\dots&amp;b\end{matrix}\right|\end{align}$</span></p>
<p>将每一行(列)加到第一行(列)，提出公因子<span
class="math inline"><em>b</em> − (<em>n</em>−1)<em>a</em></span>，再通过倍加变换消掉剩余的<span
class="math inline"><em>a</em></span>，可得到大部分元素为<span
class="math inline">0</span>的行列式，特别地，在这个例子里，<span
class="math inline">|<em>A</em>| = (<em>b</em> − (<em>n</em>−1)<em>a</em>)(<em>b</em>−<em>a</em>)<sup><em>n</em> − 1</sup></span></p>
<p>若观察到<strong>每行(列)元素的和相同</strong>，也可以采用这种方法</p>
<p>若观察发现<strong>类似范德蒙德行列式</strong>，却有某几行有区别，也可采用这种方法</p>
<hr />
<p><strong>二</strong>：<strong>三对角行列式</strong></p>
<p>形如<span
class="math inline">$\begin{align}D_n=\left|\begin{matrix}a&amp;b&amp;0&amp;\dots&amp;0\\c&amp;a&amp;b&amp;\dots&amp;0\\0&amp;c&amp;a&amp;\dots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\0&amp;0&amp;0&amp;\dots&amp;a\end{matrix}\right|\end{align}$</span>的三对角元分别相同的行列式，可采用<strong>递推法</strong></p>
<p>在这个例子里，<span
class="math inline"><em>D</em><sub><em>n</em></sub> = <em>a</em><em>D</em><sub><em>n</em> − 1</sub> − <em>b</em><em>c</em><em>D</em><sub><em>n</em> − 2</sub></span></p>
<p>设<span
class="math inline"><em>D</em><sub><em>n</em></sub> − <em>x</em><em>D</em><sub><em>n</em> − 1</sub> = <em>y</em>(<em>D</em><sub><em>n</em> − 1</sub>−<em>x</em><em>D</em><sub><em>n</em> − 2</sub>)</span>，解得<span
class="math inline">$\begin{align}\begin{cases}x=\large\frac{2bc}{a+\sqrt{a^2-4bc}}\\y=\large\frac{a+\sqrt{a^2-4bc}}2\end{cases}\end{align}$</span>或<span
class="math inline">$\begin{align}\begin{cases}x=\large\frac{2bc}{a-\sqrt{a^2-4bc}}\\y=\large\frac{a-\sqrt{a^2-4bc}}2\end{cases}\end{align}$</span></p>
<p>递归代入原方程后可得到两条关于<span
class="math inline"><em>D</em><sub><em>n</em></sub></span>和<span
class="math inline"><em>D</em><sub><em>n</em> − 1</sub></span>的式子，通过消元即可得到<span
class="math inline"><em>D</em><sub><em>n</em></sub></span></p>
<p>这种行列式很特殊，事实上三对角行列式都可以采用递推法</p>
<hr />
<p><strong>三</strong>：<strong>递推变种</strong></p>
<p><span class="math inline">(1).</span>形如<span
class="math inline">$\begin{align}D_n=\left|\begin{matrix}a&amp;b&amp;0&amp;\dots&amp;0\\0&amp;a&amp;b&amp;\dots&amp;0\\0&amp;0&amp;a&amp;\dots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\c&amp;c&amp;c&amp;\dots&amp;a\end{matrix}\right|\end{align}$</span>或<span
class="math inline">$\begin{align}D_n=\left|\begin{matrix}a&amp;0&amp;0&amp;\dots&amp;b\\c&amp;a&amp;0&amp;\dots&amp;b\\0&amp;c&amp;a&amp;\dots&amp;b\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\0&amp;0&amp;0&amp;\dots&amp;a\end{matrix}\right|\end{align}$</span>的行列式也可用<strong>递推法</strong></p>
<p>例如，在左式例子中，<span
class="math inline"><em>D</em><sub><em>n</em></sub> = <em>a</em><em>D</em><sub><em>n</em> − 1</sub> + (−1)<sup><em>n</em> + 1</sup><em>c</em><em>b</em><sup><em>n</em> − 1</sup></span></p>
<p>又例如，<span
class="math inline">$\begin{align}D_n=\left|\begin{matrix}a&amp;-1&amp;0&amp;\dots&amp;0\\0&amp;a&amp;-1&amp;\dots&amp;0\\0&amp;0&amp;a&amp;\dots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\x_1&amp;x_2&amp;x_3&amp;\dots&amp;a+x_n\end{matrix}\right|=aD_{n-1}+x_1\end{align}$</span></p>
<p><span
class="math inline">∴ <em>D</em><sub><em>n</em></sub> = <em>a</em><sup><em>n</em></sup> + <em>a</em><sup><em>n</em> − 1</sup><em>x</em><sub><em>n</em></sub> + … + <em>a</em><em>x</em><sub>2</sub> + <em>x</em><sub>1</sub></span></p>
<p><strong>若上式<span
class="math inline"><em>a</em> = <em>b</em></span></strong>，还可以采用<strong>逐列倍加法</strong>，即把第<span
class="math inline"><em>i</em></span>列的元素的<span
class="math inline"> − 1</span>倍加到第<span
class="math inline"><em>i</em> + 1</span>列上</p>
<p><span class="math inline">(2).</span>形如<span
class="math inline">$D_{2n}=\left|\begin{matrix}a&amp;&amp;&amp;&amp;&amp;&amp;&amp;b\\&amp;a&amp;&amp;&amp;&amp;&amp;b\\&amp;&amp;\ddots&amp;&amp;&amp;\dots\\&amp;&amp;&amp;a&amp;b\\&amp;&amp;&amp;c&amp;d\\&amp;&amp;\dots&amp;&amp;&amp;d\\&amp;c&amp;&amp;&amp;&amp;&amp;\ddots\\c&amp;&amp;&amp;&amp;&amp;&amp;&amp;d\end{matrix}\right|$</span>的<span
class="math inline">2<em>n</em></span>阶行列式也可用递推法</p>
<p><span
class="math inline"><em>D</em><sub>2<em>n</em></sub> = (<em>a</em><em>d</em>−<em>b</em><em>c</em>)<em>D</em><sub>2<em>n</em> − 2</sub>、<em>D</em><sub>2</sub> = <em>a</em><em>d</em> − <em>b</em><em>c</em> ⇒ <em>D</em><sub>2<em>n</em></sub> = (<em>a</em><em>d</em>−<em>b</em><em>c</em>)<sup><em>n</em></sup></span></p>
<hr />
<p><strong>四</strong>：<strong>升阶法</strong></p>
<p>当行列式每行(列)中有大部分元素相同，其中有部分元素不同时，可采用升阶法</p>
<p>例如<span
class="math inline">$\begin{align}\left|\begin{matrix}a&amp;x_2&amp;x_3&amp;\dots&amp;x_n\\x_1&amp;b&amp;x_3&amp;\dots&amp;x_n\\x_1&amp;x_2&amp;c&amp;\dots&amp;x_n\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\x_1&amp;x_2&amp;x_3&amp;\dots&amp;y\end{matrix}\right|\end{align}$</span>，由于各行、各列和不相同，不能提出公因子</p>
<p>可以转化为<span
class="math inline">$\begin{align}\left|\begin{matrix}1&amp;x_1&amp;x_2&amp;x_3&amp;\dots&amp;x_n\\0&amp;a&amp;x_2&amp;x_3&amp;\dots&amp;x_n\\0&amp;x_1&amp;b&amp;x_3&amp;\dots&amp;x_n\\0&amp;x_1&amp;x_2&amp;c&amp;\dots&amp;x_n\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\0&amp;x_1&amp;x_2&amp;x_3&amp;\dots&amp;y\end{matrix}\right|\end{align}$</span>，利用第一行消去其它行的大部分元素：</p>
<p><span
class="math inline">$\begin{align}\left|\begin{matrix}1&amp;x_1&amp;x_2&amp;x_3&amp;\dots&amp;x_n\\-1&amp;a-x_1&amp;0&amp;0&amp;\dots&amp;0\\-1&amp;0&amp;b-x_2&amp;0&amp;\dots&amp;0\\-1&amp;0&amp;0&amp;c-x_3&amp;\dots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\-1&amp;0&amp;0&amp;0&amp;\dots&amp;y-x_n\end{matrix}\right|\end{align}$</span></p>
<p>再消去第一列的<span class="math inline"> − 1</span>：<span
class="math inline">$\begin{align}\left|\begin{matrix}{\large1+\frac{x_1}{a-x_1}+\dots+\frac{x_n}{y-x_n}}&amp;x_1&amp;x_2&amp;x_3&amp;\dots&amp;x_n\\0&amp;a-x_1&amp;0&amp;0&amp;\dots&amp;0\\0&amp;0&amp;b-x_2&amp;0&amp;\dots&amp;0\\0&amp;0&amp;0&amp;c-x_3&amp;\dots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\0&amp;0&amp;0&amp;0&amp;\dots&amp;y-x_n\end{matrix}\right|\end{align}$</span></p>
<p>化为上三角行列式</p>
<hr />
<p><strong>五</strong>：<strong>逐行(列)倍加法</strong></p>
<p>若大部分相邻两行(列)间的大部分一一对应的元素差距相似，可考虑该方法，例：</p>
<p><span
class="math inline">$\begin{align}D_n=\left|\begin{matrix}0&amp;1&amp;2&amp;\cdots&amp;n-2&amp;n-1\\1&amp;0&amp;1&amp;\cdots&amp;n-3&amp;n-2\\2&amp;1&amp;0&amp;\cdots&amp;n-4&amp;n-3\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\n-2&amp;n-3&amp;n-4&amp;\cdots&amp;0&amp;1\\n-1&amp;n-2&amp;n-3&amp;\cdots&amp;1&amp;0\end{matrix}\right|\end{align}$</span></p>
<p>行和不相同，列和也不相同，但观察到第<span
class="math inline"><em>i</em> − 1</span>行的<strong>大部分</strong>元素为第<span
class="math inline"><em>i</em></span>行对应元素减<span
class="math inline">1</span>，则逐行向后倍加(第<span
class="math inline"><em>i</em> + 1</span>行乘<span
class="math inline"> − 1</span>倍加到第<span
class="math inline"><em>i</em></span>行，<span
class="math inline"><em>i</em></span>从<span
class="math inline">1</span>开始)：</p>
<p><span
class="math inline">$\begin{align}&amp;D_n=\left|\begin{matrix}-1&amp;1&amp;1&amp;\cdots&amp;1&amp;1\\-1&amp;-1&amp;1&amp;\cdots&amp;1&amp;1\\-1&amp;-1&amp;-1&amp;\cdots&amp;1&amp;1\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\-1&amp;-1&amp;-1&amp;\cdots&amp;-1&amp;1\\n-1&amp;n-2&amp;n-3&amp;\cdots&amp;1&amp;0\end{matrix}\right|=\left|\begin{matrix}0&amp;2&amp;2&amp;\cdots&amp;2&amp;1\\0&amp;0&amp;2&amp;\cdots&amp;2&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;2&amp;1\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\n-1&amp;n-2&amp;n-3&amp;\cdots&amp;1&amp;0\end{matrix}\right|\\&amp;=(-1)^{1+n}(n-1)2^{n-2}\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数: 矩阵</title>
    <url>/blogs/2024/05/11/linearAlgebra-matrix/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="矩阵">矩阵</h1>
<h2 id="概念">概念</h2>
<p>形如<span
class="math inline">$\begin{align}\left[\begin{matrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1\rm
n}\\a_{21}&amp;a_{22}&amp;...&amp;a_{2\rm
n}\\\vdots&amp;\vdots&amp;&amp;\vdots\\a_{\rm m1}&amp;a_{\rm
m2}&amp;...&amp;a_{\rm
mn}\end{matrix}\right]\end{align}$</span>的矩阵称为<span
class="math inline"><em>m</em> × <em>n</em></span>矩阵，记为<span
class="math inline"><em>A</em><sub><em>m</em> × <em>n</em></sub></span></p>
<ul>
<li>行矩阵/列矩阵：只有一行/一列的矩阵</li>
<li><span class="math inline"><em>n</em></span>阶矩阵：<span
class="math inline"><em>A</em><sub><em>n</em> × <em>n</em></sub></span></li>
<li>三角形矩阵(<span
class="math inline">0</span>一般省略不写)：三角形矩阵一定是方阵
<ul>
<li>对角矩阵：<span
class="math inline">$\begin{align}\left[\begin{matrix}a_{11}&amp;0&amp;...&amp;0\\0&amp;a_{22}&amp;...&amp;0\\\vdots&amp;\vdots&amp;&amp;\vdots\\0&amp;0&amp;...&amp;a_{\rm
nn}\end{matrix}\right]\end{align}$</span>，记为<span
class="math inline">$\rm diag(a_{11},a_{22},\cdots,a_{nn})$</span></li>
<li>上三角矩阵：<span
class="math inline">$\begin{align}\left[\begin{matrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1\rm
n}\\0&amp;a_{22}&amp;...&amp;a_{2\rm
n}\\\vdots&amp;\vdots&amp;&amp;\vdots\\0&amp;0&amp;...&amp;a_{\rm
nn}\end{matrix}\right]\end{align}$</span></li>
<li>下三角矩阵：<span
class="math inline">$\begin{align}\left[\begin{matrix}a_{11}&amp;0&amp;...&amp;0\\a_{21}&amp;a_{22}&amp;...&amp;0\\\vdots&amp;\vdots&amp;&amp;\vdots\\a_{\rm
m1}&amp;a_{\rm m2}&amp;...&amp;a_{\rm
nn}\end{matrix}\right]\end{align}$</span></li>
</ul></li>
<li>单位矩阵：<span class="math inline">$\rm
diag(1,1,\cdots,1)$</span>，记为<span
class="math inline"><em>E</em></span>或<span
class="math inline"><em>I</em></span></li>
<li>同型矩阵：行、列数相同的两矩阵</li>
</ul>
<h2 id="运算">运算</h2>
<h3 id="基本运算">基本运算</h3>
<ul>
<li>加/减法运算：<span
class="math inline"><em>A</em> + <em>B</em></span>即把各对应的元素相加/减，其中<span
class="math inline"><em>A</em>、<em>B</em></span>必须是同型矩阵</li>
<li>数乘运算：<span class="math inline">$k\bf
A$</span>即每个元素都乘上<span
class="math inline"><em>k</em></span></li>
<li>乘法运算：<span class="math inline">$A_{\rm m\times k}B_{\rm k\times
m}=C_{\rm m\times n}$</span>，<span
class="math inline">$\begin{align}c_{ij}=\sum_{a=1}^ka_{\rm ia}b_{\rm
aj}\end{align}$</span></li>
</ul>
<h3 id="运算的性质">运算的性质</h3>
<p>加减法与数乘运算的性质不赘述</p>
<ul>
<li>一般<span
class="math inline"><em>A</em><em>B</em> ≠ <em>B</em><em>A</em></span>，若<span
class="math inline"><em>A</em><em>B</em> = <em>B</em><em>A</em></span>，则<span
class="math inline"><em>A</em>、<em>B</em></span>为同阶方阵</li>
<li><span class="math inline"><em>A</em> ≠ <em>O</em></span>时，若<span
class="math inline"><em>A</em><em>B</em> = <em>A</em><em>C</em></span>，一般<span
class="math inline"><em>B</em> ≠ <em>C</em></span></li>
<li>若<span
class="math inline"><em>A</em><em>B</em> = <em>O</em></span>，一般<span
class="math inline"><em>A</em> ≠ <em>O</em></span>或<span
class="math inline"><em>B</em> ≠ <em>O</em></span>；若<span
class="math inline"><em>A</em> ≠ <em>O</em></span>且<span
class="math inline"><em>B</em> ≠ <em>O</em></span>，<span
class="math inline"><em>A</em><em>B</em></span>可能等于<span
class="math inline"><em>O</em></span></li>
<li><span
class="math inline"><em>A</em>(<em>B</em><em>C</em>) = (<em>A</em><em>B</em>)<em>C</em></span></li>
<li><span
class="math inline"><em>k</em>(<em>A</em><em>B</em>) = (<em>k</em><em>A</em>)<em>B</em> = <em>A</em>(<em>k</em><em>B</em>)</span></li>
<li><span
class="math inline"><em>A</em>(<em>B</em>+<em>C</em>) = <em>A</em><em>B</em> + <em>A</em><em>C</em></span>；<span
class="math inline">(<em>A</em>+<em>B</em>)<em>C</em> = <em>A</em><em>C</em> + <em>B</em><em>C</em></span></li>
<li><span
class="math inline"><em>A</em><em>E</em><sub>1</sub> = <em>E</em><sub>2</sub><em>A</em> = <em>A</em></span>，若<span
class="math inline"><em>A</em></span>为方阵，则<span
class="math inline"><em>E</em><sub>1</sub> = <em>E</em><sub>2</sub></span></li>
<li>两个同阶且相同类型的三角形矩阵相乘还是对应类型的三角形矩阵，且新矩阵对角元等于两矩阵对角元相乘</li>
</ul>
<h2 id="线性方程组的矩阵形式">线性方程组的矩阵形式</h2>
<p>形如<span
class="math inline">$\begin{align}\begin{cases}a_{11}x_1+a_{12}x_2+\cdots+a_{1\rm
n}x_n=b_1,\\a_{21}x_1+a_{22}x_2+\cdots+a_{2\rm n}x_n=b_2,\\\ \ \ \ \ \ \
\ \ \ \ \ \ \ \ \ \ \cdots\cdots\cdots\cdots\\a_{\rm m1}x_1+a_{\rm
m2}x_2+\cdots+a_{\rm mn}x_n=b_m\end{cases}\end{align}$</span>的<span
class="math inline"><em>m</em></span>条<span
class="math inline"><em>n</em></span>元一次方程组称为<span
class="math inline"><em>m</em> × <em>n</em></span>型方程组的一般形式</p>
<p>令<span
class="math inline">$\begin{align}A=\left[\begin{matrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1\rm
n}\\a_{21}&amp;a_{22}&amp;...&amp;a_{2\rm
n}\\\vdots&amp;\vdots&amp;&amp;\vdots\\a_{\rm m1}&amp;a_{\rm
m2}&amp;...&amp;a_{\rm
mn}\end{matrix}\right],x=\left[\begin{matrix}x_1\\x_2\\\vdots\\x_n\end{matrix}\right],b=\left[\begin{matrix}b_1\\b_2\\\vdots\\b_n\end{matrix}\right]\end{align}$</span></p>
<p>则<span
class="math inline"><em>A</em><em>x</em> = <em>b</em></span>，这是它的矩阵形式，其中<span
class="math inline"><em>A</em></span>称为系数矩阵，<span
class="math inline"><em>b</em></span>称为常数向量</p>
<p>增广矩阵：<span
class="math inline">$[A,b]=\left[\begin{matrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1\rm
n}&amp;b_1\\a_{21}&amp;a_{22}&amp;...&amp;a_{2\rm
n}&amp;b_2\\\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots\\a_{\rm
m1}&amp;a_{\rm m2}&amp;...&amp;a_{\rm
mn}&amp;b_m\end{matrix}\right]$</span></p>
<p>当<span
class="math inline"><em>b</em> = <em>O</em></span>时，称为齐次线性方程组</p>
<h2 id="转置">转置</h2>
<h3 id="定义">定义</h3>
<p><span
class="math inline"><em>A</em><sub><em>n</em> × <em>m</em></sub></span>称为<span
class="math inline"><em>A</em><sub><em>m</em> × <em>n</em></sub></span>的转置矩阵，记为<span
class="math inline">$A^{\rm T}$</span></p>
<h3 id="转置的性质">转置的性质</h3>
<ul>
<li><span class="math inline">$(A+B)^{\rm T}=A^{\rm T}+B^{\rm
T}$</span></li>
<li><span class="math inline">$(AB)^{\rm T}=B^{\rm T}A^{\rm
T}$</span></li>
<li>对称矩阵/反称矩阵：设<span
class="math inline"><em>A</em></span>为方阵，若<span
class="math inline">$A^{\rm T}=A$</span>，则为对称矩阵；若<span
class="math inline">$A^{\rm T}=-A$</span>，则为反称矩阵</li>
<li>正交矩阵：若<span class="math inline">$A^{\rm T}A=AA^{\rm
T}=E$</span>，称<span
class="math inline"><em>A</em></span>为正交矩阵</li>
<li>幂零矩阵：若存在正整数<span
class="math inline"><em>m</em></span>，使<span
class="math inline"><em>A</em><sup><em>m</em></sup> = <em>O</em></span>，则称<span
class="math inline"><em>A</em></span>为幂零矩阵</li>
<li>幂等矩阵：若<span
class="math inline"><em>A</em><sup>2</sup> = <em>A</em></span>，称<span
class="math inline"><em>A</em></span>为幂等矩阵</li>
<li>对合矩阵：若<span
class="math inline"><em>A</em><sup>2</sup> = <em>E</em></span>，称<span
class="math inline"><em>A</em></span>为对合矩阵</li>
</ul>
<h2 id="分块矩阵">分块矩阵</h2>
<p>分块后矩阵的运算与一般矩阵类似，若<span
class="math inline">$A=\left[\begin{matrix}A_{11}&amp;\cdots&amp;A_{1n}\\\vdots&amp;&amp;\vdots\\A_{m1}&amp;\cdots&amp;A_{mn}\end{matrix}\right]$</span>，则<span
class="math inline">$A^{\rm T}=\left[\begin{matrix}A_{11}^{\rm
T}&amp;\cdots&amp;A^{\rm T}_{1n}\\\vdots&amp;&amp;\vdots\\A^{\rm
T}_{m1}&amp;\cdots&amp;A^{\rm T}_{mn}\end{matrix}\right]$</span></p>
<h3 id="常用分块方法">常用分块方法</h3>
<ul>
<li>按行或按列分为<span class="math inline"><em>m</em></span>个<span
class="math inline"><em>n</em></span>阶行向量或<span
class="math inline"><em>n</em></span>个<span
class="math inline"><em>m</em></span>阶列向量</li>
<li>分为<span
class="math inline">2 × 2</span>的分块矩阵，其中应利用<span
class="math inline"><em>E</em></span>或<span
class="math inline"><em>O</em></span>或三角形矩阵</li>
</ul>
<h2 id="矩阵的初等变换">矩阵的初等变换</h2>
<p>对一个线性方程组进行操作：</p>
<ul>
<li>调换两条方程的位置</li>
<li>方程两边同乘非零常数</li>
<li>某行乘以一非零常数后加到另一行</li>
</ul>
<p>不改变该方程组的解，这些操作称为线性方程组的初等变换</p>
<p>对应到增广矩阵上，这些操作为：</p>
<ul>
<li>对调行变换/对调列变换：对调两行/两列，记为<span
class="math inline"><em>r</em><sub><em>i</em></sub> ↔︎ <em>r</em><sub><em>j</em></sub></span>或<span
class="math inline"><em>c</em><sub><em>i</em></sub> ↔︎ <em>c</em><sub><em>j</em></sub></span></li>
<li>倍乘行变换/倍乘列变换：第<span
class="math inline"><em>i</em></span>行/列乘上一个非零常数，记为<span
class="math inline"><em>r</em><sub><em>i</em></sub> × <em>k</em></span>或<span
class="math inline"><em>r</em><sub><em>i</em></sub> × <em>k</em></span></li>
<li>倍加行变换/倍加列变换：第<span
class="math inline"><em>i</em></span>行/列乘上一个非零常数后加到第<span
class="math inline"><em>j</em></span>行/列上，记为<span
class="math inline"><em>r</em><sub><em>j</em></sub> + <em>k</em><em>r</em><sub><em>i</em></sub></span>或<span
class="math inline"><em>c</em><sub><em>j</em></sub> + <em>k</em><em>c</em><sub><em>i</em></sub></span></li>
</ul>
<p>称为矩阵的初等变换，有限次变换后可逆，称原矩阵和得到的矩阵等价或相抵</p>
<h3 id="初等矩阵">初等矩阵</h3>
<p>由<span
class="math inline"><em>E</em></span>进行一次初等变换后的矩阵称为初等矩阵<span
class="math inline">(<em>k</em>≠0)</span>：</p>
<ul>
<li>对调矩阵：<span
class="math inline"><em>E</em><sub><em>i</em>, <em>j</em></sub></span>，即第<span
class="math inline"><em>i</em></span>行/列与第<span
class="math inline"><em>j</em></span>行/列对调，行或列对调得到的矩阵相同</li>
<li>倍乘矩阵：<span
class="math inline"><em>E</em><sub><em>i</em></sub>(<em>k</em>)</span>，即第<span
class="math inline"><em>i</em></span>行/列元素乘上<span
class="math inline"><em>k</em></span>，行或列倍乘得到的矩阵相同</li>
<li>倍加矩阵：<span
class="math inline"><em>E</em><sub><em>i</em>, <em>j</em></sub>(<em>k</em>)</span>，即第<span
class="math inline"><em>j</em></span>行/列乘上<span
class="math inline"><em>k</em></span>后加到第<span
class="math inline"><em>i</em></span>行/列上，<span
class="math inline">$E_r=E_c^{\rm T}$</span></li>
</ul>
<h4 id="初等矩阵的性质">初等矩阵的性质</h4>
<ul>
<li><span class="math inline">$E_{i,j}^{\rm T}=E_{i,j}、E_i^{\rm
T}(k)=E_i(k)、E^{\rm T}_{i,j}(k)=E_{j,i}(k)$</span></li>
<li><span
class="math inline"><em>E</em><sub><em>i</em>, <em>j</em></sub><em>E</em><sub><em>j</em>, <em>i</em></sub> = <em>E</em><sub><em>i</em></sub>(<em>k</em>)<em>E</em><sub><em>i</em></sub>(<em>k</em><sup>−1</sup>) = <em>E</em><sub><em>i</em>, <em>j</em></sub>(<em>k</em>)<em>E</em><sub><em>i</em>, <em>j</em></sub>(−<em>k</em>) = <em>E</em>，<em>k</em> ≠ 0</span></li>
</ul>
<h3 id="等价标准形">等价标准形</h3>
<p><span
class="math inline">$F=\left[\begin{matrix}E_s&amp;O\\O&amp;O\end{matrix}\right]$</span>称为<span
class="math inline"><em>A</em></span>的等价标准形，<span
class="math inline"><em>A</em></span>通过有限次初等变换可以变成<span
class="math inline"><em>F</em></span></p>
<p><span class="math inline"><em>F</em></span>有特例：<span
class="math inline">$\left[\begin{matrix}E_s&amp;O\end{matrix}\right]、\left[\begin{matrix}E_s\\O\end{matrix}\right]、\left[\begin{matrix}E_s\end{matrix}\right]$</span></p>
<p>一个矩阵的等价标准形是唯一的</p>
<h2 id="矩阵的行列式">矩阵的行列式</h2>
<ul>
<li>当一个矩阵是方阵时，才有行列式，记为<span
class="math inline">|<em>A</em>|</span></li>
<li><span class="math inline">$|A^{\rm T}|=|A|$</span></li>
<li><span
class="math inline">|<em>λ</em><em>A</em>| = <em>λ</em><sup><em>n</em></sup>|<em>A</em>|</span></li>
<li><span
class="math inline">|<em>A</em><em>B</em>| = |<em>A</em>||<em>B</em>|</span></li>
<li><span
class="math inline">|<em>A</em><em>B</em>| = |<em>B</em><em>A</em>|</span></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟电路入门</title>
    <url>/blogs/2024/05/04/analog-circuit/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="模拟电路">模拟电路</h1>
<h2 id="电路分析方法">电路分析方法</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>两个结点构成一条支路，支路可构成一个回路</li>
<li>基尔霍夫定律：
<ul>
<li><code>KCL</code>：流入结点电流等于流出结点电流</li>
<li><code>KVL</code>：延回路绕行一周，电压降之和等于电压升之和</li>
</ul></li>
<li>&lt;img src=“end{align}$，电流相等</li>
<li>&lt;img src=“end{align}$，电压相等</li>
<li>理想电压源：输出电阻越小，带负载能力越高，对外输出恒定电压<span
class="math inline"><em>U</em> = <em>E</em> − <em>I</em><em>R</em><sub>0</sub></span></li>
<li>理想电流源：<span
class="math inline"><em>R</em><sub>0</sub></span>越大，输出电流越稳定<span
class="math inline">$\begin{align}I=I_s-\frac{U}{R_0}\end{align}$</span></li>
<li><strong>叠加原理</strong>：对于线性电路，某一结点的电流或电压可视为所有电源单独作用后(其它电流源看作断路、电压源看作短路)，在该点产生的电流或电压的代数和(参考方向相同时即相加)</li>
<li>戴维宁定理与诺顿定理：任何有源二端线性网络可看作一个等效<strong>电压源</strong>或等效<strong>电流源</strong>，等效电源的内阻等于将电压源短路、电流源断路后的无源二段网络的总电阻</li>
<li>四种受控源：<span class="math inline">$\rm Voltage/Current\ \
Controlled\ \ Voltage/Current\ \ Source$</span>
<ul>
<li><span
class="math inline"><em>V</em><em>C</em><em>V</em><em>S</em></span>：电压控制电压源</li>
<li><span
class="math inline"><em>V</em><em>C</em><em>C</em><em>S</em></span>：电压控制电流源</li>
<li><span
class="math inline"><em>C</em><em>C</em><em>V</em><em>S</em></span>：电流控制电压源</li>
<li><span
class="math inline"><em>C</em><em>C</em><em>C</em><em>S</em></span>：电流控制电流源</li>
</ul></li>
<li>电容的容抗为<span class="math inline">$\begin{align}\frac1{\omega
C}\end{align}$</span>，阻抗为<span
class="math inline">$\begin{align}\frac1{j\omega
C}\end{align}$</span>，<span
class="math inline"><em>j</em></span>表示相位偏移，因为在通交流电时，电容的电压与流过电容的电流的相位相差<span
class="math inline">90</span>度</li>
</ul>
<h2 id="模拟电路元件">模拟电路元件</h2>
<h3 id="半导体">半导体</h3>
<p>纯净半导体掺入五价元素后变为<span
class="math inline"><em>N</em></span>型半导体，自由电子为多数载流子；掺入三价元素后变为<span
class="math inline"><em>P</em></span>型半导体，空穴为多数载流子；它们本身都不带电</p>
<p>多数载流子受掺杂浓度影响，少数载流子易受温度影响，温度越高、少子越多</p>
<p>在<span
class="math inline"><em>P</em><em>N</em></span>结里，多子扩散、少子漂移</p>
<h3 id="一般二极管">一般二极管</h3>
<p>形成<span
class="math inline"><em>P</em><em>N</em></span>结后，接入正向电压时，在<strong>克服内电场</strong>后，多子扩散加强，正向导通；接入反向电压后，内电场加强，少子漂移加强，但<strong>形成电流很小</strong>，反向截止</p>
<p>克服内电场的阶段称为<strong>死区</strong>，在反向击穿电压内电流基本保持不变，反向击穿后一般二极管即损坏，不可逆</p>
<p>正向电压更大的二极管优先导通</p>
<h3 id="稳压二极管">稳压二极管</h3>
<p>稳压二极管正常工作时接入反向击穿电压，需要接入限流电阻，过程<strong>可逆</strong>；此时该支路电压保持在<span
class="math inline"><em>U</em><sub><em>Z</em></sub></span>不变</p>
<p><strong>经典稳压电路</strong>：</p>
<p><img src="\1.20_稳压电路.png" alt="1.20_稳压电路" style="zoom:33%;" /></p>
<p>设<span class="math inline">$U_I\in[U_{\rm Imin}, U_{\rm
Imax}]$</span>，<span class="math inline">$R_L\in[R_{\rm Lmin},R_{\rm
Lmax}]$</span>，稳压二极管的击穿电压为<span
class="math inline"><em>U</em><sub><em>Z</em></sub></span>，限制流入二极管的电流<span
class="math inline">$I\in[I_{\rm min},I_{\rm max}]$</span>，则<span
class="math inline"><em>R</em></span>的选取范围为：</p>
<p><span class="math inline">$\begin{align}I_L=\frac{U_Z}{R_L},\
I_R=\frac{U_I-U_Z}{R},\ I=I_R-I_L,\ \therefore R\in\Bigg[\frac{U_{\rm
Imin}-U_Z}{I_{\rm max}+\frac{U_Z}{R_{\rm Lmin}}},\ \frac{U_{\rm
Imax}-U_Z}{I_{\rm min}+\frac{U_Z}{R_{\rm
Lmax}}}\Bigg]\end{align}$</span></p>
<h3 id="三极管">三极管</h3>
<p>常在放大电路中使用<span
class="math inline"><em>N</em><em>P</em><em>N</em></span>型三极管，分为集电极、基极、发射极<img src="1.3_NPN.png" alt="1.3_NPN" style="zoom:33%;" /></p>
<p>工作状态：</p>
<ul>
<li>当<span
class="math inline"><em>V</em><sub><em>E</em></sub> &lt; <em>V</em><sub><em>B</em></sub> &lt; <em>V</em><sub><em>C</em></sub></span>时，处于放大状态，工作在放大区，也称线性区</li>
<li>当<span
class="math inline"><em>V</em><sub><em>B</em></sub> &gt; <em>V</em><sub><em>C</em></sub></span>时，处于饱和状态，工作在饱和区(输入电压大到放大不了)</li>
<li>当<span
class="math inline"><em>V</em><sub><em>E</em></sub> &gt; <em>V</em><sub><em>B</em></sub></span>时，处于截止状态，工作在截止区(放大了，但无法发射)</li>
</ul>
<p>工作在线性区时：</p>
<ul>
<li><span
class="math inline">$\begin{align}&amp;I_E=(1+\beta)I_B&amp;I_C=\beta
I_B\end{align}$</span></li>
<li>若集电极电流上升，则<span
class="math inline"><em>β</em></span>会下降</li>
<li>三极管可等效为<span
class="math inline"><em>r</em><sub><em>b</em><em>e</em></sub></span>与一个<span
class="math inline"><em>C</em><em>C</em><em>C</em><em>S</em></span></li>
<li><span class="math inline">$\begin{align}r_{be}=(200+\frac{26\
mV}{I_B})\Omega\end{align}$</span></li>
</ul>
<h2 id="基本放大电路">基本放大电路</h2>
<p>对优秀的放大电路来讲，<span
class="math inline"><em>A</em><sub><em>u</em></sub></span>要够用，<span
class="math inline"><em>r</em><sub><em>i</em></sub></span>尽可能大，<span
class="math inline"><em>r</em><sub><em>o</em></sub></span>尽可能小</p>
<h3 id="共发射极放大电路">共发射极放大电路</h3>
<p><img src="1.4_共发射极基本放大电路.png" alt="1.4_共发射极基本放大电路" style="zoom:50%;" /></p>
<p>在集电极取输出电压，称为共发射极放大电路</p>
<p><strong>静态分析</strong>：</p>
<ul>
<li>只观察两电容中间的电路，并采用左路支路计算</li>
<li><span
class="math inline">$\begin{align}V_B=U_{BE}\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}I_B=\frac{V_{CC}-V_B}{R_b}\end{align}$</span></li>
<li><span class="math inline">$\begin{align}U_{CE}=V_{CC}-\beta
I_BR_c\end{align}$</span></li>
<li><span
class="math inline">(<em>I</em><sub><em>B</em></sub>,<em>U</em><sub><em>B</em><em>E</em></sub>)</span>和<span
class="math inline">(<em>I</em><sub><em>C</em></sub>,<em>U</em><sub><em>C</em><em>E</em></sub>)</span>分别对应输入、输出曲线上的一点，称为<strong>静态工作点<span
class="math inline"><em>Q</em></span></strong></li>
<li>放大后，电流相位不变，电压相位相反</li>
<li>若<span class="math inline"><em>Q</em></span>点过高(<span
class="math inline"><em>I</em><sub><em>B</em></sub>、<em>V</em><sub><em>B</em></sub></span>过高，反相后表现在<span
class="math inline"><em>U</em><sub><em>O</em></sub></span>下部分波形失真)，发生<strong>饱和失真</strong></li>
<li>若<span class="math inline"><em>Q</em></span>点过低(<span
class="math inline"><em>I</em><sub><em>B</em></sub>、<em>V</em><sub><em>B</em></sub></span>过低，反相后表现在<span
class="math inline"><em>U</em><sub><em>O</em></sub></span>上部分波形失真)，发生<strong>截止失真</strong></li>
</ul>
<p><strong>动态分析</strong>：</p>
<ul>
<li><p>画出交流通路后，化为<strong>等效微变电路</strong></p>
<p><img src="1.5_微变等效电路.png" alt="1.5_微变等效电路" style="zoom:50%;" /></p></li>
<li><p><span
class="math inline">$\begin{align}&amp;A_u=\frac{u_o}{u_i}=\frac{-i_c(R_c//R_L)}{i_br_{be}}\end{align}$</span></p></li>
<li><p>输入电阻<span
class="math inline">$\begin{align}r_i=R_b//r_{be}\end{align}$</span></p></li>
<li><p>输出电阻<span
class="math inline"><em>r</em><sub><em>o</em></sub> = <em>R</em><sub><em>c</em></sub></span></p></li>
</ul>
<h3 id="分压式偏置电路">分压式偏置电路</h3>
<p>温度升高时，<span
class="math inline"><em>Q</em></span>点升高，分压式偏置电路能够在温度升高时自动降低<span
class="math inline"><em>Q</em></span>点：</p>
<p><img src="1.6_分压式偏置电路.png" alt="1.6_分压式偏置电路" style="zoom: 25%;" /></p>
<ul>
<li><span class="math inline">$\begin{align}&amp;I_C\approx
I_E=\frac{V_B-U_{BE}}{R_E}\end{align}$</span></li>
<li>一般来说，<span
class="math inline"><em>U</em><sub><em>B</em><em>E</em></sub> &lt;  &lt; <em>V</em><sub><em>B</em></sub></span>时，基极电流保持稳定，<span
class="math inline"><em>Q</em></span>点不变；所以<span
class="math inline"><em>R</em><sub><em>B</em>1</sub> &gt; <em>R</em><sub><em>B</em>2</sub></span>，提高<span
class="math inline"><em>V</em><sub><em>B</em></sub></span>(但不能过高)</li>
</ul>
<p><strong>静态分析</strong>：</p>
<ul>
<li>一般认为<span
class="math inline"><em>I</em><sub><em>B</em></sub> → 0</span>，<span
class="math inline">$\begin{align}\therefore
V_B\approx\frac{R_{B2}}{R_{B1}+R_{B2}}V_{CC}\end{align}$</span></li>
<li><span class="math inline">$\begin{align}&amp;I_C\approx
I_E=\frac{V_B-U_{BE}}{R_E}\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}U_{CE}=V_{CC}-I_CR_C-I_ER_E\end{align}$</span></li>
</ul>
<p><strong>动态分析</strong>：</p>
<p><img src="1.7_分压等效微变.png" alt="1.7_分压等效微变" style="zoom:40%;" /></p>
<ul>
<li><span
class="math inline">$\begin{align}&amp;A_u=\frac{u_o}{u_i}=\frac{-i_c(R_C//R_L)}{i_b(r_{be}+(1+\beta
R_E))}\end{align}$</span>，相比未分压时减小了</li>
<li><span class="math inline">$\begin{align}r_i=R_B//(r_{be}+(1+\beta
R_E)),\ R_B=R_{B1}//R_{B2}\end{align}$</span>，相比未分压时增大了</li>
<li><span
class="math inline">$\begin{align}r_o=R_C\end{align}$</span>，不变</li>
</ul>
<p>共发射极放大电路能做到有较大的电压放大倍数、有较大的输入电阻</p>
<h3 id="共集电极放大电路">共集电极放大电路</h3>
<p>也称射极输出器</p>
<p><img src="1.8_共集电极.png" alt="1.8_共集电极" style="zoom:40%;" /></p>
<p><strong>静态分析</strong>：</p>
<ul>
<li><span
class="math inline">$\begin{align}&amp;V_{CC}=V_B+I_BR_B=U_{BE}+I_BR_B+I_ER_E&amp;I_B=\frac{V_{CC}-U_{BE}}{R_B+(1+\beta)R_E}\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}U_{CE}=V_{CC}-I_ER_E\end{align}$</span></li>
</ul>
<p><strong>动态分析</strong>：</p>
<p><img src="1.9_共集电极等效微变.png" alt="1.9_共集电极等效微变" style="zoom:40%;" /></p>
<ul>
<li><span
class="math inline">$\begin{align}&amp;A_u=\frac{u_o}{u_i}=\frac{i_e(R_E//R_L)}{i_b(r_{be}+(1+\beta)(R_E//R_L))}\approx1\end{align}$</span>，故也称<strong>电压跟随器</strong></li>
<li><span
class="math inline">$\begin{align}&amp;r_i=R_B//(r_{be}+(1+\beta)(R_E//R_L))\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}&amp;r_o=R_E//\frac{(R_S//R_B+r_{be})}{1+\beta}\end{align}$</span></li>
</ul>
<p>它的输出电阻很小，带负载能力强，且输入电阻很大</p>
<h3 id="差动放大电路">差动放大电路</h3>
<p>差动放大电路是抑制零点漂移的最有效的电路</p>
<p><img src="1.10_差动放大电路.png" alt="1.10_差动放大电路" style="zoom: 25%;" /></p>
<p>理想情况下，<span
class="math inline"><em>T</em><sub>1, 2</sub></span>的静态工作点相同，可以有效抑制共模信号</p>
<p>大小相同，但方向相反的信号称为差模信号，对差模信号有放大能力：<span
class="math inline"><em>u</em><sub><em>o</em></sub> =  − 2<em>Δ</em><em>V</em></span></p>
<p>即，<span class="math inline">$u_o=u_{\rm i2}-u_{\rm
i1}$</span>，是<span
class="math inline"><em>u</em><sub><em>o</em></sub></span>负级端信号和正级端信号的差值</p>
<p>该电路多被用于集成放大电路的第一级</p>
<h3 id="互补对称功率放大电路">互补对称功率放大电路</h3>
<p>效率<span
class="math inline">$\begin{align}\eta=\frac{负载交流功率}{电源直流功率}\end{align}$</span></p>
<p>该放大电路由<strong>两个三极管</strong>组成，在此电路中，为了减小电源直流功率，增大效率，常采用<strong>甲乙类</strong>工作状态的静态工作点，集甲类(整个周期都导通)和乙类(只有半个周期导通)的优点，能<strong>减小失真同时提高效率</strong>，此时静态工作点应<strong>略高于</strong>截止点，即<span
class="math inline"><em>I</em><sub><em>B</em></sub></span>略大于<span
class="math inline">0</span></p>
<p>此电路产生的波形会发生<strong>交越失真</strong>，因为晶体管在输入电压<span
class="math inline">0</span>附近会进入<strong>死区</strong>，导通性差，无法输出</p>
<p><img src="\1.21_交越失真.png" alt="1.21_交越失真" style="zoom:35%;" /></p>
<p>引入两个二极管，使得在任意半个周期时，总有一个三极管处于良好工作状态，另一个三极管工作点略高于截止点，使两个三极管<strong>交替地处在甲乙类状态工作，又能减少交越失真现象</strong></p>
<p>该电路多被用于放大电路的输出级</p>
<h3 id="多级放大电路">多级放大电路</h3>
<p><strong>阻容耦合</strong>：</p>
<p>使用电容耦合时，各级的静态工作点互相独立，可分别单独计算</p>
<p>动态分析时，<span
class="math inline"><em>A</em><sub><em>u</em></sub></span>等于各级<span
class="math inline"><em>A</em><sub><em>u</em></sub></span>的乘积</p>
<p>但由于电容不容易集成，这种方式不常用</p>
<p><strong>直接耦合</strong>：</p>
<p>直接耦合直接用导线连接上下两级，因此各级的静态工作点会相互影响</p>
<p>而且由于温度的影响，在静态工作时会发生<strong>零点漂移</strong>，即电压缓慢、无规则地变化现象</p>
<p>直接耦合的电路具有良好的低频特性(当在某频率上<span
class="math inline">$\begin{align}|A_u|&lt;\frac1{\sqrt2}|A_{umax}|\end{align}$</span>时，称为无效频率)</p>
<h2 id="运算放大电路">运算放大电路</h2>
<h3 id="集成放大电路">集成放大电路</h3>
<p>最大输出电压(<span class="math inline">$U_{\rm
opp}$</span>)：保持输入输出不失真的最大输出电压，若计算后输出电压的绝对值大于此值，将造成失真，输出电压的绝对值将始终等于<span
class="math inline">$U_{\rm opp}$</span></p>
<p>理想的集成放大电路如果没有接入负反馈，则始终工作在饱和区，输出<span
class="math inline">$\begin{cases}+U_{\rm
o(sat)},&amp;u_+&gt;u_-\\-U_{\rm
o(sat)},&amp;u_+&lt;u_-\end{cases}$</span>，是一个电压比较器</p>
<p>由于<span class="math inline">$r_{\rm
id}\rightarrow\infty$</span>，理想的集成放大电路一定存在<strong>虚拟断路</strong>现象，即输入端不取电流</p>
<h3 id="反馈信号">反馈信号</h3>
<p>设输入信号为<span class="math inline">$X_{\rm
i}$</span>，反馈信号为<span class="math inline">$X_{\rm
f}$</span>，叠加后的净输入信号为<span class="math inline">$X_{\rm
d}$</span>，输出信号为<span class="math inline">$X_{\rm
o}$</span>，则：</p>
<ul>
<li><span class="math inline">$X_{\rm d}=X_{\rm i}-X_{\rm
f}$</span></li>
<li>开环放大倍数<span class="math inline">$\begin{align}A=\frac{X_{\rm
o}}{X_{\rm d}}\end{align}$</span></li>
<li>反馈系数<span class="math inline">$\begin{align}F=\frac{X_{\rm
f}}{X_{\rm o}}\end{align}$</span></li>
<li>若<span
class="math inline"><em>A</em><em>F</em> &lt; 0</span>，即输入信号与反馈信号反相，则称反馈为负反馈；反之为正反馈；若<span
class="math inline">$X_{\rm f}=0$</span>，即<span
class="math inline">$R_{\rm i}$</span>短路或<span
class="math inline"><em>R</em><sub><em>f</em></sub></span>断路，则<span
class="math inline"><em>A</em><em>F</em> ≥ 0</span>，没有负反馈</li>
<li>负反馈使放大倍数降低，用于运算电路；正反馈使放大倍数增大，用于产生自激振荡，产生各种波形</li>
<li>瞬时极性法判断反馈类型：若<span class="math inline">$u_{\rm
i}$</span>接入同相端，则输出信号与它极性相同，否则不同；若反馈信号和<span
class="math inline">$u_{\rm
i}$</span>接入同一极，极性相同为正反馈，否则为负反馈；若反馈信号和<span
class="math inline">$u_{\rm
i}$</span>分别接入不同极，则与接入同一极的情况相反</li>
<li>经验判断：只跨一个集成放大电路的反馈信号，若接入同相端肯定为正反馈，否则肯定为负反馈</li>
<li>接入反馈时的放大倍数<span
class="math inline"><em>A</em><sub><em>f</em></sub></span>称为<strong>闭环放大倍数</strong>，<span
class="math inline">$\begin{align}A_{f}=\frac{X_{\rm o}}{X_{\rm
i}}=\frac A{1+AF}\end{align}$</span></li>
<li><strong>要求静态时，同、反相端对地电阻相同</strong>，所以<span
class="math inline"><em>A</em><sub><em>u</em></sub></span>一定可以化简为某一单独相端的电阻的表达式，也可以化简为由反馈电阻和输入端支路电阻组成的表达式；但若题目给出了所有电阻的具体阻值，应按流程计算，因为不一定是理想的运算电路</li>
</ul>
<h4 id="负反馈的性质">负反馈的性质</h4>
<ul>
<li>根据采样不同，负反馈分为电压反馈和电流反馈，一般来说，电压反馈直接从<span
class="math inline">$u_{\rm o}$</span>取电压
<ul>
<li>电压负反馈能<strong>稳定输出电压</strong>，<strong>减小输出电阻</strong>(从输出端向内看，相当于和一条支路并联)</li>
<li>电流负反馈能<strong>稳定输出电流</strong>，<strong>增大输出电阻</strong>(从输出端向内看，相当于和一条支路串联)</li>
</ul></li>
<li>根据与输入信号叠加形式的不同，负反馈分为串联反馈和并联反馈，一般来说，并联反馈和输入信号连接在同一极
<ul>
<li>串联负反馈能<strong>增大输入电阻</strong>(从输入端向外看，相当于和一条支路串联)</li>
<li>并联负反馈能<strong>减小输入电阻</strong>(从输入端向外看，相当于和一条支路并联)</li>
</ul></li>
<li>反馈支路能通交流成分就可称为交流负反馈，能通直流就可称为直流负反馈，一般负反馈属于交、直流反馈；以上都属于交流类型负反馈的作用，而直流负反馈能够稳定静态工作点</li>
<li>为了达成输入电阻高，输出电阻低，一般采用串联电压负反馈</li>
<li>为了使其成为恒电流源，一般采用电流负反馈</li>
<li>负反馈可减小波形失真，但不能完全消除</li>
</ul>
<p>认为只要接入负反馈，就处于深度负反馈，一定工作在线性区，此时不仅满足虚拟断路，也满足<strong>虚拟短路</strong>，即同相与反相输入端的电位相等</p>
<p>且认为<span class="math inline">$\begin{align}A_{f}=\frac{u_{\rm
o}}{u_{\rm
i}}\approx\frac1F\end{align}$</span>，此时可对输入信号进行各种运算</p>
<h3 id="比例运算电路">比例运算电路</h3>
<p><strong>反相比例运算</strong>：输入信号接在反相端，放大倍数为负数</p>
<p><img src="\1.11_反相比例.png" alt="1.11_反相比例" style="zoom: 25%;" /></p>
<p><span class="math inline">$\begin{align}V_-=\frac{R_F}{R_1+R_F}u_{\rm
i}+\frac{R_1}{R_1+R_F}u_{\rm o}=V_+=0\Rightarrow
A_{uf}=-\frac{R_F}{R_1}\end{align}$</span></p>
<p><strong>同相比例运算</strong>：输入信号接在同相端，放大倍数一定<span
class="math inline"> ≥ 1</span></p>
<p><img src="\1.12_同相比例.png" alt="1.12_同相比例" style="zoom:45%;" /></p>
<p><span class="math inline">$\begin{align}V_-=\frac{R_1}{R_1+R_F}u_{\rm
o}=V_+=u_{\rm i}\Rightarrow
A_{uf}=1+\frac{R_F}{R_1}=\frac{R_F}{R_2}\end{align}$</span></p>
<p><strong>电压跟随器</strong>：在同相比例运算电路的基础上，当<span
class="math inline"><em>R</em><sub>1</sub> = ∞</span>或<span
class="math inline"><em>R</em><sub><em>f</em></sub> = 0</span>时，<span
class="math inline"><em>A</em><sub><em>u</em><em>f</em></sub> = 1</span>，<span
class="math inline">$u_{\rm o}=u_{\rm i}$</span></p>
<h3 id="加减法运算电路">加减法运算电路</h3>
<p><strong>反相加法</strong>：</p>
<p><img src="\1.13_反相加法.png" alt="1.13_反相加法" style="zoom:25%;" /></p>
<p><span
class="math inline">$\begin{align}&amp;V_+=0=V_-=\\&amp;\frac{(R_2//R_3//R_f)u_{\rm
i1}}{R_1+R_2//R_3//R_f}+\frac{(R_1//R_3//R_f)u_{\rm
i2}}{R_2+R_1//R_3//R_f}+\frac{(R_1//R_2//R_f)u_{\rm
i3}}{R_3+R_1//R_2//R_f}+\frac{(R_1//R_2//R_3)u_{\rm
o}}{R_f+R_1//R_2//R_3}\\&amp;在此图中,R_1//R_2//R_3//R_f=0,但假设同相端有电阻R_+,则R_1//R_2//R_3//R_f=R_+\\&amp;解得:u_{\rm
o}=(-\frac{R_+}{R_1}u_{\rm i1}-\frac{R_+}{R_2}u_{\rm
i2}-\frac{R_+}{R_3}u_{\rm i3})\frac{R_f}{R_+}=-(\frac{R_f}{R_1}u_{\rm
i1}+\frac{R_f}{R_2}u_{\rm i2}+\frac{R_f}{R_3}u_{\rm
i3})\end{align}$</span></p>
<p><strong>同相加法</strong>：</p>
<p><img src="\1.14_同相加法.png" alt="1.14_同相加法" style="zoom:35%;" /></p>
<p>易得，<span class="math inline">$\begin{align}u_{\rm
o}=\frac{R_F}{R_{\rm i1}}u_{\rm i1}+\frac{R_F}{R_{\rm i2}}u_{\rm
i2}\end{align}$</span></p>
<p><strong>减法运算</strong>：</p>
<p><img src="\1.15_减法运放.png" alt="1.15_减法运放" style="zoom:35%;" /></p>
<p>易得，<span class="math inline">$\begin{align}u_{\rm
o}=\frac{R_F}{R_2}u_{\rm i2}-\frac{R_F}{R_1}u_{\rm
i1}\end{align}$</span></p>
<p><strong>结论</strong>：加减法电路基于比例运算电路，输出电压是各个输入电压单独作用时(其它输入支路断路)产生的<strong>输出电压之和</strong>，<strong>化简后</strong>的输出电压的表达式里，没有接地端的电阻，<strong>只含有反馈电阻</strong>和<strong>含输入信号的支路的电阻</strong>时，是最简的</p>
<h3 id="积分微分运算电路">积分微分运算电路</h3>
<p><strong>积分运算</strong>：</p>
<p><img src="\1.17_积分运放.png" alt="1.17积分运放" style="zoom:45%;" /></p>
<p>常见反相积分运算电路，反馈元件是一个电容</p>
<p><span class="math inline">$V_+=0=V_-=u_{\rm o}-u_{\rm c}$</span></p>
<p>电容的电流有效值为：<span
class="math inline">$\begin{align}i_c=C\frac{du_{c}}{dt}=i_1=\frac{-u_{\rm
i}}{R_1}\end{align}$</span></p>
<p>联立解得<span class="math inline">$\begin{align}u_{\rm
o}=-\frac1{R_1C}\int u_{\rm i}dt\end{align}$</span></p>
<p><strong>微分运算</strong>：</p>
<p><img src="\1.18_微分运算.png" alt="1.18_微分运算" style="zoom:25%;" /></p>
<p>微分运放中，反馈元件仍是电阻，但输入端由电阻变为电容</p>
<p>根据积分运算电路的分析，<span
class="math inline">$\begin{align}C\frac{du_{\rm i}}{dt}=-\frac{u_{\rm
o}}{R_F}\end{align}$</span></p>
<p>即<span class="math inline">$\begin{align}u_{\rm
o}=-R_FC\frac{du_{\rm i}}{dt}\end{align}$</span></p>
<h2 id="信号处理">信号处理</h2>
<h3 id="电压比较器">电压比较器</h3>
<p>之前提到过，不加负反馈的理想集放<span
class="math inline"><em>A</em><sub><em>u</em></sub> = ∞</span>，始终处于饱和失真，工作在饱和区，门限值为<span
class="math inline"><em>u</em><sub><em>R</em></sub></span>(输入在反相端)或<span
class="math inline"> − <em>u</em><sub><em>R</em></sub></span>(输入在同相端)</p>
<p>但不加反馈的电压比较器的门限值不变，这使得输入电压在门限值处反复跳变时，输出电压不准确，故引入正反馈，使其成为<strong>滞回比较器</strong>：</p>
<p><img src="\1.16_滞回比较器.png" alt="1.16_滞回比较器" style="zoom:25%;" /></p>
<p>只满足虚拟断路，<span
class="math inline">$\begin{align}&amp;u_+=\frac{R_1}{R_1+R_2}u_{\rm
o},u_-=u_{\rm i}\\&amp;当u_{\rm i}进行从小于u_+到大于u_+的转变时,u_{\rm
o}由+U_{\rm o(sat)}变为-U_{\rm
o(sat)},门限值突变为-u_+\end{align}$</span></p>
<p>若参考电压为<span
class="math inline">0</span>，两门限值互为相反数；当它不为<span
class="math inline">0</span>时，两门限值以它为中心</p>
<p>称两门限值之差的绝对值为<strong>回差电压</strong><span
class="math inline"><em>Δ</em><em>U</em></span>，<span
class="math inline">$u_{\rm o}$</span>与<span
class="math inline">$u_{\rm
i}$</span>的图像称为<strong>电压传输特性</strong>曲线</p>
<h3 id="有源滤波器">有源滤波器</h3>
<p>滤波电路分为低通、高通、带通、带阻，以下为低通滤波器：</p>
<p><img src="\1.19_低通滤波.png" alt="1.19_低通滤波" style="zoom:35%;" /></p>
<p>由于电容支路的电流相位超前<span class="math inline">$u_{\rm
i}90$</span>度，所以引入复数<span
class="math inline"><em>j</em></span>来<strong>表示相位运算</strong>，复数<span
class="math inline"><em>j</em></span>只表示相位关系，在具体求值时使用其<strong>模长</strong></p>
<p>由电容阻抗为<span
class="math inline">$\begin{align}R_c=\frac1{j\omega C}=\frac1{j2\pi
fC}\end{align}$</span>，<span
class="math inline">$\begin{align}V_-=\frac{R_1}{R_1+R_F}u_{\rm
o}=V_+=u_C=\frac{R_C}{R+R_C}u_{\rm i}\end{align}$</span></p>
<p>解得<span class="math inline">$\begin{align}u_{\rm
o}=\frac{R_1+R_F}{R_1(1+j2\pi fRC)}u_{\rm i}\end{align}$</span>，取<span
class="math inline"><em>A</em><sub><em>u</em></sub></span>模长，故<span
class="math inline">$\begin{align}A_u=\frac{R_1+R_F}{R_1\sqrt{(1+2\pi
fRC)^2}}\end{align}$</span></p>
<p>当<span class="math inline"><em>f</em> → 0</span>时，<span
class="math inline">$u_{\rm o}$</span>最大；<span
class="math inline"><em>f</em></span>上升，<span
class="math inline">|<em>A</em><sub><em>u</em></sub>|</span>逐渐下降；当<span
class="math inline">$\sqrt{(1+2\pi
fRC)^2}&gt;\sqrt2$</span>时，称这些频率无法被有效放大</p>
<p>高通滤波器的计算与其相似，电路设计上，<span
class="math inline"><em>R</em></span>与电容<span
class="math inline"><em>C</em></span>互换位置，不再赘述</p>
<p>为了使滤波器在<span
class="math inline">$|A_u|=\sqrt{|A_{u(max)}|}$</span>处衰减更快，通常在输入端再接一块电容，构成二阶有源滤波电路</p>
<h3 id="正弦波发生器">正弦波发生器</h3>
<ul>
<li>自激振荡的条件：
<ul>
<li>幅度平衡：<span
class="math inline">$\begin{align}|A_uF|=\frac{u_f}{u_{\rm
i}}=1\Rightarrow有足够的反馈量\end{align}$</span></li>
<li>相位平衡：<span class="math inline">$\varphi_A+\varphi_F=\pm
2n\pi\Rightarrow正反馈$</span></li>
</ul></li>
<li>起振过程：
<ul>
<li>切换开关使其产生一系列含不同交流成分的交流量，通过选频网络选出特定交流电</li>
<li><span class="math inline">$u_{\rm
o}&lt;U,(U为稳定时的预期幅度)$</span>，故<span
class="math inline">|<em>A</em><sub><em>u</em></sub><em>F</em>| &gt; 1</span>，要引入正反馈</li>
</ul></li>
<li>稳幅过程：
<ul>
<li>使<span
class="math inline">|<em>A</em><sub><em>u</em></sub><em>F</em>| → 1</span>的过程</li>
<li>通过含非线性伏安特性曲线的元件，例如负温度系热敏电阻或二极管，使电路在起振时，反馈量略大于输入量；稳幅时<span
class="math inline"><em>R</em><sub><em>F</em></sub></span>电阻下降，反馈量等于输入量</li>
</ul></li>
</ul>
<h2 id="直流稳压电源">直流稳压电源</h2>
<h3 id="过程">过程</h3>
<p>直流稳压过程包括：</p>
<ul>
<li>变压，降压</li>
<li>整流，使交流电变为直流电</li>
<li>滤波，减少直流电中的交流成分</li>
<li>稳压，进一步减少交流成分，且减少输出的直流电受之前部分电路的影响</li>
</ul>
<h3 id="整流电路">整流电路</h3>
<p>整流电路包括：半波、全波等</p>
<ul>
<li>评估整流电路的指数：
<ul>
<li>整流电压平均值<span
class="math inline"><em>U</em><sub><em>O</em>(<em>A</em><em>V</em>)</sub></span>：对一个周期的电压<strong>积分后除以它的周期</strong></li>
<li>整流电流平均值<span
class="math inline"><em>I</em><sub><em>O</em>(<em>A</em><em>V</em>)</sub></span>：<span
class="math inline"><em>U</em><sub><em>O</em>(<em>A</em><em>V</em>)</sub></span>除以<strong>负载的阻值</strong></li>
<li>脉动系数<span class="math inline"><em>S</em></span>：越低越好</li>
</ul></li>
<li>选取二极管的指数：
<ul>
<li>流过每个二极管的电流平均值<span
class="math inline"><em>I</em><sub><em>D</em></sub></span>：应大于<span
class="math inline"><em>I</em><sub><em>O</em>(<em>A</em><em>V</em>)</sub></span>除以<strong>导通状态</strong>的二极管的个数</li>
<li>每管承受的最高反向电压<span
class="math inline"><em>U</em><sub><em>D</em><em>R</em><em>M</em></sub></span>：应大于<strong>电压峰值</strong>除以<strong>截止状态</strong>的二极管的个数，最高反向电压往往是反向击穿电压的一半或三分之一</li>
<li>正弦波电压峰值<span
class="math inline">$U_{MAX}=\sqrt2U_{有效值}$</span></li>
<li>测量交流电时，直流表测量平均值，交流表测量有效值</li>
</ul></li>
</ul>
<p><strong>半波整流</strong>：只留下正方向的波形，完全消除负方向的电流</p>
<p>一个二极管就可以实现半波整流，其参数满足<span
class="math inline"><em>I</em><sub><em>D</em></sub> &gt; <em>I</em><sub><em>O</em>(<em>A</em><em>V</em>)</sub>, <em>U</em><sub><em>D</em><em>R</em><em>M</em></sub> &gt; <em>U</em><sub><em>M</em><em>A</em><em>X</em></sub></span></p>
<p>其它参数：<span
class="math inline">$\begin{align}S=1.57,U_{O(AV)}=0.45U_{有效值},I_{L有效值}=\frac
{I_{MAX}}2\end{align}$</span></p>
<p><strong>桥式整流</strong>：含有完整的波形，因为始终有其中两个二极管导通，另外两个二极管截止</p>
<p>二极管参数满足<span
class="math inline"><em>I</em><sub><em>D</em></sub> &gt; 0.5<em>I</em><sub><em>O</em>(<em>A</em><em>V</em>)</sub>, <em>U</em><sub><em>D</em><em>R</em><em>M</em></sub> &gt; <em>U</em><sub><em>M</em><em>A</em><em>X</em></sub></span></p>
<p>其它参数：<span
class="math inline">$\begin{align}S=0.67,U_{O(AV)}=0.9U_{有效值},I_{L有效值}=\frac{I_{MAX}}{\sqrt2}\end{align}$</span></p>
<h3 id="滤波与稳压">滤波与稳压</h3>
<p>直流稳压电路采用无源滤波器，使用电容、电感实现</p>
<p>给负载并联电容，或串联电感，可有效减少交流成分</p>
<p>稳压部分采用稳压二极管</p>
<p><strong>集成稳压电源</strong>：<span
class="math inline">78<em>X</em><em>X</em></span>代表输出大小为<span
class="math inline"><em>X</em><em>X</em></span>的正向电压；<span
class="math inline">79<em>X</em><em>X</em></span>代表输出大小为<span
class="math inline"><em>X</em><em>X</em></span>的反向电压</p>
<p>前者三个端口：<span
class="math inline">1 − <em>输</em><em>入</em><em>端</em>、2 − <em>输</em><em>出</em><em>端</em>、3 − <em>公</em><em>共</em><em>端</em></span></p>
<p>后者三个端口：<span
class="math inline">1 − <em>公</em><em>共</em><em>端</em>、2、<em>输</em><em>出</em><em>端</em>、3 − <em>输</em><em>入</em><em>端</em></span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Circuit</category>
      </categories>
      <tags>
        <tag>analog circuit</tag>
      </tags>
  </entry>
  <entry>
    <title>Turing Complete: 图灵完备，一款数电小游戏</title>
    <url>/blogs/2024/05/03/games-TuringComplete/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="overtrue"><code>OVERTRUE</code></h1>
<p><code>OVERTRUE</code>是最简单的图灵完备的处理器，即能够读取指令、分情况进行计算或跳转或转移数据，接下来从基础逻辑门开始搭建该架构</p>
<h2 id="基础逻辑电路">基础逻辑电路</h2>
<h3 id="基础逻辑门">基础逻辑门</h3>
<p><strong><code>NAND</code>与非门</strong>是最为基础的逻辑门，根据德·摩根定理，能够用它和若干个<strong><code>NOT</code>非门</strong>搭建其它三个基础门</p>
<ul>
<li><p>它的真值表为<span
class="math inline">$\begin{matrix}0&amp;1&amp;0&amp;1\\0&amp;0&amp;1&amp;1\\1&amp;1&amp;1&amp;0\end{matrix}$</span>，即<strong>非<span
class="math inline">$\begin{matrix}1\\1\end{matrix}$</span>得<span
class="math inline">1</span>，否则得<span
class="math inline">0</span></strong>，画法为<img src="1.1.NAND.png" style="zoom: 15%;" /></p></li>
<li><p>通过它可以制造<code>NOT</code>，真值表为<span
class="math inline">$\begin{matrix}0&amp;1\\1&amp;0\end{matrix}$</span>，画法为<img src="1.2.NOT.png" style="zoom:15%;" /></p></li>
<li><p>对<code>NAND</code>门的<strong>输出取反</strong>，得到<strong><code>AND</code>与门</strong>，逻辑为<strong><span
class="math inline">$\begin{matrix}1\\1\end{matrix}$</span>得<span
class="math inline">1</span>，否则得<span
class="math inline">0</span></strong>，真值表为<code>NAND</code>输出按位取反，画法为<img src="1.3.AND.png" style="zoom:15%;" /></p></li>
<li><p>对<code>NAND</code>门的<strong>输入取反</strong>，得到<strong><code>OR</code>或门</strong>，逻辑为<strong>非<span
class="math inline">$\begin{matrix}0\\0\end{matrix}$</span>得<span
class="math inline">1</span>，否则得<span
class="math inline">0</span></strong>，真值表为<code>NAND</code>输出左右颠倒，画法为<img src="1.4.OR.png" style="zoom:15%;" /></p></li>
<li><p>对<code>OR</code>门的输出取反(或对<code>AND</code>的输入取反)，得到<strong><code>NOR</code>或非门</strong>，逻辑为<strong><span
class="math inline">$\begin{matrix}0\\0\end{matrix}$</span>得<span
class="math inline">1</span>，否则得<span
class="math inline">0</span></strong>，真值表为<code>OR</code>输出按位取反，画法为<img src="1.5.NOR.png" style="zoom:15%;" /></p></li>
</ul>
<h3 id="逻辑门扩展">逻辑门扩展</h3>
<p>各个基础逻辑门互相组合，能得到所有<span
class="math inline">2<sup>4</sup> = 16</span>种真值表，在这里扩展<strong><code>XOR</code>异或门</strong>与<strong><code>XNOR</code>同或门</strong>：</p>
<ul>
<li>对<code>OR</code>门与<code>NAND</code>门的输出<code>AND</code>，得到<code>XOR</code>，逻辑为<strong>输入不同得<span
class="math inline">1</span>，否则得<span
class="math inline">0</span></strong>，真值表为<span
class="math inline">$\begin{matrix}0&amp;1&amp;0&amp;1\\0&amp;0&amp;1&amp;1\\0&amp;1&amp;1&amp;0\end{matrix}$</span>，画法为<img src="1.6.XOR.png" alt="1.6.XOR" style="zoom:15%;" /></li>
<li>对<code>XOR</code>门的输出取反(或对<code>NOR</code>门与<code>AND</code>门的输出<code>OR</code>)，得到<code>XNOR</code>，逻辑为<strong>输入相同得<span
class="math inline">1</span>，否则得<span
class="math inline">0</span></strong>，真值表为<code>XOR</code>输出按位取反，画法为<img src="1.7.XNOR.png" style="zoom:15%;" /></li>
</ul>
<h3 id="其它">其它</h3>
<p>通过<code>OR</code>与<code>AND</code>，可实现始终输出高/低电平的电路<strong><code>ON</code></strong>与<strong><code>OFF</code></strong></p>
<p>通过两个相同类型的基础逻辑门组合，可得到<strong>三路输入</strong>的对应逻辑门</p>
<p>通过三个<code>XOR</code>门组合，可实现在<strong>四路输入奇数个信号时，输出<span
class="math inline">1</span></strong></p>
<h2 id="算术运算">算术运算</h2>
<h3 id="二进制信号计数与二进制补码">二进制信号计数与二进制补码</h3>
<ul>
<li>通过三个<code>XOR</code>门组合，使得<strong>当四路输入奇数个信号时，接入代表1的二进制输出上</strong></li>
<li>枚举四路输入，使得<strong>当四路输入<span
class="math inline">2</span>或<span
class="math inline">3</span>个信号时，接入代表2的二进制输出上</strong></li>
<li>通过三个<code>AND</code>门组合，使得<strong>当四路输入全为<span
class="math inline">1</span>时，接入代表<span
class="math inline">4</span>的二进制输出上</strong></li>
</ul>
<p>总而言之，通过繁琐的排列组合，实现接受<span
class="math inline">255</span>路输入后，输出数值上最多表示<span
class="math inline">255</span>的单字节八位信号</p>
<p>为了方便，依然将这个信号用一点表示，使用<strong>分线器</strong>解散这个点，使用<strong>集线器</strong>构建这个点</p>
<p>二进制补码：将一个字节的最后一位视为<span
class="math inline"> − 128</span>后，即有<strong>按位取反加<span
class="math inline">1</span>后变为其相反数</strong>的特性</p>
<h3 id="半加器与全加器与八位加法器">半加器与全加器与八位加法器</h3>
<p>半加器指对<strong>两路</strong><span
class="math inline">1</span>位输入求和，并用两路输出<strong>本位和</strong>与<strong>进位</strong>：</p>
<ul>
<li>一个<code>XOR</code>门得到正确的本位和输出，即在<span
class="math inline">1 + 0 = 1</span>或<span
class="math inline">0 + 1 = 1</span>时输出<span
class="math inline">1</span></li>
<li>一个<code>AND</code>门得到正确的进位输出，即在<span
class="math inline">1 + 1 = 10</span>时进位</li>
</ul>
<p>全加器指对<strong>三路</strong><span
class="math inline">1</span>位输入求和，并用两路输出<strong>本位和</strong>与<strong>进位</strong>：</p>
<ul>
<li>通过两个<code>XOR</code>门，当输入信号为奇数个时在本位和处输出<span
class="math inline">1</span></li>
<li>对两路输入通过半加器，当进位为<span
class="math inline">1</span>时，或本位和为<span
class="math inline">1</span>且第三路输入为<span
class="math inline">1</span>时，在全加器进位处输出<span
class="math inline">1</span></li>
</ul>
<p>八位加法器接受一个一位输入用于继承上一个八位加法器的进位；接受两个字节输入表示两个参数；输出一个一位信号表示三个数的进位；输出一个字节信号表示除进位外的和：</p>
<ul>
<li>通过八个全加器与一个集线器即可得到八位加法器</li>
<li>附录中展现了高速八位加法器，能达到<span
class="math inline">61</span>逻辑门、<span
class="math inline">20</span>延迟</li>
</ul>
<p>通过对第二个输入取相反数，实现减法</p>
<h3 id="数据选择">数据选择</h3>
<p>根据一个<span
class="math inline">1</span>位信号输入来选择两路输入是很有价值的，所以需要<strong>开关</strong>：</p>
<ul>
<li>当开关关闭时，既不输出高电平也不输出低电平，处于<strong>高阻态</strong></li>
<li>两个开关即可实现数据选择，开关保证了在一路输出时不会受影响另一路影响</li>
<li>除了选择输入外，也可以用开关来选择输出端</li>
</ul>
<h2 id="数据存储">数据存储</h2>
<h3 id="一位存储器">一位存储器</h3>
<p>通过<strong>延迟线</strong>，能够将该刻的信号延迟到下一刻输出，实现存储器功能：</p>
<ul>
<li>接受一个代表写入开关的输入和代表待写入数据的输入，且总是输出当前存储的数据</li>
<li>当表示是否写入的输入为<span
class="math inline">0</span>时，选择延迟线的输出，否则选择待写入数据</li>
<li>将这个信号传递给延迟线后进入下一刻，则存储器能通过读取输入判断是否要覆写数据，并在覆写前将旧数据输出</li>
</ul>
<h3 id="寄存器">寄存器</h3>
<p>通过八个<span
class="math inline">1</span>位存储器，实现<strong>寄存器</strong>，它额外接受一个代表读取的输入并拥有一个额外的输出端，只有当其为<span
class="math inline">1</span>时，将该刻数据输出到这个输出端上</p>
<h3 id="计时器">计时器</h3>
<p>想让一个处理器逐个读取指令，需要一个计时器：</p>
<ul>
<li>本身处于计时模式，每过一刻钟自增固定数值；接受一个代表启动擦写的输入和一个代表待写入数值的输入；始终输出当前时刻的值</li>
<li>通过<code>ON</code>与数据选择器即可实现步进为<span
class="math inline">1</span>的计时器</li>
</ul>
<h3 id="解码器">解码器</h3>
<p>所谓解码器，即将所有输入的所有组合输出，例如三位解码器有八位输出，这使得处理器能够处理不同的指令</p>
<p>通过解码器、开关与数据选择器，能够实现根据输入来选择不同运算或直接输出数据</p>
<h2 id="总结">总结</h2>
<p><code>OVERTRUE</code>架构将一条指令看作<strong>复制、运算、条件判断、立即数</strong>的任意一种，通过解码能够简单地实现读取地址、区分运算等功能，在本架构中通过两位信号四种可能来区分它们，接下来介绍如何实现该架构</p>
<p>在<code>OVERTRUE</code>架构中，能够操作的条件种类较少，主要是与<span
class="math inline">0</span>对比，或总是跳转，如果满足条件，将跳转到某一寄存器所指的地址</p>
<p>这个架构虽然具备自行处理指令的功能，但指令之间是隔离的，即运算功能使用固定的两个寄存器，跳转功能只判断一个固定的寄存器与一个固定的数值，立即数只能传入一个固定的寄存器，都需要通过复制来处理数据，对编写程序是极不友好的，而在之后的<code>LEG</code>框架能够有效提升性能</p>
<h2 id="附录">附录</h2>
<h3 id="基础逻辑门-1">基础逻辑门</h3>
<p><code>NOT</code></p>
<p><img src="1.8.NOTp.png" alt="1.8.NOTp" style="zoom:25%;" /></p>
<p><code>NOR</code></p>
<p><img src="1.9.NORp.png" alt="1.9.NORp" style="zoom:25%;" /></p>
<p><code>OR</code></p>
<p><img src="1.11.ORp.png" alt="1.11.ORp" style="zoom:25%;" /></p>
<p><code>AND</code></p>
<p><img src="1.10.ANDp.png" alt="1.10.ANDp" style="zoom:25%;" /></p>
<p><code>XOR</code></p>
<p><img src="1.12.XORp.png" alt="1.12.XORp" style="zoom:25%;" /></p>
<h3 id="算数运算">算数运算</h3>
<p>一位半加器</p>
<p><img src="1.14.半加器.png" alt="1.14.半加器" style="zoom: 33%;" /></p>
<p>一位全加器</p>
<p><img src="1.15.全加器.png" alt="1.15.全加器" style="zoom: 33%;" /></p>
<p>高速八位加法器</p>
<figure>
<img src="1.16.高速加法器.png" alt="1.16.高速加法器" />
<figcaption aria-hidden="true">1.16.高速加法器</figcaption>
</figure>
<h3 id="时序逻辑电路基本元件">时序逻辑电路基本元件</h3>
<p>数据选择器</p>
<p><img src="1.19.数据选择器.png" alt="1.19.数据选择器" style="zoom:50%;" /></p>
<p>计时器</p>
<p><img src="1.17.计时器.png" alt="1.17.计时器" style="zoom:50%;" /></p>
<p>三位解码器</p>
<p><img src="1.18.三位解码器.png" alt="1.18.三位解码器" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>Digital Circuit</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学: 图论基础</title>
    <url>/blogs/2024/04/29/discreteMath-graph/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="图">图</h1>
<h2 id="图的基本概念">图的基本概念</h2>
<ul>
<li>图由结点集合<span class="math inline"><em>V</em></span>，边集合<span
class="math inline"><em>E</em></span>，映射关系<span
class="math inline"><em>φ</em></span>构成，其中<span
class="math inline"><em>φ</em> : <em>E</em> → <em>V</em> × <em>V</em>/{<em>V</em>, <em>V</em>}</span>为由边到结点序偶/两元素集合的函数</li>
<li>当<span
class="math inline"><em>φ</em></span>映射到序偶时，称为有向图，反之为无向图</li>
<li>每条边关联的两个点相互点邻接，同一结点上的各条边相互边邻接</li>
<li>若<span
class="math inline"><em>e</em></span>关联的两点是同一结点，称为自回路/环</li>
<li>若<span
class="math inline"><em>φ</em>(<em>e</em><sub>1</sub>) = <em>φ</em>(<em>e</em><sub>2</sub>)</span>，称这两条边互为平行边，在有向图中需注意方向</li>
<li>图的分类(侧重点不同的领域定义可能有所不同)：
<ul>
<li>简单图：既没有自回路也没有平行边</li>
<li>多重边图：没有自回路，有平行边</li>
<li>伪图：有自回路和平行边</li>
</ul></li>
<li>图的同构：含双射函数<span
class="math inline"><em>f</em> : <em>V</em> → <em>V</em>′, <em>g</em> : <em>E</em> → <em>E</em>′</span>，新的映射关系<span
class="math inline"><em>φ</em>′</span>，满足<span
class="math inline"><em>φ</em>(<em>e</em>) = {<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>} → <em>φ</em>′(<em>g</em>(<em>e</em>)) = {<em>f</em>(<em>v</em><sub>1</sub>), <em>f</em>(<em>v</em><sub>2</sub>)}</span></li>
<li>结点的度数及相关结论：
<ul>
<li>所有结点度数之和<span
class="math inline"><em>d</em>(<em>G</em>)</span>等于两倍的边数</li>
<li>一定含偶数个奇度节点</li>
</ul></li>
<li><span
class="math inline"><em>d</em></span>度正则图：所有结点度数为<span
class="math inline"><em>d</em></span>度，若结点数为<span
class="math inline"><em>d</em> + 1</span>，则称其为<strong><span
class="math inline"><em>d</em> + 1</span>阶完全无向图</strong>，记为<span
class="math inline"><em>k</em><sub><em>d</em> + 1</sub></span>
<ul>
<li><span
class="math inline"><em>k</em><sub><em>n</em></sub></span>为同阶图中边数最多的图，且<span
class="math inline">$\begin{align}|E|=\frac{n(n-1)}2=C_n^2\end{align}$</span></li>
</ul></li>
<li>子图的定义：
<ul>
<li>若子图的三个构成部分都包含于母图，称为子图</li>
<li>在子图基础上，若边、映射关系真包含于母图，称为真子图</li>
<li>在子图基础上，若结点集合和母图一致，称为<strong>生成子图</strong>，即对母图只删除边(或不删除)</li>
<li>导出子图：分为由边导出和由结点导出</li>
</ul></li>
<li>路径、回路：
<ul>
<li>路径由若干结点及连接它们的边组成，若起点和终点重合，称其为回路</li>
<li>若一条路径/回路中边互不相同，称为简单路径/回路</li>
<li>若一条路径结点互不相同/回路除起点外结点互不相同，称为基本路径/回路(圈)</li>
<li>若简单回路包含图中所有边，称为欧拉回路；若基本回路包含图中所有点，称为哈密尔顿回路</li>
<li>基本路径一定是简单路径，反之不成立；基本回路也不一定是简单回路</li>
<li><span
class="math inline"><em>n</em></span>阶图中，基本路径长度小于等于<span
class="math inline"><em>n</em> − 1</span></li>
</ul></li>
<li>连通性：
<ul>
<li>若两结点间有路径，则称它们可达，称最短路径为测地线</li>
<li>定义图的直径为最长路径的长度</li>
<li>无向图：若任意两结点可达，称<span
class="math inline"><em>G</em></span>是连通的</li>
<li>有向图：
<ul>
<li>若其对应的无向图(也叫基础图)连通，称为弱连通</li>
<li>若任意两结点有单向路径，称为单向连通</li>
<li>若任意两结点互相可达，称为强连通</li>
</ul></li>
<li>无向图连通分支：由可达关系(是一个等价类)划分出的等价类导出的子图为连通分支</li>
<li>每个连通分支都是一个连通子图</li>
<li>若通过删去边/点能使一个连通分支变为两个或以上，称其为割边/割点</li>
<li><span
class="math inline"><em>e</em><em>是</em><em>割</em><em>边</em> ⇔ <em>e</em><em>不</em><em>在</em><em>任</em><em>何</em><em>简</em><em>单</em><em>回</em><em>路</em><em>上</em></span></li>
</ul></li>
<li>邻接矩阵：注意结点没有自回路，结点和自身不可达</li>
<li>邻接矩阵的转置：表示其逆图，所有边反向</li>
<li>邻接矩阵的幂<span
class="math inline"><em>A</em><sup><em>n</em></sup></span>：<span
class="math inline"><em>a</em><sub><em>i</em><em>j</em></sub></span>表示由<span
class="math inline"><em>i</em></span>到<span
class="math inline"><em>j</em></span>的<span
class="math inline"><em>n</em></span>度路径长度</li>
<li>可达性矩阵<span
class="math inline"><em>P</em></span>：是布尔矩阵，表示可达性</li>
<li><span
class="math inline"><em>A</em><em>A</em><sup><em>T</em></sup></span>：<span
class="math inline"><em>a</em><sub><em>i</em><em>j</em></sub></span>表示以<span
class="math inline"><em>i</em>/<em>j</em></span>为起点，共同终于某些结点的边的个数</li>
<li><span
class="math inline"><em>A</em><sup><em>T</em></sup><em>A</em></span>：<span
class="math inline"><em>a</em><sub><em>i</em><em>j</em></sub></span>表示以某些结点为起点，终于<span
class="math inline"><em>i</em>/<em>j</em></span>的边的个数</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Discrete Math</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 多元函数微分</title>
    <url>/blogs/2024/04/23/calculus-multivar-diff/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="多元函数微分学">多元函数微分学</h1>
<h2 id="多元函数极限">多元函数极限</h2>
<h3 id="判别方法">判别方法</h3>
<p>多元函数的极限考虑一组自变量同时趋近一组常量，体现在二元函数上，是一个<strong>二重极限</strong></p>
<ul>
<li>任何<strong>方式</strong>趋近时极限都存在且相同，例如直线<span
class="math inline">(<em>y</em>=<em>k</em><em>x</em>)</span>、曲线方式<span
class="math inline">(<em>y</em>=<em>x</em><sup>2</sup>、<em>y</em>=sin<em>x</em>...)</span></li>
<li>由<strong>具有不同变量的初等函数的四则运算</strong>复合而成的二元函数在定义域上连续，若在该点连续，则在该点极限等于函数值</li>
<li><span class="math inline"><em>δ</em> − <em>ε</em></span>语言定义：
<ul>
<li>对任意<span class="math inline"><em>ε</em> &gt; 0</span>，存在<span
class="math inline">$\var&gt;0$</span>，当<span
class="math inline">$\begin{cases}|x-x_0|&lt;\delta\\|y-y_0|&lt;\delta\end{cases}$</span>且<span
class="math inline">(<em>x</em>,<em>y</em>) ≠ (<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>)</span>时(去心邻域内)，有<span
class="math inline">|<em>f</em>(<em>x</em>,<em>y</em>)−<em>A</em>| &lt; <em>ε</em></span>，则极限为<span
class="math inline"><em>A</em></span></li>
<li>这种语言通常通过<strong>放缩</strong>来证明二重极限存在，即找到<strong><span
class="math inline"><em>g</em>(<em>δ</em>)</span>，使其满足<span
class="math inline"><em>f</em>(<em>x</em>,<em>y</em>) − <em>A</em> &lt; <em>g</em>(<em>δ</em>)</span></strong>，令<span
class="math inline"><em>ε</em> = <em>g</em>(<em>δ</em>)</span>即可</li>
</ul></li>
</ul>
<h3 id="常见二重极限">常见二重极限</h3>
<ul>
<li><span
class="math inline">$\begin{align}&amp;\lim_{(x,y)\rightarrow(0,0)}\frac{xy}{\sqrt{x^2+y^2}}=0\end{align}$</span>，幂次方、分子继续乘<span
class="math inline"><em>x</em>、<em>y</em></span>的极限都为<span
class="math inline">0</span></li>
<li><span
class="math inline">$\begin{align}&amp;\lim_{(x,y)\rightarrow(0,0)}\frac{xy}{x^2+y^2}\end{align}$</span>不存在</li>
<li><span
class="math inline">$\begin{align}&amp;\lim_{(x,y)\rightarrow(0,0)}\frac{xy}{x+y}\end{align}$</span>不存在</li>
</ul>
<h3 id="二元函数连续性">二元函数连续性</h3>
<ul>
<li>若<span
class="math inline">$\begin{align}&amp;\lim_{(x,y)\rightarrow(x_0,y_0)}f(x,y)=f(x_0,y_0)\end{align}$</span>，称在该点连续</li>
<li>当二重极限不存在、或在该点无定义、或二重极限存在但与该点定义不等时，该点为间断点</li>
<li><span
class="math inline"><em>f</em>(<em>x</em>,<em>y</em>)</span>在<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>)</span>处连续<span
class="math inline">$\begin{align}\Leftrightarrow\lim_{(x,y)\rightarrow(0,0)}\Delta
z=0\end{align}$</span></li>
<li>多元连续函数符合有界性、介值定理</li>
</ul>
<h2 id="多元函数全微分">多元函数全微分</h2>
<h3 id="求偏导">求偏导</h3>
<ul>
<li>将其它变量视为常量，将整个函数看作一元函数求导</li>
<li>与一元函数求导一样，导数间断点但用定义、导数连续点用求导法则</li>
<li>求某点的偏导，可先行代入其它变量的值</li>
<li>偏导函数的变量结构可化为与原函数一致，但实际求出一阶偏导后，往往会多出几种变量</li>
<li>含<strong>二阶连续偏导</strong>的二元函数的<strong>二阶混合偏导相等</strong></li>
</ul>
<h3 id="求全微分">求全微分</h3>
<ul>
<li><span class="math inline">$\begin{align}&amp;\Delta z=f(x+\Delta
x,y+\Delta y)-f(x,y)&amp;(1).\end{align}$</span></li>
<li>如果函数在<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>)</span>处可微，则<span
class="math inline"><em>Δ</em><em>z</em> = <em>d</em><em>z</em> + <em>o</em>(<em>ρ</em>)</span>，且<span
class="math inline">$\begin{align}&amp;dz=f_x'dx+f_y'dy&amp;(2).全微分公式\end{align}$</span></li>
<li>换句话说，要证明函数在该点可微，就是证明<span
class="math inline"><em>Δ</em><em>z</em> − <em>d</em><em>z</em></span>是<span
class="math inline"><em>ρ</em></span>的高阶无穷小：<span
class="math inline">$\begin{align}&amp;\lim_{(x,y)\rightarrow(0,0)}\frac{o(\rho)}{\rho}=0,其中o(\rho)=(1)-(2)\\&amp;=f(x_0+x,y_0+y)-f(x_0,y_0)-f_x'(x_0,y_0)x-f_y'(x_0,y_0)y\\&amp;\rho=\sqrt{x^2+y^2}\end{align}$</span></li>
<li>全微分的四则运算法则与一元函数相同</li>
<li>若已知全增量，容易得到偏导是否存在</li>
</ul>
<h3 id="复合函数全微分">复合函数全微分</h3>
<ul>
<li>假设对<span
class="math inline"><em>x</em></span>求偏导，若所有外层函数在此点可微，最内层函数对<span
class="math inline"><em>x</em></span>可偏导(或可导)，则符合：
<ul>
<li>找到所有含<span class="math inline"><em>x</em></span>的路径</li>
<li>分叉路用偏导符号，单路用微分符号</li>
<li><span class="math inline">$\begin{align}&amp;\frac{\part f}{\part
x}=\frac{\part f}{\part u}·\frac{\part u}{\part
x}+\cdots\end{align}$</span>，即相同路径求导相乘，不同路径导数相加</li>
<li>若符号重复，可改写为<span
class="math inline"><em>f</em>(<em>x</em>,<em>y</em>,<em>z</em>)</span>的形式，并用下标<span
class="math inline">1, 2, ⋯</span>指代偏导</li>
</ul></li>
<li>一阶全微分形式不变性：复合函数一阶全微分仍可套用全微分公式</li>
</ul>
<h3 id="隐函数存在定理">隐函数存在定理</h3>
<ul>
<li>对<span class="math inline"><em>n</em></span>元函数方程确定的<span
class="math inline"><em>n</em> − 1</span>元隐函数，若在点<span
class="math inline"><em>P</em><sub>0</sub></span>处具有<strong>连续偏导</strong>、函数值为<span
class="math inline">0</span>、对变量<span
class="math inline"><em>z</em></span><strong>偏导不为<span
class="math inline">0</span></strong>，则有唯一确定的隐函数<span
class="math inline"><em>z</em> = <em>f</em>(<em>其</em><em>它</em><em>n</em>−1<em>个</em><em>变</em><em>量</em>)</span></li>
<li>该隐函数的偏导<span class="math inline">$\begin{align}\frac{\part
z}{\part i}=-\frac{f_i}{f_z}\end{align}$</span></li>
<li>由方程组确定的隐函数：将方程转换为隐函数的全微分后，联立消去某变量</li>
</ul>
<h3 id="方向导数">方向导数</h3>
<ul>
<li>定义：<span class="math inline">$\begin{align}\frac{\part f}{\part
l}=\lim_{\rho\rightarrow0}\frac{f(x+\Delta x,y+\Delta
y)-f(x,y)}\rho=\lim_{t\rightarrow0^+}\frac{f(x+t\cos\alpha,y+t\cos\beta)-f(x,y)}t\end{align}$</span></li>
<li>方向导数是沿某一<strong>射线</strong>方向切片上的导数，实质上是<strong>单侧极限</strong></li>
<li>若在一点可微，则(以二元函数为例)：
<ul>
<li>在该点各个方向的方向导数存在，且满足：<span
class="math inline">$\begin{align}\frac{\part f}{\part
l}=f_x(x,y)\cos\alpha+f_y(x,y)\cos\beta\end{align}$</span></li>
<li>向量<span
class="math inline">(<em>f</em><sub><em>x</em></sub>(<em>x</em>,<em>y</em>), <em>f</em><sub><em>y</em></sub>(<em>x</em>,<em>y</em>))</span>称为<strong>梯度</strong>，记为<span
class="math inline">$\grad f(x,y)$</span></li>
<li>方向导数最大值为<span
class="math inline">|(<em>f</em><sub><em>x</em></sub>(<em>x</em>,<em>y</em>), <em>f</em><sub><em>y</em></sub>(<em>x</em>,<em>y</em>))|</span>，即梯度方向的方向导数</li>
<li>一个点的梯度方向，就是等值线在该点的<strong>法线方向</strong></li>
</ul></li>
</ul>
<h3 id="条件关系图">条件关系图</h3>
<pre><code class="highlight mermaid">graph LR
 A(偏导连续) --&gt; B(可微)
 B --&gt; F(方向偏导数都存在)
    F --&gt; C(可偏导)
    B --&gt; D(连续)
 F --&gt; E(所有方向导数都存在)
 AA(高阶偏导连续) ---&gt; BB(低阶偏导连续) --&gt; CC(原函数可微)</code></pre>
<p>可偏导与连续无蕴涵关系，都是可微的必要条件</p>
<p>方向偏导数指在某一<strong>直线</strong>方向切片上的偏导数存在</p>
<h3 id="空间几何">空间几何</h3>
<ul>
<li>对<strong>空间曲面</strong>来说，由该曲面方程形成的三元函数的<strong>三个偏导所构成的向量</strong><span
class="math inline"><em>n⃗</em></span>就是在该点处，切平面的法向量，也即法线的方向向量</li>
<li>对以完整的参数方程形式给出的<strong>空间曲线</strong>来说，即<span
class="math inline">$\begin{cases}x=\varphi(t)\\y=\psi(t)\\z=\omega(t)\end{cases}$</span>，其中<span
class="math inline"><em>φ</em>(<em>t</em>), <em>ψ</em>(<em>t</em>), <em>ω</em>(<em>t</em>)</span>导数存在且不全为<span
class="math inline">0</span>，则切线的方向向量就是它们<strong>对<span
class="math inline"><em>t</em></span>的导数</strong>组成的向量，也即该点法平面的法向量</li>
<li>对不完整的参数方程，例如<span
class="math inline">$\begin{cases}y=\varphi(x)\\z=\omega(x)\end{cases}$</span>，则可改写为完整的参数方程<span
class="math inline">$\begin{cases}x=x\\y=\varphi(x)\\z=\omega(x)\end{cases}$</span>，此时方向向量为<span
class="math inline">(1,<em>y</em>′,<em>z</em>′)</span></li>
<li>对<strong>一般式空间曲线</strong>，由隐函数存在定理，可转化为上述情况，法平面方程由此可转化为行列式<span
class="math inline">$\left|\begin{matrix}x-x_0&amp;y-y_0&amp;z-z_0\\F_x&amp;F_y&amp;F_z\\G_x&amp;G_y&amp;G_z\end{matrix}\right|=0$</span>，此时法向量(即切线方向向量)为<span
class="math inline">$\begin{align}\left(\frac{\part(F,G)}{\part(y,z)},{\bf
-}\frac{\part(F,G)}{\part(x,z)},\frac{\part(F,G)}{\part(x,y)}\right)\end{align}$</span>，也就是<strong>两曲面法向量的叉乘积</strong></li>
</ul>
<h3 id="无条件极值">无条件极值</h3>
<ul>
<li>二元函数的<strong>二阶连续偏导</strong>点为<strong>极值点</strong>的充分条件：一阶偏导为<span
class="math inline">0</span>，海森阵行列式大于<span
class="math inline">0</span>
<ul>
<li>二元函数海森阵：<span
class="math inline">$\left[\begin{matrix}F_{xx}&amp;F_{xy}\\F_{yx}&amp;F_{yy}\end{matrix}\right]$</span>，由于二阶偏导连续时，<span
class="math inline"><em>F</em><sub><em>x</em><em>y</em></sub> = <em>F</em><sub><em>y</em><em>x</em></sub></span>，故此时不存在<span
class="math inline"><em>F</em><sub><em>x</em><em>x</em></sub> = 0</span>而行列式大于<span
class="math inline">0</span>的情况</li>
<li>若行列式大于<span
class="math inline">0</span>，则<strong>是极值点</strong>，且<span
class="math inline">$\begin{cases}F_{xx}&gt;0,&amp;极小值点\\F_{xx}&lt;0,&amp;极大值点\end{cases}$</span></li>
<li>若行列式小于<span
class="math inline">0</span>，则不是极值点，而是<strong>鞍点</strong></li>
<li>若行列式等于<span
class="math inline">0</span>，则都有可能，无法判断</li>
</ul></li>
<li>多元函数<span
class="math inline"><em>F</em>(<em>x</em>,<em>y</em>,⋯,<em>z</em>)</span>的二阶连续偏导点为极值点：一阶偏导为<span
class="math inline">0</span>，考虑海森阵行列式：
<ul>
<li>海森阵<span
class="math inline">$\left[\begin{matrix}F_{xx}&amp;F_{xy}&amp;\cdots&amp;F_{xz}\\F_{yx}&amp;F_{yy}&amp;\cdots&amp;F_{yz}\\\vdots&amp;\vdots&amp;&amp;\vdots\\F_{zx}&amp;F_{zy}&amp;\cdots&amp;F_{zz}\end{matrix}\right]$</span></li>
<li>若为正定矩阵(<strong>特征值</strong>都大于<span
class="math inline">0</span>，或<strong>顺序主子式</strong>都大于<span
class="math inline">0</span>)：为极小值点</li>
<li>若为负定矩阵(特征值都小于<span class="math inline">0</span>，或<span
class="math inline">$\begin{cases}奇数阶顺序主子式小于0\\偶数阶顺序主子式大于0\end{cases}$</span>)：为极大值点</li>
<li>若为不定矩阵(特征值含大于、小于<span
class="math inline">0</span>)：不是极值点</li>
<li>若为半正定矩阵、半负定矩阵(特征值<span
class="math inline"> ≥ 0</span>、<span
class="math inline"> ≤ 0</span>)：无法判断</li>
</ul></li>
<li>二元函数的不可导点也可能是极值点，但没有系统的方法可求解，只能根据图形判断</li>
</ul>
<h3 id="条件极值">条件极值</h3>
<p>在求多元函数某闭区域内的最值时，需要求出所有可疑的内部极值点及边界上的极值点，求边界极值时往往会附带条件，采用<strong>拉格朗日乘数法</strong>解决：</p>
<ul>
<li>求<span
class="math inline"><em>f</em>(<em>x</em>,<em>y</em>,⋯,<em>z</em>)</span>在<span
class="math inline"><em>φ</em>(<em>x</em>,<em>y</em>,⋯,<em>z</em>) = 0、⋯、<em>ψ</em>(<em>x</em>,<em>y</em>,⋯,<em>z</em>) = 0</span>条件约束下的极值</li>
<li>构造函数<span
class="math inline"><em>F</em>(<em>x</em>,<em>y</em>,⋯,<em>z</em>,<em>λ</em>,⋯,<em>u</em>) = <em>f</em> + <em>λ</em><em>φ</em> + ⋯ + <em>u</em><em>ψ</em></span></li>
<li>令<span class="math inline"><em>F</em></span>的所有偏导等于<span
class="math inline">0</span>，解方程组得到条件极值点<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>,⋯,<em>z</em><sub>0</sub>)</span>及对应的<span
class="math inline"><em>λ</em>、⋯、<em>u</em></span></li>
</ul>
<h2 id="练习">练习</h2>
<h3 id="简单判断">简单判断</h3>
<p><span
class="math inline">$\begin{align}&amp;1.讨论f(x,y)=\begin{cases}(x^2+y^2)\ln(x^2+y^2),&amp;x^2+y^2\ne0\\0,&amp;x^2+y^2=0\end{cases}在(0,0)处的连续性\\&amp;解:\lim_{(x,y)\rightarrow(0,0)}f(x,y)\xlongequal[y=\rho\cos
t]{x=\rho \sin
t}\lim_{\rho\rightarrow0}\rho^2\ln\rho^2=\lim_{\rho\rightarrow0}\frac{\ln\rho^2}{\frac1{\rho^2}}=0=f(0,0)\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;2.讨论\lim_{(x,y)\rightarrow(0,0)}\frac{xy}{x+y}是否存在.\\&amp;沿y=kx,原极限=0;沿y=x^2-x,原极限=-1,故不存在\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;3.讨论\lim_{(x,y)\rightarrow(0,0)}\frac{xy^2\sin
ky}{x^2+y^4}是否存在(k\ne0).\\&amp;0\le \left|\frac{xy^2\sin
ky}{x^2+y^4}\right|\le\left|\frac{kxy^3}{x^2+y^4}\right|\le\left|\frac{\frac12(x^2+y^4)}{x^2+y^4}ky\right|=\frac12|ky|=0\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;4.f(x,y)=\begin{cases}\frac1{xy}\sin
x^2y,&amp;xy\ne0\\0,&amp;xy=0\end{cases},则f_x'(0,1)的值为?\\&amp;分段点,定义求导f_x'(0,1)=\lim_{x\rightarrow0}\frac{\frac1x\sin
x^2}{x-0}=1\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;5.f(x,y)=e^{\sqrt{x^2+y^4}}在(0,0)处的偏导.\\&amp;在看不出是否分段时,用定义求导一定正确\\&amp;f_x(0,0)=\lim_{x\rightarrow0}\frac{e^{\sqrt{x^2}}-1}{x-0}=\lim_{x\rightarrow0}\frac{|x|}x,不存在\\&amp;f_y(0,0)=\lim_{y\rightarrow0}\frac{e^{y^2}-1}{y-0}=\lim_{y\rightarrow0}y=0\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;6.证明f(x,y)在(0,0)处可微的一个充分条件为\lim_{(x,y)\rightarrow(0,0)}\frac{f(x,y)-f(0,0)}{\sqrt{x^2+y^2}}=0\\&amp;证:由条件得\lim_{x\rightarrow0}\frac{f(x,0)-f(0,0)}{|x|}=0,两边极限都等于0,故f_x(0,0)=0\\&amp;同理f_y(0,0)=0,\\&amp;考虑\lim_{(x,y)\rightarrow(0,0)}\frac{\Delta
f-f_x(0,0)x-f_y(0,0)y}{\sqrt{x^2+y^2}}=\lim_{(x,y)\rightarrow(0,0)}\frac{f(x,y)-f(0,0)}{\sqrt{x^2+y^2}}=0\\&amp;故\Delta
f(0,0)=f_x(0,0)dx+f_y(0,0)dy+o(\sqrt{x^2+y^2}),故可微\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;7.证明f(x,y)在(0,0)处可微的一个充分条件为\lim_{(x,y)\rightarrow(0,0)}\frac{f(x,y)-f(0,0)+2x-y}{\sqrt{x^2+y^2}}=0\\&amp;与前者不同在于求偏导的过程.\\&amp;f_x(0,0)=\lim_{x\rightarrow0}(\frac{f(x,0)-f(0,0)+2x}{|x|}·\frac{|x|}{x}-2)=-2\\&amp;同理f_y(0,0)=1,其余过程相同\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;8.xy-z\ln
y+e^{xz}=1在(0,1,1)的一个邻域内可确定哪几个隐函数?\\&amp;代入F(0,1,1)=0,看偏导\\&amp;求导:F_x=y+e^{xz}z;F_y=x-\frac
zy;F_z=-\ln
y+e^{xz}x\\&amp;代入F_x(0,1,1)=2;F_y(0,1,1)=-1;F_z(0,1,1)=0\\&amp;故可确定唯一的x(y,z)和y(x,z)\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;9.求函数z=1-\left(\frac{x^2}{a^2}+\frac{y^2}{b^2}\right)在点\left(\frac
a{\sqrt2},\frac
b{\sqrt2}\right)处\\&amp;沿曲线\frac{x^2}{a^2}+\frac{y^2}{b^2}=1在这点的内法线方向的方向导数.\\&amp;解:该曲线可确定唯一的y=y(x),补充x=x,即为参数方程\\&amp;故切向量为\left(1,-\frac{f_x}{f_y}\Bigg|_{\left(\frac
a{\sqrt2},\frac b{\sqrt2}\right)}\right)=(1,-\frac
ba)\\&amp;两个相反方向的法向量为\pm(b,a),内法线方向为(-b,-a)\\&amp;故方向导数为z_x\cos\alpha+z_y\cos\beta=\frac{\sqrt{2(a^2+b^2)}}{ab}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;10.若f(x,y)在有界闭区域内有二阶连续偏导,且\frac{\part^2f}{\part
x\part y}\ne0,\frac{\part^2f}{\part x^2}+\frac{\part^2f}{\part
y^2}=0,求其最大、最小值的位置\\&amp;令A=\frac{\part^2f}{\part
x^2},B=\frac{\part^2f}{\part x\part y},C=\frac{\part^2f}{\part
y^2},易得AC-B^2&lt;0,内部没有极值点\\&amp;故最大、最小值只能在边界上\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;11.设函数f(x,y)在(0,0)处连续,且\lim_{(x,y)\rightarrow(0,0)}\frac{f(x,y)}{1-\cos{\sqrt{x^2+y^2}}}=-2,则在该点是否为极值?\\&amp;由1-\cos\sqrt{x^2+y^2}\sim\frac{x^2+y^2}2,易得f(x,y)是-(x^2+y^2)的等价无穷小\\&amp;即\lim_{(x,y)\rightarrow(0,0)}f(x,y)=0,连续\Rightarrow
f(0,0)=0\\&amp;f_x(0,0)=\lim_{x\rightarrow0}\frac{f(x,0)-0}x=0,同理f_y(0,0)=0,是可疑极值点\\&amp;f(x,y)=-(x^2+y^2)(1+\alpha),其中\lim_{(x,y)\rightarrow(0,0)}\alpha=0,故f(x,y)在邻域内&lt;0\\&amp;故是极值点,且为极大值点\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.设f(x,y)在(0,0)某邻域内连续,且\lim_{(x,y)\rightarrow(0,0)}\frac{f(x,y)-xy}{(x^2+y^2)^2}=1,证明(0,0)不是f的极值点\\&amp;由x^2+y^2\rightarrow0,得f(x,y)-xy\rightarrow0,得\lim_{(x,y)\rightarrow(0,0)}f(x,y)=0,由连续得f(0,0)=0\\&amp;[举特例说明]:再由条件得\lim_{x\rightarrow0}\frac{f(x,0)-0}{x^4}=1,即在y=0路径上为极小值点\\&amp;在y=-x路径上,\lim_{x\rightarrow0}\frac{f(x,-x)+x^2}{4x^4}=1,\therefore0&gt;\lim_{x\rightarrow0}f(x,-x)&gt;-x^2,是极大值点\\&amp;故不是极值点\\&amp;[不通过路径说明]:\frac{f(x,y)}{xy+(x^2+y^2)^2}=1+\alpha,其中\lim_{(x,y)\rightarrow(0,0)}\alpha=0\\&amp;即f(x,y)=xy+(1+\alpha)(x^2+y^2)^2\\&amp;故f(x,y)符号取决于xy,当x、y异号时为极大值点,当x、y同号时为极小值点\end{align}$</span></p>
<h3 id="大题练习">大题练习</h3>
<p><span
class="math inline">$\begin{align}&amp;1.通过\begin{cases}x=e^u\\y=e^v\end{cases},变换2x^2\frac{\part^2z}{\part
x^2}+xy\frac{\part^2z}{\part x\part y}+y^2\frac{\part^2z}{\part
y^2}=0\\&amp;\frac{\part z}{\part u}=\frac{\part z}{\part x}e^u;\ \
\frac{\part z}{\part v}=\frac{\part z}{\part
y}e^v\\&amp;\frac{\part^2z}{\part u^2}=e^u\left(\frac{\part z}{\part
x}+\frac{\part^2z}{\part
x^2}e^u\right),对v二阶偏导、混合偏导同理\\&amp;最终答案:2\frac{\part^2z}{\part
u^2}+\frac{\part^2z}{\part u\part v}+\frac{\part^2z}{\part
v^2}-2\frac{\part z}{\part u}-\frac{\part z}{\part
v}=0\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;2.讨论f(x,y)=\begin{cases}\large\frac{x^2y^2}{(x^2+y^2)^{\frac32}},&amp;x^2+y^2\ne0\\0,&amp;x^2+y^2=0\end{cases}在(0,0)处是否连续、偏导数存在性、以及是否可微\\&amp;1).0\le\lim_{(x,y)\rightarrow(0,0)}f(x,y)\le\lim_{(x,y)\rightarrow(0,0)}\frac{x^2y^2}{x^2+y^2}=0,故连续\\&amp;2).分段函数用定义,f_x(0,0)=\lim_{x\rightarrow0}\frac{f(x,0)-f(0,0)}{x-0}=\lim_{x\rightarrow0}\frac{x}{x^3}·0=0\\&amp;f_y(0,0)=\lim_{y\rightarrow0}\frac{f(0,y)-f(0,0)}{y-0}=0,偏导存在\\&amp;3).\lim_{(x,y)\rightarrow(0,0)}\frac{\frac{x^2y^2}{(x^2+y^2)^{\frac32}}-0-0x-0y}{\rho}=\lim_{(x,y)\rightarrow(0,0)}\frac{x^2y^2}{(x^2+y^2)^2}=\lim_{(x,y)\rightarrow(0,0)}\left(\frac{xy}{x^2+y^2}\right)^2不存在,\\&amp;故不可微\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学: 集合论</title>
    <url>/blogs/2024/04/22/discreteMath-set/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="集合论">集合论</h1>
<h2 id="约定">约定</h2>
<ul>
<li>小写字母表示元素，大写字母表示集合</li>
<li>元素可指代变元、集合、元组等<strong>任何离散结构</strong></li>
</ul>
<h2 id="集合基本概念">集合基本概念</h2>
<h3 id="集合表示">集合表示</h3>
<p>离散结构大厦的地基！</p>
<ul>
<li>集合是若干元素的<strong>无序聚集</strong>，且元素不重复</li>
<li>集合构造法：<span
class="math inline"><em>V</em> = {<em>x</em> | <em>P</em>(<em>x</em>), <em>Q</em>(<em>x</em>), ⋯}</span>，其中谓词<span
class="math inline"><em>P</em>, <em>Q</em></span>表示<span
class="math inline"><em>x</em></span>的性质</li>
<li>属于：<span
class="math inline"><em>x</em> ∈ <em>V</em></span>表示一个<strong>元素</strong>属于一个<strong>集合</strong>，在构造法限定元素所属父集时可写在竖线左方</li>
<li>包含关系：
<ul>
<li><span
class="math inline"><em>V</em><sub>1</sub> ⊆ <em>V</em><sub>2</sub></span>表示集合<strong><span
class="math inline"><em>V</em><sub>1</sub></span>包含于<span
class="math inline"><em>V</em><sub>2</sub></span></strong>，或<strong><span
class="math inline"><em>V</em><sub>2</sub></span>包含<span
class="math inline"><em>V</em><sub>1</sub></span></strong>，称<span
class="math inline"><em>V</em><sub>1</sub></span>是<span
class="math inline"><em>V</em><sub>2</sub></span>的<strong>子集</strong>，与<span
class="math inline"><em>V</em><sub>2</sub> ⊇ <em>V</em><sub>1</sub></span>等价</li>
<li><strong>逻辑表示</strong>：<span
class="math inline"><em>V</em><sub>1</sub> ⊆ <em>V</em><sub>2</sub> ⇔ ∀<em>x</em>(<em>x</em>∈<em>V</em><sub>1</sub>→<em>x</em>∈<em>V</em><sub>2</sub>)</span></li>
<li>所有集合都包含空集和它本身</li>
<li>包含是严格区分离散结构的，变元即变元，集合即集合，例如<span
class="math inline">{1} ⊈ {{1}}</span></li>
</ul></li>
<li>相等：
<ul>
<li>若<span
class="math inline"><em>V</em><sub>1</sub> ⊆ <em>V</em><sub>2</sub></span>且<span
class="math inline"><em>V</em><sub>2</sub> ⊆ <em>V</em><sub>1</sub></span>，称<span
class="math inline"><em>V</em><sub>1</sub> = <em>V</em><sub>2</sub></span></li>
<li>逻辑表示：<span
class="math inline"><em>V</em><sub>1</sub> = <em>V</em><sub>2</sub> ⇔ ∀<em>x</em>(<em>x</em>∈<em>V</em><sub>1</sub>↔︎<em>x</em>∈<em>V</em><sub>2</sub>)</span></li>
</ul></li>
<li>基数：<span
class="math inline">|<em>V</em>|</span>表示集合的基数，即集合中元素的个数</li>
<li>常用集合约定记号：
<ul>
<li><span class="math inline"><em>N</em></span>：所有自然数的集合</li>
<li><span class="math inline"><em>Z</em></span>：所有整数的集合</li>
<li><span
class="math inline"><em>Z</em><sup>+</sup></span>：所有正整数的集合，和<span
class="math inline">{<em>x</em> ∈ <em>N</em> | <em>x</em> ≠ 0}</span>相等</li>
<li><span class="math inline"><em>Q</em></span>：<span
class="math inline">{<em>p</em>/<em>q</em> | <em>p</em> ∈ <em>Z</em> ∧ <em>q</em> ∈ <em>Z</em> ∧ <em>q</em> ≠ 0}</span>，即所有有理数的集合</li>
<li><span class="math inline"><em>R</em></span>：所有实数的集合</li>
<li><span
class="math inline"><em>R</em><sup>+</sup></span>：所有正实数的集合</li>
<li><span class="math inline"><em>C</em></span>：所有复数的集合</li>
</ul></li>
</ul>
<h3 id="集合分类及特殊集合">集合分类及特殊集合</h3>
<ul>
<li>元素个数分类：有限集、无限集</li>
<li>空集：<span class="math inline">⌀</span>，表示不含任何元素的集合
<ul>
<li>空集不显式写在集合内，但若出现在集合内，证明是一个结构是集合的<strong>元素</strong></li>
<li>区分：空集单独作为集合写作<span
class="math inline">⌀</span>，作为其它集合的一个元素写作<span
class="math inline">{..., ⌀, ...}</span></li>
<li>逻辑表示：<span
class="math inline">{<em>x</em> | <em>P</em>(<em>x</em>) ∧ ¬<em>P</em>(<em>x</em>)}</span></li>
</ul></li>
<li><strong>幂集</strong>：<span
class="math inline">𝒫(<em>V</em>)</span>表示集合<span
class="math inline"><em>V</em></span>的幂集，是<span
class="math inline"><em>V</em></span><strong>所有子集的集合</strong>
<ul>
<li><span
class="math inline">|𝒫(<em>V</em>)| = 2<sup>|<em>V</em>|</sup></span>，若一个集合每取一次幂集，基数就取一次<span
class="math inline">2</span>的幂</li>
<li>所有集合一定包含空集和本身，而<span
class="math inline">⌀ = ⌀</span>，故<span
class="math inline">𝒫(⌀) = {⌀}</span></li>
<li>空集作为元素的边缘情况：<span
class="math inline">𝒫(𝒫(⌀)) = 𝒫({⌀}) = {⌀, {⌀}}</span></li>
</ul></li>
</ul>
<h3 id="集合运算">集合运算</h3>
<ul>
<li>集合运算的结果也是集合</li>
<li>并集：<span
class="math inline"><em>V</em><sub>1</sub> ∪ <em>V</em><sub>2</sub> = {<em>x</em> | <em>x</em> ∈ <em>V</em><sub>1</sub> ∨ <em>x</em> ∈ <em>V</em><sub>2</sub>}</span></li>
<li>交集：<span
class="math inline"><em>V</em><sub>1</sub> ∩ <em>V</em><sub>2</sub> = {<em>x</em> | <em>x</em> ∈ <em>V</em><sub>1</sub> ∧ <em>x</em> ∈ <em>V</em><sub>2</sub>}</span>，<span
class="math inline"><em>V</em><sub>1</sub> ∩ <em>V</em><sub>2</sub> = ⌀ ⇔ <em>V</em><sub>1</sub><em>和</em><em>V</em><sub>2</sub><em>不</em><em>相</em><em>交</em></span></li>
<li>相对补集：<span
class="math inline"><em>V</em><sub>1</sub> − <em>V</em><sub>2</sub> = {<em>x</em> | <em>x</em> ∈ <em>V</em><sub>1</sub> ∧ <em>x</em> ∉ <em>V</em><sub>2</sub>}</span>，称为<span
class="math inline"><em>V</em><sub>2</sub></span>相对于<span
class="math inline"><em>V</em><sub>1</sub></span>的补集，也称<span
class="math inline"><em>V</em><sub>1</sub></span>和<span
class="math inline"><em>V</em><sub>2</sub></span>的差集</li>
<li>对称差集：<span
class="math inline"><em>V</em><sub>1</sub> ⊕ <em>V</em><sub>2</sub> = (<em>V</em><sub>1</sub>−<em>V</em><sub>2</sub>) ∪ (<em>V</em><sub>2</sub>−<em>V</em><sub>1</sub>)</span>，即<span
class="math inline"><em>V</em><sub>1</sub> ∪ <em>V</em><sub>2</sub> − <em>V</em><sub>1</sub> ∩ <em>V</em><sub>2</sub></span></li>
<li>绝对补集：
<ul>
<li>通常假定所有集合都包含于一个称为<strong>全集</strong><span
class="math inline"><em>U</em></span>的大集合，通常所说<span
class="math inline"><em>V</em></span>的补集就是<span
class="math inline"><em>V</em></span>相对于<span
class="math inline"><em>U</em></span>的补集，记为<span
class="math inline"> ∼ <em>V</em></span>或<span
class="math inline"><em>V̄</em></span></li>
<li><span
class="math inline"><em>x</em> ∈ <em>V̄</em> ⇔ <em>x</em> ∉ <em>V</em></span></li>
</ul></li>
<li>集合的并集、交集运算满足布尔和、布尔积的各种恒等式，其中空集<span
class="math inline">⌀</span>对应<span
class="math inline"><em>F</em></span>，全集<span
class="math inline"><em>U</em></span>对应<span
class="math inline"><em>T</em></span></li>
</ul>
<h3 id="恒包含及补集恒等式">恒包含及补集恒等式</h3>
<ul>
<li><span class="math inline">$V_1\cap V_2\subseteq\
\begin{matrix}V_1\\V_2\end{matrix}\subseteq V_1\cup V_2$</span></li>
<li><span class="math inline">$V_1-V_2=V_1\cap\bar {V_2}=V_1-V_1\cap
V_2\subseteq V_1$</span>，相对补集满足吸收律，且最终包含于前集合</li>
<li><span
class="math inline"><em>V</em><sub>1</sub> ∩ <em>V</em><sub>2</sub> − <em>V</em><sub>1</sub> ∩ <em>V</em><sub>3</sub> = <em>V</em><sub>1</sub> ∩ (<em>V</em><sub>2</sub>−<em>V</em><sub>3</sub>)</span>，即相对补集和交集满足分配律</li>
<li><span
class="math inline"><em>V</em><sub>1</sub> ∪ <em>V</em><sub>2</sub> − <em>V</em><sub>1</sub> ∪ <em>V</em><sub>3</sub> ⊆ <em>V</em><sub>1</sub> ∪ (<em>V</em><sub>2</sub>−<em>V</em><sub>3</sub>)</span></li>
<li><span
class="math inline"><em>V</em><sub>1</sub> ⊕ <em>V</em><sub>1</sub> = ⌀</span>，自身对称补集为空集</li>
<li><span
class="math inline"><em>V</em><sub>1</sub> ⊆ <em>V</em><sub>2</sub> ⇔ <em>V</em><sub>1</sub> − <em>V</em><sub>2</sub> = ⌀</span></li>
</ul>
<h2 id="二元关系">二元关系</h2>
<h3 id="元组">元组</h3>
<ul>
<li>单纯的集合结构聚集的元素是无序的，无法表示元素的聚集顺序，故通过元组来反映<strong>次序</strong></li>
<li>元组表示：用圆括号或尖括号括起具有固定排列顺序的元素，称为一个元组</li>
<li>二元组：含有两个元素的元组，也称<strong>序偶</strong>，第一个元素称为第一元素</li>
<li>元组相等：两个元组的所有元素对应相等</li>
</ul>
<h3 id="笛卡尔积">笛卡尔积</h3>
<p>笛卡尔积<strong>从多个集合</strong>中构造出能够<strong>反映聚集顺序</strong>的<strong>元素全为元组</strong>的<strong>新集合</strong>，不满足交换律
<span
class="math display"><em>V</em><sub>1</sub> × <em>V</em><sub>2</sub> × ⋯ × <em>V</em><sub><em>n</em></sub> = {(<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,⋯,<em>x</em><sub><em>n</em></sub>) | <em>x</em><sub>1</sub> ∈ <em>V</em><sub>1</sub> ∧ <em>x</em><sub>2</sub> ∈ <em>V</em><sub>2</sub> ∧ ⋯ ∧ <em>x</em><sub><em>n</em></sub> ∈ <em>V</em><sub><em>n</em></sub>}</span>
二元笛卡尔积即构造出以<span
class="math inline"><em>V</em><sub>1</sub></span>元素为第一元素，以<span
class="math inline"><em>V</em><sub>2</sub></span>元素为第二元素的所有序偶，并放在一个新集合里</p>
<p>边缘情况：若其中一个参数集合是空集，那么新集合为空集</p>
<p>不难得到，<span class="math inline">$\begin{align}|V_1\times
V_2\times\cdots\times V_n|=\prod_{1\le i\le
n}|V_i|\end{align}$</span></p>
<h2 id="映射函数">映射函数</h2>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Discrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 常微分方程</title>
    <url>/blogs/2024/04/20/calculus-diff-equation/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="微分方程">微分方程</h1>
<h2 id="概述">概述</h2>
<p>称<span
class="math inline">$\begin{align}f(x)+f_0(x)g_0(y)+...+f_n(x)g_n(y^{(n)})=0\end{align}$</span>为一个<span
class="math inline"><em>n</em></span>阶常微分方程，有如下概念：</p>
<ul>
<li>当所有<span
class="math inline"><em>g</em>(<em>y</em><sup>(<em>t</em>)</sup>) = <em>y</em><sup>(<em>t</em>)</sup></span>时，称其为<strong>线性微分方程</strong></li>
<li>当所有<span
class="math inline"><em>f</em><sub><em>t</em></sub>(<em>x</em>) = <em>C</em></span>时，称其为<strong>常系数微分方程</strong></li>
<li>当<span
class="math inline"><em>f</em>(<em>x</em>) = 0</span>时，称方程<strong>齐次</strong></li>
<li>称含相互独立的、一共<span
class="math inline"><em>n</em></span>个<span
class="math inline"><em>C</em></span>的解为<strong>通解</strong>，由特定条件(称其为定解条件)求出<span
class="math inline"><em>C</em></span>的值的解为特解，含有<span
class="math inline"><em>C</em></span>的解为<strong>隐式通解</strong>(也称通积分)</li>
<li>称通解的图形为积分曲线族，特解的图形为积分曲线</li>
</ul>
<h2 id="初等积分法">初等积分法</h2>
<h3 id="分离变量法">分离变量法</h3>
<p>称<span
class="math inline">$\begin{align}\frac{dy}{dx}=h(x)g(y)\end{align}$</span>为一阶可分离变量方程，求解过程：</p>
<ul>
<li>分离变量：将<span
class="math inline"><em>x</em>、<em>y</em></span>相关分别分为左右两部分，由于相除过程中<span
class="math inline"><em>g</em>(<em>y</em>)</span>不能等于<span
class="math inline">0</span>，所以需判断<span
class="math inline"><em>g</em>(<em>y</em>) = 0</span>是否为它的特解</li>
<li>两边积分，得到隐式通解</li>
<li>如遇到<span
class="math inline"><em>f</em>(<em>x</em>、<em>y</em>)</span>，应先换元得到<span
class="math inline">$\begin{align}\frac{du}{dx}=h(x)g(u)\end{align}$</span></li>
</ul>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;求y'=\sin^2{(x-y+1)}的通解\\&amp;解:\\&amp;令u=x-y+1.\
得\frac{du}{dx}=1-y'\\&amp;\therefore
1-\frac{du}{dx}=\sin^2u\\&amp;\therefore\frac{du}{\cos^2u}=dx\\&amp;\therefore
\tan u=\tan(x-y+1)=x+C\end{align}$</span></p>
<hr />
<p><strong>eg2:</strong></p>
<p><span class="math inline">$\begin{align}&amp;求解初值问题:\cos
ydx+(1+e^{-x})\sin ydy=0,y(0)=\frac\pi4\\&amp;解:\\&amp;整理得\tan
ydy=-\frac{dx}{1+e^{-x}}\\&amp;积分得\ln|\cos
y|=\ln(e^{-x}+1)+C_1\\&amp;\therefore |\cos
y|=(e^{-x}+1)e^{C_1}\\&amp;\therefore C\cos y=e^{-x}+1,\ (C=\pm
\frac{1}{e^{C_1}})\\&amp;故该初值问题的解为2\sqrt2\cos
y=e^{-x}+1\end{align}$</span></p>
<hr />
<p><strong>eg3:</strong></p>
<p><span class="math inline">$\begin{align}&amp;已知\int_0^1f(\alpha
x)d\alpha=\frac12f(x)+1,\ 且f'(x)存在,\ 求f(x).\\&amp;解:\\&amp;令\alpha
x=u,\ 得\frac1x\int_0^xf(u)du=\frac12f(x)+1\\&amp;\therefore
\frac12xf(x)+x=\int_0^xf(u)du\\&amp;\therefore
\frac12\big(f(x)+2+xf'(x)\big)=f(x)\\&amp;\therefore
f'(x)=\frac{f(x)-2}x\\&amp;\therefore f(x)=Cx+2\end{align}$</span></p>
<h3 id="常数变易法">常数变易法</h3>
<p>教材先讲的不完整的线性方程的求法，实际上就是<a
href="#线性方程">常系数线性方程</a></p>
<p>一阶齐次线性方程也是一个一阶可分离变量方程，对于一阶非齐次线性方程，即<span
class="math inline">$\begin{align}\frac{dy}{dx}+f(x)y=g(x)\end{align}$</span>，由于所有<strong>非齐次线性方程的通解等于与其对应的齐次线性方程通解加上它的一个特解</strong>，所以首先也得求齐次通解，求解步骤为：</p>
<ul>
<li>求对应一阶<strong>齐次</strong>线性方程的通解，得到<span
class="math inline"><em>y</em> = <em>C</em><em>h</em>(<em>x</em>)</span></li>
<li>视<span class="math inline"><em>C</em></span>为<span
class="math inline"><em>u</em>(<em>x</em>)</span>，两边求导得到<span
class="math inline">$\begin{align}\frac{dy}{dx}\end{align}$</span></li>
<li>把<span class="math inline"><em>y</em></span>和<span
class="math inline">$\begin{align}\frac{dy}{dx}\end{align}$</span>代入原方程，得到<span
class="math inline"><em>u</em>′(<em>x</em>)</span>后积分得到<span
class="math inline"><em>u</em>(<em>x</em>)</span>，注意不定积分后的<span
class="math inline"><em>u</em>(<em>x</em>)</span>含<span
class="math inline"><em>C</em></span>，得到答案应检查是否含<span
class="math inline"><em>C</em></span></li>
</ul>
<p>由推导得<span
class="math inline"><em>u</em>(<em>x</em>)</span>会被消掉，所以将二、三步合为一步：</p>
<ul>
<li>令<span
class="math inline"><em>u</em>′(<em>x</em>)<em>h</em>(<em>x</em>) = <em>g</em>(<em>x</em>)</span>，积分求出<span
class="math inline"><em>u</em>(<em>x</em>)</span>，即<span
class="math inline"><em>C</em></span>，得到齐次通解</li>
</ul>
<p>只需要整理成<span
class="math inline">$\begin{align}\frac{dy}{dx}\end{align}$</span>系数为<span
class="math inline">1</span>的形式，就可以快速得到答案</p>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;已知连续函数f(x)满足f(x)=\int_0^{3x}f(\frac
t3)dt+e^{2x},\ 求f(x).\\&amp;解:\\&amp;\int_0^{3x}f(\frac
t3)dt=3\int_0^xf(u)du\\&amp;两边求导得,\
f'(x)=3f(x)+2e^{2x}\\&amp;先求对应齐次方程通解,\ 当f'(x)=3f(x)时,\
\ln\Big|f(x)\Big|=3x+C_0\\&amp;\therefore f(x)=C_1e^{3x},\
令C_1=u(x)\\&amp;\therefore u'(x)·e^{3x}=2e^{2x}\\&amp;\therefore
u(x)=-2e^{-x}+C,\ f(x)=(-2e^{-x}+C)e^{3x}\\&amp;由于f(0)=1,\ \therefore
f(x)=3e^{3x}-2e^{2x}\end{align}$</span></p>
<p>这道题是<strong>隐含了特解</strong>的</p>
<h3 id="伯努利方程">伯努利方程</h3>
<p>称形如<span
class="math inline">$\begin{align}\frac{dy}{dx}+f(x)y=g(x)y^n,\ (n\ne
0,\ 1)\end{align}$</span>的微分方程为伯努利方程，求解步骤如下：</p>
<ul>
<li>两边除以<span
class="math inline"><em>y</em><sup><em>n</em></sup></span>，得<span
class="math inline"><em>y</em><sup>−<em>n</em></sup><em>y</em>′ + <em>f</em>(<em>x</em>)<em>y</em><sup>1 − <em>n</em></sup> = <em>g</em>(<em>x</em>)</span>，因为<span
class="math inline">(1−<em>n</em>)<em>y</em><sup>−<em>n</em></sup><em>y</em>′ = (<em>y</em><sup>1 − <em>n</em></sup>)′</span>，故令<span
class="math inline"><em>u</em>(<em>x</em>) = <em>y</em><sup>1 − <em>n</em></sup></span></li>
<li><span class="math inline">$\begin{align}\frac{u'}{1-n}+f(x)u=g(x),\
u=y^{1-n}\end{align}$</span></li>
<li>视为一阶线性方程求解</li>
<li>将<span class="math inline"><em>u</em></span>替换为<span
class="math inline"><em>y</em><sup>1 − <em>n</em></sup></span></li>
</ul>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;求微分方程3(1+x^2)y'+2xy=2xy^4的通解.\\&amp;解:\\&amp;令u=y^{-3},\
得-(1+x^2)u'+2xu=2x\\&amp;\because (1+x^2)u'=2xu的通解为:\\&amp;\ln
u=\ln(1+x^2)+C_0\\&amp;即u=C_1(1+x^2)\\&amp;令C_1=v(x),\
得v'(x)(1+x^2)=-2x(1+x^2)^{-1}\\&amp;\therefore v(x)=\frac{1}{1+x^2}+C,\
y^{-3}=(C+\frac{1}{1+x^2})(1+x^2)\end{align}$</span></p>
<h3 id="齐次微分方程">齐次微分方程</h3>
<p>当<span
class="math inline"><em>x</em>、<em>y</em></span>次数相吻合，即<span
class="math inline">$\begin{align}y'=f(\frac
yx)\end{align}$</span>时：</p>
<ul>
<li>令<span class="math inline">$\begin{align}u(x)=\frac
yx\end{align}$</span>，则<span
class="math inline"><em>y</em>′ = (<em>u</em><em>x</em>)′ = <em>u</em>′<em>x</em> + <em>u</em> = <em>f</em>(<em>u</em>)</span>，即<span
class="math inline"><em>u</em>′<em>x</em> = <em>g</em>(<em>u</em>)</span></li>
<li>通过分离变量法求解</li>
<li>将<span class="math inline"><em>u</em></span>替换为<span
class="math inline">$\begin{align}\frac yx\end{align}$</span></li>
</ul>
<h3 id="化为齐次微分方程">化为齐次微分方程</h3>
<p>对于形如<span
class="math inline">$\begin{align}\frac{dy}{dx}=f\Big(\frac{a_1x+b_1y+c_1}{a_2x+b_2y+c_2}\Big)\end{align}$</span>的方程：</p>
<ul>
<li>若<span
class="math inline"><em>c</em><sub>1</sub> = <em>c</em><sub>2</sub> = 0</span>，则显然可以上下同除<span
class="math inline"><em>x</em></span>，构造齐次</li>
<li>否则，对<span
class="math inline">$\begin{cases}a_1x+b_1y+c_1=0\\a_2x+b_2y+c_2=0\end{cases}$</span>进行求解，如果有解，设<span
class="math inline"><em>X</em> = <em>x</em> − <em>x</em><sub>0</sub>, <em>Y</em> = <em>y</em> − <em>y</em><sub>0</sub></span>，构造齐次</li>
<li>如果无解，即<span
class="math inline">$\left|\begin{matrix}a_1&amp;b_1\\a_2&amp;b_2\end{matrix}\right|=0$</span>时，令<span
class="math inline">$\begin{align}\lambda=\frac{a_1}{a_2}=\frac{b_1}{b_2},\
u=a_2x+b_2y\end{align}$</span>，构造可分离变量方程<span
class="math inline">$\begin{align}y'=\Big(\frac{du}{dx}-a_2\Big)\frac1{b_2}=f\Big(\frac{ku+c_1}{u+c_2}\Big)\end{align}$</span></li>
</ul>
<h3 id="可降阶的高阶微分方程">可降阶的高阶微分方程</h3>
<p>假设关于<span
class="math inline"><em>y</em>(<em>x</em>)</span>的微分方程：</p>
<ul>
<li>若<span
class="math inline"><em>y</em><sup>(<em>n</em>)</sup> = <em>f</em>(<em>x</em>)</span>，逐层积分即可</li>
<li>若<span
class="math inline"><em>y</em>″ = <em>f</em>(<em>x</em>,<em>y</em>′)</span>，即<strong>含有<span
class="math inline"><em>x</em></span>，但不含<span
class="math inline"><em>y</em></span></strong>，可令<span
class="math inline"><em>y</em>′ = <em>u</em>(<em>x</em>)、<em>y</em>″ = <em>u</em>′(<em>x</em>)</span>，代入后求出<span
class="math inline"><em>u</em>(<em>x</em>)</span>，积分后为<span
class="math inline"><em>y</em>(<em>x</em>)</span></li>
<li>若<span
class="math inline"><em>y</em>″ = <em>f</em>(<em>y</em>,<em>y</em>′)</span>，即<strong>含有<span
class="math inline"><em>y</em></span>，但不含<span
class="math inline"><em>x</em></span></strong>，可令<span
class="math inline">$\begin{align}y'=u(y)、y''=\frac{du}{dx}=u'y'=u'·u\end{align}$</span>，代入后求出<span
class="math inline">$\begin{align}u(y)\end{align}$</span>，再通过<span
class="math inline"><em>y</em>′ = <em>u</em>(<em>y</em>)</span>和<strong>分离变量法</strong>求解即可</li>
<li>若<strong>既不含<span
class="math inline"><em>x</em></span>，也不含<span
class="math inline"><em>y</em></span></strong>，则上述两种方法均可，但令<span
class="math inline"><em>y</em>′ = <em>u</em>(<em>x</em>)</span>更快捷</li>
</ul>
<h3 id="一些技巧">一些技巧</h3>
<ul>
<li>常规方法求解时，一定先将<span
class="math inline">$\begin{align}\frac{dy}{dx}\end{align}$</span>整理出来</li>
<li>将<span class="math inline"><em>x</em></span>视为<span
class="math inline"><em>y</em></span>，<span
class="math inline"><em>y</em></span>视为<span
class="math inline"><em>x</em></span>，可能变成可以求解的一阶线性方程。当整理式子发现<span
class="math inline">$y'=\frac{单项式}{多项式}$</span>时，可以考虑化为<span
class="math inline"><em>x</em>′(<em>y</em>)</span></li>
<li>记住一些常见导数，将整体化为<span
class="math inline"><em>u</em>(<em>x</em>)</span>：
<ul>
<li><span
class="math inline"><em>x</em><em>y</em>′ + <em>y</em> = (<em>x</em><em>y</em>)′</span></li>
<li><span class="math inline">$\begin{align}\frac{y-xy'}{y^2}=(\frac
xy)'\end{align}$</span></li>
</ul></li>
</ul>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;求微分方程(x-2xy-y^2)\frac{dy}{dx}+y^2=0的通解.\\&amp;解:\\&amp;\frac{dx}{dy}=\frac{y^2+2xy-x}{y^2}=1+x\frac{2y-1}{y^2}\\&amp;若\frac{dx}{dy}=x\frac{2y-1}{y^2},\
则\frac{dx}x=\frac{2y-1}{y^2}dy\\&amp;\therefore \ln|x|=\ln
y^2+\frac1y+C_0\\&amp;\therefore x=C_1y^2e^{\Large\frac1y},\
令C_1=u(y)\\&amp;得u'(y)·y^2e^{\Large\frac1y}=1\\&amp;\therefore
u(y)=e^{\Large-\frac1y}+C\\&amp;\therefore x=y^2+Cy^2e^{\Large
\frac1y}\end{align}$</span></p>
<h2 id="高阶线性微分方程">高阶线性微分方程</h2>
<h3 id="常系数齐次方程">常系数齐次方程<a id="线性方程"></a></h3>
<p>对于齐次线性微分方程，它的特解会是<span
class="math inline"><em>e</em><sup><em>λ</em><em>x</em></sup></span>的形式，故对于<span
class="math inline"><em>A</em><sub>0</sub><em>y</em><sup>(<em>n</em>)</sup> + <em>A</em><sub>1</sub><em>y</em><sup>(<em>n</em>−1)</sup> + … + <em>A</em><sub><em>n</em></sub><em>y</em> = 0</span>，它的特征方程为：</p>
<ul>
<li><span
class="math inline"><em>A</em><sub>0</sub><em>λ</em><sup><em>n</em></sup> + <em>A</em><sub>1</sub><em>y</em><sup><em>n</em> − 1</sup> + … + <em>A</em><sub><em>n</em></sub> = 0</span>，求出<span
class="math inline"><em>λ</em></span>即得到它的一个特解</li>
<li>得出<span
class="math inline"><em>λ</em><sub><em>n</em></sub></span>为一重根：通解为<span
class="math inline"><em>y</em> = <em>C</em><sub>1</sub><em>e</em><sup><em>λ</em><sub>1</sub><em>x</em></sup> + <em>C</em><sub>2</sub><em>e</em><sup><em>λ</em><sub>2</sub><em>x</em></sup> + … + <em>C</em><sub><em>n</em></sub><em>e</em><sup><em>λ</em><sub><em>n</em></sub><em>x</em></sup></span></li>
<li>得出<span
class="math inline"><em>λ</em><sub>*</sub></span>为二重根：通解为<span
class="math inline"><em>y</em> = (<em>C</em><sub>1</sub>+<em>C</em><sub>2</sub><em>x</em>)<em>e</em><sup><em>λ</em><sub>*</sub><em>x</em></sup> + ...</span></li>
<li>得出<span class="math inline"><em>λ</em><sub>*</sub></span>为<span
class="math inline"><em>k</em></span>重根：通解为<span
class="math inline"><em>y</em> = (<em>C</em><sub>1</sub>+<em>C</em><sub>2</sub><em>x</em>+<em>C</em><sub>3</sub><em>x</em><sup>2</sup>+…+<em>C</em><sub><em>k</em></sub><em>x</em><sup><em>k</em> − 1</sup>)<em>e</em><sup><em>λ</em><sub>*</sub><em>x</em></sup></span></li>
<li>根据欧拉公式<span
class="math inline"><em>e</em><sup><em>i</em><em>x</em></sup> = cos <em>x</em> + <em>i</em>sin <em>x</em></span>，得出<span
class="math inline"><em>λ</em><sub>*</sub></span>为一对共轭复根<span
class="math inline"><em>α</em> ± <em>β</em><em>x</em></span>：通解为<span
class="math inline"><em>y</em> = <em>e</em><sup><em>α</em><em>x</em></sup>(<em>C</em><sub>1</sub>cos<em>β</em><em>x</em>+<em>C</em><sub>2</sub>sin<em>β</em><em>x</em>)</span></li>
<li>得出<span
class="math inline"><em>λ</em><sub>*</sub></span>为一对共轭复根各<span
class="math inline"><em>k</em></span>重<span
class="math inline"> ± <em>α</em> ± <em>β</em><em>x</em></span>：通解为<span
class="math inline"><em>y</em> = <em>e</em><sup><em>α</em><em>x</em></sup>((<em>C</em><sub>1</sub>+<em>C</em><sub>2</sub><em>x</em>+…+<em>C</em><sub><em>k</em></sub><em>x</em><sup><em>k</em> − 1</sup>)cos <em>β</em><em>x</em> + (<em>C</em><sub>1</sub>′+<em>C</em><sub>2</sub>′<em>x</em>+…+<em>C</em><sub><em>k</em></sub>′<em>x</em><sup><em>k</em> − 1</sup>)sin <em>β</em><em>x</em>)</span></li>
</ul>
<h3 id="常系数非齐次方程">常系数非齐次方程</h3>
<p>对于一个右边为单项式的非齐次线性微分方程，需要先求出它对应齐次微分方程的通解，再根据特征根求出原方程的一个特解(假设<span
class="math inline"><em>P</em><sub><em>m</em></sub>(<em>x</em>)</span>为系数确定的一元<span
class="math inline"><em>m</em></span>次线性函数，<span
class="math inline"><em>Q</em><sub><em>m</em></sub>(<em>x</em>)</span>为系数待定的一元<span
class="math inline"><em>m</em></span>次线性函数)：</p>
<ul>
<li>右式为<span
class="math inline"><em>e</em><sup><em>α</em><em>x</em></sup><em>P</em><sub><em>m</em></sub>(<em>x</em>)</span>形式，如果<span
class="math inline"><em>α</em></span>是<span
class="math inline"><em>k</em></span>重特征根，则特解形式为：<span
class="math inline"><em>x</em><sup><em>k</em></sup><em>e</em><sup><em>α</em><em>x</em></sup><em>Q</em><sub><em>m</em></sub>(<em>x</em>)</span></li>
<li>右式为<span
class="math inline"><em>e</em><sup><em>α</em><em>x</em></sup>(<em>P</em><sub><em>m</em><sub>1</sub></sub>(<em>x</em>)cos <em>β</em><em>x</em> + <em>P</em><sub><em>m</em><sub>2</sub></sub>(<em>x</em>)sin <em>β</em><em>x</em>)</span>形式，如果<span
class="math inline"><em>α</em> + <em>β</em><em>x</em></span>是<span
class="math inline"><em>k</em></span>重特征根，则特解形式为：<span
class="math inline"><em>x</em><sup><em>k</em></sup><em>e</em><sup><em>α</em><em>x</em></sup>(<em>Q</em><sub><em>m</em></sub>(<em>x</em>)cos <em>β</em><em>x</em> + <em>Q</em><sub><em>m</em></sub>′(<em>x</em>)sin <em>β</em><em>x</em>)</span>，其中<span
class="math inline"><em>m</em> = max (<em>m</em><sub>1</sub>, <em>m</em><sub>2</sub>)</span></li>
</ul>
<p>求出形式后，代入原方程求解待定的系数即可</p>
<p>对于多项式，可以拆分成多个单项式方程的特解之和求解</p>
<h3 id="欧拉方程">欧拉方程</h3>
<p>形如<span
class="math inline"><em>A</em><sub>1</sub><em>x</em><sup><em>n</em></sup><em>y</em><sup>(<em>n</em>)</sup> + <em>A</em><sub>2</sub><em>x</em><sup><em>n</em> − 1</sup><em>y</em><sup>(<em>n</em>−1)</sup> + … + <em>A</em><sub><em>n</em></sub><em>x</em><em>y</em>′ + <em>A</em><sub><em>n</em> + 1</sub><em>y</em> = <em>f</em>(<em>x</em>)</span>的方程称为欧拉方程</p>
<ul>
<li>令<span
class="math inline"><em>t</em> = ln <em>x</em></span>，导数算子<span
class="math inline">$\begin{align}D(y)=\frac{dy}{dt}\end{align}$</span>，得到<span
class="math inline">$\begin{align}&amp;xy'=D(y)=y'(t)、x^2y''=D(D-1)(y)=y''(t)-y'(t)、\dots、\\&amp;x^ny^{(n)}=D(D-1)(D-2)\dots(D-n+1)(y)\end{align}$</span></li>
<li>代入方程得到的是关于<span
class="math inline"><em>y</em>(<em>t</em>)</span>的微分方程</li>
</ul>
<h3 id="解结构降阶法">解结构降阶法</h3>
<p>对解的结构的应用，类似于线性代数中线性方程组的解，以下所指非齐次解均指同一个非齐次线性方程的解、齐次解均指该非齐次线性方程对应的齐次线性方程的解：</p>
<ul>
<li>齐次解+齐次解=齐次解</li>
<li>非齐次解+齐次解=非齐次解</li>
<li>非齐次解-非齐次解=齐次解</li>
<li>已知齐次通解<span
class="math inline"><em>y</em></span>，则非齐次通解为<span
class="math inline"><em>y</em> + <em>y</em><sup>*</sup></span>，其中<span
class="math inline"><em>y</em><sup>*</sup></span>为非齐次特解</li>
<li>假设一个关于<span
class="math inline"><em>y</em>(<em>x</em>)</span>的<strong>齐次线性</strong>微分方程，且<strong>已知一个特解</strong><span
class="math inline"><em>y</em><sup>*</sup></span>，则<span
class="math inline"><em>C</em><em>y</em><sup>*</sup></span>也是解，视<span
class="math inline"><em>C</em></span>为<span
class="math inline"><em>u</em>(<em>x</em>)</span>，代入原方程解出<span
class="math inline"><em>u</em>(<em>x</em>)</span>即可得到通解，需注意解出的<span
class="math inline"><em>u</em>(<em>x</em>)</span>含<span
class="math inline"><em>C</em></span></li>
</ul>
<p>降阶在于，代入原方程后<span
class="math inline"><em>u</em>(<em>x</em>)</span>会被消掉，只剩<span
class="math inline"><em>u</em><sup>(<em>n</em>)</sup>(<em>x</em>)</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学: 数理逻辑</title>
    <url>/blogs/2024/04/19/discreteMath-mathamatic-logic/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="数理逻辑">数理逻辑</h1>
<h2 id="命题逻辑">命题逻辑</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>命题：只有真、假两种状态的陈述语句，在命题逻辑里，原子命题不提供任何除真假以外的信息，这也导致命题逻辑的局限性</li>
<li>逻辑等价(<span
class="math inline"><em>p</em> ≡ <em>q</em></span>)：表示<strong><span
class="math inline"><em>p</em></span>等价于<span
class="math inline"><em>q</em></span></strong>，即有相同的真值表</li>
<li>否定(<span
class="math inline">¬<em>p</em></span>)：表示<strong><span
class="math inline"><em>p</em></span>的否定</strong></li>
<li>析取(<span
class="math inline"><em>p</em> ∨ <em>q</em></span>)：表示<strong><span
class="math inline"><em>p</em></span>或者<span
class="math inline"><em>q</em></span></strong></li>
<li>合取(<span
class="math inline"><em>p</em> ∧ <em>q</em></span>)：表示<strong><span
class="math inline"><em>p</em></span>并且<span
class="math inline"><em>q</em></span></strong></li>
<li>异或(<span
class="math inline"><em>p</em> ⊕ <em>q</em></span>)：表示<strong><span
class="math inline"><em>p</em></span>异或<span
class="math inline"><em>q</em></span></strong></li>
<li>条件(<span
class="math inline"><em>p</em> → <em>q</em></span>)：表示<strong>若<span
class="math inline"><em>p</em></span>，则<span
class="math inline"><em>q</em></span></strong>
<ul>
<li>从定义上看，只有当<span
class="math inline"><em>p</em> = <em>T</em> ∧ <em>q</em> = <em>F</em></span>时违反了语句，故其它情况均<strong>人为定义为<span
class="math inline"><em>T</em></span></strong></li>
</ul></li>
<li>双条件(<span
class="math inline"><em>p</em> ↔︎ <em>q</em></span>)：表示<strong><span
class="math inline"><em>p</em></span>当且仅当<span
class="math inline"><em>q</em></span></strong>，与<span
class="math inline"><em>p</em> ⊙ <em>q</em></span>等价
<ul>
<li>若<span
class="math inline"><em>p</em> ↔︎ <em>q</em></span>为<strong>永真式</strong>，称<span
class="math inline"><em>p</em> ≡ <em>q</em></span>或<span
class="math inline"><em>p</em> ⇔ <em>q</em></span></li>
</ul></li>
<li>对条件语句<span class="math inline"><em>p</em> → <em>q</em></span>：
<ul>
<li><strong>反命题</strong>：<span
class="math inline">¬<em>p</em> → ¬<em>q</em></span>，即对输入取反，真值表上下颠倒</li>
<li><strong>逆命题</strong>：<span
class="math inline"><em>q</em> → <em>p</em></span>，真值表上下颠倒</li>
<li><strong>逆否命题</strong>：<span
class="math inline">¬<em>q</em> → ¬<em>p</em></span>，和原命题<strong>等价</strong></li>
</ul></li>
<li>优先级：<span
class="math inline">¬ &gt;  ∧  &gt;  ∨  &gt;  →  &gt; ↔︎</span></li>
</ul>
<h3 id="与其它逻辑系统的对应">与其它逻辑系统的对应</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 32%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">命题逻辑</th>
<th style="text-align: center;">逻辑代数</th>
<th style="text-align: center;">位运算符</th>
<th style="text-align: center;">集合论</th>
<th style="text-align: center;">自然语言描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">¬<em>p</em></span></td>
<td style="text-align: center;"><span
class="math inline"><em>p̄</em></span></td>
<td style="text-align: center;"><span class="math inline">$\rm
NOT$</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">否定/取反</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">∨</span></td>
<td style="text-align: center;"><span class="math inline">+</span></td>
<td style="text-align: center;"><span class="math inline">$\rm
OR$</span></td>
<td style="text-align: center;"><span class="math inline">∪</span></td>
<td style="text-align: center;">析取/或/逻辑和/并</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">∧</span></td>
<td style="text-align: center;"><span class="math inline">·</span></td>
<td style="text-align: center;"><span class="math inline">$\rm
AND$</span></td>
<td style="text-align: center;"><span class="math inline">∩</span></td>
<td style="text-align: center;">合取/与/逻辑积/交</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline"><em>p</em> → <em>q</em></span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline"><em>p</em></span>蕴涵<span
class="math inline"><em>q</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline"><em>p</em> ⇒ <em>q</em></span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline"><em>p</em></span>永真蕴涵<span
class="math inline"><em>q</em></span>/<span
class="math inline"><em>p</em></span>是<span
class="math inline"><em>q</em></span>的充分条件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline"><em>p</em> ↔︎ <em>q</em></span></td>
<td style="text-align: center;"><span class="math inline">⊙</span></td>
<td style="text-align: center;"><span class="math inline">$\rm
XNOR$</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline"><em>p</em></span>当且仅当<span
class="math inline"><em>q</em></span>/<span
class="math inline"><em>p</em></span>同或<span
class="math inline"><em>q</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline"><em>p</em> ⇔ <em>q</em></span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline"><em>p</em></span>是<span
class="math inline"><em>q</em></span>的充要条件</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">|</span></td>
<td style="text-align: center;"><span class="math inline">$\rm
NAND$</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">与非</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">↓</span></td>
<td style="text-align: center;"><span class="math inline">$\rm
NOR$</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">或非</td>
</tr>
</tbody>
</table>
<h3 id="基本等价公式">基本等价公式</h3>
<ul>
<li>满足交换律、结合律、分配律</li>
<li><strong>德<span class="math inline">⋅</span>摩根律</strong>：
<ul>
<li><span
class="math inline">¬(<em>p</em>∧<em>q</em>) ≡ ¬<em>p</em> ∨ ¬<em>q</em></span></li>
<li><span
class="math inline">¬(<em>p</em>∨<em>q</em>) ≡ ¬<em>p</em> ∧ ¬<em>q</em></span></li>
</ul></li>
<li>支配律：<span
class="math inline"><em>p</em> ∨ <em>T</em> ≡ <em>T</em>、<em>p</em> ∧ <em>F</em> ≡ <em>F</em></span></li>
<li>自等律：<span
class="math inline"><em>p</em> ∨ <em>p</em> ≡ <em>p</em>、<em>p</em> ∧ <em>p</em> ≡ <em>p</em></span></li>
<li>恒等律：<span
class="math inline"><em>p</em> ∨ <em>F</em> ≡ <em>p</em>、<em>p</em> ∧ <em>T</em> ≡ <em>p</em></span></li>
<li>否定律：<span
class="math inline"><em>p</em> ∨ ¬<em>p</em> ≡ <em>T</em>、<em>p</em> ∧ ¬<em>p</em> ≡ <em>F</em></span></li>
<li><strong>吸收律</strong>：
<ul>
<li><span
class="math inline"><em>p</em> ∨ (<em>p</em>∧<em>q</em>) ≡ <em>p</em></span></li>
<li>由分配律，<span
class="math inline"><em>p</em> ∧ (<em>p</em>∨<em>q</em>) ≡ <em>p</em></span>，也即上式的对偶</li>
</ul></li>
<li><strong>消解律</strong>：
<ul>
<li><span
class="math inline">(<em>p</em>∧<em>q</em>) ∨ (¬<em>p</em>∧<em>r</em>) ≡ <em>q</em> ∧ <em>r</em></span></li>
<li>取对偶，<span
class="math inline">(<em>p</em>∨<em>q</em>) ∧ (<em>p</em>∨<em>r</em>) ≡ <em>q</em> ∨ <em>r</em></span></li>
</ul></li>
</ul>
<h3 id="条件命题的等价">条件命题的等价</h3>
<ul>
<li><span
class="math inline"><em>p</em> → <em>q</em> ≡ ¬<em>q</em> → ¬<em>p</em> ≡ ¬<em>p</em> ∨ <em>q</em></span></li>
<li><span
class="math inline">(<em>p</em>→<em>q</em>) ∧ (<em>p</em>→<em>r</em>) ≡ <em>p</em> → (<em>q</em>∧<em>r</em>)</span></li>
<li><span
class="math inline">(<em>p</em>→<em>r</em>) ∧ (<em>q</em>→<em>r</em>) ≡ (<em>p</em>∨<em>q</em>) → <em>r</em></span></li>
<li><span
class="math inline">(<em>p</em>→<em>q</em>) ∨ (<em>p</em>→<em>r</em>) ≡ <em>p</em> → (<em>q</em>∨<em>r</em>)</span></li>
<li><span
class="math inline">(<em>p</em>→<em>r</em>) ∨ (<em>q</em>→<em>r</em>) ≡ (<em>p</em>∧<em>q</em>) → <em>r</em></span></li>
</ul>
<h2 id="逻辑函数">逻辑函数</h2>
<h3 id="对偶规则">对偶规则</h3>
<ul>
<li>恒等式通常成对出现，称其为对偶，以<span
class="math inline"><em>F</em><sup><em>d</em></sup></span>表示<span
class="math inline"><em>F</em></span>的对偶函数，对一个恒等式两边取对偶不影响恒等性</li>
<li><span
class="math inline"><em>F</em><sup><em>d</em></sup> ≢ <em>F</em>(<em>一</em><em>般</em>)、(<em>F</em><sup><em>d</em></sup>)<sup><em>d</em></sup> ≡ <em>F</em></span></li>
<li>对偶函数由原函数<strong>交换逻辑与、逻辑或，交换<span
class="math inline">0</span>和<span
class="math inline">1</span>得到</strong></li>
</ul>
<h3 id="反演规则">反演规则</h3>
<ul>
<li>一个函数的反函数可以由原函数<strong>交换逻辑与、逻辑或，交换<span
class="math inline">0</span>和<span
class="math inline">1</span>，同时原变量变反变量、反变量变原变量</strong>而得，其中反变量特指单个变量上的非号，跨两个及以上变量的非号不能动</li>
<li>同样可借<span class="math inline"><em>F̄</em></span>来求<span
class="math inline"><em>F</em></span></li>
</ul>
<h2 id="谓词逻辑">谓词逻辑</h2>
<h3 id="命题逻辑的局限">命题逻辑的局限</h3>
<p>命题逻辑的最小单元是命题，所以命题逻辑无法表示那些不真不假的语句，因为它们没有指定变量的值</p>
<p>因此也无法从若干简单命题中得到新命题，例如亚里士多德三段论：</p>
<ul>
<li>三个原子命题：<span
class="math inline"><em>p</em>:</span>所有人都要死、<span
class="math inline"><em>q</em>:</span>苏格拉底是人、<span
class="math inline"><em>r</em>:</span>所以苏格拉底要死</li>
<li>根据逻辑推理，由<span class="math inline"><em>p</em></span>且<span
class="math inline"><em>q</em></span>一定可以得到<span
class="math inline"><em>r</em></span>，即要证明<span
class="math inline">(<em>p</em>∧<em>q</em>) ⇒ <em>r</em></span></li>
<li>尽管<span
class="math inline"><em>p</em> ∧ <em>q</em> = <em>T</em></span>，在命题逻辑的系统里，仍然可以把<span
class="math inline"><em>F</em></span><strong>指派</strong>给<span
class="math inline"><em>r</em></span></li>
<li>换句话说就是，给命题赋予真值的同时，也<strong>掩盖掉了具体的信息</strong>，你只知道<span
class="math inline"><em>p</em></span>是对的，<span
class="math inline"><em>q</em></span>是对的，然后无法得知任何其它信息，也就无法得知<span
class="math inline"><em>r</em></span>的真值</li>
<li>如果能变成假言三段论的形式，是可以通过命题逻辑表示的，但原子命题已经是最小的命题了</li>
</ul>
<p>谓词逻辑解决这样的事情：提取出命题中的信息，并提供一套符号用于产生新的、适用更广的命题</p>
<h3 id="谓词与量词">谓词与量词</h3>
<p>通过谓词可以从这些语句中生成命题，谓词逻辑允许对命题进行更细的划分</p>
<ul>
<li>个体：命题所描述的对象，约定用小写字母表示</li>
<li>谓词：命题赋予主体的属性或动作，约定用大写字母<span
class="math inline"><em>P</em>、<em>Q</em>、<em>R</em></span>表示</li>
<li>命题的谓词形式：由<strong>谓词</strong>和若干<strong>个体常元</strong>组合成<span
class="math inline"><em>P</em>(<em>a</em><sub>1</sub>,<em>a</em><sub>2</sub>,⋯,<em>a</em><sub><em>n</em></sub>)</span>的形式
<ul>
<li>称<span
class="math inline"><em>P</em>(<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,⋯,<em>x</em><sub><em>n</em></sub>)</span>为一个<span
class="math inline"><em>n</em></span>元谓词，其中<span
class="math inline"><em>x</em></span>为个体变元，称它能够表示的所有个体的集合为它的个体域</li>
</ul></li>
<li>量词：通过量词来限定个体域在谓词中的不确定性，例如<strong><em>所有、至少</em></strong>等
<ul>
<li>全称量词<span
class="math inline">(∀<em>x</em>)</span>：表达<strong>所有</strong></li>
<li>存在量词<span class="math inline">$(\exist
x)$</span>：表达<strong>存在</strong></li>
<li>存在唯一量词<span class="math inline">$(\exist\ !\
x)$</span>：表达<strong>存在唯一</strong></li>
<li>后接谓词<span
class="math inline"><em>P</em>(<em>x</em>)</span>表示该量词的辖域</li>
</ul></li>
</ul>
<h3 id="谓词逻辑公式">谓词逻辑公式</h3>
<ul>
<li>德<span class="math inline">·</span>摩根律：
<ul>
<li><span class="math inline">$\neg(\exist x)P(x)\equiv (\forall x)\neg
P(x)$</span></li>
<li><span class="math inline">$\neg (\forall x)P(x)\equiv(\exist x)\neg
P(x)$</span></li>
</ul></li>
<li>量词的辖域扩张：
<ul>
<li><span
class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>) ∨ <em>Q</em> ≡ (∀<em>x</em>)(<em>P</em>(<em>x</em>)∨<em>Q</em>)</span>，其中<span
class="math inline"><em>Q</em></span><strong>不含变元</strong></li>
<li>同理，将析取换为合取、将全称量词换位存在量词也成立</li>
<li><span class="math inline">$(\forall x)(P(x)\rightarrow
Q)\equiv(\exist x)P(x)\rightarrow Q$</span>，将<span
class="math inline">∀</span>和<span
class="math inline">$\exist$</span>互换同理
<ul>
<li>证明：左式<span class="math inline">$=(\forall x)(\neg P(x)\vee
Q)=(\forall x)\neg P(x)\vee Q=\neg(\exist x)P(x)\vee Q=$</span>右式</li>
</ul></li>
<li><span
class="math inline">(∀<em>x</em>)(<em>Q</em>→<em>P</em>(<em>x</em>)) ≡ <em>Q</em> → (∀<em>x</em>)<em>P</em>(<em>x</em>)</span>，将<span
class="math inline">∀</span>换成<span
class="math inline">$\exist$</span>同理</li>
</ul></li>
<li>量词的分配律：
<ul>
<li><span class="math inline">∀<em>x</em></span>对<span
class="math inline">∧</span>、<span class="math inline">$\exist
x$</span>对<span class="math inline">∨</span>满足分配律</li>
<li><span class="math inline">∀<em>x</em></span>对<span
class="math inline">∨</span>、<span class="math inline">$\exist
x$</span>对<span
class="math inline">∧</span><strong>不满足</strong>分配律，只满足<span
class="math inline">$(\forall x)P(x)\vee (\forall
x)Q(x)\Rightarrow(\forall x)(P(x)\vee Q(x))\\(\exist x)(P(x)\wedge
Q(x))\Rightarrow(\exist x)P(x)\wedge (\exist x)Q(x)$</span></li>
</ul></li>
<li>永真蕴涵式：<span class="math inline">$(\exist
x)P(x)\rightarrow(\forall x)Q(x)\Rightarrow(\forall x)(P(x)\rightarrow
Q(x))\Rightarrow (\forall x)P(x)\rightarrow(\forall x)Q(x)$</span></li>
</ul>
<h3 id="嵌套量词">嵌套量词</h3>
<ul>
<li>嵌套量词的顺序：
<ul>
<li><span class="math inline">$(\forall x)(\forall y)\equiv (\forall
y)(\forall x)\\(\exist x)(\exist y)\equiv (\exist y)(\exist
x)$</span></li>
<li><span class="math inline">$(\forall x)(\forall y)\Rightarrow(\exist
x)(\forall y)\Rightarrow(\forall y)(\exist x)\Rightarrow(\exist
x)(\exist y)\\(\forall x)(\forall y)\Rightarrow(\exist y)(\forall
x)\Rightarrow(\forall x)(\exist y)\Rightarrow(\exist x)(\exist
y)$</span></li>
</ul></li>
<li>嵌套量词的否定：
<ul>
<li>层层套用德<span class="math inline">·</span>摩根律，结果为<span
class="math inline">∀</span>和<span
class="math inline">$\exist$</span>互换，非号在最里层，例如：</li>
<li><span class="math inline">$\neg(\forall x)(\exist
y)P(x,y)\equiv(\exist x)(\forall y)\neg P(x,y)$</span></li>
</ul></li>
</ul>
<h2 id="推理规则">推理规则</h2>
<h3 id="命题逻辑规则">命题逻辑规则</h3>
<ul>
<li><span class="math inline"><em>P</em></span>：引入一个前件</li>
<li><span class="math inline"><em>T</em></span>：引用公式<span
class="math inline"><em>S</em></span></li>
<li><span class="math inline"><em>C</em><em>P</em></span>：<span
class="math inline"><em>P</em> ∧ <em>Q</em> → <em>R</em> ≡ <em>P</em> → (<em>Q</em>→<em>R</em>)</span></li>
<li>假言推理：表示为永真式<span
class="math inline">(<em>p</em>∧(<em>p</em>→<em>q</em>)) → <em>q</em></span></li>
<li>假言三段论：由一个大条件和一个小条件可得出，表示为永真式<span
class="math inline">((<em>p</em>→<em>q</em>)∧(<em>q</em>→<em>r</em>)) → (<em>p</em>→<em>r</em>)</span></li>
<li>利用永真式化简命题，其实就是在使用规则<span
class="math inline"><em>T</em></span></li>
</ul>
<h3 id="谓词逻辑规则">谓词逻辑规则</h3>
<ul>
<li>谓词逻辑是命题逻辑的推广，同样可使用命题逻辑的推理规则</li>
<li>全称特指<span class="math inline">$(\rm US)$</span>：<span
class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>) ⇒ <em>P</em>(<em>y</em>)</span></li>
<li>存在特指<span class="math inline">$(\rm ES)$</span>：<span
class="math inline">$(\exist x)P(x)\Rightarrow P(a)$</span></li>
<li>存在推广<span class="math inline">$(\rm EG)$</span>：<span
class="math inline">$P(y)\Rightarrow(\exist x)P(x)$</span>，<span
class="math inline"><em>y</em></span>属于<span
class="math inline"><em>x</em></span>的个体域</li>
<li>全称推广<span class="math inline">$(\rm UG)$</span>：<span
class="math inline"><em>P</em>(<em>y</em>) ⇒ (∀<em>x</em>)<em>P</em>(<em>x</em>)</span>，<span
class="math inline"><em>x</em></span>属于<span
class="math inline"><em>y</em></span>的个体域</li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Discrete Math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 级数练习题</title>
    <url>/blogs/2024/04/17/calculus-series-exercise/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="级数练习">级数练习</h1>
<h2 id="求常数项级数敛散性">求常数项级数敛散性</h2>
<ul>
<li>对所有收敛的常数项级数，<span
class="math inline"><em>u</em><sub><em>n</em></sub></span>严格不为<span
class="math inline">0</span></li>
<li>在此基础上，尝试对<span
class="math inline">|<em>u</em><sub><em>n</em></sub>|</span>进行<strong>比值判别法</strong>或<strong>根值判别法</strong>
<ul>
<li>均为<span class="math inline"><em>ρ</em> &lt; 1</span>收敛、<span
class="math inline"><em>ρ</em> &gt; 1</span>发散、<span
class="math inline"><em>ρ</em> = 1</span>未定</li>
<li>当出现<strong>阶乘、双阶乘、多项式乘积、<span
class="math inline"><em>n</em></span>次方</strong>等时考虑比值判别法</li>
<li>当出现<strong><span
class="math inline"><em>n</em><sup><em>α</em></sup></span>次方、多项式的幂次方</strong>时考虑根值判别法</li>
<li><span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}\sqrt[n]n=1\end{align}、\sqrt[n]{1+n}=e$</span>，两者均<strong>单调递减</strong></li>
<li>若为<strong>交错级数</strong>，通过这两种方法判断出来一定是<strong>绝对收敛或发散</strong></li>
</ul></li>
<li>在上述基础上，考虑与它相似的函数，根据比较判别法的极限形式进行判断(敛散性相同)
<ul>
<li>常用比较有：<strong><span
class="math inline"><em>p</em></span>级数、等比级数、三角<span
class="math inline"> → 1</span>、积分<span
class="math inline">→</span>可求积分、含参<span
class="math inline">→</span>常数</strong></li>
<li>放缩还可以：移项、拆项<span class="math inline">...</span></li>
<li><span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}\sqrt[A]{n^A+Bn^C}\sim
n,(A,B,C为常数,A&gt;C)\end{align}$</span></li>
</ul></li>
<li>若为交错级数，考虑<strong>莱布尼兹判别法</strong>
<ul>
<li><span
class="math inline">|<em>u</em><sub><em>n</em></sub>|</span>单调递减且趋于<span
class="math inline">0</span></li>
</ul></li>
<li>上述方案需要复习<a
href="......\大一上\工数上\md%5B工数上%5D\PDF%5B工数上%5D\极限%5B工数上%5D.pdf"><strong>极限</strong></a>，在此基础上，根据<strong>直接求<span
class="math inline"><em>S</em><sub><em>n</em></sub></span>极限</strong>或<strong>单调有界收敛原理</strong>考虑<span
class="math inline"><em>S</em><sub><em>n</em></sub></span>的敛散性</li>
<li>在上述基础上，考虑<strong>柯西收敛原理</strong>
<ul>
<li>尝试让<span
class="math inline">|<em>S</em><sub><em>n</em> + <em>p</em></sub>−<em>S</em><sub><em>n</em></sub>| &lt; <em>f</em>(<em>n</em>)</span>，且<span
class="math inline"><em>f</em>(<em>n</em>)</span>足够小，则<span
class="math inline"><em>ϵ</em> = <em>f</em>(<em>N</em>)、<em>n</em> &gt; <em>N</em></span>时级数收敛</li>
</ul></li>
<li>常见级数敛散性：
<ul>
<li><span class="math inline"><em>p</em></span>级数：<span
class="math inline"><em>p</em> &gt; 1</span>收敛，否则发散</li>
<li><span class="math inline">$\begin{align}u_n=\frac1{n^p(\ln
n)^q}\end{align}$</span>：<span
class="math inline">$\begin{matrix}p&lt;1,&amp;发散\\p&gt;1,&amp;收敛\\p=1,q\le1,&amp;发散\\p=1,q&gt;1,&amp;收敛\end{matrix}$</span></li>
</ul></li>
</ul>
<h2 id="常数项级数的一般性结论">常数项级数的一般性结论</h2>
<ul>
<li>利用<strong>收敛<span class="math inline">±</span>收敛<span
class="math inline">=</span>收敛</strong>、<strong>收敛<span
class="math inline">±</span>发散<span
class="math inline">=</span>发散</strong>、<strong>发散<span
class="math inline">±</span>发散<span
class="math inline">=</span>未定</strong>的性质</li>
<li>若一般项趋于<span
class="math inline">0</span>，则添加无限括号与去除无限括号后级数敛散性相同；若未强调一般项，则收敛级数不可随意去掉无限括号、发散级数不可随意添加无限括号</li>
<li>利用<strong>基本不等式</strong>进行放缩</li>
<li>根据第一条性质，在收敛级数的一般项上加上例如<span
class="math inline">$\begin{align}\frac{1}{n}\end{align}$</span>的发散级数一般项，从而使原级数发散</li>
</ul>
<h2 id="求幂级数和函数">求幂级数和函数</h2>
<p>求解<span class="math inline"><em>R</em></span>的方法：</p>
<ul>
<li>若不缺项，<span
class="math inline">$\begin{align}&amp;R=\lim_{n\rightarrow\infty}\Bigg|\frac{u_n}{u_{n+1}}\Bigg|\end{align}$</span></li>
<li>若缺项，可尝试换元，使其不缺项</li>
<li>若无法换元，可用根值判别法，将<span
class="math inline"><em>x</em></span>视为常数，再判断范围</li>
<li>得到<strong>收敛区间</strong>后，分别判断两个端点值，求出<strong>收敛域</strong></li>
<li>若第一项或若干项为<span
class="math inline">0</span>，可进行移位以便看出和函数</li>
</ul>
<p>对一个幂级数，首先要求其收敛域，才能求和函数</p>
<p>一般通过逐项定积分或求导，化为最简的<span
class="math inline">$\begin{align}&amp;\sum_{n=0}^\infty
x^n\end{align}$</span>的形式，利用它的<span
class="math inline">$\begin{align}S(x)=\frac{1}{1-x}\end{align}$</span>来求解；有时也会借助其它的麦克劳林级数判断</p>
<p>注意在抽取出<span
class="math inline"><em>x</em><sup><em>α</em></sup></span>后，<span
class="math inline"><em>s</em>(<em>x</em>)</span>定义域可能改变，需要分别讨论</p>
<h2 id="求函数的幂级数展开">求函数的幂级数展开</h2>
<ul>
<li>记住常见的麦克劳林级数：
<ul>
<li><span
class="math inline">$\begin{align}&amp;\frac1{1-x}=\sum_{n=0}^\infty
x^n,&amp;x\in(-1,1)\\&amp;\frac1{1+x}=\sum_{n=0}^\infty(-1)^nx^n,&amp;x\in(-1,1)\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}&amp;e^x=\sum_{n=0}^\infty\frac{x^n}{n!},&amp;x\in
R\\&amp;\ln
(1+x)=\sum_{n=1}^\infty\frac{(-1)^{n+1}x^n}{n},&amp;x\in(-1,1]\end{align}$</span></li>
<li><span class="math inline">$\begin{align}&amp;\sin
x=\sum_{n=1}^\infty\frac{(-1)^{n+1}x^{2n-1}}{(2n-1)!},&amp;x\in
R\\&amp;\cos x=\sum_{n=0}^\infty\frac{(-1)^nx^{2n}}{(2n)!},&amp;x\in
R\\&amp;\arctan
x=\int_0^x\frac1{1+x^2}dx+1,&amp;x\in[-1,1],(在两点分别判断收敛)\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}&amp;(1+x)^\alpha=1+\sum_{n=1}^\infty\frac{\alpha(\alpha-1)\dots(\alpha-n+1)x^n}{n!},&amp;R=1\\&amp;\frac1{\sqrt{1-x^2}}=1+\sum_{n=1}^\infty(-1)^n\frac{(2n-1)!!·x^{2n}}{(2n)!!},&amp;x\in(-1,1)\\&amp;\frac1{\sqrt{1+x^2}}=1+\sum_{n=1}^\infty\frac{(2n-1)!!·x^{2n}}{(2n)!!},&amp;x\in[-1,1]\end{align}$</span></li>
</ul></li>
<li>判断展开后级数的收敛域：通过求<span
class="math inline"><em>R</em></span>和收敛区间，以及端点处分别判断，以及原函数的<strong>定义域</strong>来得出；这里的<span
class="math inline"><em>R</em></span>是对<span
class="math inline"><em>x</em></span>而言的，应注意处理换元后的<span
class="math inline"><em>R</em></span></li>
</ul>
<h2 id="傅里叶级数">傅里叶级数</h2>
<h3 id="求傅里叶级数的收敛">求傅里叶级数的收敛</h3>
<ul>
<li>根据<strong>狄利克雷收敛定理</strong>，一个周期函数可以展开成傅里叶级数形式，但该级数只有连续时才收敛于原函数</li>
<li>该级数<span
class="math inline">$=\begin{cases}f(x_0),&amp;x=x_0处连续\\\Large\frac{f(x_0^+)+f(x_0^-)}2\normalsize,&amp;x=x_0处为间断点\end{cases}$</span></li>
<li>应根据这一点来确定傅里叶级数的收敛域</li>
</ul>
<h3 id="求函数的傅里叶级数展开">求函数的傅里叶级数展开</h3>
<ul>
<li>周期完整的函数
<ul>
<li><span
class="math inline">$\begin{align}f(x)\sim\frac{a_0}2+\sum_{n=1}^\infty(a_n\cos\frac{n\pi}lx+b_n\sin\frac{n\pi}lx)\end{align}$</span></li>
<li><span class="math inline">$\begin{align}\begin{cases}\large
a_n=\frac1l\int_{-l}^lf(x)\cos\frac{n\pi}lxdx\\\large
b_n=\frac1l\int_{-l}^lf(x)\sin\frac{n\pi}lxdx\end{cases}\end{align}$</span></li>
<li>收敛域为原函数的所有连续点的集合</li>
<li>特别地，当函数为奇函数或偶函数时，只需要求<span
class="math inline"><em>b</em><sub><em>n</em></sub></span>或<span
class="math inline"><em>a</em><sub><em>n</em></sub></span>，且可将定积分的另一半提成<span
class="math inline">2</span></li>
</ul></li>
<li>周期不完整的函数
<ul>
<li>一般只要求展成余弦或正弦级数，只需偶延拓或奇延拓</li>
<li>注意展开后级数的<strong>收敛域</strong></li>
</ul></li>
</ul>
<h2 id="练习">练习</h2>
<hr />
<p><span
class="math inline">$\begin{align}&amp;1.证明\sum_{n=2}^\infty\frac1{n^p(\ln
n)^q}的敛散性.\\&amp;1).当q&lt;0时,u_n&gt;\frac1{n^p},若p\le1,则原级数发散\\&amp;2).当p&gt;1时,u_n\le\begin{cases}\frac1{n^{p+q}},&amp;q\le0,&amp;p&gt;1-q时收敛\\\frac1{n^p},&amp;q&gt;0,&amp;收敛\end{cases}\\&amp;故令p'+1&lt;p,由\lim_{n\rightarrow\infty}\frac1{n^{p'}(\ln
n)^q}=0&lt;1\\&amp;故u_n=\frac1{n^{p-p'}}·\frac1{n^{p'}(\ln
n)^q}&lt;\frac1{n^{p-p'}},原级数收敛.\\&amp;3).当p=1,q\ge0时,u_n非负连续递减,与对应反常积分敛散性相同.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;2.\sum_{n=2}^\infty\frac1{(\ln
n)^{\ln n}}\\&amp;[由已知得该级数收敛,则放大.]\\&amp;(\ln n)^{\ln
n}&gt;2^{\ln n},u_n&lt;\frac1{2^{\ln n}},故收敛.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;3.\sum_{n=1}^\infty\frac{n^{n-1}}{(2n^2+\ln
n+2)^{\frac{n+1}2}}\\&amp;[根值判别法.]\\&amp;\lim_{n\rightarrow\infty}\sqrt[n]{u_n}=\lim_{n\rightarrow\infty}\frac
n{\sqrt{2n^2+\ln n+2}}&lt;\lim_{n\rightarrow\infty}\frac
nn=1,故收敛.\end{align}$</span></p>
<hr />
<blockquote>
<p>交错级数优先考虑莱布尼兹判别法，但无法使用时，考虑<span
class="math inline"><em>S</em><sub><em>n</em></sub></span>的敛散性</p>
<p>由于有奇偶性的分别，此时应先考虑<span
class="math inline"><em>S</em><sub>2<em>n</em></sub></span>，再由<span
class="math inline"><em>u</em><sub><em>n</em></sub> → 0</span>推广到<span
class="math inline"><em>S</em><sub><em>n</em></sub></span>的敛散性</p>
</blockquote>
<p><span
class="math inline">$\begin{align}&amp;4.\sum_{n=2}^\infty\frac{(-1)^n}{[n+(-1)^n]^p},(p&gt;0)\\&amp;1).当p&gt;1时,|u_n|\sim\frac1{n^p},原级数绝对收敛.\\&amp;2).当p\le1时,|u_n|发散,而S_{2n}=(\frac1{3^p}-\frac1{2^p})+(\frac1{5^p}-\frac1{4^p})+\dots+(\frac1{(2n+1)^p}-\frac1{(2n)^p})\\&amp;每项都小于0,故\{S_{2n}\}单调递减.\\&amp;又S_{2n}=-\frac1{2^p}+(\frac1{3^p}-\frac1{4^p})+\dots+(\frac1{(2n-1)^p}-\frac1{(2n)^p})+\frac1{(2n+1)^p}&gt;-\frac1{2^p}\\&amp;故S_{2n}有下界,故\lim_{n\rightarrow\infty}S_{2n+1}=\lim_{n\rightarrow\infty}S_{2n}+\frac1{(2n+3)^p}=\lim_{n\rightarrow\infty}S_{2n}=S\\&amp;故此时原级数条件收敛.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;5.下列命题正确的是()\\&amp;A.若\sum_{n=1}^\infty
a_n收敛,则\sum_{n=1}^\infty\frac{(-1)^n}{\sqrt
n}a_n收敛&amp;a_n=\frac{(-1)^n}{\sqrt
n}\\&amp;B.若正项级数\sum_{n=1}^{\infty}a_n满足\frac{a_{n+1}}{a_n}&lt;1(n=1,2,...),则\sum_{n=1}^\infty
a_n收敛\\&amp;C.若\lim_{n\rightarrow\infty}\frac{a_n}{b_n}=1,则级数\sum_{n=1}^\infty
a_n与\sum_{n=1}^\infty b_n同敛散&amp;交错级数\\&amp;D.若a_n\le b_n\le
c_n(n\ge1),且\sum_{n=1}^\infty a_n和\sum_{n=1}^\infty
c_n都收敛,则\sum_{n=1}^\infty b_n收敛\end{align}$</span></p>
<ul>
<li>交错级数<strong>不可使用比较判别法的极限形式</strong>判断</li>
<li>类似夹逼定理，在两收敛级数中间的级数也收敛</li>
</ul>
<hr />
<p><span
class="math inline">$\begin{align}&amp;6.验证y(x)=\sum_{n=0}^\infty\frac{x^{3n}}{(3n)!}满足y''+y'+y=e^x,并求\sum_{n=0}^\infty\frac{x^{3n}}{(3n)!}的和函数\\&amp;对y(x)逐项求导即可验证.\\&amp;由\lambda^2+\lambda+1=0,解得\lambda_{1,2}=\frac{-1\pm\sqrt3i}2\\&amp;故齐次通解为y_1(x)=e^{-\frac12}(C_1\cos\frac{\sqrt3}2x+C_2\sin\frac{\sqrt3}2x)\\&amp;设特解形式为y^*(x)=Ae^x,则A=\frac13\\&amp;由于y(x)在x=0处展开,故求此处的特解,将x=0代入\\&amp;y(x)=y_1(x)+y^*(x)得y(0)=1=C_1+\frac13,y'(0)=0=-\frac{C_1}2+\frac{\sqrt3}2C_2+\frac13\\&amp;\therefore
y(x)=e^{-\frac12}(\frac23\cos\frac{\sqrt3}2x)+\frac13e^x\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;7.若a_n条件收敛,求幂级数\sum_{n=1}^\infty
a_n(x-1)^n的收敛域.\\&amp;解:\\&amp;由a_n条件收敛,得幂级数R=1,收敛区间为(0,2)\\&amp;当x=0时,原级数发散;当x=2时,原级数收敛\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;8.幂级数\sum_{n=0}^\infty\frac{2n+1}{n!}x^n,求收敛域、和函数.\\&amp;解:\\&amp;易得收敛域为(-\infty,+\infty)\\&amp;设和函数为S(x),则S(x)=2s(x)-e^x,\\&amp;s(x)=\sum_{n=0}^\infty\frac{(n+1)x^n}{n!},\\&amp;\int_0^xs(x)dx=xe^x,s(x)=(x+1)e^x\\&amp;故S(x)=(2x+1)e^x,x\in(-\infty,+\infty)\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;9.求\sum_{n=0}^\infty\frac{(n+1)^2}{n!}.\\&amp;解:\\&amp;设S(x)=\sum_{n=0}^\infty\frac{(n+1)^2}{n!}x^n,则\int_0^xS(x)-1=\sum_{n=0}^\infty\frac{n+1}{n!}x^{n+1}=(x^2+x)e^x\\&amp;故S(x)=(x^2+3x+1)e^x,\therefore
S(1)=5e\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 级数</title>
    <url>/blogs/2024/04/14/calculus-series/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="无穷级数">无穷级数</h1>
<h2 id="常数项级数">常数项级数</h2>
<h3 id="定义">定义</h3>
<p>无穷多个数相加，记为<span
class="math inline">$\begin{align}\sum_{n=1}^\infty
u_n\end{align}$</span>，称为常数项无穷级数，又称常数项级数或级数</p>
<h3 id="部分和数列">部分和数列</h3>
<p>令<span
class="math inline">$\begin{align}S_n=\sum_{k=1}^nu_k(n=1,2,...)\end{align}$</span>，我们说，当<span
class="math inline"><em>n</em> → ∞</span>时，<span
class="math inline">$\begin{align}S_n\approx\sum_{n=1}^\infty
u_n\end{align}$</span></p>
<h3 id="敛散性">敛散性</h3>
<p>当<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}S_n=S\end{align}$</span>，且<span
class="math inline"><em>S</em></span>为一个有限值时，称<span
class="math inline">$\begin{align}\sum_{n=1}^\infty
u_n\end{align}$</span>收敛，且称<span
class="math inline"><em>S</em></span>为它的和，否则称它发散</p>
<p>对于敛散性问题，我们将它转换成<strong>求<span
class="math inline"><em>S</em><sub><em>n</em></sub></span>通项</strong>，再判断极限是否存在的问题</p>
<h3 id="常见级数">常见级数</h3>
<ul>
<li><strong>调和级数</strong>：<span
class="math inline">$\begin{align}\sum_{n=1}^\infty
\frac1n\end{align}$</span>发散
<ul>
<li><span
class="math inline">$\begin{align}&amp;证明:u_n=\frac1n=\int_n^{n+1}\frac1ndx&gt;\int_n^{n+1}\frac1xdx\\&amp;\therefore
S_n&gt;\int_1^{n+1}\frac1xdx=\ln
x\Bigg|_1^{+\infty}=+\infty\\&amp;\therefore\sum_{n=1}^\infty
\frac1n发散 \end{align}$</span></li>
</ul></li>
<li>p级数(超调和级数)：<span
class="math inline">$\begin{align}\sum_{n=1}^\infty\frac1{n^p}\end{align}$</span>当<span
class="math inline"><em>p</em> ≤ 1</span>时发散，当<span
class="math inline"><em>p</em> &gt; 1</span>时收敛
<ul>
<li><span
class="math inline">$\begin{align}&amp;证明:u_n=\frac1{n^p}=\int_n^{n+1}\frac1{n^p}dx&gt;\int_n^{n+1}\frac1{x^p}dx\\&amp;u_n=\frac1{n^p}=\int_{n-1}^{n}\frac1{n^p}dx&lt;\int_{n-1}^{n}\frac1{x^p}dx\\&amp;\therefore
S_n&gt;\int_1^{n+1}\frac1{x^p}dx，S_n&lt;\int_0^n\frac1{x^p}dx\\&amp;1)当p=1时，为调和级数，已证明为发散\\&amp;2)当p&lt;1时，S_n&gt;\frac1{1-p}x^{1-p}\Bigg|_1^{+\infty}，易得p&lt;1时发散\\&amp;3)当p&gt;1时，S_n&lt;\frac1{1-p}x^{1-p}\Bigg|_1^{+\infty}，易得p&gt;1时收敛\end{align}$</span></li>
</ul></li>
<li><span
class="math inline">$\begin{align}\sum_{n=2}^\infty\frac1{n^p(\ln
x)^q}\end{align}$</span>当<span
class="math inline"><em>p</em> &lt; 1</span>时发散；当<span
class="math inline"><em>p</em> &gt; 1</span>时收敛；当<span
class="math inline"><em>p</em> = 1</span>时，<span
class="math inline">$\begin{cases}发散,&amp;q\le1\\收敛,&amp;q&gt;1\end{cases}$</span></li>
</ul>
<h3 id="级数的性质">级数的性质</h3>
<ul>
<li>一个级数乘以一个实数不改变其敛散性</li>
<li>两收敛级数相加减得到的级数仍收敛，且<span
class="math inline"><em>S</em> = <em>S</em><sub>1</sub> ± <em>S</em><sub>2</sub></span></li>
<li>改变级数的<strong>有限个</strong>项，级数的敛散性不变</li>
<li>若用括号将级数(S1)的部分项合并为一项，将得到的级数称为S2，若S1收敛则S2仍收敛，若S2发散则S1必发散</li>
<li><span class="math inline">$\begin{align}\sum_{n=1}^\infty
u_n收敛\Rightarrow\lim_{n\rightarrow\infty}u_n=0，反之不成立(例如调和级数);\
\lim_{n\rightarrow\infty}u_n\ne0\Rightarrow\sum_{n=1}^\infty
u_n发散\end{align}$</span></li>
</ul>
<h3 id="正项级数的比较判别法">正项级数的比较判别法</h3>
<h4 id="一般形式">一般形式</h4>
<p>对于正项级数，<span
class="math inline">{<em>S</em><sub><em>n</em></sub>}</span>本身是单调递增的，根据单调有界收敛原理，若<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}S_n\end{align}$</span>存在，则该级数收敛</p>
<p>正项级数的比较判别法与无穷区间上反常积分的比较判别法类似： <span
class="math display">$$
\begin{align}若存在N\in N^+,当n\ge N时0&lt;u_n\le
v_n,若\sum_{n=1}^\infty u_n发散,则\sum_{n=1}^\infty
v_n发散;若\sum_{n=1}^\infty v_n收敛,则\sum_{n=1}^\infty
u_n收敛\end{align}
$$</span>
在用比较判别法判断时，应强调一般项的正负和用于比较的标准级数</p>
<p>标准级数一般为p级数、等比级数等</p>
<h4 id="极限形式">极限形式</h4>
<p><span class="math display">$$
\begin{align}&amp;\large若\lim_{n\rightarrow\infty}\frac{u_n}{v_n}=l(u_n、v_n&gt;0):\\&amp;\large1)若0&lt;l&lt;+\infty，则\sum_{n=1}^\infty
u_n和\sum_{n=1}^\infty
v_n的敛散性相同(此时k_1v_n&lt;u_n&lt;k_2v_n)\\&amp;\large2)若l=0，则说明u_n&lt;v_n，对应比较判别法\\&amp;\large3)若l=+\infty，则说明v_n&lt;u_n\end{align}
$$</span></p>
<h3 id="正项级数的比值判别法">正项级数的比值判别法</h3>
<p>比较判别法需要借助一个别的标准级数，而比值判别法由级数本身来确定它的敛散性
<span class="math display">$$
\begin{align}&amp;\large若\lim_{n\rightarrow\infty}\frac{u_{n+1}}{u_n}=\rho(u_n&gt;0):\\&amp;\large1)当\rho&lt;1时，级数收敛\\&amp;\large2)当\rho&gt;1或\rho=+\infty时，级数发散\end{align}
$$</span></p>
<h3 id="正项级数的根植判别法">正项级数的根植判别法</h3>
<p>也称柯西判别法，当一般项的外部带n次方时可以使用 <span
class="math display">$$
\begin{align}&amp;\large若\lim_{n\rightarrow\infty}\sqrt[n]{u_n}=\rho(u_n&gt;0):\\&amp;\large1)当\rho&lt;1时，级数收敛\\&amp;\large2)当\rho&gt;1或\rho=+\infty时，级数发散\end{align}
$$</span></p>
<h3 id="正项级数的积分判别法">正项级数的积分判别法</h3>
<p>上述的调和级数和p级数敛散性问题借用反常积分转换为了反常函数判别法的问题，对于正项级数，如果它的一般项<strong>单调递减</strong>，则它与<span
class="math inline">$\begin{align}\int_1^{+\infty}u(x)dx\end{align}$</span>的敛散性相同</p>
<h3 id="交错级数的莱布尼茨判别法">交错级数的莱布尼茨判别法</h3>
<p>交错级数，即各项正负相间的级数，表现为<span
class="math inline">$\begin{align}\sum_{n=1}^\infty(-1)^{n-1}u_n\end{align}$</span></p>
<p>若<span
class="math inline"><em>u</em><sub><em>n</em></sub></span>单调递减且<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}u_n=0\end{align}$</span>，则交错级数收敛</p>
<h3 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h3>
<p>对任意项级数，由其每一项的绝对值组成的新级数称为<strong>绝对值级数</strong>，如果它收敛，则原级数也收敛，这称为原级数<strong>绝对收敛</strong>。因此对于一个交错级数，既可以用莱布尼茨判别法，也可以用正项级数的判别法</p>
<p>但是，当绝对值级数发散时，不能断定原级数发散，而只能说明它不是绝对收敛。如果原级数收敛而绝对值级数发散，则称原级数<strong>条件收敛</strong>，例如<span
class="math inline">$\begin{align}\sum_{n=1}^\infty(-1)^{n-1}\frac1n\end{align}$</span></p>
<p>因为交错级数的部分和数列是小于它的绝对值级数的部分和数列的，这就很像比较判别法：大的收敛则小的也收敛；而大的发散，小的不一定发散</p>
<p>但是，由比值判别法或根值判别法得出绝对值级数发散的原级数也发散，这很好理解：由比值判别法得到<span
class="math inline"><em>u</em><sub><em>n</em></sub></span>单调递增，不符合莱布尼茨判别法的第一条件；由根值判别法得到<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}u_n=+\infty\end{align}$</span>，不符合莱布尼茨判别法的第二条件</p>
<p>-&gt;插曲：一个很有意思的事，欧拉证明欧拉公式时用到了泰勒级数的知识，被称为形式推导，没有考虑到<span
class="math inline"><em>e</em><sup><em>i</em><em>π</em></sup></span>展开后条件收敛的情况，这时调节项的位置有可能改变它的敛散性，这样证明是不严谨的</p>
<p><strong>黎曼重排定理</strong>：一个条件收敛的级数存在不同的排序方法，使其收敛于任意数(包括<span
class="math inline"> + ∞</span>)</p>
<p>证明：假设级数<span
class="math inline">$\begin{align}\sum_{n=1}^\infty
u_n\end{align}$</span><strong>条件收敛</strong>，由于<span
class="math inline">$\begin{align}\sum_{n=1}^\infty
|u_n|\end{align}$</span>发散，故必有<strong>发散</strong>的两个子级数<span
class="math inline">$\begin{align}\sum_{n=1}^\infty
a_n、\sum_{n=1}^\infty b_n\end{align}$</span>，其中<span
class="math inline"><em>a</em><sub><em>n</em></sub> &lt; 0, <em>b</em><sub><em>n</em></sub> &gt; 0</span>，由原级数条件收敛的性质，虽然它们发散，但<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}a_n=\lim_{n\rightarrow\infty}b_n=0\end{align}$</span></p>
<p>设想一个值S，它可以是有限值或无穷，从<span
class="math inline"><em>b</em><sub><em>n</em></sub></span>中取有限个项直至重排数列的和大于S，再从<span
class="math inline"><em>a</em><sub><em>n</em></sub></span>中取有限个项直至重排数列的和小于S，重复此操作直到<span
class="math inline"><em>a</em><sub><em>n</em></sub><em>与</em><em>b</em><sub><em>n</em></sub></span>剩下无穷个趋于0的项，这样，重排后的数列和将无限接近S</p>
<p>一个简单、不严谨的例子：级数<span
class="math inline">(1−1) + (1−1) + ...</span>收敛于0，取一个1放在开头，变成：<span
class="math inline">1 + (1−1) + (1−1) + ...</span>，则它收敛于1。这只是便于理解，但它是错误的，不能随意去掉收敛级数的括号或给发散级数添加无限个括号</p>
<h2 id="函数项级数">函数项级数</h2>
<h3 id="定义-1">定义</h3>
<p>所谓函数项级数，就是每一项都由一个函数组成的级数</p>
<p>如果在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>处形成的数项级数收敛，则称它为这个函数项级数的收敛点，否则称为发散点</p>
<p>所有收敛点的集合称为这个幂级数的收敛域</p>
<h3 id="幂级数">幂级数</h3>
<p>幂级数是最广泛的一类函数项级数，<span
class="math inline">$\begin{align}\sum_{n=0}^\infty
a_nx^n\end{align}$</span>称为<span
class="math inline"><em>x</em></span>的幂级数</p>
<h4 id="阿贝尔定理">阿贝尔定理</h4>
<p>若一个幂级数在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>处收敛，则它在<span
class="math inline">(−|<em>x</em><sub>0</sub>|, |<em>x</em><sub>0</sub>|)</span>上绝对收敛；如果在此处发散，则它在<span
class="math inline">(−∞, −|<em>x</em><sub>0</sub>|) ∪ (|<em>x</em><sub>0</sub>|, +∞)</span>上发散</p>
<p>幂级数只有三种情况：存在一个<span
class="math inline"><em>R</em></span></p>
<ul>
<li>如果<span
class="math inline">0 &lt; <em>R</em> &lt;  + ∞</span>，则幂级数在<span
class="math inline">(−<em>R</em>,<em>R</em>)</span>上绝对收敛，在<span
class="math inline">(−∞,−<em>R</em>) ∪ (<em>R</em>,+∞)</span>上发散</li>
<li>如果<span
class="math inline"><em>R</em> = 0</span>，则幂级数处处发散</li>
<li>如果<span
class="math inline"><em>R</em> =  + ∞</span>，则幂级数处处绝对收敛</li>
</ul>
<p>所以，收敛域一般是形如<span
class="math inline">(−<em>R</em>,<em>R</em>)</span>的区间，因此在<span
class="math inline"><em>x</em> =  ± <em>R</em></span>处需要额外判断敛散性</p>
<h4 id="收敛半径计算法">收敛半径计算法</h4>
<p><span
class="math inline"><em>R</em></span>的求法类似比值判别法，对于幂级数<span
class="math inline">$\begin{align}\sum_{n=0}^\infty
a_nx^n\end{align}$</span>的绝对值级数，假设有：</p>
<p><span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}\Bigg|\frac{a_{n+1}x^{n+1}}{a_nx^n}\Bigg|=\rho|x|,即\lim_{n\rightarrow\infty}\Bigg|\frac{a_{n+1}}{a_n}\Bigg|=\rho\end{align}$</span></p>
<p>则当<span
class="math inline"><em>ρ</em>|<em>x</em>| &lt; 1</span>，即<span
class="math inline">$\begin{align}|x|&lt;\frac1\rho\end{align}$</span>时，级数收敛，反之发散</p>
<p>因此：当<span class="math inline"><em>ρ</em> ≠ 0</span>时，<span
class="math inline">$\begin{align}R=\frac1\rho\end{align}$</span>；当<span
class="math inline"><em>ρ</em> = 0</span>时，<span
class="math inline"><em>R</em> =  + ∞</span>；当<span
class="math inline"><em>ρ</em> =  + ∞</span>时，<span
class="math inline"><em>R</em> = 0</span></p>
<p>所以，我们求<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}\Bigg|\frac{a_n}{a_{n+1}}\Bigg|\end{align}$</span>，对应的结果便是<span
class="math inline"><em>R</em></span></p>
<p>这个方法只适用于缺有限项或不缺项的幂级数，而类似<span
class="math inline">$\begin{align}\sum_{n=0}^\infty
a_nx^{2n}\end{align}$</span>这样缺无穷多项的级数应直接用比值判别法</p>
<p><strong>推论</strong>：形似<span
class="math inline">$\begin{align}\sum_{n=0}^\infty
a_nx^{kn}\end{align}$</span>的收敛半径为<span
class="math inline">$\sqrt[k]R$</span></p>
<h4 id="性质">性质</h4>
<ul>
<li>线性运算：两个幂级数相加减，收敛半径为<span
class="math inline"><em>R</em> = min (<em>R</em><sub>1</sub>,<em>R</em><sub>2</sub>)</span></li>
<li>乘法运算：两个幂级数相乘，收敛半径也为<span
class="math inline"><em>R</em></span></li>
<li>若<span class="math inline">$\begin{align}\sum_{n=0}^\infty
a_nx^n\end{align}$</span>收敛半径为<span
class="math inline"><em>R</em></span>，则<span
class="math inline">$\begin{align}\sum_{n=1}^\infty
na_nx^{n-1}、\sum_{n=2}^\infty
n(n-1)a_nx^{n-2}\end{align}$</span>和<span
class="math inline">$\begin{align}\sum_{n=0}^\infty
\frac{1}{n+1}a_nx^{n+1}\end{align}$</span>的收敛半径也为<span
class="math inline"><em>R</em></span></li>
<li>假设幂级数的和函数为<span
class="math inline"><em>S</em>(<em>x</em>)</span>，收敛半径为<span
class="math inline"><em>R</em></span>，则<span
class="math inline"><em>S</em>(<em>x</em>)</span>在<span
class="math inline">(−<em>R</em>,<em>R</em>)</span>上<strong>连续且可导且可积</strong>，且：
<ul>
<li><span class="math inline">$\begin{align}S'(x)=\sum_{n=1}^\infty
na_nx^{n-1}\end{align}$</span>，根据第三点，<span
class="math inline"><em>S</em>′(<em>x</em>)</span>对应的幂级数收敛半径也为<span
class="math inline"><em>R</em></span></li>
<li><span
class="math inline">$\begin{align}\int_0^xS(x)dx=\sum_{n=0}^\infty
\frac{1}{n+1}a_nx^{n+1}\end{align}$</span>，根据第三点，它对应的幂级数收敛半径也为<span
class="math inline"><em>R</em></span></li>
<li>求导或积分后对应的幂级数在<span
class="math inline"><em>x</em> = <em>R</em></span>上的敛散性可能变化</li>
</ul></li>
</ul>
<h4 id="泰勒级数">泰勒级数</h4>
<p>幂级数形式简单，有许多性质，而且可以把无法用初等函数表示的函数写成幂级数(例如一些函数的原函数)</p>
<p>把已知函数化为幂级数：</p>
<p>由<span
class="math inline"><em>f</em>(<em>x</em>)<em>在</em><em>x</em> = <em>x</em><sub>0</sub></span>处的泰勒展开<span
class="math inline">$\begin{align}f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...\end{align}$</span>，得<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>处的泰勒级数为<span
class="math inline">$\begin{align}f(x)=\sum_{n=0}^\infty
\frac{f^{(n)}(x_0)}{n!}{(x-x_0)}^n\end{align}$</span>，充要条件为<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub></span>处有任意阶导数且<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}(拉格朗日型余项)\end{align}$</span>趋于0</p>
<p>一般地，将<span
class="math inline"><em>f</em>(<em>x</em>)</span>展开为泰勒级数的步骤为：</p>
<ul>
<li>对<span
class="math inline"><em>f</em>(<em>x</em>)</span>高阶求导，得到幂级数</li>
<li>求幂级数的收敛域</li>
<li>证明<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}=0\end{align}$</span></li>
</ul>
<p>更好的方法为：记住常见的泰勒级数，对它们或<strong>求导</strong>，或<strong>积分</strong>，或<strong>换元</strong>来求所求函数的幂级数，例如要求<span
class="math inline"><em>g</em>(<em>x</em>) = <em>f</em>′(<em>x</em>) = cos <em>x</em></span>的级数，只需对<span
class="math inline"><em>f</em>(<em>x</em>) = sin <em>x</em></span>的泰勒级数逐项求导即可</p>
<p>常见的麦克劳林级数：</p>
<p><img src=".\calculus-series\麦克劳林级数.png" /></p>
<h3 id="傅里叶级数">傅里叶级数</h3>
<p><span
class="math inline">$\begin{align}f(x)=\frac{a_0}2+\sum_{n=1}^\infty(a_n\cos
nx+b_n\sin nx)\end{align}$</span></p>
<h4 id="狄利克雷收敛定理">狄利克雷收敛定理</h4>
<p>如果<span
class="math inline"><em>T</em><sub><em>f</em>(<em>x</em>)</sub> = 2<em>π</em></span>且<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<span
class="math inline">( − <em>π</em>, <em>π</em>]</span>上满足：</p>
<ul>
<li>连续或有有限个第一类间断点</li>
<li>有有限个单调区间</li>
</ul>
<p>则<span
class="math inline"><em>f</em>(<em>x</em>)</span>可展开为处处收敛的傅里叶级数且<span
class="math inline">$\begin{align}&amp;S(x)=\frac{a_0}2+\sum_{n=1}^\infty(a_n\cos
nx+b_n\sin nx)=\begin{cases}f(x),&amp;在x处连续\\\
\large\frac{\lim_{x\rightarrow x^-}f(x)+\lim_{x\rightarrow
x^+}f(x)}2,&amp;x为间断点\end{cases}\\&amp;a_0=\frac1\pi\int_{-\pi}^\pi
f(x)dx,\ a_n=\frac1\pi\int_{-\pi}^\pi f(x)\cos nxdx,\
b_n=\frac1\pi\int_{-\pi}^\pi f(x)\sin nxdx\end{align}$</span></p>
<h4 id="bf-t2l一般周期函数"><span class="math inline">$\bf
T=2l$</span>(一般周期)函数</h4>
<p><span
class="math inline">$\begin{align}&amp;f(x)\sim\frac{a_0}2+\sum_{n=1}^\infty(a_n\cos
\frac\pi lnx+b_n\sin \frac\pi lnx)\\&amp;a_0=\frac1l\int_{-l}^l f(x)dx,\
a_n=\frac1l\int_{-l}^l f(x)\cos \frac \pi lnxdx,\ b_n=\frac1l\int_{-l}^l
f(x)\sin \frac \pi lnxdx\end{align}$</span></p>
<p><strong>延拓</strong>：给一个只在有限区间上有定义的函数添加定义(如新定义它的周期)，从而拓广函数的定义域</p>
<p>在<span
class="math inline">[0,<em>l</em>]</span>上有定义的函数的傅里叶展开：在<span
class="math inline">[ − <em>l</em>, 0)</span>上添加定义即可，有两种：</p>
<ul>
<li>奇延拓：使其展成正弦级数，<span
class="math inline">$\begin{align}f(x)\sim \sum_{n=1}^\infty b_n\sin
\frac\pi lnx\end{align}$</span></li>
<li>偶延拓：使其展成余弦级数，<span
class="math inline">$\begin{align}f(x)\sim\frac{a_0}2+\sum_{n=1}^\infty
a_n\cos \frac\pi lnx\end{align}$</span></li>
</ul>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式: 使用regex进行模糊查询</title>
    <url>/blogs/2024/04/02/regex/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="regex"><code>Regex</code></h1>
<h2 id="基本介绍">基本介绍</h2>
<ul>
<li><code>Regex</code>全称<code>Regular Expression</code>，译为正则表达式或正规表达式</li>
<li><code>Regex</code>最常用于文本内容的模糊搜索，旨在使用一系列的语法规则高效地匹配任意文本</li>
<li>抽象定义如下：
<ul>
<li>字母表：由所有可能出现的字符组成的<strong>集合</strong></li>
<li>串：空串以及字符集中的字符的<strong>组合</strong></li>
<li>语言：串的集合</li>
<li>正则表达式：经过形式化描述的规则，文本内容(整个语言)经过给定的正则表达式得到匹配结果(语言的子集，称为正规集)</li>
</ul></li>
<li>正则表达式用一系列简洁的符号来表示语言(字符串集合)的运算：
<ul>
<li>语言的并(即两边集合的任意元素)：<code>(r) | (s)</code></li>
<li>语言的连接(即在左边集合的任意串后拼接右边集合的任意串)：<code>(r)(s)</code></li>
<li>语言的闭包(即集合中的串出现任意次地连接起来)：<code>(r)*</code></li>
<li>语言的正闭包(即集合中的串出现至少一次地连接起来)：<code>(r)+</code>
实际上是一个语法糖，等价于<code>(r)(r)*</code></li>
<li>语言与空串的并(语法糖)，表示集合中的串出现至多一次：<code>(r)?</code></li>
<li>运算的优先级：<code>* &gt; 连接 &gt; |</code></li>
</ul></li>
<li>在实现上，正则表达式拥有多套标准
<ul>
<li><code>POSIX</code>在制定类<code>Unix</code>操作系统的接口时顺带制定了<code>regex</code>的标准，<code>POSIX</code>标准又分为基础<code>BRE</code>与扩展<code>ERE</code>两种</li>
<li><code>Perl</code>语言经过多次迭代后由于其<code>regex</code>功能十分强大好用，出现了<code>PCRE</code>标准，可以说它是一套工业标准</li>
</ul></li>
</ul>
<h2 id="pcre"><code>PCRE</code></h2>
<ul>
<li><code>PCRE</code>全称<code>Perl Compatible Regular Expressions</code>，是用<code>C</code>编写的兼容<code>Perl</code>(一种不再流行的语言)正规式语法的正则表达式库
现在的大多数编程语言的正则表达式库属于<code>PCRE</code>派系，因此它也成为了一种标准</li>
</ul>
<h3 id="匹配分组环视">匹配、分组、环视</h3>
<ul>
<li>默认情况下，正则表达式会正向扫描，并将匹配成功的文本<strong>消耗掉</strong>，因此实现单遍扫描的效果
如果希望使用<strong>已经被扫描过</strong>的字符，可以由以下方法实现：</li>
<li>默认情况下，正则表达式会贪婪地消耗字符，例如面对<code>a.*a</code>这样的表达式，它不会遇到两个<code>a</code>就停止而是继续匹配直到遇到最后一个<code>a</code></li>
<li>分组：由元字符<code>()</code>括起，一个分组可以表示一个<strong>完整的正则表达式</strong>，分组有以下类型：
<ul>
<li>匿名捕获分组：类似<code>(exp)</code>的分组，它会消耗匹配的字符，同时存储它们，随后可用<code>\正整数</code>引用第<code>正整数</code>个分组的匹配结果
注意引用分组结果和完整的正则表达式不一样，它们等价于匹配的结果而不是正则表达式</li>
<li>非捕获分组：类似<code>(?:exp)</code>的分组，它会消耗匹配的字符，但不会存储它们</li>
<li>命名捕获分组：类似<code>(?P&lt;name&gt; exp)</code>的分组，在匿名捕获分组的基础上，它会将匹配结果赋给<code>name</code>，命名分组同时也会占用整数引用(相当于有两个名字)
定义命名捕获分组后，可以使用<code>(?P=&lt;name&gt;)</code>引用由<code>name</code>这个分组匹配到的字符串</li>
</ul></li>
<li>如果希望不消耗字符，即多遍扫描，可以使用环视，或者称为预查
预查是一种零宽度断言，会不消耗字符地检查后续(正向)、之前(反向)的文本是否存在能被<code>exp</code>匹配上的匹配项
这种行为通常用于条件判断，防止匹配过程中把检查项中间的文本也消耗掉了，导致中间的文本没有经过检查
肯定正向预查：类似<code>(?=exp)</code>的表达式
否定正向预查：类似<code>(?!exp)</code>的表达式，返回肯定正向预查的相反值
肯定反向预查：类似<code>(?&lt;=exp)</code>的表达式
否定反向预查：类似<code>(?&lt;!exp)</code>的表达式
这里的反向指的是在右边表达式的匹配项的位置上，从右到左查找
零宽度断言十分有用，例如当我们需要依据边界来获取内容，但又不希望匹配到边界字符本身的时候，使用预查十分有效</li>
</ul>
<h3 id="其它常用元字符">其它常用元字符</h3>
<ul>
<li>在实现上，此前所说的<code>*</code>、<code>+</code>、<code>?</code>等由于拥有额外的含义，因此自然地需要区分转义与非转义，这些字符称为<strong>元字符</strong>
元字符不一定是转义/非转义字符，例如<code>*</code>、<code>+</code>、<code>?</code>等不需要用<code>\</code>转义就能表达特殊含义，<code>b</code>、<code>z</code>等需要用<code>\</code>转义才能表达特殊含义</li>
<li><code>.</code>：匹配除<code>\n</code>外的任意字符</li>
<li>锚点字符：确定匹配位置，它们是零宽度的断言，仅匹配但<strong>不消耗字符</strong>，可以理解为匹配一个间隙
实际上它们算是一些语法糖，都可以用预查来表示
<code>^</code>：匹配<strong>一行</strong>的开始位置
<code>$</code>：匹配<strong>一行</strong>的结束位置
<code>\b</code>：匹配字母与非字母之间的位置
<code>\B</code>：匹配字母与字母之间的位置
<code>\G</code>：匹配上一次匹配结束的位置，用于链式搜索
<code>\A</code>、<code>\Z</code>、<code>\z</code>：匹配整个文件的开始、第一行结束、结束</li>
<li>量词字符：作用于前面的正则表达式，表示匹配的个数
<ul>
<li><code>*</code>：匹配任意次</li>
<li><code>?</code>：匹配至多一次</li>
<li><code>+</code>：匹配至少一次</li>
<li><code>{n}</code>：匹配恰好<code>n</code>次</li>
<li><code>{n, }</code>：匹配至少<code>n</code>次</li>
<li><code>{a, b}</code>：匹配至少<code>a</code>次、至多<code>b</code>次</li>
<li>惰性匹配：在上述量词后添加<code>?</code>，这个匹配项会尽可能少地匹配字符</li>
</ul></li>
<li>字符组：匹配集合内的<strong>单个</strong>字符
<ul>
<li><code>[]</code>：字符集合应由<code>[]</code>括住</li>
<li><code>-</code>：在字符集合里，如果被两个字符夹住，则<code>a-b</code>表示从<code>a</code>到<code>b</code>的连续字符
例如<code>[a-z]</code>表示匹配<strong>一个</strong><code>a</code>到<code>z</code>的字符</li>
<li><code>^</code>：若出现在<code>[]</code>内的开始位置，则表示反集，匹配不在集合内的单个字符
例如<code>[^a-z]</code>表示匹配一个不是<code>a</code>到<code>z</code>的字符</li>
<li>此外，还有一些元字符等价于常用的字符组(但可能部分语言不支持)：
<ul>
<li><code>\w</code>等价于<code>[a-zA-Z0-9]</code>，<code>\W</code>等价于<code>[^a-zA-Z0-9]</code></li>
<li><code>\s</code>等价于<code>[ \t\n\r]</code>，<code>\S</code>等价于<code>[^ \t\n\r]</code></li>
<li><code>\d</code>等价于<code>[0-9]</code>，<code>\D</code>等价于<code>[^0-9]</code></li>
</ul></li>
</ul></li>
<li><code>|</code>：用于分割不同的表达式，通常用法是由<code>()</code>包裹并随之使用量词来实现分支结合多次选择的效果
<code>|</code>的优先级是小于<code>()</code>的</li>
<li>关于转义：需要看被什么环境包裹
<ul>
<li>如果最外层为<code>()</code>，说明内部会被视为正常的完整的表达式，所有元字符是否转义的规则同上</li>
<li>如果除去最外层的所有<code>()</code>后剩下的最外层为<code>[]</code>，说明内部是字符类，大部分字符(包括元字符)不需要用<code>\</code>转义就能表示普通字符</li>
</ul></li>
</ul>
<h2 id="vim的regex"><code>Vim</code>的<code>Regex</code></h2>
<h2 id="sql的regex"><code>SQL</code>的<code>Regex</code></h2>
]]></content>
      <categories>
        <category>Tools &amp; Utilities</category>
        <category>3P tools</category>
        <category>regex</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>regex</tag>
        <tag>fuzzy search</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp STL: std::string</title>
    <url>/blogs/2024/03/14/cpp-string/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="string类"><code>string</code>类</h1>
<h2 id="ctors"><code>ctors</code></h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义:uint指size_type,即size_t,或许是unsigned int或unsigned long long</span></span><br><span class="line"><span class="built_in">string</span>();    <span class="comment">// 默认ctor,创建长度为0的对象</span></span><br><span class="line"><span class="built_in">string</span>(uint n,<span class="type">char</span> c); <span class="comment">// 创建内容为n个字符c构成的字符串的对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>*); <span class="comment">// 提供C风格字符串,创建内容为该字符串的对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>*,uint n);<span class="comment">// 提供C风格字符串和一个长度,创建内容为字符串前n个字符的对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp;); <span class="comment">// 复制构造函数,提供一个string对象,创建与该对象完全相同的新对象</span></span><br><span class="line"><span class="comment">// 创建内容为下标从idx开始数,一共n(默认为其长度)个字符的对象,即string(str,0)与string(str)等效</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp;,uint idx,uint n=npos);</span><br><span class="line"><span class="built_in">string</span>(It begin,It end);<span class="comment">// 提供begin,end两指针或两迭代器,创建内容为[begin,end)的对象</span></span><br><span class="line"><span class="built_in">string</span>(string&amp;&amp;);  <span class="comment">// 移动构造函数,可在临时对象将要析构而资源需要再利用时使用</span></span><br><span class="line"><span class="built_in">string</span>(initializer_list&lt;<span class="type">char</span>&gt;);<span class="comment">// 提供由单字符组成的列表,创建内容为它们整合而成的字符串的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="type">char</span> CStr[<span class="number">6</span>] = <span class="string">&quot;12345&quot;</span>; <span class="comment">// C风格字符串</span></span><br><span class="line">string A_str;   <span class="comment">// 默认ctor</span></span><br><span class="line"><span class="function">string <span class="title">B_str</span><span class="params">(<span class="string">&quot;12345&quot;</span>)</span></span>; <span class="comment">// string字符串</span></span><br><span class="line"><span class="function">string <span class="title">C_str</span><span class="params">(CStr)</span></span>;  <span class="function">string <span class="title">C_str</span><span class="params">(B_str)</span></span>;</span><br><span class="line"> <span class="comment">// 拆子串的方法</span></span><br><span class="line"><span class="function">string <span class="title">D_str</span><span class="params">(CStr,<span class="number">3</span>)</span> <span class="comment">// D_str==&quot;123&quot; 新对象字符数为3,内容为前3个字符</span></span></span><br><span class="line"><span class="function">string <span class="title">E_str</span><span class="params">(B_str,<span class="number">1</span>)</span></span>; <span class="comment">// E_str==&quot;2345&quot;新对象字符数为5(字符串长)-1,内容为下标1开始到结尾</span></span><br><span class="line"><span class="function">string <span class="title">F_str</span><span class="params">(B_str,<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">// F_str==&quot;23&quot;  新对象字符数为2,内容为下标1开始数,2个字符</span></span><br><span class="line"><span class="keyword">auto</span> it = B_str.<span class="built_in">begin</span>();<span class="comment">// type(it)==string::iterator</span></span><br><span class="line"><span class="function">string <span class="title">G_str</span><span class="params">(it,it<span class="number">+3</span>)</span></span>; <span class="comment">// G_str==&quot;123&quot; 新对象字符数等于it+3-it,内容为it开始数,3个字符</span></span><br></pre></td></tr></table></figure>
<p>与<code>C</code>风格字符串不同，<code>string</code>不带<code>'\0'</code>，在输入时也不需要考虑字符串的长度，<code>string</code>类会自动调整到刚刚好的空间，它所能容纳的长度为<code>string::npos=-1</code>(无符号整型的最大值)，在不同位数处理器下会有不同，可能是<code>unsigned long long</code>或<code>unsigned int</code>的最大值</p>
<p>这些构造函数使得需要创建子串对象时只需要知道起始点和子串字符数，就能很快算出参数</p>
<p>关于复制构造函数和移动构造函数的区别，以一个临时对象为例，假设还需要使用这个对象的内容，在被析构时，如果使用复制构造函数转移内容，需要：</p>
<ol type="1">
<li>申请新的堆内存</li>
<li>复制粘贴临时对象的内容</li>
<li>释放临时对象的堆内存</li>
</ol>
<p>而移动构造函数只需要将临时对象的堆内存转移给新对象，这个<code>ctor</code>通常由编译器自行选择使用，以优化性能，如果手动使用，需要注意它不保证<code>const</code>，可能造成问题</p>
<h2 id="方法">方法</h2>
<h3 id="重载运算符">重载运算符</h3>
<p>关于部分重载运算符如<code>=,+=,==,[],&lt;&lt;,&gt;&gt;</code>等，较容易理解，不赘述</p>
<p>关于比较运算符<code>&gt;,&lt;,&gt;=,&lt;=</code>，它们调用的方法类似<code>C</code>中的<code>strcmp()</code>，是比较字符的<code>ASCII</code>码大小而非长度</p>
<p><code>string</code>类没有定义<code>-=,-(),-(other)</code>运算符</p>
<p>需要注意用<code>[]</code>访问时，编译时不会抛出异常，即越界时有可能发生运行时错误</p>
<h3 id="遍历访问与转换">遍历访问与转换</h3>
<p>使用<code>[]</code>时，完全靠自己谨慎来保证不出错，而<code>string</code>类提供<code>at(int)</code>方法，在越界时，会抛出<code>out_of_range</code>异常，这意味着可以<code>try_catch</code>处理它而非立刻终止程序(这里的越界指的是提供的参数大于等于<code>size()</code>，因为<code>string</code>尾部不含<code>'\0'</code>)</p>
<p>关于<code>length()</code>和<code>size()</code>方法，它们功能一样，都<strong>返回总字符数</strong>，<code>size()</code>的出现是为了配合<code>STL</code>容器要求的统一名称</p>
<p>所有<code>STL</code>都提供便于遍历的类似指针的迭代器，通常用以下方法获取<code>string</code>迭代器：</p>
<ul>
<li><code>begin()</code>：返回指向<strong>开头字符</strong>的正向迭代器</li>
<li><code>end()</code>：返回指向<strong>结尾字符的下一个位置</strong>的正向迭代器</li>
<li><code>rbegin()</code>：返回指向<strong>结尾字符</strong>的<strong>反向</strong>迭代器(<code>reserve begin()</code>)</li>
<li><code>rend()</code>：返回指向<strong>开头字符的上一个位置</strong>的<strong>反向</strong>迭代器</li>
</ul>
<p>在这些方法前加上<code>'c'</code>(例如<code>cbegin()</code>)，将返回<strong>只读</strong>迭代器，用于处理<code>const</code>修饰的对象，但事实上，这四个方法都有对应的重载版本，当该对象被<code>const</code>修饰时，自动使用这个版本返回只读迭代器，所以这个<code>'c'</code>可加可不加</p>
<p>那么遍历变得很简单，而不需要用<code>[]</code>或<code>at()</code>访问字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>();it != str.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>std</code>中，<code>transform()</code>方法能够快速遍历<code>STL</code>容器并应用所提供的函数或函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义:InIt指InputIterator,OutIt指OutputIterator</span></span><br><span class="line"><span class="comment">// 提供一元函数将[Ibegin,Iend)范围内元素都通过所提供的op,并存储在从Obegin开始的对象里</span></span><br><span class="line"><span class="built_in">transform</span>(InIt Ibegin,InIt Iend,OutIt Obegin,UnaryOperation);</span><br><span class="line"><span class="comment">// 提供二元函数将[Ibegin_1,Iend)和[Ibegin_2,Iend)范围内元素通过op,存储在从Obegin开始的对象里</span></span><br><span class="line"><span class="built_in">transform</span>(InIt Ibegin_1,InIt Iend,InIt Ibegin_2,OutIt Obegin,BinaryOperation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">transform</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),a.<span class="built_in">begin</span>(),::toupper);<span class="comment">// 将a的所有小写字母都变成大写,存到a里</span></span><br></pre></td></tr></table></figure>
<h3 id="增删改查">增删改查</h3>
<ul>
<li><p><strong><code>insert()</code></strong>：用于前插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in">insert</span>(uint idx,string&amp;); <span class="comment">// 将提供的string插到str[idx]前</span></span><br><span class="line"><span class="built_in">insert</span>(uint idx,<span class="type">const</span> <span class="type">char</span>*);<span class="comment">// 提供C风格字符串,会删除\0</span></span><br><span class="line"><span class="comment">// 提供string引用,将它从下标idx_2开始数n个字符的子串插到str[idx_1]前</span></span><br><span class="line"><span class="comment">// (经测试,虽然没有char*的函数重载,但传入char*是可行的)</span></span><br><span class="line"><span class="built_in">insert</span>(uint idx_1,string&amp;,uint idx_2,uint n);</span><br><span class="line"><span class="comment">// 相当于上一条中,idx_2=0</span></span><br><span class="line"><span class="built_in">insert</span>(uint idx,<span class="type">const</span> <span class="type">char</span>*,uint n);<span class="comment">// 提供string&amp;是不行的</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>append()</code>：用于后插入，完全可以被<code>operator+()</code>和<code>insert()</code>替代</p></li>
<li><p><strong><code>erase()</code></strong>：删除某字符，自动调整空间</p></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>C/Cpp</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>Cpp STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux: 文件系统</title>
    <url>/blogs/2024/03/12/linux-file/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="bash-shell命令"><code>Bash Shell</code>命令</h1>
<p><code>Bash Shell</code>是大多数<code>Linux</code>发行版的默认<code>shell</code>，对于绝大多数命令都可以通过<code>man</code>命令查看详细用法和选项</p>
<h2 id="root用户"><code>root</code>用户</h2>
<p>区别于<code>Windows</code>系统的<code>Administrator</code>用户和更复杂的权限机制，在<code>Linux</code>中，<code>root</code>(超级管理员用户)具有最高的权限，可以调度系统的所有东西，结构上十分简单，但使用时更需慎重</p>
<p>默认情况下，<code>root</code>用户是锁定的，如果需要暂时使用<code>root</code>的权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">cat</span> /etc/sudoers  <span class="comment"># 查看被允许使用sudo命令的用户,只有root权限可查看</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">visudo     <span class="comment"># 修改/etc/sudoers文件,只有root权限可修改</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">visudo -c     <span class="comment"># 检查/etc/sudoers文件,每次修改后都应运行这条命令</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> [<span class="built_in">command</span>]   <span class="comment"># root权限运行命令,首次使用需输入当前用户密码</span></span></span><br><span class="line">sudo options:</span><br><span class="line">  -i      # 暂时切换到root用户</span><br><span class="line">  -l      # 查看当前权限</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su user     <span class="comment"># 切换用户,除非是root用户,否则需输入对方用户的密码,</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span>      <span class="comment"># 退出当前用户</span></span></span><br></pre></td></tr></table></figure>
<p>需要反复强调的是，平常开发几乎用不上<code>root</code>权限，短暂需要使用也应使用后尽快<code>exit</code>；不像<code>Windows</code>系统，<code>Linux</code>系统的软件运行时很少要求<code>root</code>权限，这让用户增加戒心而非像使用<code>Windows</code>一样无脑授权</p>
<p>开发中，应清楚知道自己在干什么，知道为什么一定要用<code>sudo</code>，并尽量少用它</p>
<h2 id="选择包管理工具">选择包管理工具</h2>
<p>有两种选择：<code>apt-get</code>与<code>apt</code>，后者被视为前者的加强版，是<code>apt-cache</code>和<code>apt-get</code>的集合，最好不要尝试其它包管理工具，否则可能扰乱<code>apt</code>的数据库，使一些命令变成危险操作</p>
<p><code>apt</code>获取软件资源的仓库位于<code>/etc/apt/sources.list</code>中，如果要修改，记得小心、备份</p>
<p>它们都需要管理员权限，常用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt update    <span class="comment"># 列出可更新软件名单</span></span></span><br><span class="line">  sudo apt install &lt;p1&gt; &lt;p2&gt; # 安装p1,p2,...软件 若存在则尝试更新</span><br><span class="line">  sudo apt upgrade    # 升级软件,应当定期执行该命令以保证系统稳定性</span><br><span class="line">  sudo apt remove &lt;p1&gt; &lt;p2&gt;  # 删除p1,p2,...软件</span><br><span class="line">  sudo apt purge &lt;p1&gt; &lt;p2&gt;  # 删除p1,p2,...软件,并删除相关依赖包和配置文件,有危险</span><br><span class="line">  sudo apt autoremove   # 删除不再被需要的依赖包,如果一直用的是apt包管理工具,则不危险</span><br><span class="line">  sudo apt list [option]  # 列出...</span><br><span class="line">install options:</span><br><span class="line">  --no-upgrade     # 若软件已安装,则不更新</span><br><span class="line">  --only-upgrade    # 若软件未安装,则不安装;若已安装,则尝试更新</span><br></pre></td></tr></table></figure>
<h2 id="文件系统">文件系统</h2>
<p>区别于<code>Windows</code>系统的盘符分区，<code>Linux</code>采取的是让根目录<code>/</code>作为所有文件或目录的祖宗路径，将所有文件纳入单个虚拟目录结构中，文件路径中没有指示其所在驱动器的信息</p>
<p>但硬盘驱动器不会只有一个，一般装载着系统文件的驱动器为根驱动器，在其它驱动器的文件会通过挂载点与根驱动器联系起来</p>
<p>路径分为绝对路径和相对路径，形如<code>./path</code>和<code>../path</code>路径前带点的路径即相对路径，分别表示相对当前目录下和相对于上级目录下，可以用多个<code>../</code>来跳转到更上级目录</p>
<p>关于文件的常用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> &lt;file&gt;    <span class="comment"># 若文件不存在,则创建它</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;file&gt;    <span class="comment"># 一次性展示文件内容</span></span></span><br><span class="line">cat options:</span><br><span class="line">  -A      # 查看文件所有字符</span><br><span class="line">  -n      # 查看时附上行号</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less      <span class="comment"># 是more的升级版,用于分页查看文件</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[less is more]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span>/head &lt;file&gt;   <span class="comment"># 查看文件的末尾/头部若干行,默认10行</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file &lt;file&gt;    <span class="comment"># 查看文件类型,事实上也可查看目录,但现在发行版都有彩色显示</span></span></span><br></pre></td></tr></table></figure>
<p>关于目录的常用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> &lt;<span class="built_in">dir</span>&gt;     <span class="comment"># 跳到指定路径下</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[change directory]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &lt;file&gt;/&lt;<span class="built_in">dir</span>&gt;   <span class="comment"># 查看[文件是否存在]/[目录下非隐藏文件]</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[list]</span></span><br><span class="line">ls options:</span><br><span class="line">  -a      # 查看目录下所有文件</span><br><span class="line">  -l      # 查看目录下非隐藏文件的详细信息</span><br><span class="line">  -R      # 递归查看,即会查看目录及其所有子目录</span><br><span class="line">  -al      # 查看目录下所有文件的详细信息</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">la      <span class="comment"># 相当于ls -a</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll      <span class="comment"># 相当于ls -al</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> &lt;<span class="built_in">dir</span>&gt;    <span class="comment"># 创建空目录</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[make directory]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> &lt;<span class="built_in">dir</span>&gt;    <span class="comment"># 删除目录,不常用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[remove directory]</span></span><br></pre></td></tr></table></figure>
<p>有些命令对文件与目录都有效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> &lt;file&gt; &lt;file&gt;/&lt;<span class="built_in">dir</span>&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[copy]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将前者复制到后者中,若为文件路径则以后者命名,若为目录路径则以前者命名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为一个目录下文件不能重名,所以后者路径不能是同名文件和当前目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> &lt;file&gt;     <span class="comment"># 删除文件</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[remove]</span></span><br><span class="line">cp&amp;rm options:</span><br><span class="line">  -i      # 覆盖/删除时发出询问,最好都加上这条选项,保证安全</span><br><span class="line">  -r      # 递归复制/删除,可用于用于复制目录</span><br><span class="line">  -f      # 强制执行,带有一定危险</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf &lt;<span class="built_in">dir</span>&gt;   <span class="comment"># 十分危险的操作</span></span></span><br><span class="line">       # 尽管现在的发行版在要删除根目录时会发出警告,也不要轻易尝试</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> &lt;file&gt;/&lt;<span class="built_in">dir</span>&gt; &lt;dst&gt;  <span class="comment"># 移动文件/目录至另一路径,常用于文件或目录改名、移动文件</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[move]</span></span><br><span class="line">mv options:</span><br><span class="line">  -i      # 覆盖文件时发出询问</span><br><span class="line">  -f      # 强制执行</span><br></pre></td></tr></table></figure>
<h2 id="文件权限">文件权限</h2>
<p>输入<code>ls -al</code>，可以看到文件和目录的一长串信息，其中头部内容就是该条文件的权限，它含有10个字符：</p>
<p>第一个字符代表文件类型，常见的有<code>l、d、-</code>三种，分别对应软链接文件、目录、普通文件</p>
<p>其余九个字符每三个为一组，分别对应属主权限(<code>u,user</code>)、属组权限(<code>g,group</code>)、其它用户权限(<code>o,other</code>)</p>
<p>三个字符<code>r、w、x</code>，分别对应可读、可写、可执行</p>
<p>关于权限的常用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> &lt;paras&gt; &lt;file&gt;  <span class="comment"># 改变文件模式</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[change mode]</span></span><br><span class="line">chmod paras:</span><br><span class="line">  [u/g/o/none][+-=][rwx] # 增/减/等于指定权限,默认改变三者的权限</span><br><span class="line">  [mmm]      # 一串三位、八进制数,每一位m表示对应用户的权限</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">m=nnn     <span class="comment"># 每一位m等于一串三位、二进制数,每一位n表示是否拥有对应rwx权限</span></span></span><br></pre></td></tr></table></figure>
<p><code>Linux</code>系统不同组会有不同权限，我们创建的第一个用户属于<code>sudo</code>组，有些发行版会为该用户创建一个独立的组，该用户创建的文件属于这个组，而通过<code>sudo</code>命令创建的文件又属于<code>root</code>组…</p>
<p>这种复杂灵活的机制让<code>Linux</code>在共享资源时保持有序、安全，关于组的常用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> groupadd    <span class="comment"># 创建组,和addgroup差不多</span></span></span><br><span class="line">groupadd options:</span><br><span class="line">  -g [id]     # 指定GID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">groupmod     <span class="comment"># 修改组属性</span></span></span><br><span class="line">groupmod options:</span><br><span class="line">  -n      # 改名</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> groupdel    <span class="comment"># 删除组,和delgroup差不多</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/group   <span class="comment"># 查看所有组的信息,它们储存在/etc/group中</span></span></span><br><span class="line">       # 每行信息为:组名,密码,GID,[组员]</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chgrp</span> &lt;newGrp&gt; &lt;file/dir&gt; <span class="comment"># 改变文件/目录所属组</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[change group]</span></span><br></pre></td></tr></table></figure>
<p>用户分为系统用户和普通用户，系统用户是某些服务运行时所用的账户，系统一般会预留500或1000个<code>UID</code>给它们(即普通用户<code>UID</code>会从500或1000开始数)</p>
<p>从未改变默认值的默认创建下，新用户将被分配到<code>GID=100</code>的公共组、不会为其设置过期日期</p>
<p>一个用户只能有一个主要组，可以有多个附属组，登录时属于主要组，可通过命令切换到其它所属组</p>
<p>关于用户的常用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/passwd   <span class="comment"># 查看所有用户的信息,它们储存在/etc/passwd中</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">id</span>      <span class="comment"># 查看用户信息</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">groups</span>     <span class="comment"># 查看用户所在所有组</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> useradd    <span class="comment"># 创建用户,和adduser是差不多</span></span></span><br><span class="line">useradd options:</span><br><span class="line">  -g &lt;grp&gt;     # 指定主要组</span><br><span class="line">  -r      # 创建系统用户</span><br><span class="line">  -u [id]     # 指定UID</span><br><span class="line">  -e      # 指定过期时间</span><br><span class="line">  -G [grps]     # 指定用户附属组</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> userdel    <span class="comment"># 删除用户信息,不删除home目录下文件,和deluser差不多</span></span></span><br><span class="line">userdel options:</span><br><span class="line">  -r      # 会删除home目录下文件,使用时需谨慎</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">usermod     <span class="comment"># 改变用户信息,一些选项与adduser的选项相同</span></span></span><br><span class="line">usermod options:</span><br><span class="line">  -l      # 改名</span><br><span class="line">  -L/-U      # 锁定/解锁用户</span><br><span class="line">  -p      # 更改密码</span><br><span class="line">  -g      # 更改用户主要组,重新登录后生效</span><br><span class="line">  -G [grps]     # 更改用户附属组,是更改而非添加,具有一定危险</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">newgrp     <span class="comment"># 切换到其它所属组</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chage      <span class="comment"># 更改用户过期时间</span></span></span><br></pre></td></tr></table></figure>
<p>无论是在<code>/etc/group</code>还是在<code>/etc/passwd</code>，出于安全因素，里面的密码字段都是<code>'x'</code>，真正的密码储存在<code>/etc/shadow</code>内，只有<code>root</code>用户有权限查看与修改，更改密码的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">passwd &lt;user&gt;    <span class="comment"># 修改用户密码</span></span></span><br><span class="line">passwd options:</span><br><span class="line">  -d      # 删除用户密码</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gppasswd &lt;grp&gt;   <span class="comment"># 修改组密码,组外用户通过密码可暂时拥有其权限,不常用</span></span></span><br><span class="line">gppasswd options:</span><br><span class="line">  -a &lt;user&gt;     # 使grp成为user的一个附属组,常用</span><br></pre></td></tr></table></figure>
<h2 id="链接">链接</h2>
<p>如果多个项目需要使用相同文件，为了节省空间、或是方便管理与维护，<code>Linux</code>提供了链接功能</p>
<p>链接分为软链接与硬链接：</p>
<ul>
<li>软链接(也称符号链接)：类似快捷方式，在软链接文件中存放的是源文件的路径，故占用空间小</li>
<li>硬链接：将创建一个虚拟文件，其本质上与源文件是同一个文件，共用同一个<code>iNode</code>，指向同一份数据块，即占用同一份空间</li>
</ul>
<p>无论是软链接还是硬链接，通过链接文件都可以修改源文件的内容，区别是：</p>
<ul>
<li>删除掉软链接的源文件，则所有指向该源文件的软链接均失效；但如果创建了另外的、同路径的文件，则这些软链接又会指向这个新文件</li>
<li>只有删除掉全部的硬链接，它们的源文件才会从磁盘中释放掉</li>
</ul>
<p>需要注意的是，硬链接不能对目录使用，也不能在不同文件系统间使用；而由于软链接存储的是路径，所以通常不应使用相对路径，否则容易失效</p>
<p>关于链接的常用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> &lt;file1&gt; &lt;file2&gt;  <span class="comment"># 给file1,file2创建硬链接;file1为源文件,必须存在</span></span></span><br><span class="line">ln options:</span><br><span class="line">  -s      # 给file1,file2创建软链接;file1为源文件,必须存在</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span>      <span class="comment"># 显示所在目录的路径,可用于创建软链接时快捷找到路径</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[<span class="built_in">print</span> work directory]</span></span><br><span class="line">pwd options:</span><br><span class="line">  -P      # 如果所在目录为软链接目录,则显示当前目录指向的源目录的路径</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unlink</span> &lt;file&gt;    <span class="comment"># 删除链接,事实上多使用rm -i而非unlink</span></span></span><br></pre></td></tr></table></figure>
<p>如要删除链接目录，需要十分小心，假设我们有源目录<code>/tmp</code>和链接目录<code>/link-&gt;/tmp</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm ~/link/    # 删除/tmp,即源目录的所有文件,链接目录本身会保留</span><br><span class="line">rm ~/link     # 这是正确方式,删除链接目录而非其中的文件</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
        <category>Administrator cmds</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>Linux</tag>
        <tag>file system</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛: 动态规划引入</title>
    <url>/blogs/2024/03/11/algo-dp-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h2 id="回溯与动态规划与贪心引入">回溯与动态规划与贪心引入</h2>
<h3 id="概念">概念</h3>
<ul>
<li>回溯法可用于求解绝大多数问题，基于深度优先，但并不是很优秀的方法，遵循自顶而下，通常通过递归实现</li>
<li>动态规划也可用于求解许多问题，从最小边界求出上层解，遵循自底而上，达到一定规模后则得到答案，但也需要更多思考</li>
<li>贪心思想总在追求局部最优解，由多个局部最优叠加得到全局最优</li>
</ul>
<h3 id="求解斐波那契数列">求解斐波那契数列</h3>
<p>边界条件为<span
class="math inline"><em>a</em>[0] = <em>a</em>[1] = 1</span></p>
<p>从回溯法的角度思考，将大问题拆解为子问题，只有深挖到边界条件时才回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> _position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_position || _position == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(_position - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(_position - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般的回溯法必然涉及大量<strong>重复</strong>的运算，优化方法只有<strong>剪枝</strong>，即可以编写函数<strong>优化判断条件</strong>及时回溯，或用数组存储已经求出的记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> _position)</span> </span>&#123;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> hash[__INT_MAX__] &#123;<span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">// 变长数组不能拥有静态存储期.</span></span><br><span class="line">    <span class="keyword">if</span> (hash[_position - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> hash[_position - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hash[_position - <span class="number">1</span>] = <span class="built_in">fibonacci</span>(_position - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(_position - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash[_position - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这已经有动态规划的影子了，只不过从概念上，动态规划是从<span
class="math inline"><em>a</em>[0, 1]</span>开始找答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> _position)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[_position] &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != _position - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>] = dp[i] + dp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[_position - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见修改为循环形式的求解能利用变长数组，节省了许多空间，这里称<code>dp[0,\ 1]</code>为<code>base case</code>，即边界条件，<code>dp[i + 1] = dp[i] + dp[i - 1]</code>为状态转移方程，即从上一个已求解的子问题状态转移到当前问题状态的方程</p>
<p>根据状态转移方程的不同可以实现<strong>对空间的优化</strong>，例如这个问题的方程，事实上只需要维护三个数，通过<strong>滚动数组</strong>，将过于小的问题抛弃：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> _position)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">// 虽然用数组, 但是三个变量就可以完成记录.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != _position - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[(i + <span class="number">1</span>) % <span class="number">3</span>] = dp[i % <span class="number">3</span>] + dp[(i - <span class="number">1</span>) % <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[(_position - <span class="number">1</span>) % <span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拆解斐波那契数列">拆解斐波那契数列</h3>
<p>问题描述：任意一个正整数可以拆解为若干个斐波那契数列的数(可以重复)之和，求出子数个数最小的拆法</p>
<p>这是一个完全背包问题，即一个容量固定的背包，需要用一些重量不同，数量无穷的物品刚好填满它，求出使用物品最少的方案</p>
<p>如果使用贪心，即我需要更少的数，就选择更大的数，即时刻让接下来需要计算的数更小，这实际上有一个问题：如果拆解出的小问题恰好不大不小，反而增加了需要用到的数，结果就是错误的</p>
<h3 id="求最大连续子数组和">求最大连续子数组和</h3>
<p>这种问题要求连续选择，反而用贪心思想和搜索更优：</p>
<ul>
<li>明确贪心：如果当前和小于零，则抛弃当前窗口，否则继续；如果新窗口和大于旧最大值，则更新答案窗口</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保证数组不为空.</span></span><br><span class="line"><span class="function">array <span class="title">max_son</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> sum = arr[<span class="number">0</span>], max=sum;</span><br><span class="line">    <span class="keyword">auto</span> itbegin=arr.<span class="built_in">begin</span>(), itend=pbegin; <span class="comment">// 存储答案的两个迭代器.</span></span><br><span class="line">    <span class="keyword">auto</span> itslow=itbegin, itfast=itslow; <span class="comment">// 当前窗口的两个迭代器.</span></span><br><span class="line">    <span class="keyword">while</span> (itfast != arr.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            itfast++;</span><br><span class="line">            itslow=itfast;</span><br><span class="line">            <span class="keyword">if</span> (itfast != arr.<span class="built_in">end</span>())</span><br><span class="line">             sum=*itfast;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">            itbegin=itslow;</span><br><span class="line">            itend=itfast;</span><br><span class="line">            max=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        itfast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>(itbegin, itend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<h3 id="基本思路">基本思路</h3>
<p>动态规划在贪心的基础上做出的优化在于，这种算法能看到更长远的子问题(因为本身就是从子问题上升求解的)，如果用<code>f(x)</code>表示对一个问题的最优解，那么<code>dp</code>在子问题中挑出最优解<code>better[f(x1), f(x2), f(x3)]</code>，最终访问到最基础的最优解，也就得到了全局的最优解</p>
<p>例如用<code>1, 5, 6</code>分凑<code>10</code>分的情况，贪心会选择<code>6+1+1+1+1</code>，而动态规划选择<code>better[f(10-6)+1, f(10-5)+1, f(10-1)+1]</code>，即在全局上贪心</p>
<p>所以对于能用<code>dp</code>解决的问题：</p>
<ul>
<li>拥有<strong>最优子结构</strong>：即大问题可拆分成子问题，而且子问题有<strong>唯一的最优</strong>解</li>
<li>能够确定初始状态，即<code>base case</code></li>
<li>能够求出状态转移方程，即递推公式，这是拆分的基础</li>
</ul>
<p>也就是，我在做决策时，只需要考虑当前状态了，因为子问题已经是最优了</p>
<p>判断可以用动态规划后，可一步步思考解法：</p>
<ul>
<li>明确<code>dp</code>的维度及含义</li>
<li>列出所有状态</li>
<li>考虑不同状态，取最优解，列出状态转移方程</li>
<li>思考<code>base case</code>与如何初始化数组</li>
<li><code>dp</code>维度的遍历顺序</li>
<li>测试时输出整个<code>dp</code>数组，方便寻找问题所在</li>
</ul>
<h3 id="基础背包问题">基础背包问题</h3>
<h4 id="背包">01背包</h4>
<p>给定一个<strong>容量固定</strong>的背包，将一些物品放入其中，其中每种物品只有一件，求出最大价值方案/不同价值方案数/最少物品数</p>
<p>每种物品只有选/不选两种状态，这称为<code>01</code>，以求出最大价值方案为例：</p>
<ul>
<li><code>dp[i][j]</code>：表示用前<code>i</code>种物品填满容量为<code>j</code>的背包，所得到的最大价值</li>
<li>状态转移：<code>dp[i][j]=max(dp[i-1][j], dp[i-1][j-weights[i]]+value[i])</code>。<code>max</code>中前者为<strong>不选择</strong>第<code>i</code>种物品，则与使用前<code>i-1</code>种物品相同；后者为<strong>选择</strong>第<code>i</code>种物品，则当前价值为用前<code>i-1</code>种物品填满”当前容量减去当前物品的重量”背包的最大价值加上<strong>当前物品</strong>的价值。两者取最优，在这里表现为<code>max()</code>；为防止越界访问，定义当当前物品重量大于当前背包时，必定为不选择当前物品</li>
<li><code>base case</code>：<code>dp[...][0]=0</code>，即容量为<code>0</code>，价值定为<code>0</code>；<code>dp[0][weights[0]~k]=value[0]</code>，即用第<code>0</code>种物品填满容量为<code>weights[0]~k</code>的背包，最大价值就是当前物品的价值。注意这里不要求恰好填满，如果要求恰好，则有所不同</li>
<li>这个问题不要求顺序，因为<strong>根据递推方程</strong>，当前元素由左上或正上方元素决定；根据<code>base case</code>，第<code>0</code>行与第<code>0</code>列都已经初始化；故顺序不同都可以在求当前位置前求出这两个位置的值</li>
</ul>
<p>状态转移方程中，由于每种物品只有一件，所以每次迭代都需要<code>i-1</code>，避免重复选择：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// 这里进行简化, 用 value下标+1 表示该物品的重量.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[value.<span class="built_in">size</span>()][k<span class="number">+1</span>] &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k<span class="number">+1</span>; i++) &#123; <span class="comment">// i的初始化为weights[i].</span></span><br><span class="line">        dp[<span class="number">0</span>][i]=value[<span class="number">0</span>]; <span class="comment">// 该问题不要求恰好填满, 所以初始化一个范围.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; value.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">+1</span> &gt; j) &#123; <span class="comment">// 这里的i+1是简化后的重量, 具体问题中应为weights[i].</span></span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-(i<span class="number">+1</span>)] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[value.<span class="built_in">size</span>()<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察递推方程可知，当前元素只与左上/正上方元素相关，则可以利用滚动数组优化空间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[k<span class="number">+1</span>] &#123;&#125;; <span class="comment">// 将物品维度压缩.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k<span class="number">+1</span>; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; value.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 倒序遍历一定需要整一层的初始化.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = k; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">+1</span> &gt; j) &#123;</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">// 直接用正上方的数据覆盖, 则不作改变.</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j], dp[j-(i<span class="number">+1</span>)] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这样优化必然需要让背包容量在内层循环，因为是行行覆盖；而且背包是倒序遍历，因为需要保证在每一层的计算中(<code>i</code>不变时)，每个物品只被选择一次；如果正序遍历，会因”由前一元素推出当前元素”的影响，错误的用新值覆盖本应用于计算的旧值</p>
<h4 id="完全背包">完全背包</h4>
<p>完全背包与<code>01</code>背包的不同在于，每个物品有无数个，这使它们有多种状态(选<code>0,1,...,n</code>次)，最多选择”背包容量除以重量”次；这样的问题可以转换为<code>01</code>背包(将每种物品按最多次数展开就是<code>01</code>背包)：</p>
<ul>
<li>如果不选择，则等于上层结果</li>
<li>如果选择若干次后不再选择，则等于该层结果</li>
<li>如果继续选择，则覆盖该层结果</li>
</ul>
<p>则很容易想到新增一层循环，达成”选择多次”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[value.<span class="built_in">size</span>()][k<span class="number">+1</span>] &#123;&#125;;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">1</span> &lt; k<span class="number">+1</span>, i += <span class="number">1</span>) &#123; <span class="comment">// 后两个表达式中的1是简化后的第0物品的重量.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * <span class="number">1</span>; j &lt; i * <span class="number">2</span> &amp;&amp; j &lt; k<span class="number">+1</span>; j++) &#123;</span><br><span class="line">         dp[<span class="number">0</span>][j]=i * value[<span class="number">0</span>]; <span class="comment">// 不要求填满.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; value.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]; <span class="comment">// 先进行初始化, 方便多次比较.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x * (i<span class="number">+1</span>) &lt;= j; x++) &#123; <span class="comment">// 最多选择 容量/单个重量 次.</span></span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-x * (i<span class="number">+1</span>)] + x * value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[value.<span class="built_in">size</span>()<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到每次算出一个<code>dp[i][j]</code>，其实是对该元素正上方元素、正上方左边若干个元素(两两之间距离为<code>weights[i]</code>)进行比较(只是因为<code>max</code>一次性只比较两个元素而遍历)，且每一层循环所要判断的物品是同一种(重量一样，<strong>选择不同个数物品后元素的距离一样</strong>)，那么只需要利用上一次比较的结果(即当前元素正上方左边元素的最优)与当前元素正上方元素相比较，就可以减少不必要的比较了，于是可以对状态转移方程优化：</p>
<p><img src=".\pictures\1_dp.jpg" style="zoom: 20%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[value.<span class="built_in">size</span>()][k<span class="number">+1</span>] &#123;&#125;;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">1</span> &lt; k<span class="number">+1</span>, i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * <span class="number">1</span>; j &lt; i * <span class="number">2</span> &amp;&amp; j &lt; k<span class="number">+1</span>; j++) &#123;</span><br><span class="line">         dp[<span class="number">0</span>][j]=i * value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; value.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-(i<span class="number">+1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// max前者为正上方元素, 后者为之前计算过的最优解+多选择一件的价值.</span></span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j-(i<span class="number">+1</span>)]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[value.<span class="built_in">size</span>()<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现这个方程与<code>01</code>背包极为类似，只因后者变化而<strong>允许了重复选择</strong></p>
<p>效仿<code>01</code>背包，依然可以降维：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[k<span class="number">+1</span>] &#123;&#125;;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">1</span> &lt; k<span class="number">+1</span>, i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * <span class="number">1</span>; j &lt; i * <span class="number">2</span> &amp;&amp; j &lt; k<span class="number">+1</span>; j++) &#123;</span><br><span class="line">         dp[j]=i * value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; value.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k + <span class="number">1</span>; j++) &#123; <span class="comment">// 这里是正序, 因为可以选择多次.</span></span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">+1</span> &gt; j) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j], dp[j-(i<span class="number">+1</span>)] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全背包可以考虑的一个优化点在于，对于求解价值问题，可以考虑将”重量相同但价值更小”与”价值相同但重量更大”的物品去除，因为可以选择无数次，而这样的优化首先需要<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>的遍历，或者用一些高效的排序方法实现更低的复杂度优化</p>
<h4 id="多重背包与混合背包">多重背包与混合背包</h4>
<p>多重背包与完全背包十分相似，它限定了物品的个数。最基础的解法为类似完全背包的三次循环，为了防止多次选择，一维数组解法的<code>j</code>层循环仍需<strong>逆序遍历</strong></p>
<p>因为这种解法实质上是通过<strong>完全展开</strong>所有的次数来表示所有的可能，也就是用<strong><code>1</code>进制</strong>形式重构了物品，会造成多余无效的比较，所以：</p>
<ul>
<li>将这些<code>1</code>进制的多个同种物品压缩成<code>n</code>进制不同种的<code>01</code>物品，价值为<code>n*value[i]</code>，重量为<code>n*weights[i]</code>，个数为<code>1</code></li>
<li>尝试找出一种压缩方法，能使压缩后的这些物品进行排列组合后能够表示所有的可能</li>
<li>因为<code>01</code>物品<strong>只有两种状态</strong>选或不选，所以只能用<strong>二进制压缩</strong></li>
</ul>
<p>完全背包问题可以完全优化掉个数的循环，而多重背包不行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_input</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; input)</span> </span>&#123; <span class="comment">// 初始化输入.</span></span><br><span class="line">    <span class="type">int</span> n, m, v, w;  <span class="comment">// 物品种类数, 物品个数, 物品价值, 物品重量.</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= m) &#123;</span><br><span class="line">            input.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v*j, w*j));</span><br><span class="line">            m -= j;</span><br><span class="line">            j &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m) &#123; <span class="comment">// 如果剩余m个, 则把它压缩为1个, 加上这个余数就可以表示原来的m范围内所有数了.</span></span><br><span class="line">            input.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v*m, w*m));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在遍历时套用<code>01</code>背包解法就行了，对于个数的时间复杂度由<code>O(n)</code>优化成了<code>O(logN)</code>，乘上价值与重量的时间复杂度的话，已经优化相当多了</p>
<p>混合背包即将三种物品类型结合起来，很容易得出它的解法：</p>
<ul>
<li>如果是完全背包类型，则这一层以完全背包方程遍历，一维数组是顺序遍历</li>
<li>如果为多重背包类型，则转化为<code>01</code>背包，并加入到<code>01</code>背包的循环中，一维数组是倒序遍历</li>
</ul>
<h4 id="变种背包问题">变种背包问题</h4>
<p>以上是三种最基础、经典的背包问题，也有不同的变式，例如：</p>
<ul>
<li><p>外表上只含重量的背包问题：例如数组凑出固定和问题，在这个问题上，价值其实与重量相等</p></li>
<li><p>输出具体方案：可以同时维护一个<code>bool</code>二维数组记录选择。例如<code>01</code>背包中，用<code>0</code>表示没有选择，并查询正上方的选择；用<code>1</code>表示选择了，并查询<code>[i-1][j-weights[i]]</code>的状态；最后通过递归逆序搜索，顺序输出即可</p></li>
<li><p>作”恰好装满”的限制：初始化时必须注意有效状态(装满为有效，否则定义为<code>-1</code>或其它无效值)，在求最大价值问题上，应用<code>INF</code>或<code>__INT_MAX__</code>作为无效值(因为取最大)</p></li>
<li><p>求解最少物品恰好装满问题：<code>dp</code>数组含义变为所需的最少物品，且初始化时无关值应用<code>__INT_MAX__</code>处理，在比较时使用<code>min()</code>，无效值为<code>-1</code>；之前提到的拆分斐波那契数列问题其实就是一个这样的完全背包问题</p></li>
<li><p>求解恰好填满方案数问题：<code>dp</code>数组含义变为方案数，且递推方程由比较变为两种状态<strong>求和</strong>，无效值为<code>-1</code></p></li>
<li><p>求解价值最优方案数问题：同时维护一个二维数组记录最优方案数。如果选择/不选择价值相等，则当前方案数为两者相加，否则为更优方案的方案数，以<code>01</code>背包为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> strategy[value.<span class="built_in">size</span>()][k<span class="number">+1</span>] &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123; <span class="comment">// 二维数组求法.</span></span><br><span class="line">        ...; <span class="comment">// 递推公式.</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] == dp[i<span class="number">-1</span>][j])</span><br><span class="line">            strategy[i][j] += strategy[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] == dp[i<span class="number">-1</span>][j-w[i]]+value[i])</span><br><span class="line">            strategy[i][j] += strategy[i<span class="number">-1</span>][j-w[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123; <span class="comment">// 一维数组求法.</span></span><br><span class="line">        <span class="keyword">if</span> (dp[j] &gt; dp[j-w[i]]+value[i]) &#123;</span><br><span class="line">            strategy[j] += strategy[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] &lt; dp[j-w[i]]+value[i]) &#123;</span><br><span class="line">            strategy[j] += strategy[j-w[i]];</span><br><span class="line">            dp[j] = strategy[j-w[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            strategy[j] += strategy[j-w[i]]+strategy[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求解排列顺序问题：和求解组合数不同，对于完全/多重背包时，因为一种物品可以多次选择，于是有顺序问题，所以求解所有排列时，如果只使用两层循环，需要让<strong>外层循环为背包容量，内层循环为物品</strong></p>
<ul>
<li><p>原因在于，求组合时，是先往背包中放同一种物品，然后遍历后续的物品，始终只有一种排列</p></li>
<li><p>而求排列时，允许背包先放入不同的物品，然后再扩大容量</p></li>
<li><p>可以这么认为，前者一次遍历只允许出现一种物品，后者一次遍历则是求出了小背包的所有组合</p></li>
</ul></li>
<li><p>连续选择问题：即要求选择的物品必须是连续的，这种方法难以通过<code>dp</code>求解，更好的办法是通过贪心与搜索</p></li>
</ul>
<p>对于背包问题，不用纠结它有没有背包，背包只是一系列问题的一种映射，重要的是”只需要作出当前决策”的特性</p>
<h3 id="进阶背包问题">进阶背包问题</h3>
<h4 id="二维背包问题">二维背包问题</h4>
<p>这类问题在基础背包问题上添加了一个限制，例如：</p>
<ul>
<li>两个背包问题：放入一个物品会使这两个背包都添加重量</li>
<li>数量限制问题：可以放入背包的物品最大数量有限(假设为<code>k</code>)，这个”最大数量”其实就是第二个容量为<code>k</code>的背包，放入物品同时会使它的重量加<code>1</code></li>
</ul>
<p>按照之前的思路，只需要添加一层循环与一个维度即可，利用滚动数组可以只使用二维数组</p>
<h4 id="分组背包问题">分组背包问题</h4>
<p>这类问题将<code>n</code>种物品改为<code>n</code>组物品，且在每组中只能选出<code>1</code>件，那就是很简单的嵌套最优<code>01</code>背包问题，只需要添加一层循环，但不需要添加数组维度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; group.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = k; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; group[i].<span class="built_in">size</span>(); x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">+1</span> &gt; j) &#123; <span class="comment">// group[i].weights[x] &gt; j.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j], dp[j-(i<span class="number">+1</span>)] + group[i].value[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是依赖问题的基础，此问题的变形还有：</p>
<ul>
<li>每组不限种类，总共能选择<code>n</code>件，这其实是二维背包问题，淡化了”组”的分别</li>
<li>每组只能选出<code>1</code>种，且能够选择多/无数件，这也很好解决，套用多重/完全背包模板再添加循环即可</li>
<li>每组能够选出<code>n</code>种，每种能够选择<code>1</code>/多/无数件，这样的问题已经变得相当复杂，涉及不同排列组合问题</li>
</ul>
<h4 id="依赖背包问题与泛化物品">依赖背包问题与泛化物品</h4>
<p>这是进阶背包问题，每种物品可能与其它物品有依赖关系，即选择附属物品必须选择对应的主物品，这使得附属物品有有效状态和无效状态之分，而不单纯是有效状态上选择或不选择的区别</p>
<p>遍历思路一定是如果选择主物品，再考虑其附属物品，所以首先考虑缩小附属物品的范围，即先在每一个主物品的附属集合中使用背包策略求出子<code>dp</code>，再与不选主物品的情况捆绑成一个组，由于每个元素代表一种策略，而我们只能选择一种策略，故可以通过分组背包问题求解</p>
<p>如果一组附属物品只依赖于一个主物品，那么产生的组就是子<code>dp</code>(每个元素需加上主物品的重量与价值，因为有依赖关系)，不选择主物品的情况就是不在这个组里选择任何物品</p>
<p>泛化物品概念的来源是，假设这些附属物品也有附属物品，那么问题就变成了背包数，是一个图了</p>
<p>根据依赖问题的思路，将附属物品的集合看作一种新的物品，这种物品可以是一个组，表现为一个<code>dp</code>数组，即提供不同的容量限制，它会返回不同的价值，这就是泛化物品</p>
<p>泛化物品当然可以作为三个基础背包问题的对象，而一旦容量与类型确定，它的价值也都固定了：</p>
<ul>
<li><code>01</code>泛化物品：提供容量<code>k</code>，选择则<code>weight=k, value=dp[k]</code></li>
<li>多重或完全泛化物品：提供容量<code>k</code>，选择则<code>weight=w[i], value=k/w[i] * dp[w[i]]</code></li>
</ul>
<p>取泛化物品中的最优是有点麻烦的，因为它们的容量不确定，暴力解决是枚举所有分配容量的方案，再取最优</p>
<h3 id="例题">例题</h3>
<h4 id="目标和">目标和</h4>
<p>给你一个<strong>没有<code>0</code></strong>的数组，每个数可以<strong>取正或负</strong>，得到一个表达式，再给你一个<strong>正</strong>的目标和，求出能够得到这个目标和的表达式数</p>
<p>这也是很经典的<code>01</code>背包问题，求恰好填满，只是状态从是否选择变成了是否<strong>取正负</strong>且每个数必须选择，事实上这样会不能进行一维数组的空间优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;...&#125;; <span class="comment">// 求出fabs(arr)的和sum.</span></span><br><span class="line">    <span class="keyword">if</span> (target &gt; sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[sum<span class="number">+1</span>] &#123;&#125;;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 数组没有0, 故可以确定用第一个数凑出0的方案数为0. 如果允许不选, 应为dp[0]=1.</span></span><br><span class="line">    dp[<span class="built_in">fabs</span>(arr[<span class="number">0</span>])]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = sum; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]+j &gt; sum &amp;&amp; arr[i] &gt; j) &#123; <span class="comment">// 既不能取正也不能取负.</span></span><br><span class="line">                dp[j] = <span class="number">0</span>; <span class="comment">// 如果允许不选, 这里应该不变.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; j) &#123; <span class="comment">// 如果只能取正.</span></span><br><span class="line">                dp[j] = dp[arr[i] + j]; <span class="comment">// 允许不选, 则+=.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i]+j &gt; sum) &#123; <span class="comment">// 如果只能取负.</span></span><br><span class="line">                dp[j] = dp[j-arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 都可取.</span></span><br><span class="line">                dp[j] = dp[arr[i] + j] + dp[j-arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，<code>dp</code>同时受到左右两边元素的影响，是<strong>不能用一维数组</strong>的</p>
<h4 id="求解最后一块石头的重量">求解最后一块石头的重量</h4>
<p>给你一些石头，石头之间可以互相抵消，求出抵消剩一块石头时，这块石头的最小重量</p>
<p>如果要求两块石头相邻，很容易用贪心思想得到，每轮抵消我都要让最大的石头和旁边的石头抵消(无关左右)，每轮抵消后再次寻找最大的石头，因为虽然最大值可能互相隔离，但最终都要相碰，最后三个石头的抵消实际上是在做：</p>
<ul>
<li>新大石头-(旧大石头-隔壁石头)=新大石头-旧大石头+隔壁石头</li>
</ul>
<p>它一定是两个小石头的和减去那个大石头</p>
<p>那如果不要求相邻，根据上面的思路就是抽出一些石头取正数，一些石头取负数，然后求最小和，那么在求出<code>dp</code>后，从小遍历最后一行就能得到答案了</p>
<h4 id="分割字符串">分割字符串</h4>
<p>给你一个字符串和字典，你可以重复使用字典中的字符串，求解是否能够通过字典来凑出它</p>
<p>示例：<code>str="applepenapple", dict=["apple", "pen"]</code>，返回<code>true</code></p>
<p>这就是一个完全背包问题，字符串的容量为<code>size()</code>，字典中每个物品的重量也为<code>size()</code>，只需要求出所有能够恰好凑出容量的排列即可，注意需要保存具体的组合内容</p>
<p>然而求出所有排列是深搜的做法，<code>dp</code>可以在此之前就进行判断，剔除无关的字符串，判断条件可以是集合的<code>count()</code>方法，并充分利用前面的状态，这样就可以将排列数转换为布尔值了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isdict</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">const</span> unordered_set&lt;string&gt;&amp; dict)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> dp[str.<span class="built_in">size</span>()<span class="number">+1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 表示可以凑出空字符串, 方便记录第一个出现的字典串的状态.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>() + <span class="number">1</span>; i++) &#123; <span class="comment">// 先遍历背包容量, 即子串.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; <span class="comment">// 遍历子串的子串.</span></span><br><span class="line">            <span class="comment">// 将0~i子串拆分为0~j和j~i两个子串, dp[j]表示可以凑成0~j, 后者表示字典含有j~i串.</span></span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; dict.<span class="built_in">count</span>(str.<span class="built_in">substr</span>(j, i-j))) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>; <span class="comment">// 则可以凑成0~i.</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 增加背包容量.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[str.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍系列问题">打家劫舍系列问题</h4>
<p><strong>打家劫舍一</strong>：给你一行屋子，你可以抢劫非相邻房屋，求出最大收益</p>
<p>这个问题，不同物品间有排斥关系，而且看似没有背包，很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_p</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[arr.<span class="built_in">size</span>()] &#123;&#125;; <span class="comment">// 这里用dp[i]表示抢劫前i间屋所得的最大收益.</span></span><br><span class="line">    <span class="comment">// 初始化: 0比1大或相等, 则抢0不抢1, 表现为[0]==[1]; 0比1小, 则抢1不抢0, 表现为[0]!=[1].</span></span><br><span class="line">    dp[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i<span class="number">-1</span>] == dp[i<span class="number">-2</span>]) &#123; <span class="comment">// 证明没有抢前者, 则假设抢当前屋, 不抢的情况在下一轮处理.</span></span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 证明当前屋不可抢.</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] + dp[i<span class="number">-2</span>] &gt; dp[i<span class="number">-1</span>]) &#123; <span class="comment">// 但如果抢i比抢i-1划算.</span></span><br><span class="line">    dp[i<span class="number">-1</span>]=dp[i<span class="number">-2</span>]; <span class="comment">// 则修改前一个元素的状态.</span></span><br><span class="line">                dp[i]=dp[i<span class="number">-2</span>] + arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 不抢.</span></span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[arr.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打家劫舍二</strong>：仍然给你一些屋子，但这个屋子头尾相邻，你不能抢劫相邻的屋子</p>
<p>这其实分成三种情况：</p>
<ul>
<li>头尾都不选：答案等于对中间元素进行<code>dp</code></li>
<li>只选头：答案等于对前<code>n-1</code>个元素进行<code>dp</code></li>
<li>只选尾：答案等于对后<code>n-1</code>个元素进行<code>dp</code></li>
</ul>
<p>第一种情况是被包含在后两种情况中的，也就是求的过程中就已经取了最优，而后两种情况只需要分别计算再取最优即可</p>
<p><strong>打家劫舍三</strong>：给你一些树状结构的房子，依然是不能抢劫相邻的屋子</p>
<p>一节二叉树可以化为普通的线性数组，但多节多叉树就要考虑多种因素，那么其实这涉及到树形<code>dp</code></p>
<p>处理树形结构一个可行的方法就是递归搜索，并同时运用<code>dp</code></p>
<h4 id="贪心之多背包问题">贪心之多背包问题</h4>
<p>给你<code>k</code>个背包，<code>n</code>个珠子(<code>n&gt;=k</code>)，你必须把所有珠子填入其中且保证每个背包含有至少<code>1</code>个珠子，且每个背包内珠子一定是连续放入的，每个背包的价值为最先放入珠子和最后放入珠子的和，求出所有背包价值和最大值与最小值的差值</p>
<p>这个问题中各个背包之间的关系其实不大，很难用动态规划来求解，而是用贪心思想</p>
<p>任意方案都要求将整个数组分割成<code>k</code>个连续子数组，以代数形式列出价值和：</p>
<p><span class="math inline">$\begin{align}&amp;\rm\because
arr[0,n]=arr[0,n_1],arr[n_1+1,n_2],\dots,arr[n_{k-1}+1,n]\\&amp;\rm\therefore
sum=value\Big(0+n_1+(n_1+1)+n_2+\dots+(n_{k-1}+1)+n\Big)\\&amp;\ \ \ \ \
\ \ \ \ \ \ \ =\rm
value\Big(0+\big(n_1+(n_1+1)\big)+n_2+\dots+(n_{k-1}+1)+n\Big)\end{align}$</span></p>
<p>由观察可知，一个方案的价值总和等于头尾元素价值之和+所有分割处相邻元素价值之和，且共有<code>k-1</code>个分割处</p>
<p>我们知道<code>n</code>的数组有<code>n-1</code>个分割处，那么只要把所有这些分割处两边元素和求出，再由贪心取最大/最小的<code>k-1</code>个分割处，就可以算出最大/最小值了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>()<span class="number">-1</span>; it++) &#123;</span><br><span class="line">        *it += *(it<span class="number">+1</span>); <span class="comment">// 数组内计算, 节省空间.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序, 方便贪心, 这里因为数组内计算, 所以最后一个元素是无效的.</span></span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++) &#123; <span class="comment">// 遍历k-1次.</span></span><br><span class="line">        sum += arr[arr.<span class="built_in">size</span>()<span class="number">-2</span>-i] - arr[i]; <span class="comment">// 求的是差值.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>beginner</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Python: 常用的数据结构</title>
    <url>/blogs/2024/02/02/python-data-structure/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h3 id="不可变可变类型">不可变/可变类型</h3>
<p>回顾一下不可变、可变类型的区别</p>
<ul>
<li><p>展现给开发者的：</p>
<ul>
<li><p>内置不可变类型不提供任何<code>set</code>类型的<code>API</code>，最多仅提供<code>get</code>类型的方法(例如点操作符、<code>[]</code>切片语法糖等)(且在用户试图修改这些方法的返回值时抛出<code>TypeError</code>或<code>AttributeError</code>)，用户<strong>只能</strong>通过<strong>赋值修改</strong>实例的<strong>引用</strong>来实现修改对象的功能
用户既不能修改内容，也不能在类外绑定新的实例属性
需要再次强调，不可变类型和<code>C++ const&amp;</code>引用类型不是一种东西，更像<code>C++ const*</code>：用户完全可以修改其指向，只是不能修改其指向的内容</p></li>
<li><p>很自然的是，因为所有对象均为引用(包括形参)，因此传递参数时：
若为不可变类型参数，则修改该参数不会影响实际参数(因为用户只能修改形参的指向)
若为可变类型参数，则修改其内容将影响实际参数(形参、实参指向相同的数据)、通过赋值修改形参的引用不会影响实际参数(修改形参的指向，未修改实参的引用及其指向的数据)</p></li>
<li><p>用户定义的类均为可变类型，可以模仿不可变类型的行为，有多种灵活的方法：
首先是类属性这种所有实例共用的数据，在初始化时就应设置成不可变类型
定义不可变实例属性：</p>
<ul>
<li>用<code>@property</code>将一个<strong>实例方法转换为实例属性</strong>，当用户访问该实例属性时，相当于调用该实例方法；使该实例方法始终返回一个不可变类型实例，就能实现使该实例属性无法修改</li>
<li>最常用的保底机制：直接<strong>重载<code>__setattr__()</code></strong>进行检查，拦截被修改/绑定的属性，可由用户决定是否抛出异常
也可以防止用户在类外绑定实例属性</li>
</ul>
<p>不允许用户在类外绑定实例属性：除了上述方法外，还可<strong>定义类属性<code>__slots__</code></strong>(一个由字符串组成的元组)，表示<strong>允许用户绑定的实例属性名</strong></p>
<ul>
<li><p>实例原本通过字典<code>__dict__</code>维护其实例属性，但定义这个类属性后，实例不再拥有<code>__dict__</code>，而是一个固定长度的数组</p></li>
<li><p>这个类属性<strong>不允许包含其它类属性名</strong>，否则会抛出<code>ValueError</code>
配合上在用户<strong>通过实例修改类属性</strong>时，解释器优先解释为用户想要创建和类属性同名的实例属性这个特性，这种操作必然会报错，虽然原因不同：
<img src="./python-data-structure\slots_1.png" style="zoom:40%;" />
<img src="./python-data-structure\slots_2.png" style="zoom:40%;" /></p>
<p>(1)试图创建不在<code>__slots__</code>中的新的实例属性(2)试图通过实例修改类属性
还是一句话，尽量不要通过实例访问类属性，如果手贱，尽量只进行只读操作</p></li>
<li><p>这个类属性不对子类生效</p></li>
</ul></li>
</ul></li>
<li><p>内部实现细节：</p>
<ul>
<li>解释器会为内置不可变类型的对象维护缓存，使内容相同的对象只指向一份实际内存空间</li>
<li>当用户调用赋值符修改属性时，实际是调用内置的<code>__setattr__()</code>，这也是上述保底机制的原理</li>
<li>当用户调用赋值符修改对象引用时，维护原/新数据的引用计数，通过<code>GC</code>维护内存</li>
</ul></li>
</ul>
<h3 id="序列公共api">序列公共<code>API</code></h3>
<ul>
<li>序列的赋值：</li>
<li>内置序列类型，即有序的数据集合，包括元组(不可变)、列表(可变)、字符串(不可变)、<code>range()</code>(不可变)</li>
<li>运算符语法糖：
<ul>
<li><code>seq1 + seq2</code>：拼接序列，返回新实例</li>
<li><code>seq * n</code>：拼接<code>n</code>个相同序列，返回新实例</li>
<li><code>val in/not in seq</code>：判断值是否在序列中，返回布尔值</li>
</ul></li>
<li><code>len()</code>：返回长度</li>
<li><code>max()/min()</code>：返回序列中最大/最小值，要求所有元素的类型相同(除非是<code>python</code>允许的隐式类型转换)</li>
<li><code>range(start, end, step=1)</code>：创建从<code>start</code>到<code>end</code>(包含)的步长为<code>step</code>的<code>range</code>类(整数序列)，<code>step</code>默认为<code>1</code>，<code>step</code>允许为负数，不允许为零
和切片的功能不同，不能用于截取序列，其用法是快速创建整数数组方便<strong>产生<code>for</code>循环索引</strong>/数据分析</li>
<li><code>slice(start, end, step=1)</code>：参数用法与<code>range()</code>类似(<code>end</code>不包含)，但产生的序列不能访问，其正确用法是通过<code>[]</code><strong>作用于其它序列上，截取子序列</strong></li>
<li><code>[]</code>语法糖：
<ul>
<li><code>[x]</code>：访问下标为<code>x</code>的元素</li>
<li><code>[s:e]</code>：等同于<code>[slice(s, e)]</code>，<code>s、e</code>允许为空，此时代表取到头/尾</li>
<li><code>[s:e:i]</code>：等同于<code>[slice(s, e, i)]</code>，同样<code>i</code>允许为负数</li>
</ul></li>
<li><code>enumerate(seq, start=1)</code>：返回由元组构成的序列，其中元组的第一项为整数序列，从<code>start</code>(默认为<code>1</code>)开始，第二项为序列中的内容(从下标<code>0</code>代表的元素开始)
实际上，所有可遍历</li>
</ul>
<h3 id="集合公共api">集合公共<code>API</code></h3>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
        <category>Std library</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp: I/O</title>
    <url>/blogs/2024/01/19/cpp-io/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="c风格的io"><code>C++</code>风格的<code>I/O</code></h1>
<p><code>I/O</code>是一门语言很重要的部分，<code>&lt;iostream&gt;</code>之所以含有相当一部分好用的函数，是因为在<code>I/O</code>实现时各个头文件互相包含，使得只需要包含<code>&lt;iostream&gt;</code>就能够使用很多的东西</p>
<p>但如果要用<code>STL</code>、实现文件交互等，<code>&lt;iostream&gt;</code>并没有包含它们，推荐使用万能头文件<code>&lt;bits/stdc++.h&gt;</code>，包含几乎所有会用到的东西</p>
<h2 id="stdinput"><code>stdInput</code></h2>
<h3 id="cin"><code>cin</code></h3>
<p>在<code>C++</code>中，<code>istream</code>类的对象<code>cin</code>(在<code>&lt;iostream&gt;</code>中声明)替代了<code>scanf</code>，它自动创建标准输入缓冲区，从标准输入流提取输入</p>
<p>这些对象被称为流对象，它将流和对象联系起来，一个非<code>iostream,fstream</code>类流对象只和一个缓冲区、两端(程序端、输出输入端)相关联</p>
<p>最简单的获取输入的代码如下，它是格式化流插入符(即会将读取的字符串转换成后接对象的相应类型，除了它，其它方法都是非格式化读取)，接受一个<strong>引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; identifier;     <span class="comment">// 有回显、有缓冲、忽略空格与换行,遇空格或回车停止</span></span><br></pre></td></tr></table></figure>
<p>自然想到，如何读取空格，实现面向行的输入？<code>cin</code>有两种方法可以实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(<span class="type">char</span>*,std::streamsize);<span class="comment">// 读取size-1个字符后或遇到换行符停止,且丢弃换行符</span></span><br><span class="line">cin.<span class="built_in">get</span>(<span class="type">char</span>*,std::streamsize);  <span class="comment">// 读取size-1个字符后或遇到换行符停止,将换行符保留在缓冲区</span></span><br></pre></td></tr></table></figure>
<p><code>std::streamsize</code>是<code>long int</code>的重命名，即有符号整型；它们的共同特性是都不会将换行符读入到字符串中，且可以添加第三个<code>char</code>型参数表示自定义终止字符</p>
<p>如果需要只读取缓冲区内的任意一字符，<code>cin</code>有重载的<code>get()</code>方法，其一的用法类似<code>getchar()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ch = cin.<span class="built_in">get</span>();      <span class="comment">// 读取一字符,返回它的字符编码;如遇到EOF,则返回eof(一个负数)</span></span><br><span class="line">cin.<span class="built_in">get</span>(<span class="type">char</span>&amp; ch);     <span class="comment">// 将读取的字符赋值给ch;如遇到EOF,则返回0</span></span><br></pre></td></tr></table></figure>
<p>它们常用于抛弃掉缓冲区的换行符，但一次调用只能丢弃一个字符，<code>cin</code>提供<code>ignore()</code>方法来一次性抛弃多个字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>(std::streamsize n,delim=<span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 抛弃n个字符后或遇到delim并抛弃它后停止</span></span><br></pre></td></tr></table></figure>
<p><code>operator&gt;&gt;(),cin.getline(),cin.get(...),cin.get(char),cin.ignore()</code>都返回<code>cin</code>的引用，这意味着它们可以<strong>链式调用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(a,b).<span class="built_in">getline</span>(a,b);  <span class="comment">// 读取两行(或是读取一串较长行)</span></span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cin.<span class="built_in">get</span>(ch).<span class="built_in">get</span>();     <span class="comment">// 连续读取两字符</span></span><br><span class="line">(cin.<span class="built_in">get</span>(ch)&gt;&gt;a).<span class="built_in">get</span>();</span><br><span class="line">cin.<span class="built_in">get</span>().<span class="built_in">get</span>(ch);     <span class="comment">// 错误,get(void)返回的不是istream引用</span></span><br></pre></td></tr></table></figure>
<p>如果非要给<code>cin</code>改名，可以选择创建引用<code>istream&amp; in=cin</code>(一般不会直接使用<code>istream</code>或<code>ostream</code>的构造函数，只有在创建文件流对象的时候会间接调用<code>i(o)stream(sb&amp;)</code>、或是想实现多缓冲区输入输出时会直接使用它，在这里不作讨论)</p>
<h3 id="string的输入"><code>string</code>的输入</h3>
<p>上述方法都不支持<code>string</code>类对象，然而显然<code>string</code>类更常用，于是<code>&lt;string&gt;</code>中有一个全局函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getline</span>(istream&amp;,string&amp;,<span class="type">char</span>=<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>三个参数，第一个为自定义的输入流，通常是标准输入流<code>cin</code>，第三个参数为指定的结束符(默认为换行符)</p>
<p>有些编译器在使用<code>string</code>类后默认添加<code>&lt;string&gt;</code>，所以就算没有包含它也能运行，但<code>getline()</code>是<code>&lt;string&gt;</code>的函数，应该养成习惯事先包含它，以免出错</p>
<h2 id="stdoutput"><code>stdOutput</code></h2>
<h3 id="cout"><code>cout</code></h3>
<p>与<code>cin</code>的大部分内容类似，<code>cout</code>是<code>ostream</code>类的对象，它与标准输出流相关联，格式化输出如下，<code>operator&lt;&lt;</code>接受<strong>引用或常量</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; identifier &lt;&lt; constant;</span><br></pre></td></tr></table></figure>
<p>由于<code>string</code>类定义的<code>operator&lt;&lt;()</code>能完整输出整个字符串，所以输出部分不像输入一样有专门的函数</p>
<p>对应<code>putchar()</code>，<code>cout</code>也有类似的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="type">char</span>)  <span class="comment">// 输出单个字符</span></span><br></pre></td></tr></table></figure>
<p><code>operator&lt;&lt;(),cout.put(char)</code>都返回指向<code>cout</code>的引用，所以<code>cout</code>也可以链式输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(cout &lt;&lt; str &lt;&lt; endl).<span class="built_in">put</span>(<span class="number">48</span>)</span><br></pre></td></tr></table></figure>
<p>标准输出缓冲区采用行缓冲，它遇到换行符或<code>eof</code>时将自动刷新缓冲区，此外还提供了两个控制符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; flush &lt;&lt; endl;  <span class="comment">// flush直接刷新缓冲区,endl在缓冲区中插入换行符后再刷新它</span></span><br></pre></td></tr></table></figure>
<h3 id="精细控制输出">精细控制输出</h3>
<p><code>C++</code>提供一种不逊于<code>printf()</code>那样精细控制输出位数、输出形式的，更简洁的输出方式，那就是许多控制符</p>
<p>除了刷新缓冲区的<code>flush</code>和<code>endl</code>(在<code>&lt;ostream&gt;</code>中)，其它常用的控制符如下：</p>
<ul>
<li><code>hex,oct,dec</code>：将整型数据以十六、八、十进制输出，在<code>&lt;bits/basic_ios.h&gt;</code>中</li>
<li><code>setprecision(int)</code>：永久设置数据的精度(显示数据的总位数)</li>
<li><code>setfill(char)</code>：永久设置字段中填充的字符(默认为空格)</li>
<li><code>setw(int)</code>：暂时设置字段的宽度，在输出下一数据后恢复默认字段值(即0)，用于对齐画面等</li>
</ul>
<p>除了第一条，其它三条控制符都需要包含头文件<strong><code>&lt;iomanip&gt;</code></strong></p>
<p>这些控制符实际上是调用<code>iostream</code>类的祖宗类<code>ios_base</code>的成员函数<code>setf()</code>和部分成员，来实现控制输出的功能，其它控制符详见<a
href="#~fmtflags"><code>fmtflags</code></a><a id="fmtflags"></a></p>
<p>注：<code>fmtflags</code>不是控制符，而只是部分控制符<strong>调用了<code>setf(fmtflags)</code></strong>而已，<code>ios_base::fmtflags</code>和后续将提到的<code>ios_base::iostate,ios_base::openmode</code>都是一串二进制掩码(<code>bitmask</code>)，这意味着它们可以<strong>通过<code>'|'</code>运算符叠加</strong>，在<code>ios_base</code>中提供了它们的一些枚举常量</p>
<p><code>ios</code>(即<code>basic_ios&lt;char&gt;</code>)类是<code>ios_base</code>类的派生类，能使用它的所有公开和保护性成员，所以直接用<code>ios::badbit</code>等也是正确的，所以在<strong>除定义外的说明和实例中都使用<code>ios::</code></strong></p>
<h2 id="流状态">流状态</h2>
<h3 id="状态位">状态位</h3>
<p>所有流对象都有称为流状态的属性，流的打开或关闭由三个状态位决定：</p>
<ul>
<li><code>badbit</code>：系统性错误时(如文件不存在、文件不允许访问等)被设置，这种错误一般无法恢复</li>
<li><code>failbit</code>：格式错误时(如输入字符赋给整型对象、<code>get(str)</code>读取到空行等)被设置，这种错误可以恢复</li>
<li><code>eofbit</code>：遇到<code>eof</code>时被设置</li>
</ul>
<p><code>ios_base</code>类中有<code>ios_base::badbit,ios_base::failbit,ios_base::eofbit,ios_base::goodbit</code>四种标准状态常量，它们以三位二进制数表示，分别为<code>001,100,010,000</code></p>
<p>当这三个状态位都被清除(即<code>0</code>)时，<code>goodbit</code>将被清除，表示这个流一切正常，是打开的</p>
<h3 id="检查状态的方法">检查状态的方法</h3>
<p>可通过对应的方法(<code>bad(),fail(),eof(),rdstate()</code>)查看这四个位的状态(具体应查看头文件定义，实际上有略微不同)</p>
<p><code>operator!()</code>和<code>rdstate()</code>效果一样，而<code>good()</code>是与<code>operator!()</code>相反的方法，当<code>goodbit=0</code>时返回<code>true</code></p>
<p>这些方法都在<code>ios</code>中定义</p>
<p>需要清楚的是，<code>rdstate()</code>的返回值是<code>ios_base::iostate</code>对象，而其它方法都返回布尔类型，这意味着<code>rdstate()</code>方法还可以通过与标准状态常量对比进行错误检测</p>
<p>这些方法都可用于检测错误，例如<code>rdstate()</code>可用于粗略地检查所有错误类型，出错则返回真</p>
<p>这些流并不会在出错时报错，这涉及到<code>ios::exceptions()</code>方法，它默认返回<code>goodbit</code>，只有当<strong><code>f.exceptions() &amp; f.rdstate()</code>不为零</strong>时，程序才会抛出<code>ios_base::failure</code>错误</p>
<p>如果需要让流报错，应改变<code>exceptions()</code>的返回值(使用它的重载函数<code>exceptions(iostate)</code>)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">f.<span class="built_in">exceptions</span>(ios::failbit);  <span class="comment">// 设置成100,则一旦流的failbit被设置,将报错</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="built_in">catch</span> (ios::failure&amp; message)&#123;</span><br><span class="line">    cerr &lt;&lt; message.<span class="built_in">what</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清除状态的方法">清除状态的方法</h3>
<p><code>ios::clear()</code>和<code>ios::setstate()</code>方法可将流设置成正常，原理有所不同：</p>
<ul>
<li><code>clear()</code>将该流的状态强制改成提供的状态，默认提供<code>0</code>，即<code>ios::goodbit</code></li>
<li><code>setstate()</code>将该流的状态和提供的状态相叠加，相当于两个二进制数进行了<strong>按位或</strong>操作，实际上，进行<code>f.setstate(state)</code>相当于进行<code>f.clear(f.rdstate() | state)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">file.<span class="built_in">clear</span>(ios_base::iostate=<span class="number">0</span>);  <span class="comment">// 默认参数为000,不设置任何位,即清除所有三位</span></span><br><span class="line">file.<span class="built_in">setstate</span>(ios_base::iostate);  <span class="comment">// 必须提供参数,只会设置它而不影响其它两位</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">file.<span class="built_in">clear</span>(ios::eofbit);    <span class="comment">// 参数为010,设置eofbit,清除其它两位</span></span><br><span class="line">file.<span class="built_in">clear</span>(ios::eofbit | ios::badbit) <span class="comment">// 参数为011,清除failbit,设置其它两位</span></span><br></pre></td></tr></table></figure>
<p>当然，可以用其他流的状态作为参数，只是这没有意义</p>
<p>常用不带参数的<code>clear()</code>方法来强制打开流，而<code>setstate()</code>常被流对象自动调用，来叠加到自身的流状态里</p>
<h2 id="文件io">文件<code>I/O</code></h2>
<p>实现文件<code>IO</code>需要包含头文件<code>&lt;fstream&gt;</code>，创建输入流则创建<code>ifstream</code>对象，创建输出流则创建<code>ofstream</code>对象，只不过流的另一端由键盘和显示器变成了文件</p>
<p>因为<code>ifstream,ofstream</code>分别为<code>istream,ostream</code>的派生类，所以可以像<code>cin,cout</code>一样使用方法，而除此之外，文件<code>IO</code>有额外的成员和方法</p>
<h3 id="创建文件流和关闭文件">创建文件流和关闭文件</h3>
<p><code>ifstream</code>和<code>ofstream</code>类中额外定义了默认构造函数和带字符串(有<code>char*</code>类型和<code>string&amp;</code>类型的两个重载)参数的构造函数</p>
<p>以<code>ifstream</code>为例，初始化一个文件流对象如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">ifstream fin;  <span class="comment">// 默认构造函数,这会创建一个新的缓冲区(fb)并将fb的引用传递给基类初始化器</span></span><br><span class="line"><span class="comment">// 将字符串传递给构造函数,它将创建缓冲区并以默认为ios::in的模式调用open(&quot;fileName&quot;)</span></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="type">char</span>*,ios_base::openmode=ios_base::in)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(string&amp;,ios_base::openmode=ios_base::in)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个文件流对象除了继承<code>istream/ostream</code>的用于<strong>格式化输入输出的流装置</strong>外，还额外包含一个私有的<code>filebuf</code>对象，用于<strong>与文件进行底层交互</strong>；例如文件流对象含有的成员函数<code>open()</code>和<code>close()</code>，它们实质上是<strong>调用<code>filebuf</code>类</strong>的<code>open()</code>和<code>close()</code>，只是在类里面重写了一遍方便使用罢了</p>
<p><code>fstream</code>类的对象较为特殊，它继承了两个缓冲区，目的在于用一个对象实现对文件的输入和输出</p>
<p>它们的析构函数是空的，这意味着文件是通过方法<code>close()</code>关闭的，即关闭文件不影响流对象的重复使用，而流的打开与关闭和<strong>流状态</strong>有关；这也更说明，流不是一个容器，而数据也只会<strong>暂时</strong>存储在缓冲区中</p>
<h3 id="文件模式">文件模式</h3>
<p>对于一个文件流对象<code>fio</code>，如果要<strong>检查它的流是否异常</strong>(而不是文件是否打开)，一般不用像<code>cin,cout</code>一样的<code>operator!(),rdstate()</code>方法，而是成员函数<strong><code>is_open()</code></strong>(还是调用<code>filebuf</code>类的成员，但这次是间接调用了<code>file</code>类的成员)，它能检查出“文件打开方式错误”一类的异常</p>
<p><code>C++</code>的文件模式设计与<code>C</code>有许多共通之处，但更好理解和记忆：</p>
<table border="2" width="50px">
<tr>
<th>
ios_base::openmode(以下省略ios::)
</th>
<th>
C风格
</th>
<th>
意义
</th>
<th>
文件存在
</th>
<th>
文件不存在
</th>
</tr>
<tr>
<td>
in(ifstream默认值)
</td>
<td>
“r”
</td>
<td>
读打开
</td>
<td>
正常
</td>
<td>
异常(failbit+badbit)
</td>
</tr>
<tr>
<td>
out(ofstream默认值;默认加上trunc)
</td>
<td>
“w”
</td>
<td>
写打开
</td>
<td>
清空文件
</td>
<td>
创建空文件
</td>
</tr>
<tr>
<td>
ate
</td>
<td>
fseek(file*,0,SEEK_END)
</td>
<td>
跳到eof
</td>
<td colspan="2">
文件必须已经打开
</td>
</tr>
<tr>
<td>
app(默认加上out)
</td>
<td>
“a”
</td>
<td>
追加写打开
</td>
<td>
不会被清空,并在文件尾开始添加内容
</td>
<td>
创建空文件
</td>
</tr>
<tr>
<td>
trunc
</td>
<td>
-
</td>
<td>
清空文件
</td>
<td colspan="2">
文件必须已经写打开
</td>
</tr>
<tr>
<td>
binary
</td>
<td>
“b”
</td>
<td>
二进制模式打开
</td>
<td colspan="2">
文件必须已经打开
</td>
</tr>
<tr>
<td>
in | out(fstream默认值)
</td>
<td>
“r+”
</td>
<td>
读写打开
</td>
<td>
不清空文件,并在文件开头开始添加内容
</td>
<td>
异常(failbit+badbit)
</td>
</tr>
<tr>
<td>
in | out | trunc
</td>
<td>
“w+”
</td>
<td>
读写打开
</td>
<td>
清空文件
</td>
<td>
创建空文件
</td>
</tr>
<tr>
<td>
other | ate
</td>
<td>
“other”后,fseek(file*,0,SEEK_END)
</td>
<td>
打开文件后跳到eof
</td>
<td colspan="2">
视other而定
</td>
</tr>
<tr>
<td>
other | binary
</td>
<td>
“other+b”
</td>
<td>
二进制other模式打开
</td>
<td colspan="2">
视other而定
</td>
</tr>
</table>
<p>以下为常用模式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="built_in">ofstream</span>(<span class="string">&quot;tmp/old&quot;</span>);  <span class="comment">// 创建空文件或覆盖旧文件,并写打开; 和显式声明out或out|trunc等价</span></span><br><span class="line"><span class="built_in">ofstream</span>(<span class="string">&quot;file&quot;</span>,ios::app);  <span class="comment">// 追加写打开; 和显式声明out|app等价</span></span><br><span class="line">ifstream(<span class="string">&quot;file&quot;</span>);   <span class="comment">// 只读打开; 和显式声明in等价</span></span><br><span class="line"><span class="built_in">fstream</span>(<span class="string">&quot;file&quot;</span>);   <span class="comment">// 读写打开文件,不清空文件; 和显式声明in|out等价</span></span><br><span class="line"><span class="built_in">fstream</span>(<span class="string">&quot;tmp/old&quot;</span>,ios::in|ios::out|ios::trunc);<span class="comment">// 创建空文件或覆盖旧文件,并读写打开; 不常用</span></span><br><span class="line"><span class="comment">// 用于图像或其它二进制资源的读写:</span></span><br><span class="line"><span class="built_in">ofstream</span>(<span class="string">&quot;Icon/other&quot;</span>,ios::out|ios::binary);</span><br><span class="line">ifstream(<span class="string">&quot;Icon/other&quot;</span>,ios::in|ios::binary);</span><br></pre></td></tr></table></figure>
<h3 id="读写与异常处理">读写与异常处理</h3>
<p>一般来说，只要打开或关闭文件正常，那么文件流就会保持正常，对于文本内容，像使用<code>cin,cout</code>一样即可；而对于<strong>二进制</strong>内容，可以用<code>read()</code>(读方法，在<code>istream</code>类中)和<code>write()</code>(写方法，在<code>ostream</code>类中)，它们和其它输入输出方法的区别是在读取/输出时不会添加<code>\0</code>，且<code>read()</code>函数不提供默认或指定的终止符(<code>getline()</code>默认遇回车停止)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fin.<span class="built_in">read</span>(<span class="type">char</span>*,<span class="type">int</span>);  <span class="comment">// 读取指定个字符到char*中,不支持string类</span></span><br><span class="line">fout.<span class="built_in">write</span>(<span class="type">char</span>*,<span class="type">int</span>);  <span class="comment">// 向文件写入指定个字符,不支持string类</span></span><br></pre></td></tr></table></figure>
<p>当然在关闭文件后，为了防止读到<code>EOF</code>或其他问题影响这个流对象的再使用，应选择改变<code>exceptions()</code>，或是不管不顾直接<code>clear()</code>强行打开流</p>
<h2 id="附">附</h2>
<p>以阅读头文件的方式回顾所学(<code>Doxygen</code>风格注释)，以下是部分内容在头文件内的定义(小标题是头文件名)：</p>
<h3 id="各类关联">各类关联</h3>
<p>重命名：</p>
<p><img src=".\1.1.1.1.typedef.png" alt="1.typedef" style="zoom:50%;" /></p>
<p><img src=".\1.1.1.2.typedef.png" alt="2.typedef" style="zoom:50%;" /></p>
<p>继承关系：</p>
<p><img src=".\1.1.2.classes.png" alt="classes" style="zoom: 80%;" /></p>
<h3 id="ios_base.h"><code>ios_base.h</code></h3>
<p>以下都属于<code>ios_base</code>类：</p>
<p>流状态常量：</p>
<p><img src=".\1.2.1.ios_base_Ios_Iostate.png" alt="ios_base_Ios_Iostate" style="zoom:50%;" /></p>
<p><img src=".\1.2.2.ios_base_iostate.png" alt="ios_base_iostate" style="zoom:50%;" /></p>
<p><img src=".\1.2.3.ios_base_bit.png" alt="ios_base_bit" style="zoom:50%;" /></p>
<p><a href="#fmtflags">控制符相关</a><a id="~fmtflags"></a>：</p>
<p><img src=".\1.2.4.1.ios_base_fmtflags.png" alt="1.ios_fmtflags" style="zoom:50%;" /></p>
<p><img src=".\1.2.4.2.ios_base_fmtflags.png" alt="2.ios_fmtflags" style="zoom:50%;" /></p>
<p><img src=".\1.2.4.3.ios_base_fmtflags.png" alt="3.ios_fmtflags" style="zoom:50%;" /></p>
<p><img src=".\1.2.4.4.ios_base_fmtflags.png" alt="4.ios_fmtflags" style="zoom:50%;" /></p>
<p><img src=".\1.2.5.ios_base_setf.png" alt="ios_setf" style="zoom:50%;" /></p>
<p>文件模式：</p>
<p><img src=".\1.2.6.1.ios_base_openmode.png" alt="1.ios_base_openmode" style="zoom:50%;" /></p>
<p><img src=".\1.2.6.2.ios_base_openmode.png" alt="1.ios_base_openmode" style="zoom:50%;" /></p>
<h3 id="basic_ios.h"><code>basic_ios.h</code></h3>
<p><img src=".\1.3.1.ios_method.png" alt="ios_method" style="zoom:50%;" /></p>
<p><img src=".\1.3.2.ios_clear()&setstate().png" alt="ios_clear()&setstate()" style="zoom:50%;" /></p>
<p><img src=".\1.3.3.1.ios_checkErr.png" alt="1.ios_checkErr" style="zoom:50%;" /></p>
<p><img src=".\1.3.3.2.ios_checkErr.png" alt="2.ios_checkErr" style="zoom:50%;" /></p>
<p><img src=".\1.3.4.1.ios_exceptions.png" alt="1.ios_exceptions" style="zoom:50%;" /></p>
<p><img src=".\1.3.4.2.ios_exceptions.png" alt="2.ios_exceptions" style="zoom:50%;" /></p>
<p>以上是<code>ios</code>类中的成员，下面这个控制符以及<code>oct,dec</code>等是本头文件内的内联函数：</p>
<p><img src=".\1.3.5.ios_hex.png" alt="ios_hex" style="zoom:50%;" /></p>
<h3
id="istreamostream"><code>istream</code>&amp;<code>ostream</code></h3>
<p>以<code>istream</code>为例，<code>operator&lt;&lt;</code>与其类似：</p>
<p><img src=".\1.4.1.iostream_exceptions.png" alt="iostream_exceptions" style="zoom:50%;" /></p>
<p><code>get(...)</code>与其类似：</p>
<p><img src=".\1.4.2.iostream_strInput.png" alt="1.4.2.iostream_strInput" style="zoom:50%;" /></p>
<p><img src=".\1.4.3.iostream_ignore.png" alt="1.4.3.iostream_ignore" style="zoom:50%;" /></p>
<p>基类初始化器：</p>
<p><img src=".\1.4.5.iostream_ctor.png" alt="iostream_ctor" style="zoom:50%;" /></p>
<p>控制符<code>flush</code>和<code>endl</code>都在<code>&lt;ostream&gt;</code>里，它们是内联函数：</p>
<p><img src=".\1.4.4.iostream_endl.png" alt="1.4.4.iostream_endl" style="zoom:50%;" /></p>
<h3
id="ifstreamofstream"><code>ifstream</code>&amp;<code>ofstream</code></h3>
<p>以<code>ifstream</code>类为例：</p>
<p><img src=".\1.5.1.fstream_ctor.png" alt="fstream_ctor" style="zoom:50%;" /></p>
<p><img src=".\1.5.2.fstream_detor.png" alt="fstream_detor" style="zoom:50%;" /></p>
<h3 id="fstream"><code>fstream</code></h3>
<p>这些是<code>filebuf</code>类里的：</p>
<p><img src=".\1.6.1.fstream_open.png" alt="fstream_open" style="zoom:50%;" /></p>
<p><img src=".\1.6.2.fstream_close.png" alt="fstream_close" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>C/Cpp</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>I/O API</tag>
      </tags>
  </entry>
  <entry>
    <title>Python: 使用pyplot可视化</title>
    <url>/blogs/2024/01/11/python-pyplot/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="matplotlib数据可视化"><code>matplotlib</code>数据可视化</h1>
<h2 id="基本用法">基本用法</h2>
<p><code>matplotlib</code>用于将数据呈现为图，它并非<code>python</code>自带的库，需要<code>pip install</code></p>
<p>生成一条直线的步骤如下，它的原理是将提供的数组中<strong>各点连接</strong>，所以提供的<strong>数组越大，线越光滑</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  <span class="comment"># 常用的是pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># x,y可以是数字或字符串，为字符串时默认等距。</span></span><br><span class="line">x = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">500</span>) <span class="comment"># linspace:在1-10区间内生成500个等距点,返回数组</span></span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">1</span>     <span class="comment"># 直线方程</span></span><br><span class="line"></span><br><span class="line">plt.figure()    <span class="comment"># 创建新图,方便开多个figure</span></span><br><span class="line"><span class="comment"># plt.figure(num=4)     可以传数字参数num=?,空则默认按顺序命名</span></span><br><span class="line"><span class="comment"># plt.figure(figsize=(5,6))   自定义宽,高(但实际上可以用鼠标拉长)</span></span><br><span class="line">plt.title(<span class="string">&#x27;a line&#x27;</span>)   <span class="comment"># 图的名称</span></span><br><span class="line">plt.plot(x,y)    <span class="comment"># 生成图,x轴数组为x,y轴数组为y</span></span><br><span class="line">plt.show()     <span class="comment"># 将该图展现出来</span></span><br></pre></td></tr></table></figure>
<p><img src="./python-pyplot/plt_figure.png" style="zoom: 33%;" /></p>
<p>如图，底栏所示功能编号1-7</p>
<ol type="1">
<li>返回首页(即一开始看到的页面)</li>
</ol>
<p>​ 2-3. 后退/前进</p>
<ol start="4" type="1">
<li>移动</li>
<li>放大窗口</li>
<li>调整图的边界参数</li>
<li>保存当前窗口</li>
</ol>
<h2 id="自定义线">自定义线</h2>
<p>如果想在一个<code>figure</code>内画多条线，<code>plt.plot</code>还可以接受其他参数用于<strong>区分两条线</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = exp(x)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.plot(y,x,color=<span class="string">&#x27;red&#x27;</span>,linestyle=<span class="string">&#x27;--&#x27;</span>)<span class="comment"># 默认蓝色,这里改为红色,虚线</span></span><br><span class="line"><span class="comment"># linestyle可简写为ls,color可简写为c</span></span><br><span class="line">plt.plot(x,y,linestyle=(<span class="number">0</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))  <span class="comment"># 元组定义线型</span></span><br></pre></td></tr></table></figure>
<p><img src="./python-pyplot/plt_expFigure.png" style="zoom:33%;" /></p>
<p>关于元组定义线型，<code>(num,(n1,n2,n3,...))</code>表示以后面元组的值<strong>作为单位</strong>画线
例如<code>(0,(1,2,3))</code>指的是<code>(1磅实线,2磅空白,3磅实线)</code>，因为是<strong>奇数</strong>个，所以下一组变为<code>(1磅空白,2磅实线,3磅空白)</code>，所以一般来说，常用的是偶数个元素的元组
关于<code>num</code>，它用于在<strong>显示标签</strong>时<strong>偏移</strong>的长度，例如：</p>
<p><img src="./python-pyplot/plt_linestyle.png" alt="plt_linestyle" style="zoom:50%;" /></p>
<p><code>color</code>参数可用简写如<code>'r'(红色),'g'(绿色)</code>，多条曲线不指定颜色时会<strong>自动选择不同颜色</strong>，其它颜色如下：</p>
<ul>
<li><code>'m'</code>：洋红色</li>
<li><code>'w'</code>：白色</li>
<li><code>'k'</code>：黑色</li>
<li><code>'y'</code>：黄色</li>
<li><code>'g'</code>：绿色</li>
<li><code>'#000000'</code>：自定义<code>RGB</code>颜色字符串-&gt;<a
href="https://www.sojson.com/rgb.html">RGB颜色查询对照表</a></li>
</ul>
<p>其它常用<code>linestyle</code>如下：</p>
<ul>
<li><code>'-'/'solid'</code>：实线，默认</li>
<li><code>'--'/'doshed'</code>：虚线</li>
<li><code>':'/'dotted'</code>：点线</li>
<li><code>'-.'/dashdot</code>：点划线</li>
</ul>
<p>其它参数：</p>
<ul>
<li><code>label='name'</code>：设置这条线的标签，可用<code>plt.legend()</code>显示</li>
<li><code>linewidth=num</code>：线的宽度，默认为1，可简写为<code>lw</code></li>
<li><code>alpha</code>：线的透明度，范围<code>0~1</code></li>
<li><code>'bo'</code>：改为用蓝色<strong>实心圈</strong>绘制而非连线，常用于绘制单独的点，通过<strong>改变首字母来改变颜色</strong>，以下标记也可以在前面添加表示颜色的字母，不再赘述</li>
<li><code>'.'/','</code>：点/像素点(很小的点)绘制</li>
<li><code>'&lt;'/'&gt;'/'^'/'v'</code>：各种三角<img
src="https://www.runoob.com/images/m03.png" alt="m03" /></li>
<li><code>'1'/'2'/'3'/'4'</code>：各种三叉<img
src="https://www.runoob.com/images/m07.png" alt="m07" /></li>
<li><code>'*'</code>：星号绘制</li>
<li><code>'+'</code>：<strong>+</strong>号绘制，上面标记都<strong>只能跟在数组后且不能重复</strong></li>
</ul>
<p>如果只提供一个数组，则x会<strong>默认为<code>[0,1,...,N-1]</code></strong>，<code>N</code>为提供的数组的元素个数</p>
<h2 id="绘图标记">绘图标记</h2>
<p>除了改变线型，<code>pyplot</code>还可以用<code>marker</code>更改<strong>点的样式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(x,y,marker=<span class="string">&#x27;o&#x27;</span>) <span class="comment"># 每个点用实心圆代替(但是线型还是直线)</span></span><br><span class="line">plt.plot(x,y,marker=<span class="string">r&#x27;$\alpha$&#x27;</span>,markersize=<span class="number">10</span>,label=<span class="string">&#x27;name&#x27;</span>)  <span class="comment"># markersize可简写为ms</span></span><br><span class="line">plt.plot(x,y,marker=<span class="string">&#x27;*&#x27;</span>,mec=<span class="string">&#x27;r&#x27;</span>,mfc=<span class="string">&#x27;k&#x27;</span>) <span class="comment"># mec设置点边框的颜色,mfc设置点内部颜色</span></span><br><span class="line"><span class="comment"># mec:markeredgecolor, mfc:markerfacecolor</span></span><br></pre></td></tr></table></figure>
<p>除了线型所支持的标记外，点的标记还<strong>支持<code>Latex</code>语法</strong></p>
<p>可以用<code>fmt='[mk][line][color]'</code>参数快速设置点、线、色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(x,y,fmt=<span class="string">&#x27;o:k&#x27;</span>)  <span class="comment"># 实心圆(点),虚线(线),黑色(色)</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义坐标轴">自定义坐标轴</h2>
<h3 id="设置坐标轴的值">设置坐标轴的值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.xlim((<span class="number">0</span>,<span class="number">1</span>))  <span class="comment"># 限制x轴的范围</span></span><br><span class="line">plt.ylim((<span class="number">1</span>,<span class="number">2</span>))  <span class="comment"># 限制y轴的范围(也可以用[]括起)</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;label&#x27;</span>) <span class="comment"># 设定x轴的标签,即说明x轴是什么,同理可用plt.ylabel()设置y轴的标签</span></span><br><span class="line"><span class="comment"># loc属性:设置标签的位置,有right/left/center 默认center ---&gt; title(),legend()都有该属性</span></span><br><span class="line"><span class="comment"># ylabel的loc属性有top/bottom/center</span></span><br><span class="line"></span><br><span class="line">plt.xticks(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>)) <span class="comment"># 更改x轴的单位,默认每0.5为一个节点,这里设置为将0-1分割为5点</span></span><br><span class="line"><span class="comment"># 后面数组对应前面数组的值,可以改成自己需要的名称</span></span><br><span class="line">plt.xticks([<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>],[<span class="string">&#x27;none&#x27;</span>,<span class="string">&#x27;middle&#x27;</span>,<span class="string">&#x27;pretty good&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="./python-pyplot/plt_xticks.png" style="zoom:33%;" /></p>
<p>此外，后面数组还支持<code>Latex</code>语法，因为可能要用到转义字符等，所以这种情况需要在字符串前加上<code>'r'/'R'</code>，将它视为原始字符串<code>(raw string)</code>来解析，例如<code>plt.xticks([0,1,5],[r'$\theta$','$x$',r'$\Theta$'])</code>的效果为：</p>
<p><img src="./python-pyplot/plt_Latex.png" style="zoom:25%;" /></p>
<h3 id="移动坐标轴">移动坐标轴</h3>
<p>需要用到<code>gca()</code>方法，全称<code>get current axis</code>，一般将返回的对象称为<code>ax</code>，以下是隐藏右轴及上轴的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax = plt.gca() <span class="comment"># 获取前面这整张图的坐标轴,有上下左右四条轴</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;right&#x27;</span>,<span class="string">&#x27;top&#x27;</span>]:</span><br><span class="line"> ax.spines[i].set_color(<span class="string">&#x27;none&#x27;</span>) <span class="comment"># 可以通过spines[]更改对应轴的属性</span></span><br></pre></td></tr></table></figure>
<p>四条轴分别为：<code>top,bottom,left,right</code></p>
<p>需要移动坐标轴，则要用到<code>set_position()</code>方法，它接受元组参数，效果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>)) <span class="comment"># 将y轴移动到x=0的位置</span></span><br></pre></td></tr></table></figure>
<p><img src="./python-pyplot/plt_spines.png" style="zoom:33%;" /></p>
<p>一般来说，将坐标轴交点设置在<code>(0,0)</code>处的方法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;bottom&#x27;</span>]:</span><br><span class="line"> ax.spines[i].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h2 id="网格线">网格线</h2>
<p>可用<code>grid</code>方法设置网格线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.grid(<span class="literal">None</span>,which=<span class="string">&#x27;major&#x27;</span>,axis=<span class="string">&#x27;both&#x27;</span>,...) <span class="comment"># 其它参数和设置线型时类似</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>None</code>：是否显示网格线，如果后面接了其它参数，则默认为1，可设置为0</li>
<li><code>which</code>：显示主要/次要网格线，默认只显示主要，可改为<code>minor</code>或<code>both</code></li>
<li><code>axis</code>：显示某方向的网格线，默认为<code>both</code>，可改为<code>x</code>或<code>y</code></li>
</ul>
<h2 id="绘制子图">绘制子图</h2>
<p><code>pyplot</code>提供<code>subplot()</code>和<code>subplots()</code>方法，它能在一张画布中绘制多张图</p>
<h3 id="subplot"><code>subplot</code></h3>
<p><code>subplot</code>有三个必选参数，从左到右分别是<strong>行、列、标号</strong>，可以加可选参数例如共享轴、标签、投影类型等，返回<strong>一个对象</strong>，在<code>subplots</code>里将详细讲述对象作图
或者，把逗号删去，使用一个三位数的参数，例如<code>plt.subplot(111)</code></p>
<p>子图里可以改变图的投影类型，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()        <span class="comment"># 创建画布,或:</span></span><br><span class="line">fig = plt.figure()       <span class="comment"># 将画布赋给fig</span></span><br><span class="line">ax = plt.subplot(<span class="number">111</span>,projection=<span class="string">&#x27;polar&#x27;</span>) <span class="comment"># 极坐标投影,或:</span></span><br><span class="line">ax = plt.subplot(<span class="number">111</span>,polar=<span class="number">1</span>)    <span class="comment"># 等效</span></span><br></pre></td></tr></table></figure>
<p>其它投影类型还有：</p>
<ul>
<li><code>aitoff</code></li>
<li><code>hammer</code></li>
<li><code>lambert</code></li>
<li><code>mollweide</code></li>
</ul>
<p>这些投影类型需借助其它库，超出了<code>pyplot</code>的范围，且都用作绘制世界地图，故不细讲</p>
<p>注意到这个<code>fig</code>对象，它让切分画布变得便利：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax1 = fig.add_subplot(<span class="number">111</span>)   <span class="comment"># 将左上角的区域切分出来</span></span><br></pre></td></tr></table></figure>
<h3 id="subplots"><code>subplots</code></h3>
<p><code>subplots</code>用于一次性创建多个子图，并返回数组对象方便操作，现在介绍不同于上述用<strong>函数作图</strong>的<strong>对象作图</strong>方法，这种方法更<strong>常用</strong>，便于进行精细化操作。当然，如果只需要简单的图形，用函数作图的方式也无妨</p>
<p>它利用<code>subplots</code>返回画布和图对象，通过<strong>改变对象的属性</strong>，进行对特定画布中特定部分的修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots()  <span class="comment"># 返回画布,图数组(这里没给参数,默认生成一张图)</span></span><br><span class="line">ax.plot(x,y)</span><br></pre></td></tr></table></figure>
<p>这里的<code>ax</code>指的是<code>axes</code>，即画布中的一部分。这里因为只生成一张图，所以只有一个<code>axes</code></p>
<p>这种方法就不需要<code>plt.figure()</code>了，因为<code>subplots()</code>返回时就已创建一张画布了</p>
<p>此外，还可以设置共享轴与投影形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,(ax1,ax2) = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,sharex=<span class="number">1</span>,sharey=<span class="number">1</span>) <span class="comment"># 1即所有子图共享,0即所有子图独立</span></span><br><span class="line"><span class="comment"># 改变图形与subplot不同,需要将参数转换为字典传进去</span></span><br><span class="line">fig,ax3 = plt.subplots(<span class="number">1</span>,<span class="number">1</span>,subplot_kw=<span class="built_in">dict</span>(projection=<span class="string">&#x27;polar&#x27;</span>))</span><br><span class="line">fig,ax3 = plt.subplots(<span class="number">1</span>,<span class="number">1</span>,subplot_kw=<span class="built_in">dict</span>(polar=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>还可设置为<code>col</code>(每列子图共享，列与列间独立)，<code>row</code>(每行子图共享，行与行间独立)</p>
<p>其它设置与函数作图类似但部分有所不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,axs = plt.subplots(<span class="number">2</span>,<span class="number">2</span>)      <span class="comment"># 两行两列,返回数组,用坐标访问</span></span><br><span class="line">axs[<span class="number">0</span>,<span class="number">0</span>].set_title(<span class="string">&#x27;titleName&#x27;</span>)     <span class="comment"># 标题</span></span><br><span class="line">axs[<span class="number">0</span>,<span class="number">0</span>].plot(x,y,lw=<span class="number">1</span>,c=<span class="string">&#x27;r&#x27;</span>,marker=<span class="string">&#x27;*&#x27;</span>,...) <span class="comment"># plot</span></span><br><span class="line">axs[<span class="number">0</span>,<span class="number">0</span>].set_xticks(array)      <span class="comment"># 轴的单位</span></span><br><span class="line">axs[<span class="number">0</span>,<span class="number">0</span>].set_xlim(-<span class="number">1</span>,<span class="number">1</span>)       <span class="comment"># 轴的范围</span></span><br><span class="line">axs[<span class="number">0</span>,<span class="number">0</span>].spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)  <span class="comment"># 隐藏轴</span></span><br><span class="line">axs[<span class="number">0</span>,<span class="number">0</span>].axis(<span class="string">&#x27;off&#x27;</span>)       <span class="comment"># 隐藏所有轴,可以用xaxis/yaxis</span></span><br><span class="line">axs[<span class="number">0</span>,<span class="number">0</span>]<span class="number">1.</span>set_xlabel(<span class="string">&#x27;labelName&#x27;</span>)    <span class="comment"># 给x轴加标注</span></span><br></pre></td></tr></table></figure>
<h2 id="其它图形">其它图形</h2>
<p>接下来简略介绍其它图形的绘制</p>
<h3 id="散点图scatter">散点图<code>(scatter)</code></h3>
<p>除了<code>x、y</code>外，其它参数可以有：<code>marker(改变点的样式),s(点的大小),c(点的颜色),lw</code>等已经讲过的，和：</p>
<ul>
<li><p><code>cmap(colormap)</code>：调色盘，只有当<code>c</code>是一个浮点数数组时启用，会将这些数值对应到调色盘内的某个颜色。默认为<code>viridis</code>，可以通过以下命令查看颜色条</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># c=y,则y的数值大小可以清晰地映射到颜色条上</span></span><br><span class="line">plt.scatter(x,y,c=y,cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">plt.colorbar()           <span class="comment"># 函数作图</span></span><br><span class="line">ax.figure.colorbar(ax.scatter(x,y,c=y,cmap=<span class="string">&#x27;viridis&#x27;</span>)) <span class="comment"># 对象作图</span></span><br></pre></td></tr></table></figure>
<p>其它可选调色盘：</p>
<p><img src="./python-pyplot/plt_colorbar.png" style="zoom: 50%;" /></p></li>
<li><p><code>vmin,vmax</code>：调节颜色条的范围，大于<code>vmax</code>的数值将被强制映射到<code>vmax</code>上，<code>vmin</code>同理</p></li>
<li><p><code>norm</code>：也是用于调节范围的，优先级高于上一条，参数没搞懂，有如下：</p>
<ul>
<li><code>linear</code></li>
<li><code>log</code></li>
<li><code>symlog</code></li>
<li><code>asinh</code></li>
<li><code>logit</code></li>
<li><code>function</code></li>
<li><code>functionlog</code></li>
</ul></li>
</ul>
<h3 id="柱形图barbarh">柱形图<code>(bar/barh)</code></h3>
<p><code>bar</code>即纵向柱形图，<code>barh</code>即横向柱形图。除<code>x,y</code>外的其它参数有：</p>
<ul>
<li><code>width</code>：浮点数数组，表示柱子宽度</li>
<li><code>height</code>：浮点数数组，表示横向柱子的宽度，它是<code>barh()</code>的参数</li>
<li><code>bottom</code>：底线值，即<code>y=?</code>，默认0</li>
<li><code>color</code>：颜色，不能缩写为<code>c</code>，可接受颜色数组</li>
<li><code>align</code>：对齐方式，默认<code>center</code>，即值的中间，可改为<code>edge</code>(左对齐)，如要实现右对齐，可以传递负数宽度值</li>
</ul>
<h3 id="饼图pie">饼图<code>(pie)</code></h3>
<p>饼图的参数有点不同，它只需要一个<code>x</code>的参数，且它必须是非负数、非字符串的值。其它参数如下：</p>
<ul>
<li><code>explode</code>：一个数组，表示各个扇形的间隔。一般来说，没有显式说明的第二个参数默认为它</li>
<li><code>labels</code>：一个列表，表示各个扇形的标签</li>
<li><code>colors</code>：自定义颜色</li>
<li><code>autopct</code>：数值显示形式，与<code>C</code>语言类似，<code>%d</code>表示整数，<code>%0.1f</code>表示一位小数，在后面加上<code>%%</code>表示百分比形式显示</li>
<li><code>labeldistance</code>：标签的位置，默认1.1，即饼图外侧</li>
<li><code>pctdistance</code>：与上一条类似，表示数值的位置</li>
<li><code>shadow</code>：饼图是否有阴影，默认为0</li>
<li><code>radius</code>：饼图半径</li>
</ul>
<p>其它参数实用性不强，这里不再说明</p>
<h3 id="直方图hist">直方图<code>(hist)</code></h3>
<p>直方图用于统计数的个数，也只需要提供<code>x</code>。其它参数如下：</p>
<ul>
<li><code>bins</code>：箱数，默认为10。<code>hist</code>将直方图分为<code>bins</code>个等距区间(即箱)，每个箱子的柱高表示这个区间内数的个数</li>
<li><code>density</code>：是否以频率显示。默认为0，即默认为统计个数而非频率</li>
<li><code>weights</code>：数组，表示每个箱子的权重，箱子中每有一个数就会乘以这个权重值</li>
<li><code>bottom</code>：与柱形图功能相同</li>
<li><code>histtype</code>：直方图样式，可选参数有(一些没有区别的已省去)：
<ul>
<li><code>bar</code>：默认值</li>
<li><code>step</code>：空心柱</li>
</ul></li>
</ul>
<h2 id="其它装饰">其它装饰</h2>
<h3 id="复杂子图">复杂子图</h3>
<p>在讲述<code>subplots</code>时，只是提到了一个简便的画图方法，如果需要更加精细地切分画布，这种规规整整的方式就不行了。于是我们需要用到网格：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">ax1 = plt.subplot2grid((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># 将画布切分为2行2列,并把(0,0)网格返回给ax对象</span></span><br><span class="line">ax2 = plt.subplot2grid((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">0</span>),colspan=<span class="number">2</span>) <span class="comment"># ax2占满第二行</span></span><br><span class="line">ax3 = plt.subplot2grid((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">1</span>),rowspan=<span class="number">2</span>) <span class="comment"># ax3占满第二列</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>matplotlib.gridspec</code>模块实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line">plt.figure()</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>,<span class="number">3</span>)  <span class="comment"># 将画布切分成3行3列</span></span><br><span class="line">ax1 = plt.subplot(gs[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">ax2 = plt.subplot(gs[<span class="number">1</span>:,<span class="number">1</span>])</span><br><span class="line">ax3 = plt.subplot(gs[-<span class="number">1</span>,-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>网格坐标写法有如下：</p>
<ol type="1">
<li><code>start:end</code>：从<code>start</code>开始占到<code>end</code>，例如<code>[1:,1]</code>为占了第一列的第二行到最后一行</li>
<li><code>-num</code>：倒数第<code>num</code>行</li>
</ol>
<p>这还是有点方正了，如果想随心所欲改变图的长宽，可以用<code>update</code>方法或<code>plt.subplots_adjust</code>，它们的参数是类似的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gs1 = gridspec.GridSpec(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">gs1.update(left=<span class="number">0</span>,right=<span class="number">0.5</span>) <span class="comment"># 限定gs1网格只占画布的左边</span></span><br></pre></td></tr></table></figure>
<p>其它参数：</p>
<ul>
<li><code>wspace</code>：横向子图的间距，默认<code>0.2</code></li>
<li><code>hspace</code>：纵向子图的间距，默认<code>0.2</code></li>
<li><code>top,bottom</code>：上边界和下边界</li>
</ul>
<h3 id="中文显示">中文显示</h3>
<p>需要在开头加上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&quot;font.family&quot;</span>]=<span class="string">&quot;SimHei&quot;</span> <span class="comment"># 将字体名称设置为&quot;SimHei&quot;(黑体)</span></span><br></pre></td></tr></table></figure>
<p>关于其它字体的设置：<a
href="https://blog.csdn.net/qq_35240689/article/details/130924160">链接</a></p>
<p>但是在正则表达式中似乎无效</p>
<h3 id="tick_params"><code>tick_params()</code></h3>
<p>通过这个方法可以让刻度线消失：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.tick_params(length=<span class="number">0</span>) <span class="comment"># 直接设置刻度线的长度,或</span></span><br><span class="line">ax.tick_params(bottom=<span class="number">0</span>) <span class="comment"># 不显示底轴的刻度线</span></span><br></pre></td></tr></table></figure>
<h2 id="实例">实例</h2>
<p><code>code</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    x = np.linspace(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">30</span>)</span><br><span class="line">    xSin = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi,<span class="number">30</span>)</span><br><span class="line">    theta = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi,<span class="number">30</span>)</span><br><span class="line">    yExp = np.exp(x)</span><br><span class="line">    ySin = np.sin(xSin)</span><br><span class="line">    rHeart = np.sin(theta)</span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="comment"># 左网格</span></span><br><span class="line">    gsL = gridspec.GridSpec(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    gsL.update(left=<span class="number">0.05</span>,right=<span class="number">0.4</span>,wspace=<span class="number">0.4</span>)</span><br><span class="line">    axSin = plt.subplot(gsL[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">    axPol = plt.subplot(gsL[<span class="number">0</span>,<span class="number">1</span>], polar=<span class="number">1</span>)  <span class="comment"># 心形线极坐标映射</span></span><br><span class="line">    axExp = plt.subplot(gsL[<span class="number">1</span>,:])           <span class="comment"># 占满第二行</span></span><br><span class="line"></span><br><span class="line">    axSin.plot(xSin,ySin)</span><br><span class="line">    axSin.set_xticks([<span class="number">0</span>,np.pi,<span class="number">2</span>*np.pi],[<span class="number">0</span>,<span class="string">r&#x27;$\pi$&#x27;</span>,<span class="string">r&#x27;$2\pi$&#x27;</span>])</span><br><span class="line">    axSin.set_title(<span class="string">&#x27;y=sinx&#x27;</span>,backgroundcolor=<span class="string">&#x27;skyblue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    axPol.plot(theta, rHeart)</span><br><span class="line">    axPol.set_title(<span class="string">r&#x27;$\rm r=sin\theta$&#x27;</span>,backgroundcolor=<span class="string">&#x27;skyblue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    axExp.plot(x,yExp,label=<span class="string">r&#x27;$y=e^x$&#x27;</span>)</span><br><span class="line">    axExp.plot(yExp,x,ls=(<span class="number">0</span>,(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)),label=<span class="string">&#x27;y=lnx&#x27;</span>)</span><br><span class="line">    axExp.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],<span class="string">&#x27;ko&#x27;</span>)</span><br><span class="line">    axExp.set_xlim(-<span class="number">0.5</span>,<span class="number">2</span>)</span><br><span class="line">    axExp.set_ylim(-<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">    axExp.set_xticks(np.linspace(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">    axExp.set_yticks(np.linspace(-<span class="number">5</span>,<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line">    axExp.tick_params(length=<span class="number">0</span>)</span><br><span class="line">    axExp.set_title(<span class="string">r&#x27;$\rm y=e^x\ &amp;\ y=\ln x$&#x27;</span>,backgroundcolor=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;right&#x27;</span>,<span class="string">&#x27;top&#x27;</span>]:</span><br><span class="line">        axSin.spines[i].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">        axExp.spines[i].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;bottom&#x27;</span>]:</span><br><span class="line">        axSin.spines[i].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line">        axExp.spines[i].set_position((<span class="string">&#x27;data&#x27;</span>,<span class="number">0</span>))</span><br><span class="line">    <span class="comment"># 右网格</span></span><br><span class="line">    gsR = gridspec.GridSpec(<span class="number">2</span>,<span class="number">2</span>,left=<span class="number">0.5</span>,right=<span class="number">0.9</span>,hspace=<span class="number">0.3</span>)</span><br><span class="line">    axDens = plt.subplot(gsR[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">    axNums = plt.subplot(gsR[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">    axPie = plt.subplot(gsR[<span class="number">1</span>,:])</span><br><span class="line"></span><br><span class="line">    rng = np.random</span><br><span class="line">    xNums1 = rng.randn(<span class="number">1000</span>)</span><br><span class="line">    xNums2 = rng.randn(<span class="number">1000</span>)</span><br><span class="line">    axDens.hist(xNums1,alpha=<span class="number">0.7</span>,color=<span class="string">&#x27;skyblue&#x27;</span>,</span><br><span class="line">                bins=<span class="number">100</span>,weights=[np.array(<span class="number">2</span>)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)],density=<span class="number">1</span>)</span><br><span class="line">    axDens.hist(xNums2,alpha=<span class="number">0.7</span>,color=<span class="string">&#x27;pink&#x27;</span>,bins=<span class="number">100</span>,density=<span class="number">1</span>)</span><br><span class="line">    axDens.tick_params(length=<span class="number">0</span>)</span><br><span class="line">    axDens.set_title(<span class="string">&#x27;two groups\&#x27;s density&#x27;</span>,backgroundcolor=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    axNums.hist(xNums1,alpha=<span class="number">0.7</span>,color=<span class="string">&#x27;skyblue&#x27;</span>,</span><br><span class="line">                bins=<span class="number">100</span>,weights=[np.array(<span class="number">2</span>)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)])</span><br><span class="line">    axNums.hist(xNums2,alpha=<span class="number">0.7</span>,color=<span class="string">&#x27;pink&#x27;</span>,bins=<span class="number">100</span>)</span><br><span class="line">    axNums.tick_params(length=<span class="number">0</span>)</span><br><span class="line">    axNums.set_title(<span class="string">&#x27;two groups&#x27;</span>,backgroundcolor=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    axPie.pie([<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>],colors=[<span class="string">&#x27;#a4f9e4&#x27;</span>,<span class="string">&#x27;#f9c5a4&#x27;</span>,<span class="string">&#x27;#c9a4f9&#x27;</span>,<span class="string">&#x27;#d1f9a4&#x27;</span>],</span><br><span class="line">              autopct=<span class="string">&quot;%d%%&quot;</span>,radius=<span class="number">1.5</span>,</span><br><span class="line">              labels=[<span class="string">&#x27;yorushika&#x27;</span>,<span class="string">&#x27;atarayo&#x27;</span>,<span class="string">&#x27;zutomayo&#x27;</span>,<span class="string">&#x27;yoasobi&#x27;</span>],</span><br><span class="line">              labeldistance=<span class="number">0.7</span>,</span><br><span class="line">              pctdistance=<span class="number">0.3</span>,</span><br><span class="line">              shadow=<span class="number">1</span>,</span><br><span class="line">              explode=[<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">    axPie.set_title(<span class="string">&quot;The four &#x27;YoRu&#x27;s in my mind&quot;</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><code>run</code>：</p>
<p><img src="plt_run.png" alt="plt_run" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
        <category>Data Science Utils</category>
      </categories>
      <tags>
        <tag>pyplot</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 练习题</title>
    <url>/blogs/2023/12/11/calculus-exercise-1/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="极限">极限</h1>
<h2 id="函数极限">函数极限</h2>
<p><span class="math inline">$\begin{align}&amp;1.\lim_{x\rightarrow
0}\frac{\tan x-\sin
x}{x\ln(1+\sin^2x)}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{\tan x-\sin
x}{x^3}=\frac12\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;2.\lim_{x\rightarrow0}\frac{(x-\sin
x)e^{-x^2}}{\sqrt{1-x^3}-1}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{\frac16x^3}{-\frac12x^2}=-\frac13\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;3.\lim_{x\rightarrow0}\frac{\ln(e^{\sin
x}+\sqrt[3]{1-\cos x})-\sin x}{\arctan(4\sqrt[3]{1-\cos
x})}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{e^{\sin x}+\sqrt[3]{1-\cos
x}-1-\sin x}{4\sqrt[3]{1-\cos
x}}\\&amp;=\lim_{x\rightarrow0}\frac{1+\sin x+\frac{\sin^2x}2-1-\sin
x+o(x^2)}{4\sqrt[3]{1-\cos
x}}+\frac14\\&amp;=\frac14\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;4.\lim_{x\rightarrow0}\frac{1-\cos
x\sqrt{\cos 2x}\sqrt[3]{\cos
3x}}{x^2}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{1-\cos x+\cos
x(1-\sqrt{\cos 2x}+\sqrt{\cos 2x}(1-\sqrt[3]{\cos
3x}))}{x^2}\\&amp;=\lim_{x\rightarrow0}\frac{\frac12x^2+\frac12(1-\cos
2x)+\frac13(1-\cos
3x)}{x^2}=\lim_{x\rightarrow0}\frac{\frac12x^2+x^2+\frac32x^2}{x^2}=3\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;5.\lim_{x\rightarrow\frac\pi2}\frac{(1-\sqrt{\sin
x})(1-\sqrt[3]{\sin x})\cdots(1-\sqrt[n]{\sin x})}{(1-\sin
x)^{n-1}}\\&amp;=\lim_{x\rightarrow\frac\pi2}\frac{\frac1{n!}(1-\sin
x)^{n-1}}{(1-\sin x)^{n-1}}=\frac1{n!}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;6.\lim_{x\rightarrow0}\frac{\sqrt{\frac{1+x}{1-x}}\sqrt[4]{\frac{1+2x}{1-2x}}\sqrt[6]{\frac{1+3x}{1-3x}}\cdots\sqrt[2n]{\frac{1+nx}{1-nx}}-1}{3\pi\arctan
x-(x^2+1)\arctan^3x},n为正整数\\&amp;解:原式\xlongequal{\ln极限逆用}\lim_{x\rightarrow0}\frac{\ln(\sqrt{\frac{1+x}{1-x}}\sqrt[4]{\frac{1+2x}{1-2x}}\sqrt[6]{\frac{1+3x}{1-3x}}\cdots\sqrt[2n]{\frac{1+nx}{1-nx}})}{3\pi\arctan
x-(x^2+1)\arctan^3x}\\&amp;=\lim_{x\rightarrow0}\frac{\frac12(\frac2{1-x}-2)+\frac14(\frac{2}{1-2x}-2)+\cdots}{3\pi
x-x^5-x^3}\\&amp;=\lim_{x\rightarrow0}\frac{\frac{x}{1-x}+\frac
x{1-2x}+\cdots}{3\pi x-x^5-x^3}=\lim_{x\rightarrow}\frac{nx}{3\pi
x}=\frac n{3\pi}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;7.\lim_{x\rightarrow\infty}\frac{(\int_0^xe^{u^2}\mathrm
du)^2}{\int_0^xe^{2u^2}\mathrm
du}\\&amp;解:原式=\lim_{x\rightarrow\infty}\frac{2\int_0^xe^{u^2}\mathrm
du}{e^{x^2}}=2\lim_{x\rightarrow\infty}\frac{e^{x^2}}{2xe^{x^2}}=0\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;8.\lim_{x\rightarrow0}\left(\frac{e^x+e^{2x}+\cdots+e^{nx}}n\right)^{\Large\frac
ex}\\&amp;解:原式=e^{\lim_{x\rightarrow0}{\Large\frac
ex}\ln(1+\frac{e^x+e^{2x}+\cdots+e^{nx}}n-1)}\\&amp;幂上极限为\lim_{x\rightarrow0}\frac
ex\frac{e^x+e^{2x}+\cdots+e^{nx}-n}n\\&amp;=\lim_{x\rightarrow0}\frac
ex\frac{x+2x+\cdots+nx}n=\frac{(n+1)e}{2}\\&amp;故原极限=e^{\Large\frac{(n+1)e}2}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;9.若f(x)在点x=a处可导,且f(a)\ne0,则\lim_{n\rightarrow\infty}\left(\frac{f\left(a+\frac1n\right)}{f(a)}\right)^n\\&amp;原式=e^{\lim_\limits{n\rightarrow\infty}n\ln(\frac{f\left(a+\frac1n\right)}{f(a)})}\\&amp;幂上极限=\lim_{n\rightarrow\infty}
n\frac{f\left(a+\frac1n\right)-f(a)}{f(a)}=\frac{f'(a)}{f(a)}\\&amp;故原极限=e^{\Large\frac{f'(a)}{f(a)}}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;10.\lim_{x\rightarrow\infty}e^{-x}\left(1+\frac1x\right)^{x^2}\\&amp;解:原式=e^{\lim_\limits{x\rightarrow\infty}-x+x^2\ln(1+\frac1x)}=e^{\lim_\limits{x\rightarrow\infty}(-x+x^2(\frac1x-\frac1{2x^2}+o(x^2)))}=e^{-\frac12}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;11.\lim_{x\rightarrow0}\frac{\sin^2x-x^2\cos^2x}{x^2\sin^2x}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{(\sin
x-x+x(1-\cos x))(\sin x-x+x(1+\cos
x))}{x^4}\\&amp;=\lim_{x\rightarrow0}\frac{(-\frac16x^3+\frac12x^3)(-\frac16x^3+2x)}{x^4}=-\frac13+1=\frac23\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.若f(1)=0,f'(1)存在,则极限\lim_{x\rightarrow0}\frac{f(\sin
^2x+\cos x)\tan 3x}{(e^{x^2}-1)\sin
x}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{f(1+\sin^2x+\cos
x-1)-f(1)}{\sin^2x+\cos x-1}·\frac{\tan 3x(\sin^2x+\cos
x-1)}{(e^{x^2}-1)\sin
x}\\&amp;=f'(1)·\lim_{x\rightarrow0}\frac{3x(x^2-\frac12x^2)}{x^3}=\frac32f'(1)\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;13.设f(x)有二阶连续导数,且f(0)=f'(0)=0,f''(0)=6,则\lim_{x\rightarrow0}\frac{f(\sin
^2x)}{x^4}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{\sin2x·f'(\sin^2x)}{4x^3}=\lim_{x\rightarrow0}\frac{f'(\sin^2x)-f'(0)}{2\sin^2x}=3\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;14.设f(x)在点x=1附近有定义,且在点x=1处可导,f(1)=0,f'(1)=2,求\lim_{x\rightarrow0}\frac{f(\sin
x+\cos x)}{x^2+x\tan
x}\\&amp;解:原式=\lim_{x\rightarrow0}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.\end{align}$</span></p>
<h2 id="数列极限">数列极限</h2>
<h1 id="一元积分学">一元积分学</h1>
<h2 id="不定积分">不定积分</h2>
<h3 id="常见微分等式">常见微分等式</h3>
<ul>
<li><span class="math inline">$\begin{align}\mathrm
d\left(\ln(x+\sqrt{\pm k^2+x^2})\right)=\frac1{\sqrt{\pm
k^2+x^2}}\end{align}$</span></li>
<li><span class="math inline">$\begin{align}\mathrm d\left(x\pm\frac
kx\right)=1\mp\frac k{x^2}\end{align}$</span>，由于<span
class="math inline">$\begin{align}\left(x\pm\frac
kx\right)^2=x^2+\frac{k^2}{x^2}\pm2k\end{align}$</span>，遇到<strong>分子分母分别为二次、四次多项式，且不包含奇数幂次</strong>时，可考虑用分子凑出该微分，而分母通过<strong>配方</strong>化作该式的平方，实现降幂</li>
<li><span class="math inline">$\begin{align}\mathrm d(\sin x\pm\cos
x)=\cos x\mp\sin x\end{align}$</span>，在处理<span
class="math inline">sin <em>x</em>cos <em>x</em></span>时很有效</li>
</ul>
<h3 id="常见计算技巧">常见计算技巧</h3>
<ul>
<li>更换积分对象：
<ul>
<li>分部积分：<span class="math inline">$\begin{align}\int u\mathrm
dv=uv-\int v\mathrm
du\end{align}$</span>，若分部后的积分容易算，采用分部积分</li>
<li>例一：分母带平方或其它幂次方，可尝试用分母凑微分，实现分母降幂</li>
</ul></li>
<li>三角代换或三角公式：
<ul>
<li>包含<span class="math inline">$\begin{align}\sqrt{k^2+x^2}\mathrm
dx\end{align}$</span>的表达式，可令<span
class="math inline"><em>x</em> = <em>k</em>tan <em>t</em></span>，则<span
class="math inline">$\mathrm dx=k\sec^2t\,\mathrm
dt、\sqrt{k^2+x^2}=k\sec t$</span>
<ul>
<li>此外，通过直角三角形可知，<span
class="math inline">$\begin{align}\sin t=\frac x{\sqrt{1+x^2}}、\cos
t=\frac1{\sqrt{1+x^2}}\end{align}$</span></li>
<li>例如<span class="math inline">$\begin{align}&amp;\int\frac{\mathrm
dx}{\sqrt{1+x^2}}\xlongequal{x=\tan t}\int\sec t\,\mathrm
dt=\int\frac{\mathrm d(\sin t)}{1-\sin^2t}\\&amp;=\ln(\sqrt{\frac{1+\sin
t}{1-\sin t}})+C=\ln(x+\sqrt{1+x^2})+C\end{align}$</span></li>
</ul></li>
<li>包含<span class="math inline">$\sqrt{k^2-x^2}\mathrm
dx$</span>的表达式，可令<span
class="math inline"><em>x</em> = <em>k</em>sin <em>t</em></span>或<span
class="math inline"><em>x</em> = <em>k</em>cos <em>t</em></span></li>
<li>包含<span class="math inline">$\sqrt{x^2-k^2}\mathrm
dx$</span>的表达式，可令<span
class="math inline"><em>x</em> = <em>k</em>sec <em>t</em></span>，则<span
class="math inline">$\begin{align}\mathrm dx=k\frac{\sin
x}{\cos^2x}、\sqrt{x^2-k^2}=k\tan x\end{align}$</span></li>
<li>通过倍角公式，当分母是关于三角函数的多项式时，将其变为单项式</li>
<li>通过辅助角公式，将所有<span
class="math inline">sin <em>x</em> ± cos <em>x</em>、sin <em>x</em>cos <em>x</em></span>统一为一个含有特定角度的三角函数；或者取<span
class="math inline">sin <em>x</em> ± cos <em>x</em></span>化为<strong>微分</strong><span
class="math inline">d(±sin<em>x</em>−cos<em>x</em>)</span>，将剩余的<span
class="math inline">sin <em>x</em>cos <em>x</em></span>化为<span
class="math inline">(±sin<em>x</em>−cos<em>x</em>)<sup>2</sup> + <em>k</em></span>的形式后，令<span
class="math inline"><em>t</em> =  ± sin <em>x</em> − cos <em>x</em></span></li>
</ul></li>
<li>微分代换：分母根式借助<strong>配方</strong>和微分等式代换，但一般没有三角代换常用
<ul>
<li><span class="math inline">$\begin{align}\mathrm d(\arcsin
x)=\frac1{\sqrt{1-x^2}}\end{align}$</span></li>
<li><span class="math inline">$\begin{align}\mathrm
d\left(\ln(x+\sqrt{1+x^2})\right)=\frac1{\sqrt{1+x^2}}\end{align}$</span></li>
</ul></li>
<li>区间再现：实际上是定积分的技巧，包括正弦、余弦函数的华里士公式；体现在不定积分上，实际上就是通过分部积分导出的含有重复待求积分的式子。当幂数不常见时，可通过该方法求出递推式z</li>
<li>欧拉变换：设被积函数为关于<span
class="math inline"><em>x</em></span>的，包含<span
class="math inline">$\sqrt{ax^2+bx+c}$</span>根式的函数
<ul>
<li>欧拉第一代换：若<span
class="math inline"><em>a</em> &gt; 0</span>，则可令整个根式<span
class="math inline">$=t\pm\sqrt ax$</span></li>
<li>欧拉第二代换：若<span
class="math inline"><em>c</em> &gt; 0</span>，则可令整个根式<span
class="math inline">$=xt\pm\sqrt c$</span></li>
<li>欧拉第三代换：若可十字相乘(有两不同实根)，可令整个根式<span
class="math inline"> = <em>t</em>(<em>x</em>−<em>x</em><sub>1</sub>)</span>，其中<span
class="math inline"><em>x</em><sub>1</sub></span>为其中一个实根</li>
</ul></li>
<li>万能代换将三角函数换为有理式：令<span
class="math inline">$\begin{align}t=\tan\frac
x2\end{align}$</span>，则<span class="math inline">$\begin{align}\sin
x=\frac{2t}{1+t^2}、\cos t=\frac{1-t^2}{1+t^2}、\mathrm
dx=\frac{2}{1+t^2}\mathrm dt\end{align}$</span></li>
<li>积分抵消：仍是通过分部积分<span
class="math inline">$\begin{align}uv=\int u\mathrm dv+\int v\mathrm
du\end{align}$</span>，若两个不定积分都不好求，但刚好能凑出两个该形式的不定积分，则可合成一个<span
class="math inline"><em>u</em><em>v</em></span>；有时有两个不相关的不定积分，也可尝试分别分部积分，分出的部分可能是有关的</li>
</ul>
<h3 id="题集">题集</h3>
<p>典型分母降幂</p>
<p><span class="math inline">$\begin{align}&amp;1.\int\frac{e^{-\sin
x}\sin 2x}{(1-\sin x)^2}\mathrm dx\\&amp;解:原式=2\int e^{-\sin x}\sin
x\ \mathrm d\left(\frac1{1-\sin x}\right)=2\left(\frac{e^{-\sin x}\sin
x}{1-\sin x}-\int\frac{\mathrm d(e^{-\sin x}\sin x)}{1-\sin
x}\right)\\&amp;=2\left(\frac{e^{-\sin x}\sin x}{1-\sin x}-\int e^{-\sin
x}\mathrm d(\sin x)\right)=\frac{2e^{-\sin x}}{1-\sin
x}+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;2.\int\frac{x^2e^x}{(x+2)^2}\mathrm
dx\\&amp;解:原式=-\int x^2e^x\mathrm
d\left(\frac1{x+2}\right)=-\left(\frac{x^2e^x}{x+2}-\int\frac{\mathrm
d(x^2e^x)}{x+2}\right)=\frac{x-2}{x+2}e^x+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;3.\int\frac{(2x+1)e^{-2x}}{x^2}\mathrm
dx\\&amp;解:原式=-\int(2x+1)e^{-2x}\mathrm
d\left(\frac1{x}\right)=-\left(\frac{(2x+1)e^{-2x}}x-\int\frac{\mathrm
d((2x+1)e^{-2x})}x\right)=-\frac{e^{-2x}}x+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;4.\int\frac{x\ln(x+\sqrt{1+x^2})}{(1+x^2)^2}\mathrm
dx\\&amp;原式=-\frac12\int\ln(x+\sqrt{1+x^2})\mathrm
d\left(\frac1{1+x^2}\right)\\&amp;=-\frac12\left(\frac{\ln(x+\sqrt{1+x^2})}{1+x^2}-\int\frac{\mathrm
d\left(\ln(x+\sqrt{1+x^2})\right)}{1+x^2}\right)\\&amp;=-\frac12\left(\frac{\ln(x+\sqrt{1+x^2})}{1+x^2}-\int\frac{\mathrm
dx}{(1+x^2)^{\frac32}}\right)\xlongequal{三角代换}\frac{x\sqrt{1+x^2}-\ln(x+\sqrt{1+x^2})}{2(1+x^2)}+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;5.\int\frac{\ln(x+\sqrt{1+x^2})}{(1+x^2)^\frac32}\mathrm
dx\\&amp;解:原式=\int\ln(x+\sqrt{1+x^2})\mathrm d\left(\frac
x{(1+x^2)^\frac12}\right)=\frac{x\ln(x+\sqrt{1+x^2})}{(1+x^2)^\frac12}-\int\frac{x\mathrm
dx}{1+x^2}\\&amp;=\frac{x\ln(x+\sqrt{1+x^2})}{\sqrt{1+x^2}}-\frac12\ln(1+x^2)+C\end{align}$</span></p>
<hr />
<p>积分抵消，最后一步可不写</p>
<p><span
class="math inline">$\begin{align}&amp;6.\int\left(1+x-\frac1x\right)e^{x+\frac1x}\mathrm
dx\\&amp;解:原式=\int\left[1+x\left(1-\frac1{x^2}\right)\right]e^{x+\frac1x}\mathrm
dx=\int e^{x+\frac1x}\mathrm dx+\int x\mathrm
d(e^{x+\frac1x})\\&amp;=I+xe^{x+\frac1x}-I=xe^{x+\frac1x}+C\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;7.\int\frac{x+\sin
x}{1+\cos x}\mathrm dx\\&amp;解:原式=\int\frac{x+\sin
x}{2\cos^2{\large\frac x2}}\mathrm dx=\int\frac{x\,\mathrm
dx}{2\cos^2{\large\frac x2}}+\int\tan\frac x2\mathrm dx\\&amp;=\int
x\,\mathrm d\left({\tan\frac x2}\right)+\int\tan\frac x2\mathrm
dx\xlongequal{分部积分}x\tan\frac x2+C\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;8.\int e^{2x}(1+\tan
x)^2\mathrm dx\\&amp;解一:原式\xlongequal{x=\arctan t}\int e^{2\arctan
t}\frac{(1+t)^2}{1+t^2}\mathrm dt=\int e^{2\arctan t}\mathrm dt+\int
e^{2\arctan t}\frac{2t}{t^2+1}\mathrm dt\\&amp;=\int e^{2\arctan
t}\mathrm dt+\int t\mathrm d\left(e^{2\arctan t}\right)=te^{2\arctan
t}+C=\tan x·e^{2x}+C\\&amp;解二:原式=\int e^{2x}\frac{1+2\sin x\cos
x}{\cos^2x}\mathrm dx=\int e^{2x}\mathrm d(\tan x)+2\int e^{2x}\tan
x\mathrm dx\\&amp;=\int e^{2x}\mathrm d(\tan x)+\int\tan x\,\mathrm
d\left(e^{2x}\right)=\tan x·e^{2x}+C\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;9.\int e^{\sin
x}\frac{x\cos^3x-\sin x}{\cos^2x}\mathrm dx=\int x\mathrm d\left(e^{\sin
x}\right)-\int e^{\sin x}\frac{\sin x}{\cos^2x}\mathrm
dx\\&amp;\xlongequal{分母降幂}\int x\mathrm d\left(e^{\sin
x}\right)-\int e^{\sin x}\mathrm d\left(\frac1{\cos
x}\right)\\&amp;=\int x\mathrm d\left(e^{\sin x}\right)-e^{\sin x}\sec
x+\int\sec x\mathrm d\left(e^{\sin x}\right)\\&amp;=\int x\mathrm
d\left(e^{\sin x}\right)-e^{\sin x}\sec x+\int e^{\sin x}\mathrm
dx=e^{\sin x}(x-\sec x)+C\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;10.\int x\arctan
x\ln(1+x^2)\mathrm dx\\&amp;解:原式=\frac12\int\arctan
x\ln(1+x^2)\mathrm d\left(1+x^2\right)\\&amp;=\frac12\left(\arctan
x\ln(1+x^2)(1+x^2)-\int(1+x^2)\mathrm d\left(\arctan
x\ln(1+x^2)\right)\right)\\&amp;=\frac12\left(\arctan
x\ln(1+x^2)(1+x^2)-\int\ln(1+x^2)\mathrm dx-\int2x\arctan x\mathrm
dx\right)\\&amp;=\frac12\left(\arctan
x\ln(1+x^2)(1+x^2)-\left(x\ln(1+x^2)-\int\frac{2x^2}{1+x^2}\mathrm
dx\right)-2\int x\arctan x\mathrm dx\right)\\&amp;\int x\arctan x\mathrm
dx=\frac12\int\arctan x\mathrm d\left(x^2+1\right)=\frac{\arctan
x·(1+x^2)-x}2+C\\&amp;\int\frac{2x^2}{1+x^2}\mathrm dx=2(x-\arctan
x)+C\\&amp;综上,原式=\frac{\arctan{x[(x^2+1)\ln(1+x^2)-(x^2+3)]-x\ln(1+x^2)+3x}}2+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;11.\int\frac{x^2+1}{x^4+1}\mathrm
dx\\&amp;解:原式=\int\frac{1+\frac1{x^2}}{x^2+\frac1{x^2}}\mathrm
dx=\int\frac{\mathrm
d\left(x-\frac1x\right)}{(x-\frac1x)^2+2}=\frac1{\sqrt2}{\arctan\frac{x-\frac1x}{\sqrt2}}+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.\int\frac{x^2\pm1}{1+kx^2+x^4}\mathrm
dx\\&amp;解:原式=\int\frac{1\pm\frac1{x^2}}{\frac1{x^2}+k+x^2}\mathrm
dx=\int\frac{\mathrm
d(x\mp\frac1x)}{(x\mp\frac1x)^2+k\pm2}\\&amp;\xlongequal{t=(x\mp\frac1x)\large\frac1{\sqrt{k\pm2}}}\frac1{\sqrt{k\pm2}}\int
\frac{\mathrm
dt}{t^2+1}=\frac1{\sqrt{k\pm2}}\arctan\frac{x\mp\frac1x}{\sqrt{k\pm2}}+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;13.\int\frac1{\sin^3x+\cos^3x}\mathrm
dx,\frac14&lt;x&lt;\frac12\\&amp;解:原式\xlongequal{立方和公式}\int\frac1{(\sin
x+\cos x)(1-\sin x\cos x)}\mathrm dx\\&amp;=\int\frac{\sin x+\cos
x}{(1+2\sin x\cos x)(1-\sin x\cos x)}\mathrm dx\\&amp;=\int\frac{\mathrm
d(\sin x-\cos x)}{(2-(\sin x-\cos x)^2)(1-\frac{1-(\sin x-\cos
x)^2}2)}\\&amp;\xlongequal{t=\sin x-\cos
x}2\int\frac1{(2-t^2)(1+t^2)}\mathrm dt=\frac23\arctan
t+\frac1{3\sqrt2}\ln(\frac{\sqrt2+t}{\sqrt2-t})+C\\&amp;=\frac23\arctan(\sin
x-\cos x)+\frac1{3\sqrt2}\ln(\frac{\sqrt2+\sin x-\cos x}{\sqrt2+\cos
x-\sin x})+C\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;14.\int\frac{\mathrm
dx}{x\sqrt{x^2-2x-3}}\\&amp;解:原式=\int\frac{\mathrm
dx}{x^2\sqrt{1-\frac2x-\frac3{x^2}}}=-\frac1{\sqrt3}\int\frac{\mathrm
d\left(\frac{\sqrt3}x+\frac1{\sqrt3}\right)}{\sqrt{-(\frac{\sqrt3}x+\frac1{\sqrt3})^2+\frac43}}\\&amp;=-\frac1{\sqrt3}\int\frac{\mathrm
d(\frac{\sqrt3}2(\frac{\sqrt3}x+\frac1{\sqrt3}))}{\sqrt{1-\frac34(\frac{\sqrt3}x+\frac1{\sqrt3})^2}}=-\frac{\arcsin(\frac{\sqrt3}2(\frac{\sqrt3}x+\frac1{\sqrt3}))}{\sqrt3}+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;15.\int\sqrt\frac{1-x}{1+x}\mathrm
dx\\&amp;解:原式\xlongequal{t=\sqrt{\frac{1-x}{1+x}}}-4\int\frac{t^2}{(1+t^2)^2}\mathrm
dt=2\int t\mathrm d\left(\frac1{1+t^2}\right)\\&amp;=2\left(\frac
t{1+t^2}-\int\frac{\mathrm dt}{1+t^2}\right)=2\left(\frac
t{1+t^2}-\arctan t\right)+C\\&amp;=\sqrt{(1+x)(1-x)}-2\arctan
\sqrt{\frac{1-x}{1+x}}+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;16.I(n)=\int\frac{1}{(a^2+x^2)^n}\mathrm
dx,\ n为正整数\\&amp;解:原式=\frac
x{(a^2+x^2)^n}+2n\int\frac{x^2}{(a^2+x^2)^{n+1}}\mathrm dx\\&amp;=\frac
x{(a^2+x^2)^n}+2n\int\frac{1}{(a^2+x^2)^n}\mathrm
dx-2na^2\int\frac{1}{(a^2+x^2)^{n+1}}\mathrm
dx\\&amp;故有递推式:2na^2·I(n+1)=(2n-1)·I(n)+\frac x{(a^2+x^2)^n},\
当n=1时,I(1)=\arctan x+C\\&amp;偏移后:I(n)=\frac{(2n-3)·I(n-1)+\Large
\frac x{(a^2+x^2)^{n-1}}}{2(n-1)a^2}\\&amp;特别地,\ 当n=2时,\
I(2)=\frac{\arctan x+\Large \frac
x{a^2+x^2}}{2a^2}+C\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;由题15、16,形如\frac{ax^2+bx+c}{(k^2+x^2)^2}的被积函数可拆分成三部分计算\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;17.I=\int\sqrt{k\pm
x^2}\mathrm dx,\ k\pm x^2\ge0,k&gt;0\\&amp;解:I=x\sqrt{k\pm x^2}-\int
x\frac{\pm x}{\sqrt{k\pm x^2}}\mathrm dx=x\sqrt{k\pm
x^2}-I+k\int\frac{\mathrm dx}{\sqrt{k\pm
x^2}}\\&amp;故I=\frac12\left(x\sqrt{k+ x^2}+k\ln(x+\sqrt{k+
x^2})\right)+C&amp;k+x^2时\\&amp;或I=\frac12\left(x\sqrt{k-
x^2}+k\arcsin(\frac x{\sqrt
k})\right)+C&amp;k-x^2时\end{align}$</span></p>
<hr />
<h1 id="中值定理">中值定理</h1>
<h2 id="复习">复习</h2>
<h3 id="常用定理定义">常用定理定义</h3>
<ul>
<li>零点定理：若<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<span
class="math inline">[<em>a</em>,<em>b</em>]</span>内连续，且<span
class="math inline"><em>f</em>(<em>a</em>)<em>f</em>(<em>b</em>) &lt; 0</span>，则至少存在一点<span
class="math inline"><em>x</em><sub>0</sub> ∈ (<em>a</em>,<em>b</em>)</span>，使<span
class="math inline"><em>f</em>(<em>x</em><sub>0</sub>) = 0</span>；零点定理可视为介值定理的特例</li>
<li>唯一零点定理：在<strong>零点定理成立</strong>的条件下，若<span
class="math inline"><em>f</em>(<em>x</em>)</span>可导且<span
class="math inline"><em>f</em>′(<em>x</em>) ≠ 0</span>，则有且仅有一点使<span
class="math inline"><em>f</em>(<em>x</em><sub>0</sub>) = 0</span></li>
<li>介值定理：设<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<span
class="math inline">(<em>a</em>,<em>b</em>)</span>内连续，且最大值为<span
class="math inline"><em>M</em></span>，最小值为<span
class="math inline"><em>m</em></span>，若有<span
class="math inline"><em>m</em> ≤ <em>A</em> ≤ <em>M</em></span>，则至少存在一点<span
class="math inline"><em>x</em><sub>0</sub> ∈ (<em>a</em>,<em>b</em>)</span>，使<span
class="math inline"><em>f</em>(<em>x</em><sub>0</sub>) = <em>A</em></span></li>
<li>罗尔中值定理：若<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<strong>闭区间</strong><span
class="math inline">[<em>a</em>,<em>b</em>]</span>内<strong>函数连续</strong>、<strong>开区间</strong><span
class="math inline">(<em>a</em>,<em>b</em>)</span>内<strong>函数可导</strong>，且<span
class="math inline"><em>f</em>(<em>a</em>) = <em>f</em>(<em>b</em>)</span>，则在<strong>开区间</strong><span
class="math inline">(<em>a</em>,<em>b</em>)</span>内存在一点<span
class="math inline"><em>ξ</em></span>，使<span
class="math inline"><em>f</em>′(<em>ξ</em>) = 0</span>；<span
class="math inline">$\rm Rolle$</span>中值定理是<span
class="math inline">$\rm Largrange$</span>中值定理的特例</li>
<li>拉格朗日中值定理：若<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<strong>闭区间</strong><span
class="math inline">[<em>a</em>,<em>b</em>]</span>内<strong>函数连续</strong>、<strong>开区间</strong><span
class="math inline">(<em>a</em>,<em>b</em>)</span>内<strong>函数可导</strong>，则在<strong>开区间</strong><span
class="math inline">(<em>a</em>,<em>b</em>)</span>内存在一点<span
class="math inline"><em>ξ</em></span>，使<span
class="math inline">$\begin{align}f'(\xi)=\frac{f(a)-f(b)}{a-b}\end{align}$</span>；<span
class="math inline">$\rm Largrange$</span>中值定理是<span
class="math inline">$\rm Taylor$</span>中值定理的特例</li>
<li>泰勒中值定理：若<span
class="math inline"><em>f</em>(<em>x</em>)</span>在<span
class="math inline"><em>x</em><sub>0</sub></span>的<span
class="math inline">(<em>a</em>,<em>b</em>)</span>邻域内<strong>有<span
class="math inline"><em>n</em> + 1</span>阶导</strong>，则存在介于<span
class="math inline"><em>x</em></span>和<span
class="math inline"><em>x</em><sub>0</sub></span>之间的中值<span
class="math inline"><em>ξ</em></span>(<span
class="math inline"><em>x</em> ∈ (<em>a</em>,<em>b</em>)</span>)，使其泰勒展开后拉格朗日型余项为<span
class="math inline">$\begin{align}R_n=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\end{align}$</span></li>
<li>积分中值定理：若有<span
class="math inline">$\begin{align}\int_a^bf(x)dx=0\end{align}$</span>，则存在一点<span
class="math inline"><em>x</em><sub>0</sub> ∈ (<em>a</em>,<em>b</em>)</span>，使<span
class="math inline"><em>f</em>(<em>x</em><sub>0</sub>) = 0</span></li>
</ul>
<h3 id="构造辅助函数-微分方程">构造辅助函数(<code>-&gt;</code><a
href="#微分方程">微分方程</a>)</h3>
<p>通过中值定理证明给定方程<span
class="math inline"><em>F</em>(<em>x</em>) = 0</span>的题型中，寻找辅助函数的过程相当于解出微分方程后移项，常见构造如下(可不记，相当于初等微分方程)：</p>
<ul>
<li>构造的<span
class="math inline"><em>G</em>(<em>x</em>)</span>可任意加常数<span
class="math inline"><em>C</em></span>，该<strong>常数根据所给条件</strong>，最终必须凑出<span
class="math inline"><em>G</em>(<em>a</em>) = <em>G</em>(<em>b</em>)</span>，一般是<span
class="math inline">0</span></li>
<li>形如<span
class="math inline"><em>f</em>′(<em>x</em>) + <em>P</em>(<em>x</em>)<em>f</em>(<em>x</em>) = 0</span>的待证方程，通常构造<span
class="math inline">$\begin{align}G(x)=f(x)e^{\int
P(x)dx}+C\end{align}$</span></li>
<li>形如<span
class="math inline"><em>f</em>′(<em>x</em>) + <em>P</em>(<em>x</em>)<em>f</em>(<em>x</em>) = <em>Q</em>(<em>x</em>)</span>的待证方程，通常构造<span
class="math inline">$\begin{align}G(x)=f(x)e^{\int P(x)dx}-\int e^{\int
P(x)dx}Q(x)dx+C\end{align}$</span></li>
<li>形如<span
class="math inline"><em>f</em>″(<em>x</em>) + <em>p</em><em>f</em>′(<em>x</em>) + <em>q</em><em>f</em>(<em>x</em>) = <em>Q</em>(<em>x</em>)</span>的待证方程，通常将<span
class="math inline"><em>F</em>(<em>x</em>) = <em>f</em>′(<em>x</em>) − <em>A</em><em>f</em>(<em>x</em>)</span>作为整体降阶，相当于<strong>解差分方程</strong>，即<span
class="math inline"><em>λ</em><sup>2</sup> + <em>p</em><em>λ</em> + <em>q</em> = 0</span>的解分别作为<span
class="math inline"><em>A</em>、<em>P</em></span>，得到等价的降阶方程<span
class="math inline"><em>F</em>′(<em>x</em>) + <em>P</em><em>F</em>(<em>x</em>) = <em>Q</em>(<em>x</em>)</span>；类似的三对角行列式、递推数列也是差分方程</li>
</ul>
<p>以上是记忆型的知识点，事实上只要<strong>假设方程<span
class="math inline"><em>F</em>(<em>x</em>) = 0</span>恒成立，解出<span
class="math inline"><em>f</em>(<em>x</em>)</span>的通解</strong>，再<strong>通过已知条件</strong>设定一个特解，将<strong>所有项移到一边</strong>，就能得到辅助函数：</p>
<ul>
<li>与关于<span
class="math inline"><em>f</em>(<em>x</em>)</span>微分方程的联系：如此构造出的<span
class="math inline">$\begin{align}G(x)=f(x)e^{\int P(x)dx}-\int e^{\int
P(x)dx}Q(x)dx=C\end{align}$</span>，移项后求出的<span
class="math inline"><em>f</em>(<em>x</em>)</span>就是熟悉的公式<span
class="math inline">$\begin{align}f(x)=e^{-\int P(x)dx}\left(\int
e^{\int P(x)dx}Q(x)dx+C\right)\end{align}$</span>；所以解出<span
class="math inline"><em>f</em>(<em>x</em>)</span>，辅助函数也就得到了</li>
<li>和微分方程的区别：微分方程恒成立，而中值定理往往是只有单中值或双中值满足给定方程，相当于求特解；反过来说，如果能保证构造出的<span
class="math inline"><em>G</em>(<em>x</em>)</span>恒等于常数，那么其中的<span
class="math inline"><em>f</em>(<em>x</em>)</span>就是通解了</li>
</ul>
<h2 id="题集-1">题集</h2>
<p>简单构造：</p>
<p><span
class="math inline">$\begin{align}&amp;1.设函数f(x)在[0,1]上连续,在(0,1)内可微,且\end{align}$</span>
<span class="math display">$$
f(0)=f(1)=0,f\left(\frac12\right)=1
$$</span> <span
class="math inline">$\begin{align}&amp;证明:(1)存在\xi\in\left(\frac12,1\right)使得f(\xi)=\xi\\&amp;(2)存在\eta\in(0,\xi)使得f'(\eta)=f(\eta)-\eta+1\\&amp;证:(1)令F(x)=f(x)-x,则F\left(\frac12\right)=\frac12,F(1)=-1,\\&amp;由零点定理,必然存在一点\xi\in\left(\frac12,1\right)使F(\xi)=0,证毕\\&amp;[2](草稿纸过程:容易解得f(x)=e^{-x}(xe^{-x}+C),即辅助函数G(x)=f(x)e^x-xe^{-x})\\&amp;令G(x)=f(x)e^x-xe^{-x},则G(0)=0,G(\xi)=0,由罗尔中值定理,存在\eta\in(0,\xi)使G'(\eta)=0,证毕\end{align}$</span></p>
<hr />
<p>双中值：</p>
<p><span
class="math inline">$\begin{align}&amp;2.设f(x)在[0,1]上连续,f(x)在(0,1)上可导,且f(0)=0,f(1)=1\\&amp;证明:(1)存在x_0\in(0,1),使f(x_0)=2-3x_0\\&amp;(2)存在\xi,\eta
\in(0,1),且\xi\ne\eta,使[1+f'(\xi)][1+f'(\eta)]=4\\&amp;证:(1)令F(x)=f(x)+3x-2,则F(0)=-2,F(1)=2,\\&amp;根据零点定理,存在x_0\in(0,1)使F(x_0)=0,证毕\\&amp;[2](双中值问题自然想法是拉中定理分区间)\\&amp;在(0,x_0)区间上,拉中有\frac{2-3x_0-f(0)}{x_0}=f'(\xi),\xi\in(0,x_0)\\&amp;在(x_0,1)区间上,同理有\frac{1-(2-3x_0)}{1-x_0}=f'(\eta),\eta\in(x_0,1)\\&amp;代入得证,证毕\end{align}$</span></p>
<p>如果无视第一问给的条件，则要逆向推导：</p>
<p><span
class="math inline">$\begin{align}&amp;(2)设在(0,1)上有一点x_1,使得拉中有:\\&amp;\frac{f(x_1)-f(0)}{x_1}=f'(\xi),\frac{f(1)-f(x_1)}{1-x_1}=f'(\eta),则满足\xi\ne\eta\\&amp;要使结论成立,则解出f(x_1)=2-3x_1成立,由(1)得总存在x_0使该式成立\\&amp;则令x_1=x_0,故总存在...证毕\end{align}$</span></p>
<hr />
<p>遇定积分可先通过积分中值定理得出一个零点，后续几问都相当于求解微分方程</p>
<p><span
class="math inline">$\begin{align}&amp;3.设函数f(x)在[a,b]上连续,在(a,b)内二阶可导,且\end{align}$</span>
<span
class="math display"><em>f</em>(<em>a</em>) = <em>f</em>(<em>b</em>) = 0, ∫<sub><em>a</em></sub><sup><em>b</em></sup><em>f</em>(<em>x</em>)<em>d</em><em>x</em> = 0</span>
<span
class="math inline">$\begin{align}&amp;(1)证明存在互不相同的点x_1,x_2\in(a,b),使得f'(x_i)=f(x_i),i=1,2;\\&amp;(2)证明存在\xi\in(a,b),\xi\ne
x_i,i=1,2,使得f''(\xi)=f(\xi);\\&amp;(3)证明存在\eta\in(a,b),\eta\ne
x_i,i=1,2,使得f''(\eta)-3f'(\eta)+2f(\eta)=0\\&amp;证:[1](积分中值定理)令F(x)=\int_a^x
f(x)dx,则F(a)=0,F(b)=0,故存在一点x_0使得F'(x_0)=f(x_0)=0\\&amp;令G(x)=f(x)e^{-x},则G(a)=G(x_0)=G(b)=0,则存在两点x_1\ne
x_2,使f'(x_i)=f(x_i),i=1,2\\&amp;其中x_1\in(a,x_0),x_2\in(x_0,b),证毕\\&amp;[2](\lambda^2-1=0\Rightarrow
f''(x)-f'(x)+f'(x)-f(x)=0)\\&amp;令H(x)=e^{x}(f'(x)-f(x)),则H(x_1)=H(x_2)=0,故存在\xi\in(x_1,x_2)使H'(\xi)=0,证毕\\&amp;[3](\lambda^2-3\lambda+2=0\Rightarrow
f''(x)-f'(x)+2(f'(x)-f(x))=0)\\&amp;令K(x)=e^{2x}(f'(x)-f(x)),...,证毕\end{align}$</span></p>
<hr />
<p>给出若干低阶导，求高阶导；或给出若干定积分，求本身或其导，都有可能考察泰勒中值定理</p>
<p>通过<strong>待定系数法</strong>求出辅助函数的常量值，运用多次罗尔定理也可得到结论(又是通过微分方程，但是最高有三阶导)</p>
<p><span
class="math inline">$\begin{align}&amp;4.设函数f(x)在闭区间[-1,1]上具有连续的三阶导数,且f(-1)=0,f(1)=1,f'(0)=0\\&amp;求证:在开区间(-1,1)内至少存在一点\xi,使f'''(\xi)=3\\&amp;证法一:在x=0点处泰勒展开,f(x)=f(0)+f'(0)x+\frac{f''(0)x^2}2+\frac{f'''(\xi)x^3}6,\xi介于x和0之间\\&amp;则\begin{cases}f(-1)=0=f(0)-f'(0)+\frac{f''(0)}2-\frac{f'''(\xi_1)}6\\f(1)=1=f(0)+f'(0)+\frac{f''(0)}2+\frac{f'''(\xi_2)}6\end{cases}\\&amp;得f(1)-f(-1)=1=2\left(f'(0)+\frac{f'''(\xi_1)+f'''(\xi_2)}6\right)\\&amp;即\frac{f'''(\xi_1)+f'''(\xi_2)}2=3,由于\xi_1,\xi_2\in(-1,1),设在该区间内f'''(x)最小值为m,最大值为M\\&amp;则m\le
f'''(\xi_1),f'''(\xi_2)\le M,故m\le\frac{f'''(\xi_1)+f'''(\xi_2)}2\le
M\\&amp;由介值定理,必存在一点\xi\in(-1,1),使f'''(\xi)=\frac{f'''(\xi_1)+f'''(\xi_2)}2=3,证毕\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;证法二:[草稿纸过程]\\&amp;由结论出发,令F''(x)=f''(x)-3x+A\\&amp;再积分令F'(x)=f'(x)-\frac32x^2+Ax+B\\&amp;再积分F(x)=f(x)-\frac{x^3}2+\frac
A2x^2+Bx+C,\\&amp;为了使其满足罗尔定理,令F(-1)=F(1)=F(0)=0&amp;\exist两点使F'(x_1)=F'(x_2)=0\\&amp;令F'(0)=F'(x_1)=F'(x_2)=0&amp;\exist两点使F(x_3)=F(x_4)=0\\&amp;求出A、B、C(即使包含未知的函数值也可,因为连续)\\&amp;得到的F(x)就是辅助函数,通过多次罗尔定理得证\end{align}$</span></p>
<hr />
<p>含变限积分的函数不需要继续积分，可借助积分中值定理和分部积分，因为只需要额外的一点</p>
<p><span
class="math inline">$\begin{align}&amp;5.设函数f(x)在[0,1]上具有连续导数,且\int_0^1f(x)dx=\frac52,\int_0^1xf(x)dx=\frac32\\&amp;证明:存在\xi\in(0,1),使f'(\xi)=3\\&amp;证:[草稿纸过程]\\&amp;同样为了使用多次罗尔定理,令F'(x)=f(x)-3x+A\\&amp;F(x)=\int_0^xf(t)dt-\frac32x^2+Ax+B\\&amp;令F(0)=F(1)=0解出A,B后,此时还需要找到一点\\&amp;可以使用积分中值定理,只需证\int_0^1F(x)dx=0,则存在一点使F(x_0)=0,且x_0\in(0,1)\\&amp;由分部积分,原定积分=xF(x)\bigg|_0^1-\int_0^1xF'(x)dx=F(1)-\int_0^1x(f(x)-3x+A)\\&amp;确实等于0,则可通过三次罗尔定理得证\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;6.设函数f(x)在(-\infty,+\infty)上具有二阶导数,并且\end{align}$</span>
<span
class="math display"><em>f</em>″(<em>x</em>) &gt; 0, lim<sub><em>x</em> →  + ∞</sub><em>f</em>′(<em>x</em>) = <em>α</em> &gt; 0, lim<sub><em>x</em> →  − ∞</sub><em>f</em>′(<em>x</em>) = <em>β</em> &lt; 0</span>
<span
class="math inline">$\begin{align}&amp;且存在一点x_0,使得f(x_0)&lt;0,证明:方程f(x)=0在(-\infty,+\infty)恰有两个实根\\&amp;先证至少有两个实根:\\&amp;证法一\cdot广义洛必达法则:若有g(x_0)\rightarrow\infty,且\lim_{x\rightarrow
x_0}\frac{f'(x)}{g'(x)}=A,\\&amp;则{\bf\color{red}无论f(x_0)趋于何值},\lim_{x\rightarrow
x_0}\frac{f(x)}{g(x)}=\lim_{x\rightarrow
x_0}\frac{f'(x)}{g'(x)}=A\\&amp;根据该定理,未知f(x_0)是否趋于无穷时,也可运用洛必达\\&amp;则\lim_{x\rightarrow+\infty}\frac{f(x)}{x}=\lim_{x\rightarrow+\infty}f'(x)=\alpha&gt;0,\lim_{x\rightarrow-\infty}\frac{f(x)}x=\lim_{x\rightarrow
x_0}f'(x)=\beta&lt;0\\&amp;故\lim_{x\rightarrow+\infty}f(x)=+\infty,\lim_{x\rightarrow-\infty}f(x)=+\infty,\\&amp;即\forall
N_1&gt;0,\exist x_1&gt;N_1使f(x_1)&gt;0\\&amp;\forall N_2&lt;0,\exist
x_2&lt;N_2使f(x_2)&gt;0,由存在x_0使f(x_0)&lt;0,由零点定理得证至少有两个实根\\&amp;证法二·泰勒展开\\&amp;在任意一点x_1处展开,f(x)=f(x_1)+f'(x_1)(x-x_1)+\frac{f''(\xi)(x-x_1)^2}2,\xi介于x和x_1间\\&amp;由f''(x)&gt;0,得f(x)&gt;f(x_1)+f'(x_1)(x-x_1)\\&amp;根据已给条件,\begin{cases}{\exist充分大N_1&gt;0,当x_1&gt;N_1时,f'(x_1)&gt;0}\\\exist充分大N_2&lt;0,当x_1&lt;N_2时,f'(x_1)&lt;0\end{cases}\\&amp;因此\lim_{x\rightarrow+\infty}f(x)&gt;\lim_{x\rightarrow+\infty}(f(x_1)+f'(x_1)(x-x_1))&gt;0,[当x_1&gt;N_1时,该极限为(常数+正数*正无穷)]\\&amp;\lim_{x\rightarrow-\infty}f(x)&gt;\lim_{x\rightarrow-\infty}(f(x_1)+f'(x_1)(x-x_1))&gt;0,[当x_1&lt;N_2时,该极限为(常数+负数*负无穷)]\\&amp;通过和证法一相同的极限语言,零点定理得证\\&amp;再证只有两个实根:\\&amp;反证法,若有三个及以上实根,三次罗尔定理后应存在一点\eta使f''(\eta)=0,然而f''(x)&gt;0,矛盾\\&amp;故f(x)=0恰有两个实根,证毕\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;7.设函数f(x)在区间[0,1]上连续且\int_0^1f(x)dx\ne0,证明:在区间[0,1]上存在三个不同的点x_1,x_2,x_3,使得\end{align}$</span>
<span class="math display">$$
\frac\pi8\int_0^1f(x)dx=\left[\frac1{1+x_1^2}\int_0^{x_1}f(t)dt+f(x_1)\arctan
x_1\right]x_3\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
\ \ \ =\left[\frac1{1+x_2^2}\int_0^{x_2}f(t)dt+f(x_2)\arctan
x_2\right](1-x_3)
$$</span> <span
class="math inline">$\begin{align}&amp;证:[草稿纸过程]\\&amp;观察两式,联想到分部积分,式子即F(x)=\arctan
x\int_0^xf(t)dt的导数\\&amp;观察x_3、1-x_3,x_3\in(0,1),然后x_1、x_2是双中值,尝试拉中\\&amp;证:[作答]\\&amp;令F(x)=\arctan
x\int_0^xf(t)dt,则F(0)=0,F(1)=\frac\pi4\int_0^1f(x)dx\\&amp;由\int_0^1f(x)dx\ne0,得0&lt;\left|\frac\pi8\int_0^1f(t)dt\right|&lt;\left|\frac\pi4\int_0^1f(t)dt\right|\\&amp;又F(x)在[0,1]上连续,由介值定理必存在一点x_3\in(0,1)使F(x_3)=\frac\pi8\int_0^1f(t)dt\\&amp;在[0,x_3]上拉中,\frac{\frac\pi8\int_0^1f(t)dt}{x_3}=F'(x_1)=\frac1{1+x_1^2}\int_0^{x_1}f(t)dt+f(x_1)\arctan
x_1\\&amp;在[x_3,1]上拉中,\frac{\frac\pi8\int_0^1f(t)dt}{1-x_3}=F'(x_2)=\frac1{1+x_2^2}\int_0^{x_2}f(t)dt+f(x_2)\arctan
x_2\\&amp;证毕.\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;8.设函数f(x)在[0,1]上有二阶导数,且有正常数A,B,使得\end{align}$</span>
<span
class="math display">|<em>f</em>(<em>x</em>)| ≤ <em>A</em>, |<em>f</em>″(<em>x</em>)| ≤ <em>B</em></span>
<span
class="math inline">$\begin{align}&amp;证明:对于任意x\in[0,1],有|f'(x)|\le
2A+\frac
B2\\&amp;证:在[0,1]中任意点展开,f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(\xi)(x-x_0)^2}2,\xi介于x和x_0间\\&amp;则\begin{cases}f(0)=f(x_0)-f'(x_0)x_0+\frac{f''(\xi_1)x_0^2}2\\f(1)=f(x_0)+f'(x_0)(1-x_0)+\frac{f''(\xi_2)(1-x_0)^2}2\end{cases}\\&amp;f(1)-f(0)=f'(x_0)+\frac{f''(\xi_2)(1-x_0)^2-f''(\xi_1)x_0^2}2\\&amp;则有f(x_0)=f(1)-f(0)+\frac{f''(\xi_1)x_0^2-f''(\xi_2)(1-x_0)^2}2\\&amp;|f'(x_0)|\le|f(1)|+|f(0)|+\left|\frac{f''(\xi_1)x_0^2}2\right|+\left|\frac{f''(\xi_2)(1-x_0)^2}2\right|\\&amp;\le2A+(x_0^2+(1-x_0)^2)\frac
B2\le2A+\frac B2,证毕\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;9.设函数f(x)在[-2,2]上二阶可导,且|f(x)|&lt;1,又f^2(0)+[f'(0)]^2=4,\\&amp;试证在(-2,2)内至少存在一点\xi,使f(\xi)+f''(\xi)=0\\&amp;[给出的等式条件求导后恰好包含待证式]\\&amp;证:令F(x)=f^2(x)+[f'(x)]^2,则F(0)=4,一个点不足以使用罗尔定理,因此要分区间\\&amp;然而提供的是不等式,故推出新的不等式后需通过介值定理(或直接用费马引理)\\&amp;[-2,0]上拉中,存在\xi_1\in(-2,0)使f'(\xi_1)=\frac{f(0)-f(-2)}2,|f'(\xi_1)|\le\frac{|f(0)|}2+\frac{|f(-2)|}2&lt;1\\&amp;[0,2]上拉中,存在\xi_2\in(0,2)使f'(\xi_2)=\frac{f(2)-f(0)}2,同理|f'(\xi_2)|&lt;1\\&amp;因此F(\xi_1)&lt;2,F(\xi_2)&lt;2,而F(0)=4\\&amp;故由局部极大值定理和费马引理,\\&amp;存在\xi\in(\xi_1,\xi_2),也即\xi\in(-2,2)使F'(\xi)=2f(\xi)f'(\xi)+2f'(\xi)f''(\xi)=0,且它是一个极大值\\&amp;又F(\xi)=f^2(\xi)+[f'(\xi)]^2&gt;2,(极大值的性质)得f'(\xi)\ne0\\&amp;结论得证\end{align}$</span></p>
<hr />
<p>通常双中值问题中，用于划分区间的中值<span
class="math inline"><em>x</em><sub>0</sub></span>是给出的(一般是关于<span
class="math inline"><em>x</em><sub>0</sub></span>的等式，例如题<span
class="math inline">2.(1)</span>)，而在一些未给出的问题中，需要通过待定系数法求解，即<strong>假设存在可将大区间划分成两个子区间的中值</strong>，<strong>使</strong>得出的<strong>双中值满足待证结论</strong>，再求出它所满足的式子</p>
<p><span
class="math inline">$\begin{align}&amp;10.设函数f(x)在区间[0,1]上连续,且I=\int_0^1f(x)dx\ne0.证明:在(0,1)内存在不同的两点x_1,x_2使得\\&amp;\frac1{f(x_1)}+\frac1{f(x_2)}=\frac2I\\&amp;证:令F(x)=\int_0^xf(t)dt,则F(0)=0,F(1)=I,,记F(x_0)=A,x_0\in(0,1)\\&amp;在[0,x_0]上拉中,存在x_1\in(0,x_0)使\frac{A}{x_0}=f(x_1)\\&amp;在[x_0,1]上拉中,存在x_2\in(x_0,1)使\frac{I-A}{1-x_0}=f(x_2)\\&amp;则\frac1{f(x_1)}+\frac1{f(x_2)}=\frac{x_0I-x_0A+A-x_0A}{(I-A)A}\\&amp;令其=\frac
2I,解得I^2x_0-(2x_0+1)IA+2A^2=(x_0I-A)(I-2A)=0,\\&amp;转化为证明存在一点x_0,使x_0I-F(x_0)=0或I-2F(x_0)=0\\&amp;即找到一点x_0,使F(x_0)=\frac
I2,显然由介值定理可得该点是存在的\\&amp;找出x_0的过程为草稿纸过程,实际作答应直接说明存在x_0使F(x_0)=\frac
I2再顺着逻辑证明\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;11.设f(x)在[0,+\infty)上可微,f(0)=0,且存在常数A&gt;0,使得\\&amp;|f'(x)|\le
A|f(x)|在[0,+\infty)上成立,试证明:在(0,+\infty)上有f(x)\equiv0\\&amp;分析:在[0,x]上拉中,则存在一点x_0\in(0,x)使f(x)=xf'(x_0)\\&amp;则|f(x)|=|xf'(x_0)|\le
A|f(x_0)||x|,由|f(x)|\ge0,要证f(x)\equiv0,即证|f(x)|\le0\\&amp;证:取\
x\in\left(0,\frac1{2A}\right],记|f(x_1)|为\max\left(|f(x)|,x\in\left(0,\frac1{2A}\right]\right),\\&amp;在[0,x_1]上拉中,存在一点\xi_1\in(0,x),使\
|f(x_1)|\le
A|f(\xi_1)||x_1|\le\frac{|f(\xi_1)|}2\le\frac{|f(x_1)|}2\\&amp;故在此区间内,|f(x)|的最大值为0,即0\le|f(x)|\le0\\&amp;取x\in\left(\frac1{2A},\frac2{2A}\right],拉中后仍能得出在此区间内|f(x)|的取值只能为0\\&amp;递推区间至[0,+\infty)仍成立,证毕\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.设函数f(x)在[0,1]上连续,且\int_0^1f(x)dx=0,\int_0^1xf(x)dx=1,试证:\\&amp;(1)\
\exist x_0\in[0,1]使得\Big|f(x_0)\Big|&gt;4;(2)\ \exist
x_1\in[0,1]使得\Big|f(x_1)\Big|=4\\&amp;\end{align}$</span></p>
<hr />
<h1 id="微分方程">微分方程<a id="微分方程"></a></h1>
<h2 id="复习-1">复习</h2>
<ul>
<li>一阶非齐次线性微分方程：含公式
<ul>
<li>关于<span class="math inline"><em>y</em>(<em>x</em>)</span>的<span
class="math inline"><em>y</em>′(<em>x</em>) + <em>P</em>(<em>x</em>)<em>y</em>(<em>x</em>) = <em>Q</em>(<em>x</em>)</span>：<span
class="math inline">$\begin{align}y=e^{-\int P(x)\mathrm dx}\left(\int
e^{\int P(x)\mathrm dx}Q(x)\mathrm dx+C\right)\end{align}$</span></li>
</ul></li>
<li>二/高阶线性微分方程：解差分方程，当作两个一阶非齐次线性微分方程解；含公式，公式原理即前者所述
<ul>
<li>以下公式<strong>以特征方程的解<span
class="math inline"><em>λ</em></span>为基础</strong>，实质上就是差分方程</li>
<li>二阶的推导：对<span
class="math inline"><em>y</em>″ + <em>p</em><em>y</em>′ + <em>q</em><em>y</em> = <em>f</em>(<em>x</em>)</span>，有<span
class="math inline">(<em>y</em>′−<em>λ</em><sub>1</sub><em>y</em>)′ − <em>λ</em><sub>2</sub>(<em>y</em>′−<em>λ</em><sub>1</sub><em>y</em>) = <em>f</em>(<em>x</em>)</span>，故有<span
class="math inline">$\begin{align}&amp;y'-\lambda_1y=e^{\lambda_2x}\left(\int
e^{-\lambda_2x}f(x)\mathrm dx+C_1\right)\\&amp;y=e^{\lambda_1
x}\left(\int \left(e^{(\lambda_2-\lambda_1)x}·\left(\int e^{-\lambda_2
x}f(x)\mathrm dx+C_1\right)\right)\mathrm
dx+C_2\right)\end{align}$</span></li>
<li>由数学归纳法有以下结论：<span
class="math inline">$\begin{align}&amp;当f(x)=0,\lambda_1\ne\lambda_2时,y=\frac{C_1'e^{\lambda_1x}+C_2'e^{\lambda_2
x}}{\lambda_2-\lambda_1}=C_1''e^{\lambda_1
x}+C_2''e^{\lambda_2x},(单根)\\&amp;当f(x)=0,\lambda_1=\lambda_2时,y=e^{\lambda_1x}\left(C_1x+C_2\right),(二重根,多重根类似)\\&amp;\\&amp;当f(x)=0,\lambda为共轭复数单根\alpha\pm\beta\
i时,根据欧拉公式,y=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta
x)\\&amp;当f(x)=0,\lambda为共轭复数n重根时,\\&amp;y=e^{\alpha
x}((C_1+C_2x+\cdots+C_nx^n)\cos\beta
x+(C_1'+C_2'x+\cdots+C_n'x^n)\sin\beta x)\\&amp;\\&amp;当f(x)\ne
0,且为(Ax^n+Bx^{n-1}+\cdots+C)e^{\alpha
x}类型时,\\&amp;y的一个特解为(A'x^n+B'x^{n-1}+\cdots+C')e^{\alpha
x}x^k,\
其中\alpha为k重特征根\\&amp;当f(x)\ne0,且为((Ax^n+Bx^{n-1}+\cdots+C)\cos\beta
x+(A'x^n+B'x^{n-1}+\cdots+C')\sin\beta x)e^{\alpha
x}时,\\&amp;y的一个特解为\\&amp;((A''x^n+B''x^{n-1}+\cdots+C'')\cos\beta
x+(A'''x^n+B'''x^{n-1}+\cdots+C''')\sin\beta x)e^{\alpha
x}x^k,\\&amp;其中\alpha+\beta\
i为k重特征根\\&amp;当f(x)\ne0且为上述三种情况的线性组合时,y的一个特解是各项特解的线性组合\end{align}$</span></li>
</ul></li>
<li>全微分方程：凑微分法或偏积分法</li>
</ul>
<h2 id="题集-2">题集</h2>
<p><span
class="math inline">$\begin{align}&amp;1.求解微分方程:\begin{cases}{\large\frac{\mathrm
dy}{\mathrm
dx}}-xy=xe^{x^2}\\y(0)=1\end{cases}\\&amp;解:y的通解为e^{\int x\mathrm
dx}\left(\int e^{\int -x\mathrm dx} xe^{x^2}\mathrm
dx+C\right)=e^{x^2}+Ce^{\frac{x^2}2}\\&amp;代入y(0)=1,则C=0,\
y=e^{x^2}\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;2.求解微分方程:\begin{cases}{(x+1){\large\frac{\mathrm
dy}{\mathrm
dx}}}-xy=xe^{x^2}\\y(0)=0\end{cases}\\&amp;解:y的通解为e^{^{\int\frac{x}{x+1}\mathrm
dx}}\left(\int e^{\int-\frac{x}{x+1}\mathrm
dx}·\frac{xe^{x^2}}{x+1}\mathrm
dx+C\right)\\&amp;=\frac{e^x}{x+1}\left(\frac{e^{2x^2-2x}}4+C\right),\
代入y(0)=0,得C=-\frac14\\&amp;故y=\frac{e^x}{x+1}\left(\frac{e^{2x^2-2x}}4-\frac14\right)\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;3.设实数a\ne0,求解微分方程\begin{cases}y''-ay'^2=0\\y(0)=0,y'(0)=-1\end{cases}\\&amp;解:易解得y'=-\frac1{ax+C_1}\\&amp;则y=-\ln(ax+C_1)+C_2\\&amp;代入y(0)=0,y'(0)=-1,得C_1=1,C_2=0\\&amp;故y=-\ln(ax+1)\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;4.求解微分方程:y''-(y')^3=0的通解\\&amp;解:易得-\frac{(y')^{-2}}2=x+C\\&amp;即y'=\sqrt{\frac1{C_1-2x}}\\&amp;故y=\int
y'\mathrm dx=-\sqrt{C_1-2x}+C_2\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;5.已知y_1=e^x和y_2=xe^x是齐次二阶常系数线性微分方程的解,则该微分方程是:\\&amp;解:易猜测特征根为\
1(双重根),则特征方程为(\lambda-1)^2=0\\&amp;故微分方程为y''-2y'+y=0\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;6.已知y_1=xe^x+e^{2x},y_2=xe^x+e^{-x},y_3=xe^x+e^{2x}-e^{-x}\\&amp;是某二阶常系数线性非齐次微分方程的三个解,求其微分方程\\&amp;解:两特解之差为对应齐次方程的特解:y^*_1=e^{-x},y^*_2=e^{2x}\\&amp;易得两根为-1,2,即对应齐次方程为y''-y'-2y=0\\&amp;又有y_3+y_2-y_1=xe^x也是非齐次方程的一个特解,\\&amp;代入得该非齐次方程为y''-y'-2y=e^x-2xe^x\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;7.已知可导函数f(x)满足f(x)\cos
x+2\int_0^xf(t)\sin t\mathrm
dt=x+1,则f(x)=\_\_\_\_\_.\\&amp;解:两边求导:-f(x)\sin x+f'(x)\cos
x+2f(x)\sin x=1\\&amp;即f'(x)+\tan xf(x)-\sec
x=0\\&amp;解得f(x)=e^{-\int \tan x\mathrm dx}\left(\int e^{\int \tan
x\mathrm dx}\sec x\mathrm dx+C\right)\\&amp;=\sin x+C\cos x,\
代入f(0)=1,得C=1,故f(x)=\sin x+\cos x\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;8.满足\frac{\mathrm
du(t)}{\mathrm dt}=u(t)+\int_0^1u(t)\mathrm
dt及u(0)=1的可微函数u(t)为\_\_\_\_.\\&amp;解:设I=\int_0^1u(t)\mathrm
dt,由u'(t)=u(t)+I,得\ln|u(t)+I|=t+C\\&amp;即u(t)=Ce^t-I\\&amp;两边从0到1积分,得I=C(e-1)-I\\&amp;即I=\frac{C(e-1)}2\\&amp;故u(t)=Ce^t-\frac{C(e-1)}2,代入u(0)=1,得C=\frac2{3-e}\\&amp;故u(t)=\frac{2e^t+1-e}{3-e}\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;9.求方程(2x+y-4)\mathrm
dx+(x+y-1)\mathrm dy=0的通解\\&amp;解:全微分方程:\mathrm
d(x^2-4x)+\mathrm d(\frac{y^2}2-y)+\mathrm
d(xy)=0\\&amp;故其通解为x^2-4x+\frac{y^2}2-y+xy+C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;10.设函数f(x,y)具有一阶连续偏导数,满足\mathrm
df(x,y)=ye^y\mathrm dx+x(1+y)e^y\mathrm
dy及f(0,0)=0,则f(x,y)=\\&amp;解:f(x,y)=ye^yx+Q(y)\\&amp;f_y'(x,y)=(1+y)e^yx+Q'(y)=x(1+y)e^y\Rightarrow
Q'(y)=0\Rightarrow
Q(y)=C\\&amp;故f(x,y)=xye^y+C,代入f(0,0)=0得C=0\\&amp;故f(x,y)=xye^y\end{align}$</span></p>
<hr />
<p><span class="math inline">$\begin{align}&amp;11.已知\mathrm
du(x,y)=\frac{y\mathrm dx-x\mathrm
dy}{3x^2-2xy+3y^2},则u(x,y)=\_\_\_\_.\\&amp;解:u(x,y)=\int\frac
y{3x^2-2xy+3y^2}\mathrm dx=y\int\frac{\mathrm dx}{(\sqrt
3x-\frac{y}{\sqrt
3})^2+\frac83y^2}\\&amp;=\frac{\sqrt2}4\arctan(\frac{3x-y}{2\sqrt2y})+Q(y)\\&amp;u_y'(x,y)=\frac{\sqrt2}4·\frac{\frac{-2\sqrt2y-2\sqrt2(3x-y)}{8y^2}}{1+\frac{9x^2-6xy+y^2}{8y^2}}+Q'(y)=\frac{-x}{3x^2-2xy+3y^2}\\&amp;解得Q'(y)=0,即Q(y)=C\\&amp;故u(x,y)=\frac{\sqrt2}4\arctan(\frac{3x-y}{2\sqrt2y})++C\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;12.设f(u,v)具有连续偏导数,满足f_u(u,v)+f_v(u,v)=uv,\\&amp;求y(x)=e^{-2x}f(x,x)所满足的一阶微分方程,并求其通解\\&amp;解:两边对x求导,得y'(x)=e^{-2x}(f_1'(x,x)+f'_2(x,x)-2f(x,x))=e^{-2x}x^2-2y(x)\\&amp;故y=e^{-\int2\mathrm
dx}\left(\int e^{\int 2\mathrm dx}e^{-2x}x^2\mathrm
dx+C\right)=e^{-2x}\left(\frac{x^3}3+C\right)\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;13.设f(x)有连续导数,且f(1)=2.记z=f(e^xy^2),若\frac{\part
z}{\part
x}=z,f(x)在x&gt;0的表达式为\_\_\_\_.\\&amp;解:z_x=f'(e^xy^2)·y^2e^x=f(e^xy^2),解得\ln|f(e^xy^2)|=\ln|e^xy^2|+C_0\\&amp;即f(e^xy^2)=Ce^xy^2,也即f(x)=Cx\\&amp;代入f(1)=2,得C=2,即f(x)=2x\\&amp;当x&gt;0时,e^xy^2&gt;y^2\ge0,则f(x)在x&gt;0的表达式为f(x)=2x,x&gt;0\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;14.设可微函数f(x,y)满足\frac{\part
f}{\part x}=-f(x,y),f\left(0,\frac\pi2\right)=1,且\end{align}$</span>
<span class="math display">$$
\begin{align}\lim_{n\rightarrow
\infty}\left(\frac{f\left(0,y+{\Large\frac1n}\right)}{f(0,y)}\right)^n=e^{\cot
y}\end{align}
$$</span> <span
class="math inline">$\begin{align}&amp;则f(x,y)=\_\_\_\_.\\&amp;解:由该极限可得\lim_{n\rightarrow\infty}e^{n\ln\large\frac{f\left(0,y+\frac1n\right)}{f(0,y)}}=e^{\cot
y}\\&amp;即\lim_{n\rightarrow\infty}\frac{(f(0,y+\frac1n)-f(0,y))n}{f(0,y)}=\cot
y\\&amp;即\frac{f_y'(0,y)}{f(0,y)}=\cot y,解得f(0,y)=C\sin
y,代入f(0,\frac\pi2)=1,得C=1\\&amp;即f(0,y)=\sin
y\\&amp;设f(x,y)=P(x)\sin y+Q(x),则P(0)=1,\
Q(0)=0,\\&amp;f_x'(x,y)=-f(x,y)\Rightarrow-P(x)\sin y-Q(x)=P'(x)\sin
y+Q'(x)\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;解得P(x)=e^{-x},Q(x)=0\\&amp;即f(x,y)=e^{-x}\sin
y\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;15.设函数f(x)的导数f'(x)在[0,1]上连续,f(0)=f(1)=0,且满足\end{align}$</span>
<span class="math display">$$
\int_0^1\left[f'(x)\right]^2\mathrm dx-8\int_0^1f(x)\mathrm dx+\frac43=0
$$</span> <span
class="math inline">$\begin{align}&amp;则f(x)=\_\_\_\_.\\&amp;解:\int_0^1f(x)\mathrm
dx=xf(x)\Bigg|_0^1-\int xf'(x)\mathrm
dx\\&amp;故该等式可化为\int_0^1[[f'(x)]^2+8 xf'(x)]\mathrm
dx+\frac43=0\\&amp;即\int_0^1[[f'(x)]^2+8xf'(x)+\frac43]\mathrm
dx=0\\&amp;若[f'(x)]^2+8xf'(x)+\frac43=[F(x)]^2\ge0,则由该积分可得F(x)=0\\&amp;待定系数法设F(x)=f'(x)+4x+A,其中A为常数\\&amp;则有A^2+8A\int_0^1x\mathrm
dx+2A\int_0^1f'(x)\mathrm dx=\frac43-16\int_0^1 x^2\mathrm
dx\\&amp;即A^2+4A=-4,解得A=-2\\&amp;得F(x)=f'(x)+4x-2=0\\&amp;解得f(x)=-2x^2+2x+C,由f(0)=f(1)=0,得C=0\\&amp;故f(x)=-2x^2+2x\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;16.设f(x)在[0,+\infty)上是有界连续函数,证明:方程y''+14y'+13y=f(x)的\\&amp;每一个解在[0,+\infty)上都是有界函数\\&amp;解:由y''+14y'+13y=f(x)\Rightarrow\lambda_1=-13,\lambda_2=-1\\&amp;y'+13y=e^{-x}\left(\int
e^xf(x)\mathrm dx+C_1\right),\\&amp;解得y=e^{-13 x}\left(\int
e^{12x}\left(\int e^xf(x)\mathrm
dx+C_1\right)+C_2\right)\\&amp;由f(x)在[0,+\infty)上是有界连续函数,故e^xf(x)可积,设m\le
f(x)\le M\\&amp;则me^x+C_1\le \int e^xf(x)\mathrm dx+C_1\le
Me^x+C_1\\&amp;则\frac m{13}e^{13x}+\frac{C_1}{12}e^{12x}+C_2\le \int
e^{12x}\left(\int e^xf(x)\mathrm dx+C_1\right)+C_2\le \frac
M{13}e^{13x}+\frac{C_1}{12}e^{12x}+C_2\\&amp;即\frac
m{13}+\frac{C_1}{12}e^{-x}+C_2e^{-13x}\le y\le \frac
M{13}+\frac{C_1}{12}e^{-x}+C_2e^{-13x}\\&amp;其中0&lt;e^{-13x}&lt;e^{-x}\le
1,(x\in[0,+\infty))\\&amp;即对y的通解,它在[0,+\infty)上都是有界函数\end{align}$</span></p>
<hr />
<p><span
class="math inline">$\begin{align}&amp;13.\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;13.\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;13.\end{align}$</span></p>
<p><span class="math inline">$\begin{align}&amp;f(x,y)=(y+1)^2-(2-x)\ln
x,求由曲线f=0绕y=-1旋转而成的几何体的体积\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript: 基本使用</title>
    <url>/blogs/2023/12/09/javascript-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="javascript语法"><code>JavaScript</code>语法</h1>
<h2 id="简介">简介</h2>
<p><code>JS</code>实现了<code>html</code>文档与用户的更丰富的交互，实现在客户端处理部分信息而不是每次交互都向服务器报告。本身的一套标准为<code>ECMAScript</code>，除此以外还和<code>DOM</code>、<code>BOM</code>紧密相连，是这三个部分实现了<code>JS</code>的功能</p>
<p><code>DOM</code>和<code>BOM</code>都是<code>API</code>(可以理解为一个封装好的类)，分别定义了对<strong><code>html</code>文档</strong>、对<strong>浏览器</strong>的接口和方法，在今后将会涉及，在这里着重讲述语法</p>
<p><code>JS</code>的设计有许多<code>C++</code>及类<code>C++</code>语言的影子，理解起来不难</p>
<h2 id="与html的接口">与<code>HTML</code>的接口</h2>
<h3 id="script"><code>&lt;script&gt;</code></h3>
<p>想在<code>HTML</code>文档中运行<code>js</code>脚本，只需要添加<code>&lt;script&gt;&lt;/script&gt;</code>元素，虽然可以直接在元素内添加行内脚本，但更好的做法是引用<strong>外部文件</strong>，好处有：</p>
<ul>
<li>方便管理、修改<code>js</code>代码</li>
<li>一份多用，方便浏览器缓存使用</li>
</ul>
<p>也有坏处，如果引用了其它域的文件，则有可能被传入恶意脚本；所以引用外部文件应该确保安全可信</p>
<p><code>&lt;script&gt;</code>元素含有诸多属性：</p>
<ul>
<li><code>src</code>：类似<code>&lt;img&gt;</code>的<code>src</code>，用于指示外部文件来源，可配合<code>&lt;base&gt;</code>使用相对地址；需要注意如果一条<code>&lt;script&gt;</code>元素既有<code>src</code>又有内部代码，那么浏览器会忽视内部，只执行外部文件</li>
<li><code>integrity</code>：接收资源时先对比数字签名，确保其来源可信，是防范恶意脚本的武器</li>
<li><code>async</code>：立即下载这条元素指示的外部文件，但不影响其它页面或脚本的加载，即<strong>异步脚本</strong>；异步脚本脱离了执行顺序，所以不应该在里面进行<code>DOM</code>操作，以免导致异常</li>
<li><code>defer</code>：立即下载这条元素指示的外部文件，但可被推迟到所有其它页面或脚本加载完再执行；这样的脚本没有脱离顺序而只是延后执行了</li>
</ul>
<p><code>js</code>本身并不包含<code>DOM</code>等，所以单独运行访问<code>window</code>等对象的程序是有错误的，只有在<code>html</code>文档中才可以正常运行</p>
<h3 id="脚本位置">脚本位置</h3>
<p>以前，脚本都放在<code>&lt;head&gt;</code>内，以集中<code>js</code>和<code>css</code>的外部文件；但这将使浏览器在加载完所有脚本后才开始渲染<code>&lt;body&gt;</code>的内容，所以现在都选择将<code>&lt;script&gt;</code>部分放在<code>&lt;body&gt;</code>最后</p>
<h2 id="数据类型">数据类型</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<p><code>js</code>的数据类型管理是松散的，它的关键字不决定数据类型而是作用域等；有六种基本数据类型是原始类型，其中五种类型含有字面量(一个常量)：</p>
<ul>
<li><code>Number</code>：数值类型，字面量包括全体数字、<code>NaN</code>、<code>Infinity</code>与<code>-Infinity</code></li>
<li><code>String</code>：字符串类型，字面量包括所有字符串</li>
<li><code>Boolean</code>：布尔值类型，字面量有<code>true</code>与<code>false</code></li>
<li><code>Undefined</code>：未定义类型，字面量只有<code>undefined</code>，没有相应函数</li>
<li><code>Null</code>：空类型，字面量只有<code>null</code>，它是一个空指针，所以用<code>typeof null</code>返回的是<code>object</code>类型，没有相应函数</li>
</ul>
<p>剩下的一个类型为<code>Symbol</code>(符号类型)，它没有字面量语法，要用特殊的函数来声明；设计如此特殊的<code>Symbol</code>是为了提供一个全局<strong>唯一</strong>的标识符，以避免属性键冲突问题</p>
<h3 id="原始值与引用值">原始值与引用值</h3>
<p>以上六种数据类型都是原始值，其对象没有属性和方法，且互相赋值时进行的操作是<strong>完全复制</strong>；这些类型和<code>Object</code>类型可以作为<code>Object</code>类型对象的属性，对象类型的对象实质上是<strong>引用值</strong>，互相赋值时进行的操作是<strong>起别名</strong>，而不是创建副本</p>
<p>要创建一个原始值，可以直接使用字面量语法，或是调用相应类型的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> val_1 = val;   <span class="comment">// 使用字面量,自动分析val的类型.</span></span><br><span class="line"><span class="keyword">let</span> val_2 = <span class="title class_">Number</span>(val); <span class="comment">// 使用字面量,自动将val转换成指定的类型.</span></span><br><span class="line"><span class="keyword">let</span> val_3 = <span class="title class_">Symbol</span>();  <span class="comment">// Symbol类型没有字面量.</span></span><br></pre></td></tr></table></figure>
<p>要创建一个对象类型的值，可以使用字面量，也可以使用<code>new</code>加上一个类型，这相当于一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;     <span class="comment">// 使用字面量,创建空对象.</span></span><br><span class="line"><span class="keyword">let</span> obj_1 = <span class="title class_">Object</span>(val);  <span class="comment">// 创建对应类型的对象,自动分析val的类型.</span></span><br><span class="line"><span class="keyword">let</span> obj_2 = <span class="keyword">new</span> <span class="title class_">Number</span>(val); <span class="comment">// 创建对应类型的对象,自动将val转换成指定类型.</span></span><br><span class="line"><span class="keyword">let</span> obj_3 = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="number">5</span>);  <span class="comment">// 与obj_3 = Object(5);等价.</span></span><br><span class="line"><span class="keyword">let</span> obj_copy = <span class="title class_">Object</span>(obj_3); <span class="comment">// 与obj_copy = obj_3;等价.</span></span><br></pre></td></tr></table></figure>
<p>如果提供了指定的类型(<code>obj_2</code>)，或是使用<code>Object()</code>时提供的是<strong>原始值</strong>(<code>obj_1,obj_3</code>)，那么这种方式得到的对象称为<strong>包装对象</strong>，可以简单理解为<strong>被允许含有属性和方法的原始值</strong>，在之后会提到</p>
<p>创建好一个对象之后，可以随时为它添加属性，也可以在初始化时赋予：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;  <span class="comment">// 初始化时添加属性.</span></span><br><span class="line">    <span class="attr">key</span>: val, <span class="comment">// 键值对形式-[属性名: 属性值].</span></span><br><span class="line">    <span class="attr">key</span>: val,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">key</span> = val; <span class="comment">// 之后添加属性.</span></span><br><span class="line">obj.<span class="property">array</span> = [<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">3</span>]; <span class="comment">// 添加数组属性.</span></span><br></pre></td></tr></table></figure>
<p>一个数组也是<code>Object</code>类型的，它是一种特殊的对象，其中的成员都是属性，每个属性都有一个索引(即下标，从0开始)</p>
<h3 id="symbol"><code>Symbol</code></h3>
<p><code>Symbol</code>类型的值不能通过字面量声明，而且，虽然它可以作为属性，但不能是包装对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym_0 = <span class="title class_">Symbol</span>();   <span class="comment">// 声明一个唯一的标识符.</span></span><br><span class="line"><span class="keyword">let</span> sym_1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;1&#x27;</span>);  <span class="comment">// 声明一个唯一的标识符,&#x27;1&#x27;为它的解释.</span></span><br><span class="line"><span class="keyword">let</span> sym_2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;1&#x27;</span>);  <span class="comment">// 声明一个唯一的标识符,&#x27;1&#x27;为它的解释,且sym_1 != sym_2.</span></span><br><span class="line"><span class="keyword">let</span> sym_error = <span class="keyword">new</span> <span class="title class_">Symbol</span>(); <span class="comment">// 错误声明.</span></span><br><span class="line"><span class="keyword">let</span> sym_copy = sym_0;   <span class="comment">// 则sym_copy == sym_0.</span></span><br></pre></td></tr></table></figure>
<p>括号内的字符串(如果不是则调用<code>String()</code>)只是一个解释，不影响这个值的<strong>唯一性</strong>；所以就算两个值使用同样的解释，它们也是不一样的</p>
<p>如果想重复用同一个<code>Symbol</code>，除了直接赋值，还可以用注册表，能更好地管理符号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym_1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;key&#x27;</span>); <span class="comment">// 注册一个为&#x27;key&#x27;的键,同时它也作为符号的解释.</span></span><br><span class="line"><span class="keyword">let</span> sym_2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;key&#x27;</span>); <span class="comment">// 先寻找,发现&#x27;key&#x27;已存在,则变成sym_2 = sym_1;.</span></span><br></pre></td></tr></table></figure>
<p>同样，虽然使用相同的解释，由注册表创建的符号和一般形式创建的符号是不同的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym_1=<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;k&#x27;</span>), sym_2=<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;k&#x27;</span>), sym_3=<span class="title class_">Symbol</span>(<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">sym_1 === sym_2; <span class="comment">// true.</span></span><br><span class="line">sym_1 === sym_3; <span class="comment">// false.</span></span><br></pre></td></tr></table></figure>
<h3 id="数据间的转换">数据间的转换</h3>
<p>数据类型管理松散虽然方便，但也因此带来一些麻烦，为此需要熟悉数据间的转换规则，可以调用转类型函数：</p>
<ul>
<li><code>Number()</code>：
<ul>
<li>以下为合法数值：如果是小数，则必须含<code>'.'</code>，且小数点前后至少存在一边；如果是假值(例如<code>Infinity</code>)，则返回假值；如果以0开头，则为八进制数；如果以0x或0X开头，则为十六进制数</li>
<li>对字符串，如果它只是合法数值加上了引号(空字符串为0)，则原封不动变成数值，注意它检测不出八进制数，因为它会忽略开头的0；否则返回<code>NaN</code></li>
<li>对布尔值，<code>true</code>返回1，<code>false</code>返回0</li>
<li>对<code>undefined</code>，返回<code>NaN</code></li>
<li>对<code>null</code>，返回0</li>
<li>对对象，如果是包装对象、或是只含一个元素的数组，则以上述规则转换；如果是空对象，则返回<code>NaN</code></li>
<li>不能将符号类型转换成数值</li>
</ul></li>
<li><code>parseInt()/parseFloat()</code>：如果只想将字符串转换成整数或小数，可以选择它们，它们会取字符串的第一个数值(直到遇到非整数/小数字符时停止，如果没有则为<code>NaN</code>)。它与<code>Number()</code>逻辑上有些不同，例如空字符串返回<code>NaN</code>而不是0，而<code>"12abc"</code>返回12而不是<code>NaN</code>。<code>parseInt()</code>还接受第二个参数，以确定数值的进制(默认为自动识别)</li>
<li><code>String()</code>：
<ul>
<li>所有字符串都是合法的，可以用<code>''</code>、<code>""</code>、<code>``</code>(反引号)包围，用<code>'\'</code>转义，但只有用反引号包围的字符串能够解析插值符</li>
<li>对所有假值和数值，一般是原封不动；如果数值是十六进制或八进制，则先转换成十进制</li>
<li>对符号类型，返回<code>Symbol(description)</code></li>
<li>对对象，如果是包装对象或数组，一般原封不动；其它会返回<code>"[object Object]"</code></li>
</ul></li>
<li><code>String.raw``</code>：将反引号包围的字符串视作原始字符串，不会解析转义字符、插值等</li>
<li><code>Boolean()</code>：
<ul>
<li>对数值，非0或<code>Infinity</code>等假值返回<code>true</code>，0或<code>NaN</code>返回<code>false</code></li>
<li>对字符串，非空返回<code>true</code>，否则返回<code>false</code></li>
<li>对对象和符号类型，都返回<code>true</code></li>
<li>对未定义与<code>null</code>，返回<code>false</code></li>
</ul></li>
<li><code>Symbol()</code>：调用<code>String()</code></li>
<li><code>undefined</code>与<code>null</code>：只能转换成其它类型，不能由其它类型转换而来</li>
<li><code>Object()</code>：将其它类型转换成对象</li>
</ul>
<p>除未定义与空类型都有<code>toString()</code>方法，相当于调用<code>String()</code></p>
<h3 id="引用类型">引用类型</h3>
<h4 id="介绍">介绍</h4>
<p>由基本数据类型可组成对象类型，将这个设计好的对象类型称为一个引用类型；类似面向对象中的类(但<code>js</code>中的引用类型不具备类的许多特征，是不完整的类)</p>
<p>创建一个引用类型与数据类型相似，不带<code>new</code>则是创建一个与基本数据类型对应的值(隐式调用这个引用类型的类型转换方法)，带<code>new</code>则是使用构造函数，创建一个对象类型的引用值，一个新实例</p>
<h4 id="基本引用类型">基本引用类型</h4>
<p>标准提供了一些自带的引用类型，例如之前所说的五种含有构造函数的基本数据类型：</p>
<ul>
<li><code>Date</code>：时间类型，继承<code>String</code>，重写<code>toString()</code>(返回一个字符串，表示所在时区、时间)和<code>valueOf()</code>(返回一个数值，表示距离<code>UTC:1970.1.1.00:00:00</code>的毫秒)</li>
<li><code>RegExp</code>：正则表达式类型，字面量由两个’/’夹住的匹配文本、和跟在后面的标记字母组成。例如<code>/abc/g</code>匹配整个字符串的<code>abc</code>，标记可以一起使用，标记有：
<ul>
<li><code>g</code>：查找全部而非第一个字符串</li>
<li><code>i</code>：不区分大小写</li>
<li><code>m</code>：不因达到行末而停止</li>
</ul></li>
<li><code>Boolean,Number,String</code>：之前提到的包装对象就是用这些引用类型创建的，原始值没有属性和方法，但为了让原始值有着对象的行为，<code>js</code>保留了这些引用类型。当通过原始值调用方法时，系统会调用这些引用类型的构造函数和方法(这个临时对象生存周期在句内，这是不能给一个原始值添加属性或方法的原因)。不建议显式创建包装对象</li>
<li><code>Error,ReferenceError</code>等：用于处理错误的类型，例如访问未声明对象会抛出<code>ReferenceError</code></li>
</ul>
<h4 id="一些内置对象">一些内置对象</h4>
<p>不详细展开：</p>
<ul>
<li><code>Global</code>：它无法被访问，所有在全局范围内定义的对象、函数都将成为它的成员，包括标准已经定义的<code>parseInt()</code>等。它还有其它的重要的成员函数：
<ul>
<li><code>encodeURIComponent()</code>：编码<code>URI</code>，方便传递给浏览器。与<code>encodeURI()</code>(编码所有非标准字符)相比，它会编码所有非字母字符，更常用</li>
<li><code>decodeURIComponent()</code>：解码<code>URI</code>，替换所有特殊字符</li>
<li><code>eval()</code>：解释提供的字符串，相当于运行所提供的字符串，方便处理用户输入。使用它应慎重，因为会遭到恶意攻击</li>
</ul></li>
<li><code>window</code>：它是<code>Window</code>引用类型的一个内置实例，是<code>DOM</code>展示出来的接口，被视为<code>Global</code>的代理</li>
<li><code>Math</code>：存放数学常量和方法的对象，含有<code>E,PI</code>等常量，<code>max(),min(),ceil(),floor(),random()</code>等方法</li>
</ul>
<h4 id="集合引用类型">集合引用类型</h4>
<ul>
<li><p><code>Array</code>：数组，它的每个槽位可以放不同数据类型的值，构造一个<code>Array</code>有多种方法：</p>
<p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>(<span class="title class_">Number</span>); <span class="comment">// 构造含Number个元素的数组.</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>(...);  <span class="comment">// 构造内容为...的数组.</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="title class_">Array</span>();  <span class="comment">// 与let arr3 = Array();等价.</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>Map</code>：映射，专门用于存储多个键值对，虽然很多方法可以由<code>Object</code>实现，但也有不同：它可以用任何数据类型作为键，且会维护顺序方便迭代</p></li>
<li><p><code>WeakMap</code>：弱映射，与<code>Map</code>的区别在于它的键的数据类型只能是<code>Object</code>，它的弱在于存储的键是弱实例，不属于正式的引用，不会阻止垃圾回收</p></li>
<li><p><code>Set</code>：数据的集合，在功能上像是加强的<code>Map</code>，也支持顺序迭代</p></li>
<li><p><code>WeakSet</code>：弱集合，与<code>Set</code>的区别在于它的数据只能是<code>Object</code>类型的，同样不会阻止垃圾回收</p></li>
</ul>
<h2 id="运算符">运算符</h2>
<p>不同类型的数据可以相互转换，还存在一些假值，这使运算符较为琐碎，也因此要注意表达式的运算顺序：</p>
<ul>
<li><code>Symbol</code>类型不能参与运算；双目运算中只有一边是对象类型时，将调用<code>valueOf()</code>方法</li>
<li>单目<code>!</code>：调用<code>Boolean()</code>，再取反；两次<code>!</code>相当于一次<code>Boolean()</code></li>
<li>单目<code>+/-</code>：对数字和<code>Infinity</code>则是变为正/负值(0也分正负，但<code>+0 === -0</code>)，<code>NaN</code>则还是<code>NaN</code>；字符串类型会先调用<code>Number()</code>；其它类型会先调用<code>String()</code>，再调用<code>Number()</code></li>
<li>双目<code>+/-</code>：
<ul>
<li>两边均为数值：存在一边为<code>NaN</code>，则为<code>NaN</code>；无穷减无穷(或负无穷加无穷)也为<code>NaN</code>；无穷加无穷为无穷；具体数和无穷相加减得到这个无穷</li>
<li>其它情况相加：<strong>都调用<code>String()</code></strong>，然后拼接</li>
<li>其它情况相减：都调用<code>Number()</code>，然后运算</li>
</ul></li>
<li>双目<code>*</code>：
<ul>
<li>两边均为数值：存在一边为<code>NaN</code>，则为<code>NaN</code>；无穷与其它值相乘还是无穷，同号正异号负</li>
<li>只有数值和字符串：先调用<code>Number()</code>，再相乘</li>
<li>其它情况：先调用<code>String()</code>，再调用<code>Number()</code></li>
</ul></li>
<li>双目<code>/</code>：
<ul>
<li>两边均为数值：一般数字都视作小数运算；如果存在一边为<code>NaN</code>、或<code>0/0</code>、无穷除无穷，则为<code>NaN</code>；非0除以0得无穷；非无穷除以无穷得0</li>
<li>只有数值和字符串：先调用<code>Number()</code>，再相除</li>
<li>其它情况：先调用<code>String()</code>，再调用<code>Number()</code></li>
</ul></li>
<li>双目<code>**</code>：类似<code>python</code>，求幂，与数学逻辑类似；1的无穷为<code>NaN</code></li>
<li>比较操作符：
<ul>
<li>两边均为数值：任一为<code>NaN</code>时，小、大、等于均返回<code>false</code>(包括<code>NaN==NaN</code>)；<code>Infinity</code>等于<code>Infinity</code>；<code>null</code>等于<code>undefined</code></li>
<li>两边均为字符串：逐个比较字符编码</li>
<li>其中一边为数值或布尔值：将两边转换成数值</li>
<li>两边都是对象：查看是否指向同一对象</li>
</ul></li>
<li>全等(<code>===</code>)、不全等(<code>!==</code>)：上面的比较操作符比较反直觉，而这两个运算符类似强类型比较，它们不会转换两边的类型；对全等来说，只有在两边类型、值完全一致时才会返回<code>true</code></li>
<li>三目运算符：<code>exp ? T_val : F_val</code></li>
</ul>
<h2 id="关键字">关键字</h2>
<h3 id="定义变量">定义变量</h3>
<p>关键字并不指定变量的数据类型，而是指定其作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">val_0;   <span class="comment">// 全局变量,第一次声明时必须初始化.</span></span><br><span class="line"><span class="keyword">var</span> val_1;  <span class="comment">// 作用域为函数内.</span></span><br><span class="line"><span class="keyword">let</span> val_2;  <span class="comment">// 作用域为块内.</span></span><br><span class="line"><span class="keyword">const</span> val_3; <span class="comment">// 声明不变量,声明时必须初始化,不能再改变;作用域为块内.</span></span><br></pre></td></tr></table></figure>
<p>使用<code>var</code>时，声明语句会提升至函数头部，且只保留一次声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于:</span></span><br><span class="line"><span class="keyword">var</span> val;</span><br><span class="line">val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    val = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以同名的<code>var</code>变量在函数体内，即使被块分隔，却始终是一个变量；为了防止不经意的重名，不推荐使用<code>var</code></p>
<p>而<code>let</code>和<code>const</code>则更讨喜，它们的声明语句不会提升，且作用域为块内，所以块内外的量是不同的；但因为不会提升也不会合并，所以不能在一个块内用<code>let</code>和<code>const</code>声明同名变量；由于一切对象都以引用值传递，所以优先考虑使用<code>const</code>，其次为<code>let</code>，最后是<code>var</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a; <span class="comment">// 和块外的不冲突,是不同的变量.与C一样,块内优先.</span></span><br><span class="line">    <span class="keyword">let</span> a; <span class="comment">// 和上一条冲突.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个量可以通过插值符顺畅地在字符串中解析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="string">`a + b = <span class="subst">$&#123;a + b&#125;</span>`</span>  <span class="comment">// a + b = 3</span></span><br><span class="line"><span class="string">&quot;a + b = $&#123;a + b&#125;&quot;</span>  <span class="comment">// a + b = $&#123;a + b&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于全局变量，如果已确保不再使用，可以赋<code>null</code>，这有利于浏览器进行内存回收</p>
<h3 id="循环语句">循环语句</h3>
<p>除了<code>C</code>的<code>if</code>、<code>while</code>、<code>do-while</code>，还提供了几种语句：</p>
<ul>
<li><code>for (variable in object)</code>(<code>for-in</code>)：遍历对象的<strong>非符号键属性</strong>，在每一轮循环中赋值给<code>variable</code>，顺序未知</li>
<li><code>for (variable of iterable)</code>(<code>for-of</code>)：遍历可迭代对象(例如字符串、数组)的元素，在每一轮循环中赋值给<code>variable</code>，以迭代顺序输出</li>
<li><code>for await (variable of iterable)</code>(<code>for-await-of</code>)：<code>for-of</code>的扩展，用于遍历异步可迭代对象</li>
<li><code>labelName : 循环</code>：给循环加标签，结合<code>continue</code>与<code>break</code>在嵌套循环中使用</li>
<li><code>with(object)</code>：创建一个属于<code>object</code>的块，在块内使用变量时首先检查是否已声明，若无则检查是否为这个<code>object</code>的成员方法。因此块内调用这个<code>object</code>的方法时有时不用显式写出它，但它影响性能、难以调试维护，在严格模式下禁用也不推荐使用</li>
</ul>
<p>实际上每轮循环中的<code>variable</code>都是临时创建并初始化的，在一轮结束后会丢弃。关键字<code>let,const</code>都可使用，只是在块内会有区别，多次强调的是应该多用<code>const</code>！</p>
<p><code>Js</code>的<code>switch</code>语句在<code>C</code>的基础上，可以对任何数据类型进行<code>switch</code>，<code>case</code>后也可以接表达式或变量；在比较时使用全等，不会进行类型转换</p>
<h3 id="定义函数">定义函数</h3>
<p>只需要关键字<code>function</code>，就可以定义一个函数，在不接参数的<code>return</code>后，跳出函数并返回<code>undefined</code></p>
<p>函数对返回类型管理不严格，但不建议将返回<code>undefined</code>和返回实际值混合使用</p>
<h2 id="迭代器">迭代器</h2>
<p>迭代器让使用者不需要事先得知其数据结构就可以顺序访问其值，迭代器关注的只有”如何访问下一个值”这个问题。可迭代对象(<code>iterable</code>)通常是集合引用类型，即包含元素有限、含有顺序，具体是看是否实现了<code>[Symbol.iterator]()</code>方法，它会返回一个可迭代对象，调用第一次<code>next()</code>后它将指向第一个元素</p>
<p>标准原生的可迭代对象拥有如下方法：</p>
<ul>
<li><code>next()</code>：无论是否存在下一元素，都会顺序迭代一次，返回一个<code>iteratorResult</code>对象</li>
</ul>
<p><code>iteratorResult</code>对象必然含有两个属性：</p>
<ul>
<li><code>done</code>：判断现在的<code>iterable</code>是否可以继续调用<code>next()</code></li>
<li><code>value</code>：如果可以调用，则输出现在<code>iterable</code>指向的值</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code: 较为轻量的IDE</title>
    <url>/blogs/2023/12/08/vscode/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="vs-code"><code>VS Code</code></h1>
<h2 id="基本功能介绍">基本功能介绍</h2>
<ul>
<li><code>VS Code</code>是微软开发的开源的代码编辑器，支持<code>Windows</code>、<code>MacOS</code>、<code>Linux</code>等操作系统
其最显著的优点是<strong>轻量</strong>且<strong>快速</strong>，且得益于活跃的插件生态而<strong>支持多种编程语言</strong>
高度灵活的自定义配置也是其吸引我的一点</li>
<li>左侧一栏为快捷的插件打开方式，包括资源管理器、项目管理器、扩展市场等
<ul>
<li>资源管理器：与其他<code>IDE</code>类似，<code>VS Code</code>将一个项目当作一个工作区来管理，提供的快捷方式包括打开文件夹等
其它更多有关文件管理的功能在顶栏的“文件”中</li>
<li>项目管理器是图标为分叉的一项，它允许将项目绑定一个版本控制管理器，例如<code>Git</code>或<code>SVN</code>，同时也支持绑定<code>Github</code>或其它远程仓库托管网站的账号</li>
<li>扩展市场：这是体现<code>VS Code</code>丰富生态的地方</li>
</ul></li>
<li>顶上一个搜索栏可以最重要的作用是通过键入一个<code>&gt;</code>，以快速搜索并调用插件的功能，之前所说的功能均可由搜索栏搜索得到</li>
<li>以上<code>UI</code>的布局均可随意拖动，以及可以在右上方调整布局</li>
<li>配置：<code>VS Code</code>将配置分为三级，默认配置、用户配置、工作区配置，默认配置存储于<code>defaultSettings.json</code>中，另外两者存储在同名文件<code>settings.json</code>中，所有均在<strong><code>首选项:打开XX配置(JSON)</code></strong>中，<code>VS Code</code>提供了<code>UI</code>界面帮助修改，但建议直接编辑<code>json</code>文件
<ul>
<li>默认配置：<code>VS Code</code>本身及其插件会提供一系列的配置项，插件维护者需要为每一个配置项提供默认值，用户下载该插件后则会登记在默认配置中
该文件是只读文件，无需在意</li>
<li>用户配置：用户配置是<strong>用户自定义的全局的配置</strong>，存放在本机用户家目录下，是最常改的配置文件，在用户定义后，它会覆盖默认配置，否则使用默认配置</li>
<li>工作区配置：存放在工作文件夹下自动生成的<code>./vscode/settings.json</code>，它会覆盖所有上级配置，未定义的配置项使用用户配置</li>
</ul></li>
</ul>
<h2 id="基本的配置">基本的配置</h2>
<ul>
<li><p>编辑器的基本配置(仅包括影响较大的可设置为非默认值的配置)：</p>
<ul>
<li><p>区分内联建议与快速建议：快速建议指的是由字典服务提供的键入值后在光标右侧显示的提示，内联建议指由内置<code>AI</code>智能生成的代码补全
不建议使用内联建议</p></li>
<li><p>不在提交字符时接受建议(建议即快速提示)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.acceptSuggestionOnCommitCharacter&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>不在按下<code>Enter</code>时接受建议：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.acceptSuggestionOnEnter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置在保存代码时进行的动作：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 在显示保存时自动import所需包</span></span><br><span class="line">    <span class="attr">&quot;source.organizeImports&quot;</span><span class="punctuation">:</span> <span class="string">&quot;explicit&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 有其它source动作</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置打开文件时不检测<code>tabSize</code>与<code>insertSpaces</code>，即编辑器无法改变预设<code>tab</code>的空格数以及预设的是否用空格代替<code>tab</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.detectIndentation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>设置保存文件时自动格式化(格式化程序需可用，通常分别设置格式化程序而在全局设置一次以下属性)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>设置键入<code>Tab</code>键时写入<code>\t</code>而不是空格：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.insertSpaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>
<p>此外，如果要设置一个<code>\t</code>的空格数以及一个缩进的空格数，可以设置<code>editor.tabSize</code>以及<code>editor.indentSize</code></p></li>
<li><p>设置接受快速建议时，替换右侧的代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.suggest.insertMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;replace&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置在宽度不足时换行显示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.wordWrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>通过设置<code>"[xxx]"</code>字典，可以设置专门适用于某种文件的配置，例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;[java]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;redhat.java&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>很常用的是对不同的文件配置不同的默认格式化程序</p></li>
</ul>
<h2 id="推荐插件">推荐插件</h2>
<h3 id="中文与颜色主题">中文与颜色主题</h3>
<ul>
<li><code>Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</code>：简体中文插件</li>
<li>设置颜色主题：在左下齿轮图标中设置<code>主题&gt;颜色主题</code>，或通过搜索栏搜索<code>&gt;首选项: 颜色主题</code>，第一项可以搜索查找本机没有的主体并自动下载对应的插件</li>
<li>推荐的主题(浅色党)，安装对应的浅色主题插件后会有对应的暗色主题
<ul>
<li><code>Default Light Modern</code>：<code>VS Code</code>的内置浅色主题</li>
<li><code>Github Light</code>：类<code>Github</code>风格</li>
<li><code>Monokai Pro Light</code>：偏灰色主题</li>
<li><code>Falcon Light</code>：比较护眼的主题，有青、绿、灰、粉、黄色</li>
<li><code>Trae Light</code>、<code>Pure White</code>、<code>Solarized Light</code>也是不错的主题</li>
<li>其它主题可在<a href="https://vscodethemes.com/"
class="uri">https://vscodethemes.com/</a>快速预览</li>
</ul></li>
</ul>
<h3 id="markdown"><code>Markdown</code></h3>
<ul>
<li><p><code>Markdown PDF</code>：支持导出为<code>PDF</code>、<code>HTML</code>、图片、<code>json</code>等</p></li>
<li><p><code>markdownlint</code>：语法高亮与风格检测，同时提供更好用的格式化程序，通过以下配置来设置格式化程序、忽略部分警告：</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;[markdown]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DavidAnson.vscode-markdownlint&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;markdownlint.config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 警告与错误提示</span></span><br><span class="line">    <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MD033&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>Markdown Preview Enhanced</code>：提供更好的预览，通过以下配置来支持行内<code>LaTeX</code>公式渲染：</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;markdown-preview-enhanced.mathRenderingOption&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MathJax&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>Markdown Preview Mermaid Support</code>：提供<code>mermaid</code>代码块的渲染</p></li>
<li><p><code>GitHub Markdown Preview</code>：使用<code>Github</code>的预览风格</p></li>
</ul>
<h3 id="cc"><code>C/C++</code></h3>
<ul>
<li><p><code>C/C++</code>：</p></li>
<li><p><code>C/C++ Runner</code>：支持运行<code>C/Cpp</code>代码，包含以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 额外包含的路径</span></span><br><span class="line"><span class="attr">&quot;C_Cpp_Runner.includePaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// C/Cpp标准</span></span><br><span class="line"><span class="attr">&quot;C_Cpp_Runner.cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span></span><br><span class="line"><span class="attr">&quot;C_Cpp_Runner.cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>clangd</code></p></li>
<li><p><code>CMake</code>与<code>CMake Tools</code></p></li>
</ul>
<h3 id="java"><code>Java</code></h3>
<ul>
<li><code>Extension Pack for Java</code></li>
<li>?<code>Java Language Support</code></li>
<li><code>Spring Boot Extension Pack</code></li>
</ul>
<h3 id="远程连接">远程连接</h3>
<ul>
<li><code>Remote Development</code></li>
</ul>
<h3 id="数据库">数据库</h3>
<ul>
<li><code>Database Client</code></li>
</ul>
<h3 id="vim"><code>Vim</code></h3>
<ul>
<li><code>Vim</code></li>
<li><code>settings.json</code>代替了<code>vimrc</code>配置：
<ul>
<li><p>配置插入模式的快捷键，建议绑定<code>esc</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;j&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;j&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&lt;esc&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>在插入模式下键入两次<code>j</code>等价于键入<code>esc</code></p></li>
<li><p>配置在正常模式下的快捷键(例如将保存文件设置为<code>&lt;leader&gt;+s</code>)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.normalModeKeyBindingsNonRecursive&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&lt;leader&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;s&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;:w!&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&lt;leader&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;q&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;:q!&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置<code>leader</code>键为空格(默认为<code>\</code>)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.leader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;space&gt;&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="latex"><code>LaTeX</code></h3>
<ul>
<li><code>LaTeX</code></li>
</ul>
<h3 id="vue"><code>Vue</code></h3>
<ul>
<li><code>Vue (Official)</code></li>
<li><code>Vetur</code></li>
</ul>
<h3 id="python"><code>Python</code></h3>
<ul>
<li><code>Python Extension Pack</code></li>
<li><code>Black Formatter</code></li>
<li><code>Flake8</code></li>
<li><code>Jupyter</code></li>
</ul>
<h3 id="rust"><code>Rust</code></h3>
<h3 id="其它插件">其它插件</h3>
<ul>
<li><code>GitHub Pull Requests</code>：支持在<code>VS Code</code>中提<code>PR</code>与讨论<code>Issue</code></li>
</ul>
]]></content>
      <categories>
        <category>Tools &amp; Utilities</category>
        <category>editor</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>beginner</tag>
        <tag>vscode</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 反常积分</title>
    <url>/blogs/2023/12/03/calculus-improper-int/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="反常积分">反常积分</h1>
<p>即广义积分，分为<strong>无穷区间</strong>上与<strong>无界函数</strong>上两种</p>
<h2 id="计算">计算</h2>
<h3 id="无穷区间上">无穷区间上</h3>
<p><span
class="math inline">$\begin{align}&amp;\int_a^{+\infty}f(x)dx=\lim_{b\rightarrow+\infty}\int_a^bf(x)dx\end{align}$</span></p>
<p>拆为两项，其中需要关注<span
class="math inline">$\begin{align}\lim_{x\rightarrow\infty}f(x)\end{align}$</span>一项，如果它<strong>存在</strong>，则积分<strong>收敛</strong>，否则发散</p>
<p>需要熟悉不定积分的求法，利用<strong>牛顿莱布尼茨</strong>公式进行求解，不同之处在于它需要计算一项或两项的极限值</p>
<hr />
<p><strong>eg:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;计算\int_0^{+\infty}\frac{xe^{-x}}{(1+e^{-x})^2}dx\\&amp;解:原式\xlongequal{t=-x}\int_0^{+\infty}\frac{te^t}{(1+e^t)^2}dt=(-\frac{t}{1+e^t})\Bigg|_0^{+\infty}+\int_0^{+\infty}\frac{1}{e^t(1+e^t)}de^t\\&amp;=(\ln\frac{e^t}{(1+e^t)}-\frac{t}{1+e^t})\Bigg|_0^{+\infty}=\ln2\end{align}$</span></p>
<h2 id="证明广义积分等式">证明广义积分等式</h2>
<p>一般需要作代换，可以考虑<strong>倒代换</strong>、三角代换等</p>
<hr />
<p><strong>eg:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;证明\int_0^{+\infty}\frac{dx}{1+x^4}=\int_0^{+\infty}\frac{x^2}{1+x^4}dx，并求值\\&amp;证:左边\xlongequal{t=\Large
\frac{1}{x}}\int_{+\infty}^0-\frac{dx}{x^2(1+\frac{1}{x^4})}=\int_0^{+\infty}\frac{x^2}{1+x^4}dx=右边\\&amp;\therefore原式=\frac{1}{2}\int_0^{+\infty}\frac{1+x^2}{1+x^4}dx=\frac{1}{2}\int_0^{+\infty}\frac{1+\large\frac{1}{x^2}}{x^2+\large\frac{1}{x^2}}dx=\frac{1}{2}\int_0^{+\infty}\frac{d({x-\large\frac{1}{x}})}{(x-{\large\frac{1}{x}})^2+2}=\\&amp;\frac{\sqrt2}{4}\arctan{\bigg[\frac{\sqrt2}{2}(x-\frac{1}{x})\bigg]}\Bigg|_0^{+\infty}=\frac{\sqrt2\pi}{4}\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 定积分</title>
    <url>/blogs/2023/11/28/calculus-definite-int/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="定积分">定积分</h1>
<h2 id="定义">定义</h2>
<p><span
class="math inline">$\begin{align}\int_a^bf(x)dx=\lim_{\lambda\rightarrow0}\sum_{i=1}^nf(\xi_i)\Delta
x_i\end{align}$</span></p>
<h2 id="可积的条件">可积的条件</h2>
<ol type="1">
<li>f(x)在[a, b]上连续</li>
<li>f(x)在[a, b]上单调</li>
<li>f(x)在[a, b]上有界，且只有有限个间断点</li>
</ol>
<h2 id="一些特殊性质">一些特殊性质</h2>
<h3 id="单调性反之不成立">单调性(反之不成立)</h3>
<p><span
class="math inline">$\begin{align}若f(x)与g(x)在[a,b]上均可积，且f(x)\le
g(x)，则\int_a^bf(x)dx\le\int_a^bg(x)dx\end{align}$</span></p>
<h3 id="textcolorred最大最小值"><span
class="math inline">$\textcolor{red}{最大最小值}$</span></h3>
<p><span
class="math inline">$若M和m分别是可积函数f(x)的最大值和最小值，则\\m(b-a)\le\int_a^bf(x)dx\le
M(b-a)$</span></p>
<h3 id="textcolorred区间可加性"><span
class="math inline">$\textcolor{red}{区间可加性}$</span></h3>
<p><span
class="math inline">$\begin{align}&amp;可以分为若干个分割，即\\&amp;\int_a^bf(x)dx=\int_a^cf(x)dx+\int_c^bf(x)dx\\&amp;\int_a^bf(x)dx=-\int_b^af(x)dx\end{align}$</span></p>
<h3 id="乘法可积">乘法可积</h3>
<p><span
class="math inline"><em>若</em><em>f</em>(<em>x</em>), <em>g</em>(<em>x</em>)<em>在</em>[<em>a</em>,<em>b</em>]<em>上</em><em>可</em><em>积</em>, <em>则</em><em>f</em>(<em>x</em>)<em>g</em>(<em>x</em>)<em>在</em>[<em>a</em>,<em>b</em>]<em>上</em><em>也</em><em>可</em><em>积</em></span></p>
<h3 id="textcolorred积分中值定理"><span
class="math inline">$\textcolor{red}{积分中值定理}$</span></h3>
<p><span
class="math inline">$\begin{align}&amp;若f(x)在[a,b]上连续,则存在\xi\in[a,b],使\\&amp;\int_a^bf(x)dx=f(\xi)(b-a)\end{align}$</span></p>
<h2 id="牛顿莱布尼茨公式">牛顿莱布尼茨公式</h2>
<p><span
class="math inline">$\begin{align}&amp;求定积分时，可以直接求f(x)不带C的原函数F(x)\\
&amp;\int_a^bf(x)dx=F(x)(b-a)\end{align}$</span></p>
<h2 id="变上限函数">变上限函数</h2>
<h3 id="定义f不带c的一个特殊原函数">定义(f不带C的一个特殊原函数)</h3>
<p><span
class="math inline">$\begin{align}\phi(x)=\int_a^xf(t)dt\end{align}$</span></p>
<h3 id="性质">性质</h3>
<h4 id="连续且有界">连续且有界</h4>
<p><span
class="math inline"><em>如</em><em>果</em><em>f</em><em>可</em><em>积</em>，<em>则</em><em>ϕ</em>(<em>x</em>)<em>连</em><em>续</em><em>且</em><em>有</em><em>界</em></span></p>
<h4 id="导函数">导函数</h4>
<p><span
class="math inline"><em>ϕ</em>′(<em>x</em>) = <em>f</em>(<em>x</em>)</span></p>
<p>任何连续函数都具有原函数</p>
<h2 id="题型计算定积分">[题型]计算定积分</h2>
<h4 id="beginaligntextcolorred1.int_abfxdxint_abfab-xdxendalign"><span
class="math inline">$\begin{align}\textcolor{red}{1.\int_a^bf(x)dx=\int_a^bf(a+b-x)dx}\end{align}$</span></h4>
<p>即令t=a+b-x, 此方法可以证明它本身和f(sin x)与f(cos x)的关系</p>
<p><span
class="math inline">$\begin{align}利用此方法还可以计算：\int_a^bf(x)dx=\frac{1}{2}\int_a^b(f(x)+f(a+b-x))dx\end{align}$</span></p>
<h4 id="利用牛顿莱布尼茨公式">2.利用牛顿莱布尼茨公式</h4>
<h4 id="textcolorred3.利用奇偶性"><span
class="math inline">$\textcolor{red}{3.利用奇偶性}$</span></h4>
<p><span
class="math inline">$\begin{align}\int_{-a}^af(x)dx=\int_0^a{(f(x)+f(-x))dx}\end{align}$</span></p>
<p>当f(x)是奇函数时,<span
class="math inline">$\begin{align}\int_{-a}^af(x)dx=0\end{align}$</span></p>
<p>当f(x)是偶函数时,<span
class="math inline">$\begin{align}\int_{-a}^af(x)=2\int_0^af(x)dx\end{align}$</span></p>
<p>当f(x)中有一部分是奇或偶函数时也可尝试这个公式</p>
<h4 id="利用周期性">4.利用周期性</h4>
<p><span
class="math inline">$\begin{align}&amp;若f(x)以T为周期，则\\&amp;\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx\\&amp;\int_a^{a+nT}f(x)dx=n\int_0^Tf(x)dx\end{align}$</span></p>
<h4 id="关于三角函数的定积分">5.关于三角函数的定积分</h4>
<p><span
class="math inline">$\begin{align}1).\int_0^{\frac{\pi}{2}}(\cos
x)dx=\int_0^{\frac{\pi}{2}}(\sin x)dx\end{align}$</span></p>
<p>​ 1)可以使<span
class="math inline">$\begin{align}t=\frac{\pi}{2}-x证明\end{align}$</span></p>
<p><span class="math inline">$\begin{align}2).\int_0^\pi xf(\sin
x)dx=\frac{\pi}{2}\int_0^\pi f(\sin x)dx=\pi\int_0^\frac{\pi}{2}f(\sin
x)dx\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;3).\int_0^\frac{\pi}{2}f(\sin^nx)dx\\
&amp;当n为偶数时,\int_0^\frac{\pi}{2}f(sin^nx)dx=\frac{n-1}{n}\frac{n-3}{n-2}...\frac{1}{2}·\frac{\pi}{2}\\&amp;当n为奇数时,\int_0^\frac{\pi}{2}f(sin^nx)dx=\frac{n-1}{n}\frac{n-3}{n-2}...\frac{1}{3}·1\end{align}$</span></p>
<h2 id="题型计算极限">[题型]计算极限</h2>
<h3 id="求数列多项和的极限">求数列多项和的极限</h3>
<ol type="1">
<li><p>先考虑夹逼定理</p></li>
<li><p>若无法夹逼，可以提出<span
class="math inline">$\begin{align}\frac{1}{n}\end{align}$</span>后，化为一个0到1的定积分</p></li>
</ol>
<p>例：</p>
<p><span
class="math inline">$\begin{align}&amp;求\lim_{n\rightarrow\infty}(\frac{n}{n^2+1^2}+\frac{n}{n^2+2^2}+\frac{n}{n^2+3^2}+...+\frac{n}{n^2+n^2})\\&amp;解：\\&amp;原式=\frac{1}{n}\sum_{i=1}^\infty
n·\frac{n}{n^2+i^2}(n\rightarrow\infty)=\int_0^1\frac{1}{1+x^2}dx=\arctan
1=\frac{\pi}{4}\end{align}$</span></p>
<h3 id="关于变限函数导数的计算">关于变限函数导数的计算</h3>
<p>通过换元，可以得到<span
class="math inline">$\begin{align}\int_{v(x)}^{u(x)}f(t)dt=\int_0^{u(x)}f(t)dt-\int_0^{v(x)}f(t)dt=f\Big(u(x)\Big)u'(x)-f\Big(v(x)\Big)v'(x)\end{align}$</span></p>
<h2 id="求面积">求面积</h2>
<p>求面积时一定注意结果是<strong>正数</strong></p>
<h3 id="单个函数">单个函数</h3>
<p>最基础的，求一个连续图形的面积和x轴包围的面积，即求<span
class="math inline">$\begin{align}\int_a^by\ dx\end{align}$</span></p>
<p>如果要求和y轴包围的面积，反函数连续，即求<span
class="math inline">$\begin{align}\int_a^bx\ dy\end{align}$</span></p>
<h3 id="多条曲线">多条曲线</h3>
<p>如果求多条曲线包围的面积，先观察它或反函数在这个区间内是否连续，取微分时，被积函数是连续的可以方便计算，同时也要判断反函数是否好求</p>
<hr />
<p><strong>eg1</strong>：</p>
<p><span class="math inline">$\begin{align}&amp;在第一象限内，求曲线\rm
y=-x^2+1上的一点，使该点处的切线与所给曲线及两坐标轴围成的图形面积为\\&amp;最小，并求此最小面积\\&amp;解:先求切线，设切点为(a,-a^2+1)\\&amp;则切线为\rm
y=-2ax+a^2+1\\&amp;得到与x、y轴的交点分别为(\frac{a^2+1}{2a},\ 0)、(0,\
a^2+1)\\&amp;则S=\int_0^{\Large\frac{a^2+1}{2a}}(-2ax+a^2+1)dx-\int_0^1(-x^2+1)dx=\frac{a^3}{4}+\frac{a}{2}+\frac{1}{4a}-\frac{2}{3}\\&amp;\therefore
S'=\frac{3a^2}{4}+\frac{1}{2}-\frac{1}{4a^2}(a\in[0,1])，令S'=0，得a^2=\frac{1}{3}，即a=\frac{1}{\sqrt3}\\&amp;易得该点为最小值S_{min}=\frac{2}{9}(2\sqrt3-3)\end{align}$</span></p>
<hr />
<p><strong>eg2</strong>：</p>
<p><span class="math inline">$\begin{align}&amp;已知抛物线\rm
y=px^2+qx(其中p&lt;0,q&gt;0)在第一象限内与直线x+y=5相切，且抛物线与x轴围成\\&amp;的平面图形的面积为S\\&amp;(1)问:p和q为何值时，S达到最大值?\\&amp;(2)求出此最大值\\&amp;令y=0得x=-\frac{q}{p}，故S=\int_0^{\large-\frac{q}{p}}(px^2+qx)dx=\frac{q^3}{6p^2}\\&amp;又由相切，得\begin{cases}2px_0+q=-1\\px_0^2+qx_0=-x_0+5\end{cases}，切点为(x_0,y_0)\\&amp;\therefore
S=\frac{200q^3}{3(q+1)^4}，令S'=0，得q=3，易得S_{max}=\frac{225}{32}\end{align}$</span></p>
<hr />
<p><strong>eg3</strong>：</p>
<p><span
class="math inline">$\begin{align}&amp;设F(x)=\begin{cases}e^{2x},&amp;x\le0\\e^{-2x},&amp;x&gt;0\end{cases}，S表示夹在x轴与曲线y=F(x)之间的面积，对任何t&gt;0，S_1(t)表示矩形\\&amp;-t\le
x\le t,0\le y\le
F(t)的面积，求\\&amp;(1)S(t)=S-S_1(t)的表达式\\&amp;(2)S(t)的最小值\\&amp;解:S(t)=2\int_0^{+\infty}e^{-2x}dx-2t·e^{-2t}=1-2t·e^{-2t}\\&amp;\therefore
S'(t)=(4t-2)e^{-2t}\\&amp;令S'(t)=0，得t=\frac{1}{2},易得S(t)_{min}=1-\frac{1}{e}\end{align}$</span></p>
<h3 id="极坐标下面积">极坐标下面积</h3>
<p>在利用定积分前，需要知道怎么将一般方程转换成极坐标方程：令<span
class="math inline">$\rm x=a\cos\theta,\ y=a\sin\theta$</span>即可</p>
<hr />
<p><strong>eg1</strong>：</p>
<p>求双纽线<span class="math inline">$\rm
(x^2+y^2)^2=x^2-y^2$</span>的极坐标方程</p>
<p><span
class="math inline">$\begin{align}&amp;解:令x=r\cos\theta,y=r\sin\theta,得r^4=r^2(\cos^2\theta-\sin^2\theta),即r=\sqrt{\cos2\theta}=\rho(\theta)\end{align}$</span></p>
<p>接下来求它围成的面积，对<span
class="math inline"><em>θ</em></span>取微分，将面积分割为许多个扇形，而<span
class="math inline">$\begin{align}\mathbf{S_{扇形}=\frac{1}{2}r^2\theta}\end{align}$</span></p>
<p>那么，积分上下限怎么求呢? <span
class="math inline"><em>θ</em></span>是从原点出发而言的，双纽线是对称图形，这意味着只需要求第一象限部分的面积，那么积分下限就是0，而<strong><span
class="math inline"><strong>r</strong></span>是大于0的</strong>，因此<strong>令<span
class="math inline"><strong>r</strong> <strong>=</strong> <strong>0</strong></span></strong>，得到<span
class="math inline">$\begin{align}\theta=\frac{\pi}{4}\end{align}$</span></p>
<p>因此<span class="math inline">$\begin{align}\rm
S=4\int_0^{\large\frac{\pi}{4}}\frac{1}{2}r^2d\theta\end{align}$</span></p>
<hr />
<p><strong>eg2</strong>：求两种极坐标下曲线围成的面积，注意一般这种曲线具有<strong>对称性</strong>，所以是两倍的<span
class="math inline">$\begin{align}[0,\pi]区间或[-\frac{\pi}{2},\frac{\pi}{2}]\end{align}$</span></p>
<p>求心脏线<span
class="math inline">$\begin{align}\rho=a(1+\cos\varphi)\end{align}$</span>与圆<span
class="math inline"><em>ρ</em> = <em>a</em></span>所围成的各部分的面积(a&gt;0)</p>
<p><span
class="math inline">$\begin{align}&amp;解:\\&amp;(1)求共有面积\\&amp;[简单来说,谁的r小就取谁的表达式,因为是''共有面积'']\\&amp;\therefore当\cos\theta\le0时，取心脏线\rho_1，否则取\rho_2\\&amp;\therefore
S=\frac{1}{2}·2\Bigg(\int_0^{\large\frac{\pi}{2}}a^2d\theta+\int_{\large\frac{\pi}{2}}^\pi\Big
(a(1+\cos\varphi)\Big)^2d\theta\Bigg)\\&amp;(2)求心脏线独有面积\\&amp;[当心脏线大于圆时计算面积]\\&amp;S=2·\frac{1}{2}\int_0^{\large\frac{\pi}{2}}\Big(a(1+\cos\theta)\Big)^2-a^2d\theta\\&amp;(3)求圆独有面积:与(2)同理，不多赘述\end{align}$</span></p>
<hr />
<p><strong>eg3</strong>：简易的画图可以帮助更快地做题，我们将右式在<span
class="math inline">[0,2<em>π</em>](<em>或</em>[−<em>π</em>,<em>π</em>])</span>上展开，大于0的范围合起来就是图</p>
<p><span
class="math inline">$\begin{align}&amp;\rm求曲线r=\sqrt2\sin\theta及r^2=\cos2\theta所围成的公共部分的面积\\&amp;解:[分析:只有r大于0时才算进图里，对r_1来说,\theta\in{\small[0,\pi]},对r_2来说,\theta\in{\small[-\frac{\pi}{4},\frac{\pi}{4}]\And[\frac{5\pi}{4},\frac{7\pi}{4}]}]\\&amp;令r_1=r_2，得\theta=\frac{\pi}{6}或\frac{5\pi}{6},当\frac{\pi}{6}&lt;\theta&lt;\frac{\pi}{4}时，r_1&gt;r_2\\&amp;\therefore
S=\frac12·2(\int_0^{\large\frac{\pi}{6}}2\sin^2\theta\
d\theta+\int_{\large\frac{\pi}{6}}^{\large\frac{\pi}{4}}\cos2\theta \
d\theta)=\frac\pi6+\frac{1-\sqrt3}2\end{align}$</span></p>
<h3 id="旋转体表面积">旋转体表面积</h3>
<h2 id="求体积">求体积</h2>
<h3 id="柱壳法">柱壳法</h3>
<p>当所求旋转体是中空时，可以用柱壳法求体积，以每层薄薄的”柱壳”为<span
class="math inline"><em>d</em><em>t</em></span>，对’<span
class="math inline"><em>周</em><em>长</em> · <em>高</em></span>’积分</p>
<p><strong>eg</strong>：</p>
<p><span
class="math inline">$\begin{align}&amp;\rm求曲线y=x^2-2x,y=0,x=1,x=3所围成的平面图形绕y轴旋转一周的旋转体的体积V\\&amp;解:先画图\end{align}$</span></p>
<p><img src="旋转体.png" alt="旋转体" style="zoom:33%;" /></p>
<p><span
class="math inline">$\begin{align}&amp;\rm因为[1,2]范围是负数,所以V=\int_2^12\pi
xy\ dx+\int_2^32\pi xy\ dx=9\pi\end{align}$</span></p>
<p>其中，<span class="math inline">$\rm 2\pi
x$</span>为每个柱壳的周长，<span class="math inline">$\rm
y$</span>为每个柱壳的高。注意，当旋转轴不是单纯的x轴或y轴时，求柱壳体积需额外注意，例如本例，如果绕<span
class="math inline"><em>x</em> =  − 1</span>旋转，则<span
class="math inline">$\rm V_{柱壳}=2\pi(x+1)y$</span></p>
<h3 id="截面法">截面法</h3>
<p>显然，不是所有的情况都适用柱壳法，大多数情况下使用的是截面法，特别是多条复杂曲线所围成的图形</p>
<p><strong>eg</strong>：</p>
<p><span
class="math inline">$\begin{align}&amp;\rm设直线y=\frac{\sqrt2}2x和y=x^2围成的面积为S_1,它们与x=1围成的面积为S_2,求这两个平面图形绕x轴旋转\\&amp;而成旋转体的总体积\rm
V\\&amp;解:画图\end{align}$</span></p>
<p><img src="定积分_旋转体2.png" alt="定积分_旋转体2" style="zoom:33%;" /></p>
<p><span class="math inline">$\begin{align}&amp;\rm
V=\int_0^{\large\frac{\sqrt{2}}2}\pi(\frac{x^2}2-x^4)dx+\int_{\large\frac{\sqrt{2}}2}^1\pi(x^4-\frac{x^2}2)dx=\frac{(1+\sqrt2)\pi}{30}\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 不定积分</title>
    <url>/blogs/2023/11/12/calculus-indefinite-int/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="不定积分">不定积分</h1>
<h2 id="公式">公式</h2>
<h3 id="基本公式">基本公式</h3>
<p><span class="math inline">$\begin{align} &amp;\int kdx=kx+C,\ \int
kx^\alpha dx=\frac{k}{\alpha+1}x^{\alpha+1}+C(\alpha\neq -1)\\&amp; \int
\frac{dx}{x}=ln|x|+C, \int e^{kx}dx=\frac{1}{k}e^{kx}+C\\&amp; \int \sin
xdx=-\cos x+C, \int \cos xdx=\sin x+C, \int \sec^2xdx=\tan x+C\\&amp;
\int\csc^2xdx=\int\frac{dx}{\sin^2x}=-\cot x+C\\&amp; \int\sec x\tan
xdx=\sec x+C, \int\csc x\cot xdx=\int\frac{\cos x}{\sin^2x}dx=-\csc
x+C\\&amp; \int \frac{1}{1+x^2}dx=\arctan
x+C,\int\frac{dx}{\sqrt{1-x^2}}=\arcsin x+C \end{align}$</span></p>
<h3 id="拓展公式需要熟悉推导过程">拓展公式(需要熟悉推导过程)</h3>
<p><span class="math inline">$\begin{align}&amp; \int\tan
xdx=\int\frac{\sin xdx}{\cos x}=-\ln|\cos x|+C\\&amp; \int\cot
xdx=\int\frac{\cos xdx}{\sin x}=ln|\sin x|+C\\&amp; \int\sec
xdx=\int\frac{dx}{\cos x}=\int\frac{\cos xdx}{\cos^2x}=\int\frac{d(\sin
x)}{1-\sin^2x}=\frac{1}{2}ln|\frac{1+\sin x}{1-\sin x}|+C\\&amp;
\int\csc xdx=\int\frac{\sin xdx}{\sin^2x}=-\int\frac{d(\cos
x)}{1-\cos^2x}=-\frac{1}{2}ln|\frac{1+\cos x}{1-\cos x}|+C\\\\\\&amp;
对于\sin^nx与\cos^nx，n较小时\\&amp; 若n为偶数:\\&amp;
直接通过cos2x=1-2sin^2x=2cos^2x-1降次\\&amp; 若n为奇数:\\&amp;
将一个抽取出来凑微分，剩下的部分通过sin^2x+cos^2x=1进行替换\\\\&amp;
若n较大:记公式(没必要)\int\sin^nxdx=-\frac{1}{n}sin^{n-1}xcosx+\int\frac{n-1}{n}sin^{n-2}xdx
\end{align}$</span></p>
<h3 id="常凑微分">常凑微分</h3>
<p><span class="math inline">$\begin{align}&amp; (凑常数):\int
f(ax+b)dx=\frac{1}{a}\int f(ax+b)d(ax+b)=\frac{1}{a}\int
f(t)dt\Big\vert_{t=ax+b}\\&amp;
(凑x^\alpha):x^{\alpha}dx=\frac{1}{\alpha+1}dx^{\alpha+1}\\&amp;
(凑\frac{1}{x}):\frac{1}{x}dx=d(\ln x)\\&amp; (凑\sec^2 x):\sec^2
xdx=d(\tan x)\\&amp; (凑\csc^2 x):\csc^2 xdx=-d(\cot x)\\&amp;(凑\sqrt
x):\frac{dx}{\sqrt x}=2d(\sqrt
x)\\&amp;(凑\frac{dx}{\sqrt{二次项式}}):将分母凑配方，得到\sqrt{1-Ax^2}的形式\\&amp;(凑1\pm\frac{1}{x^2}):(1\pm\frac{1}{x^2})dx=d(x\mp\frac{1}{x}),而(x\mp\frac{1}{x})^2=(x^2+\frac{1}{x^2})\pm
2\\&amp;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
即通过倒代换凑出\end{align}$</span></p>
<h3 id="分部积分">分部积分</h3>
<p><span class="math inline">$\begin{align}\int
f(x)g'(x)dx=\Big(f(x)·g(x)\Big)'-\int f'(x)·g(x)\end{align}$</span></p>
<h2 id="求不定积分的技巧">求不定积分的技巧</h2>
<h3 id="分式">分式</h3>
<h4
id="假分式化为真分式分子最高次幂大于等于分母最高次幂">假分式化为真分式(分子最高次幂大于等于分母最高次幂)</h4>
<p>exp1:</p>
<p><span
class="math inline">$\begin{align}&amp;求\int\frac{x^3}{x+3}dx\\&amp;解:\\&amp;原式=\int\frac{(x+3)(x^2-3x+9)-27}{x+3}dx=\frac{1}{3}x^3-\frac{3}{2}x^2+9x-27ln|x+3|+C\end{align}$</span></p>
<p>具体方法:</p>
<p><img src="D:\Picture\Screenshots\截图[工数上]\1.jpg" style="zoom: 25%;" /></p>
<h4 id="真分式化为四种分式">真分式化为四种分式</h4>
<p><span class="math inline">$\begin{align}&amp;1.\int\frac{A}{x-a}dx\ \
\ \ \ \ \ \ \ \ \ \ \ \ \ \ Aln|x-a|\\&amp;2.\int\frac{A}{(x-a)^n}dx\ \
\ \ \ \ \ \ \ \ \
A\frac{1}{1-n}(x-a)^{1-n}\\&amp;3.\int\frac{Mx+N}{x^2+px+q}dx\ \ \ \ \
将分母配方为(x-a)^2+b的形式即可\\&amp;4.\int\frac{Mx+N}{(x^2+px+q)^n}dx\end{align}$</span></p>
<p>怎么拆开? 假设我们有:</p>
<p><span
class="math inline">$\begin{align}&amp;1.\frac{分子}{(x+a)^p(x+b)^q},则应拆成:\\&amp;\frac{A_1}{(x+a)^p}+\frac{A_2}{(x+a)^{p-1}}+\frac{A_3}{(x+a)^{p-2}}+...+\frac{B_1}{(x+a)^{q-1}}+\frac{B_2}{(x+a)^{q-2}}+...\\\\&amp;2.\frac{分子}{(x^2+px+q)(其它分母)},则应拆成:\\&amp;\frac{Ax+B}{x^2+px+q}+...\end{align}$</span></p>
<p>然后得到:</p>
<p><span
class="math inline">$\begin{align}分子=分式1分子+分式2分子+...\end{align}$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 极限练习题</title>
    <url>/blogs/2023/11/05/calculus-limit-exercise/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="极限">极限</h1>
<h2 id="证明数列极限存在">证明数列极限存在</h2>
<p>应当利用单调有界收敛原理</p>
<hr />
<p><strong>eg:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;已知x_1=1，x_{n+1}=\frac{1}{1+x_n}，n=1,2,3,...，证明\lim_{n\rightarrow\infty}x_n存在\\&amp;证:\\&amp;\because
x_{n+1}-x_n=-\frac{x_n^2+x_n-1}{1+x_n}&gt;0，\therefore
x_n单调递减\\&amp;又x_n&gt;0恒成立，\therefore
x_n有界\\&amp;根据有界收敛原理，\lim_{n\rightarrow\infty}x_n存在，令A=\frac{1}{1+A}，得极限=\frac{1+\sqrt5}{2}\end{align}$</span></p>
<h2 id="证明极限不存在">证明极限不存在</h2>
<p>判断极限存在时，一定要注意趋近值的两边</p>
<hr />
<p><strong>eg1:</strong></p>
<p><span class="math inline">$1.
当x\rightarrow1时，函数\Large\frac{x^2-1}{x-1}e^{\frac{1}{x-1}}\normalsize的极限$</span><a
href="#1" title="答案"></a><a id="~1"></a></p>
<p>A. 等于2 B. 等于0 C. 为<span class="math inline">∞</span> D.
不存在但不为<span class="math inline">∞</span></p>
<hr />
<p><strong>eg2:</strong></p>
<p><span class="math inline">$\begin{align}&amp;当x\rightarrow
x_0时，判断左右极限\\&amp;当x\rightarrow\infty时，取相近的两无穷大数判断\\&amp;证明\lim_{x\rightarrow+\infty}x\sin
x不存在\\&amp;证:取x_1=n\pi，x_2=n\pi+\frac{\pi}{2}\\&amp;易得\lim_{x\rightarrow+\infty}f(x_1)=0，\lim_{x\rightarrow+\infty}f(x_1)=+\infty\\&amp;故不存在\end{align}$</span></p>
<hr />
<p><strong>eg3: 换元</strong>法将复杂问题变简单</p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow1}(1-x)^2e^{\Large\frac{1}{x-1}}\\&amp;解:\lim_{x\rightarrow1^-}f(x)=0\\&amp;\lim_{x\rightarrow1^+}f(x)\xlongequal{\Large
t=\frac{1}{x-1}}\lim_{t\rightarrow+\infty}\frac{e^t}{t^2}=+\infty\\&amp;故原极限不存在\end{align}$</span></p>
<h2 id="判断数列函数的极限">判断数列/函数的极限</h2>
<p>数列是特殊的，需要注意它是一个个点组成的，在判断有界无界，收敛发散时与函数不同</p>
<hr />
<p><strong>eg1:</strong></p>
<p>​ 2. 设数列 <span
class="math inline">$\begin{align}x_n与y_n满足\lim_{n\rightarrow\infty}x_ny_n=0\end{align}，则正确的是$</span><a
href="#2" title="答案"></a><a id="~2"></a></p>
<p>​ A. 若<span
class="math inline"><em>x</em><sub><em>n</em></sub></span>发散，则<span
class="math inline"><em>y</em><sub><em>n</em></sub></span>必发散 B.
若<span
class="math inline"><em>x</em><sub><em>n</em></sub></span>无界，则<span
class="math inline"><em>y</em><sub><em>n</em></sub></span>必有界</p>
<p>​ C. 若<span
class="math inline"><em>x</em><sub><em>n</em></sub></span>有界，则<span
class="math inline"><em>y</em><sub><em>n</em></sub></span>必为无穷小 D.
若<span
class="math inline">$\begin{align}\frac{1}{x_n}\end{align}$</span>为无穷小，则<span
class="math inline"><em>y</em><sub><em>n</em></sub></span>必为无穷小</p>
<hr />
<p><strong>eg2:</strong></p>
<ol start="3" type="1">
<li><p>关于数列{<span
class="math inline"><em>x</em><sub><em>n</em></sub></span>}，下列说法不正确的是<a
href="#3" title="答案"></a><a id="~3"></a></p>
<p>A. <span
class="math inline">$\begin{align}若\lim_{x\rightarrow\infty}x_n=a,则\lim_{x\rightarrow\infty}x_{2n}=\lim_{x\rightarrow\infty}x_{2n-1}=a\end{align}$</span></p>
<p>B. <span
class="math inline">$\begin{align}若\lim_{x\rightarrow\infty}x_{2n}=\lim_{x\rightarrow\infty}x_{2n-1}=a,则\lim_{x\rightarrow\infty}x_n=a\end{align}$</span></p>
<p>C. <span
class="math inline">$\begin{align}若\lim_{x\rightarrow\infty}x_n=a,则\lim_{x\rightarrow\infty}x_{3n}=\lim_{x\rightarrow\infty}x_{3n-1}=a\end{align}$</span></p>
<p>D. <span
class="math inline">$\begin{align}若\lim_{x\rightarrow\infty}x_{3n}=\lim_{x\rightarrow\infty}x_{3n-1}=a,则\lim_{x\rightarrow\infty}x_n=a\end{align}$</span></p></li>
</ol>
<hr />
<p>函数中，注意<span
class="math inline">∞</span>是<strong>有符号</strong>的，在判断极限是否存在时需注意两边极限，例如</p>
<p><span
class="math inline">$\begin{align}\lim_{x\rightarrow\infty}\arctan
x，\lim_{x\rightarrow1}\arctan\frac{1}{x-1}都不存在\end{align}$</span></p>
<h2 id="分子或分母有理化">分子或分母有理化</h2>
<p>应用于去根号</p>
<h3 id="平方差">平方差</h3>
<hr />
<p><strong>eg:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow-\infty}x(\sqrt{x^2+100}+x)\\&amp;解:原式=\lim_{x\rightarrow-\infty}\frac{100x}{\sqrt{x^2+100}-x}=\lim_{x\rightarrow-\infty}\frac{100}{-\sqrt{1+\Large\frac{100}{x^2}}\normalsize-1}=-50\end{align}$</span></p>
<p>需要注意的是，由于<strong>x趋于负无穷</strong>，从根号里提出一个x时需要<strong>变号</strong>!</p>
<h3 id="三角函数内去根号">三角函数内去根号</h3>
<p>根据三角函数的周期性，可以让根号通过平方差进行更换</p>
<hr />
<p><strong>eg:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;求\lim_{x\rightarrow0}\frac{1-\cos
x\sqrt{\cos{2x}}\sqrt[3]{\cos{3x}}}{x^2}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{1-\cos
x+\cos
x(1-\sqrt{\cos{2x}}\sqrt[3]{\cos{3x}})}{x^2}\\&amp;=\lim_{x\rightarrow0}\frac{1-\cos
x+\cos
x(1-\sqrt{\cos{2x}}+\sqrt{\cos{2x}}(1-\sqrt[3]{\cos{3x}}))}{x^2}\\&amp;=\frac{1}{2}+1+\frac{2}{3}=3\end{align}$</span></p>
<hr />
<p><a
href="./三角函数去根号%5B工数上%5D.pdf">更多例子</a>(由于typora导出时会强制替换为绝对路径，又没有服务器供存放附件，所以link失效)</p>
<h2 id="倒代换">倒代换</h2>
<p>对于<strong>趋于无穷的x</strong>，建议先做一次<strong>倒代换</strong>，这能使问题更清晰，有时甚至可以直接解出题目</p>
<p>当然，从根号提出时一定注意x的<strong>正负</strong>!</p>
<p>还有一个好处是，对于<span
class="math inline">sin <em>x</em></span>这类x<strong>趋于无穷</strong>时是一个有界量，x<strong>趋于0</strong>时sin
x~x的易混淆的极限值不容易被坑</p>
<p>还有类似<span
class="math inline"><em>e</em><sup><em>x</em></sup>，cos <em>x</em>，<em>x</em><sup><em>α</em></sup></span>等等</p>
<hr />
<p><strong>eg1:</strong></p>
<ol start="4" type="1">
<li><p>设<span class="math inline">$\begin{align}f(x)=\frac{\tan
x}{|x|}\arctan\frac{1}{x}，则\end{align}$</span><a href="#4"
title="答案"></a><a id="~4"></a></p>
<p>A. x=0是振荡间断点 B. x=0是无穷间断点 C. x=0是可去间断点 D.
x=0是跳跃间断点</p></li>
</ol>
<hr />
<p><strong>eg2:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow+\infty}x^3\Bigg(\sqrt[3]{\frac{x^3+x}{x^6+x^3+1}}-\sin{\frac{1}{x}}\Bigg)\\&amp;解:原式=\lim_{x\rightarrow0}\frac{1}{x^3}\Bigg(\sqrt[3]{\frac{x^5+x^3}{x^6+x^3+1}}-\sin
x\Bigg)=\lim_{x\rightarrow0}\frac{\Bigg(x\Big(\Large\sqrt[3]{\frac{x^2+1}{x^6+x^3+1}}\normalsize-1\Big)+x-\sin
x\Bigg)}{x^3}\\&amp;=\lim_{x\rightarrow0}\frac{-x^6-x^3+x^2}{3x^2(x^6+x^3+1)}+\frac{1}{6}=\frac{1}{2}\end{align}$</span></p>
<h2 id="多项式多因式极限">多项式/多因式极限</h2>
<h3 id="夹逼定理">夹逼定理</h3>
<p>在求多项式子和的极限时，可以<strong>放缩</strong>求极限或者化为定积分。在这里只讨论前者</p>
<p>例如<span
class="math inline">$\begin{align}\lim_{n\rightarrow\infty}\sqrt[n]{f(n)}=1\end{align}$</span></p>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{n\rightarrow+\infty}(\frac{n}{n^2+\pi}+\frac{n}{n^2+2\pi}+...+\frac{n}{n^2+n\pi})\\&amp;解:原式\le\lim_{n\rightarrow+\infty}(\frac{n^2}{n^2+\pi})=1\\&amp;原式\ge\lim_{n\rightarrow+\infty}(\frac{n^2}{n^2+n\pi})=1\\&amp;故原式=1\end{align}$</span></p>
<hr />
<p><strong>eg2:</strong> 利用<strong>回归法</strong>证明不等式后夹逼</p>
<p><span
class="math inline">$\begin{align}&amp;证明不等式\frac{1}{2n}&lt;\frac{1}{2}·\frac{3}{4}·...·\frac{2n-1}{2n}&lt;\frac{1}{\sqrt{2n+1}}，并求\lim_{n\rightarrow\infty}\frac{1}{2}·\frac{3}{4}·...·\frac{2n-1}{2n}\\&amp;证:1).\
中间式子=\frac{3}{2}·\frac{5}{4}·...·\frac{2n-1}{2n-2}·\frac{1}{2n}&gt;\frac{1}{2n}\\&amp;2).\
两边平方，得\frac{1·3}{2^2}·\frac{3·5}{4^2}·...·\frac{(2n-1)(2n+1)}{(2n)^2}·\frac{1}{2n+1}&lt;\frac{1}{2n+1}\\&amp;\therefore\lim_{n\rightarrow\infty}\frac{1}{2}·\frac{3}{4}·...·\frac{2n-1}{2n}=0\end{align}$</span></p>
<h3 id="合并后求极限">合并后求极限</h3>
<p>观察式子，可以<strong>加减或乘除</strong>式子可以将原式合并(回归法)，或根据等比/等差数列<strong>求和</strong></p>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{n\rightarrow\infty}(\frac{1}{n^2+1}+\frac{2}{n^2+2}+...+\frac{n}{n^2+n})\\&amp;解:原式\le\lim_{n\rightarrow\infty}\frac{1+2+...+n}{n^2}=\lim_{n\rightarrow\infty}\frac{n(n+1)}{2n^2}=\frac{1}{2}\end{align}$</span></p>
<p><span
class="math inline">$\begin{align}&amp;原式\ge\lim_{n\rightarrow\infty}\frac{1+2+...+n}{n^2+n}=\lim_{n\rightarrow\infty}\frac{n(n+1)}{2(n^2+n)}=\frac{1}{2}\end{align}$</span></p>
<hr />
<p><strong>eg2:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{n\rightarrow+\infty}(1+x)(1+x^2)...(1+x^{2^n})，(|x|\le1)\\&amp;解:原式=\lim_{n\rightarrow+\infty}\frac{(1-x)(1+x)(1+x^2)...(1+x^{2^n})}{1-x}=\frac{1-x^{2^{n+1}}}{1-x}=\frac{1}{1-x}\end{align}$</span></p>
<hr />
<p><strong>eg3:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{n\rightarrow\infty}(1+\frac{1}{n^2})·(1+\frac{2}{n^2})·...·(1+\frac{n}{n^2})\\&amp;解:原式=e^{\Large\lim_{n\rightarrow\infty}\ln(1+\frac{1}{n^2})+\ln(1+\frac{2}{n^2})+...+\ln(1+\frac{n}{n^2})}\\&amp;=e^{\Large\lim_{n\rightarrow\infty}\frac{n(n+1)}{2n^2}}=e^{\frac{1}{2}}\end{align}$</span></p>
<h2 id="求同底数或同幂数项的极限">求同底数或同幂数项的极限</h2>
<p><strong>并非</strong>一定是把后面项提出，提出一项的目的是让括号内式子<strong>变为”1+0”或”<span
class="math inline">1<sup>+</sup> − 1</span>“</strong>的形式</p>
<hr />
<p><strong>eg:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;求f(x)=\lim_{n\rightarrow\infty}\frac{\ln{(e^n+x^n)}}{n}\\&amp;解:1).当x\lt
e时，原式=\lim_{n\rightarrow\infty}\frac{\ln{e^n}+\ln{(1+\Large(\frac{x}{e})^n)}}{n}\normalsize=1\\&amp;2).当x=e时，原式=1\\&amp;3).当x\gt
e时，原式=\lim_{n\rightarrow\infty}\frac{\ln{x^n}+\ln{(1+\Large(\frac{e}{x})^n)}}{n}\normalsize=\ln
x\end{align}$</span></p>
<h2 id="极限中参数的确定">极限中参数的确定</h2>
<p>先确定<strong>带变量的值</strong>，再确定其他参数，有时需要通过<strong>洛必达法则</strong>确定参数</p>
<hr />
<p><strong>eg:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow+\infty}(\sqrt[3]{1-x^6}-ax^2-b)=0，求a和b的值\\&amp;解:原式=\lim_{x\rightarrow+\infty}\Big[x^2(\sqrt[3]{\frac{1}{x^6}-1}-a)-b\Big]，得-1-a=0，即a=-1\\&amp;\therefore
b=\lim_{x\rightarrow+\infty}(\sqrt[3]{1-x^6}-ax^2)=\lim_{x\rightarrow+\infty}x^2\frac{1}{3x^6}=0\end{align}$</span></p>
<hr />
<h2 id="关于计算极限时需要注意的细节">关于计算极限时需要注意的细节</h2>
<ol type="1">
<li><p><strong>有限个</strong>无穷小的和或积是无穷小，<strong>无限个</strong>项则不成立</p></li>
<li><p>无穷小与<strong>有界量</strong>的乘积是无穷小</p></li>
<li><p>计算极限时不能随意进行<strong>代入</strong>或<strong>等价无穷小替换</strong></p>
<p>3.3.
原因：极限是整体变化的，但是有时候这样替换是正确的，这是因为我们把<strong>四则运算</strong>的过程简化了</p>
<p>这一问题的更详细的说明是：直接代入或等价无穷小替换是<strong>有精度的</strong>，分母<strong>越小</strong>，越会对替换带来的变化起反应，导致极限运算错误</p>
<p><strong>判断方法</strong>：进行<strong>四则运算拆开</strong>时，需要<strong>两项因式极限都存在</strong>才可以进行替换</p>
<p>简单例子:</p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow0}\frac{x-\sin
x}{x^3}=\lim_{x\rightarrow0}\frac{1}{x^2}-\lim_{x\rightarrow0}\frac{\sin
x}{x^3}=\infty-\infty，不能替换\\&amp;\lim_{x\rightarrow0}\frac{x+\sin
x}{x}=\lim_{x\rightarrow0}1+\lim_{x\rightarrow0}\frac{\sin
x}{x}=1+1，可以替换\end{align}$</span></p>
<h3 id="经典例子">经典例子</h3>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow0}\frac{x\cos
x-\sin x}{x^3}\\&amp;解:原式=\lim_{x\rightarrow0}\frac{x\cos x-x+x-\sin
x}{x^3}=-\frac{1}{3}\end{align}$</span></p>
<hr />
<p><strong>eg2:</strong> 这是一个隐含四则运算的极限，不能直接套用<span
class="math inline">$\lim_{x\rightarrow\infty}{(1+\large\frac{1}{x})^x}=e^x$</span>，最后用到洛必达法则</p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow+\infty}\frac{(1+\large\frac{1}{x})^x}{e^x}\\&amp;解:原式=\lim_{x\rightarrow+\infty}\frac{e^{x\ln(1+\Large\frac{1}{x})}}{e^x}=\lim_{x\rightarrow+\infty}e^{x^2\Big(\ln(1+\Large\frac{1}{x}\normalsize)-\Large\frac{1}{x}\normalsize\Big)}=e^{\lim_{x\rightarrow0}\large\frac{\Large\ln(1+x)-x}{x^2}}=e^{-\frac{1}{2}}\end{align}$</span></p>
<hr />
<p><strong>eg3:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;\lim_{x\rightarrow+\infty}\frac{e^x}{(1+\large\frac{1}{x})^{x^2}}\\&amp;解:原式=e^{\Large\lim_{x\rightarrow+\infty}x-x^2\ln(1+\frac{1}{x})}=e^{\Large\lim_{x\rightarrow0}\LARGE\frac{x-\ln(1+x)}{x^2}}=e^\frac{1}{2}\end{align}$</span></p>
<hr /></li>
<li><p>发现不能直接替换后，可以尝试<strong>泰勒展开</strong>或者<strong>回归法(加一项减一项)</strong>来解题</p></li>
</ol>
<h2 id="定理证明题">定理证明题</h2>
<p><strong>介值定理</strong>：在<strong>闭区间</strong><span
class="math inline">[<em>a</em>,<em>b</em>]</span>上的<strong>连续</strong>函数任取一点，该点必定满足<span
class="math inline"><em>m</em> ≤ <em>f</em>(<em>x</em>) ≤ <em>M</em></span></p>
<p>引申出<strong>零点定理</strong>：如果存在两点<strong>异号</strong>，则必定存在一点<span
class="math inline"> ∈ (<em>a</em>,<em>b</em>)</span>满足<span
class="math inline"><em>f</em>(<em>x</em>) = 0</span></p>
<p><strong>保号性定理</strong>：如果有<span
class="math inline">$\begin{align}\lim_{x\rightarrow
x_0}f(x)&gt;0\end{align}$</span>，则在<span
class="math inline"><em>x</em><sub>0</sub></span>某<strong>去心邻域</strong>内，<span
class="math inline"><em>f</em>(<em>x</em>) &gt; 0</span>成立</p>
<hr />
<p><strong>eg1:</strong></p>
<p><span
class="math inline">$\begin{align}&amp;设f(x)在[0,1]上连续，f(1)=0，\lim_{x\rightarrow\frac{1}{2}}\frac{f(x)-1}{\large(x-\frac{1}{2})^{\normalsize2}}=1，证明:\\&amp;1).
存在\xi\in(\frac{1}{2},1)，使f(\xi)=\xi\ \ \ \ \ 2).
f(x)在[0,1]上最大值大于1\\&amp;解:1)由洛必达法则，f(\frac{1}{2})=1\\&amp;令F(x)=f(x)-x，易得\begin{cases}F(1)=-1\\F(\large\frac{1}{2})=\frac{1}{2}\end{cases}\\&amp;\therefore
连续函数F(x)存在一点\xi\in(\frac{1}{2},1)，使得F(\xi)=0\\&amp;2).
\because\lim_{x\rightarrow\frac{1}{2}}\frac{f(x)-1}{\large(x-\frac{1}{2})^{\normalsize2}}=1&gt;0\\&amp;由保号性可知，当x\in(\frac{1}{2}-\delta
x,\frac{1}{2})\cup(\frac{1}{2},\frac{1}{2}+\delta
x)时，\frac{f(x)-1}{\large(x-\frac{1}{2})^{\normalsize2}}&gt;0\\&amp;\therefore在这个去心邻域内f(x)&gt;1\end{align}$</span></p>
<hr />
<p><strong>eg2:</strong></p>
<p>设<span
class="math inline"><em>a</em><sub>2<em>m</em></sub> &lt; 0</span>，证明：<span
class="math inline"><em>x</em><sup>2<em>m</em></sup> + <em>x</em><sup>2<em>m</em> − 1</sup><em>a</em><sub>1</sub> + ... + <em>x</em><em>a</em><sub>2<em>m</em> − 1</sub> + <em>a</em><sub>2<em>m</em></sub> = 0</span>至少有两个零点</p>
<p><span
class="math inline">$\begin{align}&amp;证:左边=x^{2m}\Big(1+\frac{a_1}{x}+...+\frac{a_{2m-1}}{x^{2m-1}}+\frac{a_{2m}}{x^{2m}}\Big)\\&amp;当x\rightarrow\infty时，原式=+\infty\\&amp;又当x=0时，原式=a_{2m}&lt;0\\&amp;\therefore对(-\infty,0)和(0,+\infty)分别使用零点定理，得证\end{align}$</span></p>
<hr />
<p><strong>eg3:</strong></p>
<p><span class="math inline">$\begin{align}&amp;设f(x)在[0,n](n\in
N^*且n\ge2)上连续，f(0)=f(n)，证明:存在\xi,\xi+1\in[0,n],使f(\xi)=f(\xi+1)\\&amp;证:令F(x)=f(x)-f(x+1)\\&amp;则F(0)=f(0)-f(1),F(1)=f(1)-f(2),...,F(n-1)=f(n-1)-f(n)\\&amp;合并得\sum_{i=0}^{n-1}F(i)=f(0)-f(n)=0\\&amp;设F_{min}=m,F_{max}=M,可知nm\le\sum_{i=0}^{n-1}F(i)\le
nM\\&amp;即m\le\frac{1}{n}\sum_{i=0}^{n-1}F(i)\le
M\\&amp;由介值定理可知，存在\xi\in[0,n-1],使f(\xi)=\frac{1}{n}\sum_{i=0}^{n-1}F(i)=0\end{align}$</span></p>
<h1 id="总结">总结</h1>
<ol type="1">
<li><p>求单项极限时，应想到<strong>回归法</strong>凑无穷小、<strong>换元法</strong>或<strong>平方差</strong>解决式子<strong>有理化</strong>问题、提出<strong>同幂或同底</strong>项、<strong>倒代换</strong>、化为<strong>e的对数</strong>、<strong>上下同除</strong>等技巧</p></li>
<li><p>求多项和的极限时，应想到<strong>合并、夹逼、定积分</strong>，求多项积的极限时，应想到化为<strong>e的对数</strong>，<strong>拆开</strong>各因式</p></li>
<li><p>求三角函数的极限时，运用<strong>和差化积</strong>或<strong>回归法</strong>(利用周期性)</p></li>
<li><p>从<strong>根号</strong>中提出x时，一定注意是否需要<strong>变号</strong>，这在判断两边极限(或极限是否存在)问题时很关键</p></li>
<li><p>对待数列时，应注意数列的特殊性，即非连续而是一点一点的，且<span
class="math inline"><em>n</em> ∈ <em>N</em><sup>*</sup></span></p></li>
<li><p>证明极限时，想到<strong>单调有界收敛</strong>原理</p></li>
<li><p>证明式子时，应想到作<strong>辅助函数</strong></p></li>
</ol>
<div style="page-break-after: always;">

</div>
<h1 id="部分答案及解析">部分答案及解析</h1>
<hr />
<p><a href="#~1" title="返回">1. D</a><a id="1"></a></p>
<p>​ 此题是经典的<span
class="math inline">$x^\alpha，\alpha趋向正负无穷时是不一样的$</span></p>
<hr />
<p><a href="#~2" title="返回">2. D</a><a id="2"></a></p>
<p>​ 此处只探讨B和D。</p>
<p>​ B.
由于两者是数列，那么让前者为{0,1,0,1,…}，让后者为{1,0,1,0,…}，它们都无界，而乘积的极限为0</p>
<p>​ D. 原式<span
class="math inline">$\begin{align}=\lim_{n\rightarrow+\infty}\frac{y_n}{\large\frac{1}{x_n}}=0\end{align}$</span></p>
<hr />
<p><a href="#~3" title="返回">3. D</a><a id="3"></a></p>
<hr />
<p><a href="#~4" title="返回">4. C</a><a id="4"></a></p>
<hr />
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分: 关于极限</title>
    <url>/blogs/2023/10/30/calculus-limitation/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="极限">极限</h1>
<h2 id="注意关于极限">[注意]关于极限</h2>
<ol type="1">
<li><span class="math inline">$\begin{align}x\rightarrow 0时,\cos
\frac{1}{x},\sin
\frac{1}{x}都为有界量,和x相乘等于无穷小\end{align}$</span></li>
<li><span
class="math inline">$\begin{align}合理利用换元,如求\lim_{x\rightarrow
0}(\frac{x}{x+1})^x可令t=x+1\end{align}$</span></li>
<li>合理利用夹逼定理，如求多项式极限时，有时也会用到定积分</li>
<li>求式子中参数a、b时，若一边为0，可猜测一边也为0(因为这样才有不为0的极限存在)，用洛必达法则求出参数</li>
</ol>
<h2 id="求反函数">求反函数</h2>
<p>虽然并不属于极限的范畴，但是是有可能考到的题型</p>
<p>总的来说就是让newY=oldX，newX=f(x)</p>
<p>newX的范围就是f(x)的值域</p>
<hr />
<p>eg:</p>
<p><span
class="math inline">$\begin{align}&amp;f(x)=\begin{cases}1-2x^2,&amp;x\lt-1\\x^3,&amp;-1\le
x\le2\\12x-16,&amp;x\gt2\end{cases}\\&amp;求f^{-1}(x)\\&amp;解:1).当x\lt-1时，f^{-1}(x)=\sqrt\frac{1-x}{2}，x\lt-1\\&amp;2).当-1\le
x\le2时，f^{-1}(x)=\sqrt[3]{x}，-1\le
x\lt8\\&amp;3).当x\gt2时，f^{-1}(x)=\frac{16+x}{12}，x&gt;8\end{align}$</span></p>
<hr />
<h2
id="题型利用单调有界收敛定理证明函数极限存在">[题型]利用单调有界收敛定理证明函数极限存在</h2>
<p><font color="red"><strong>def：单调（增减）且有（上下）界的数列一定收敛</strong></font></p>
<ol type="1">
<li><p>放缩法证明其有（上/下）界</p></li>
<li><p>观察法证明其单调性</p></li>
<li><p>合理利用假设法</p>
<hr /></li>
</ol>
<p><span class="math inline">$\begin{align}&amp;eg:\\
&amp;设c&gt;0,a_1=\sqrt
c,且a_{n+1}=\sqrt{c+a_n}.证明数列{a_n}收敛,并求其极限值\\&amp;证明:\\&amp;\because
a_2=\sqrt{c+a_1}&gt;\sqrt
c=a_1.\\&amp;假设a_n&gt;a_n-1,则有a_{n+1}=\sqrt{c+a_n}&gt;\sqrt{c+a_{n-1}}=a_n\\&amp;\therefore
a_n单调递增\\&amp;又\because a_2&lt;\sqrt c+1.假设a_n&lt;\sqrt
c+1\\&amp;则有a_{n+1}=\sqrt{c+a_n}&lt;\sqrt{c+\sqrt c+1}&lt;\sqrt
c+1\\&amp;\therefore a_n有上确界\\&amp;\therefore
\lim_{n\rightarrow\infty}a_n=\sqrt c+1\end{align}$</span></p>
<hr />
<h2 id="求极限">求极限</h2>
<h3
id="题型同底数异指数或同指数异底数常考确定某个常量的值">[题型]同底数异指数或同指数异底数(常考确定某个常量的值)</h3>
<p>提出后一项求极限</p>
<p>eg:</p>
<hr />
<p><span class="math inline">$\begin{align} &amp;1):同指数异底数\\&amp;
已知极限\lim_{n\rightarrow\infty}\frac{n^\alpha}{(n+1)^\beta-n^\beta}=2017,求\alpha,\beta\\&amp;
解：\\&amp; \because
原式=\lim_{n\rightarrow\infty}\frac{n^\alpha}{n^\beta((\frac{n+1}{n})^\beta-1)}\\&amp;
=\lim_{n\rightarrow\infty}\frac{n^\alpha}{n^\beta(e^{\beta
\ln(\frac{n+1}{n})}-1)}\\&amp;
=\lim_{n\rightarrow\infty}\frac{n^\alpha}{n^\beta(\beta\ln(\frac{n+1}{n}))}\\&amp;
=\lim_{n\rightarrow\infty}\frac{n^\alpha}{n^\beta\frac{1}{n}\beta}=\lim_{n\rightarrow\infty}\frac{n^\alpha}{n^{\beta-1}\beta}=2017\\&amp;
\therefore 易得\alpha=\beta-1,\beta=\frac{1}{2017}\\&amp; \therefore
\alpha=-\frac{2016}{2017}\end{align}$</span></p>
<hr />
<p>$ $</p>
<hr />
<h3 id="题型上下同除">[题型]上下同除</h3>
<p>利用除以<span
class="math inline"><em>x</em><sup>3</sup></span>和四则运算求极限</p>
<hr />
<p>$ $</p>
<hr />
<h2 id="题型间断点判断">[题型]间断点判断</h2>
<ol type="1">
<li><p>找出间断点</p>
<p>1.1.
寻找间断点时，这个点可能是<strong>未定义</strong>的，也可能是<strong>两边极限不等</strong>的</p>
<p>1.2. 具体例子为：前者<span
class="math inline">$\begin{cases}\large\frac{1}{x}\normalsize,&amp;x=0\\\ln
x,&amp;x=0\end{cases}$</span>，后者<span
class="math inline">$\begin{cases}x^\infty,&amp;x=1\\
e^{\Large\frac{1}{x-1}},&amp;x=1\end{cases}$</span></p></li>
<li><p>求极限</p>
<hr />
<p><span class="math inline">$\begin{align}&amp;eg:\\&amp;
求函数f(x)=(1+x)^{\frac{x}{\tan(x-\frac{\pi}{4})}}在区间(0,2\pi)内的间断点,并判断其类型\\&amp;
解：\\&amp;
令\tan(x-\frac{\pi}{4})=0,得x=\frac{\pi}{4}或x=\frac{5\pi}{4}\\&amp;
令x-\frac{\pi}{4}=\frac{\pi}{2}+k\pi,得x=\frac{3\pi}{4}或x=\frac{7\pi}{4}\\&amp;
x\rightarrow\frac{\pi}{4}^+时,\lim_{x\rightarrow\frac{\pi}{4}^+}f(x)不存在(趋于正无穷大)\\&amp;
x\rightarrow\frac{\pi}{4}^-时,\lim_{x\rightarrow\frac{\pi}{4}^-}f(x)=0,故x=\frac{\pi}{4}是第二类间断点,x\rightarrow\frac{5\pi}{4}与其类似\\&amp;
x\rightarrow\frac{3\pi}{4}时,\lim_{x\rightarrow\frac{3\pi}{4}}f(x)=\lim_{x\rightarrow\frac{7\pi}{4}}f(x)=1,故均为第一类间断点,由于两边极限相等,故为可去间断点\end{align}$</span></p></li>
</ol>
<hr />
<h2 id="题型复合函数的极限">[题型]复合函数的极限</h2>
<p>拆出f(x),用α(x)代替</p>
<hr />
<p><span class="math inline">$\begin{align}&amp;eg:\\&amp;
已知\lim_{x\rightarrow 0}\frac{\sqrt{1+f(x)\sin 2x}-1}{\tan
3x}=2,求\lim_{x\rightarrow 0}f(x)\\&amp; 解：\\&amp;
令\alpha(x)=\frac{\sqrt{1+f(x)\sin 2x}-1}{\tan 3x},则\lim_{x\rightarrow
0}\alpha(x)=2\\&amp; \therefore f(x)=\frac{(\alpha(x)\tan
3x+1)^2-1}{\sin 2x}\\&amp; \therefore \lim_{x\rightarrow
0}f(x)=\lim_{x\rightarrow 0}\frac{2\alpha(x)\tan 3x}{\sin
2x}=6\end{align}$</span></p>
<hr />
<h1 id="导数与微分">导数与微分</h1>
<h2 id="基本公式">基本公式</h2>
<p><span class="math inline">$\begin{align}&amp;(\tan
x)'=\frac{1}{\cos^2x}=sec^2x\\&amp; (\sec x)'=\sec x\tan x,\ (\csc
x)'=-\csc x\cot x\\&amp; (arctan x)'=\frac{1}{1+x^2},\ (arccot
x)'=-\frac{1}{1+x^2}\\&amp; (\arcsin x)'=\frac{1}{\sqrt{1-x^2}},\
(\arccos x)'=-\frac{1}{\sqrt{1-x^2}}\end{align}$</span></p>
<h2
id="题型是否可导问题和求导数问题">[题型]是否可导问题和求导数问题</h2>
<ol type="1">
<li><p>先判断在该点是否连续，不连续则必不可导</p></li>
<li><p>后用定义求左右导数，若都存在且相等才可导</p></li>
<li><p>在其他部分正常求导即可 <span class="math display">$$
\begin{align}\Large&amp;是否连续与是否可导不一样\\\\&amp;连续:\lim_{x\rightarrow
x_0}f(x)=f(x_0)\\&amp;可导:f'(x_0)=\lim_{x\rightarrow
x_0^+}\frac{f(x)-f(x_0)}{x-x_0}=\lim_{x\rightarrow
x_0^-}\frac{f(x)-f(x_0)}{x-x_0}\end{align}
$$</span></p></li>
<li></li>
</ol>
<h2 id="题型反函数的求导">[题型]反函数的求导</h2>
<p><span class="math inline">$\begin{align}&amp;f'(x) =
\frac{1}{\varphi'(y)}\\&amp; 即\frac{dy}{dx} =
\frac{1}{\frac{dx}{dy}}\end{align}$</span></p>
<h2 id="注意函数的微分">[注意]函数的微分</h2>
<p><span
class="math inline">$\begin{align}&amp;\frac{函数的微分}{自变量的微分}=函数的导数=f'(x)\\\\&amp;
所以\textcolor{red}{dy = f'(x)·dx}\\&amp; 函数的增量\Delta y = f(x +
\Delta x) - f(x)\\&amp;当\Delta x\rightarrow 0时,\textcolor{red}{\Delta
y = f'(x)·\Delta x + o(\Delta x) = dy + o(\Delta
x)}\end{align}$</span></p>
<h2 id="题型高阶导数和微分">[题型]高阶导数和微分</h2>
<h3 id="技巧">技巧</h3>
<ol type="1">
<li><p>归纳为递推公式</p></li>
<li><p>sin或cos进行降次(合并为幂次方或二倍角公式或积化和差公式)</p>
<p>2.1 积化和差公式</p></li>
</ol>
<p><span class="math inline">$\begin{align}&amp;\ \ \ \ \ \ \
令\alpha=\frac{a+b}{2},\beta=\frac{a-b}{2}\\&amp; \ \ \ \ \ \ \
例如\sin\alpha\cos\beta可以化为\frac{1}{2}(\sin(\alpha+\beta)+\sin(\alpha-\beta))\end{align}$</span></p>
<ol start="3" type="1">
<li>取对数法：多项乘法由于展开后更好求，一般可以取对数</li>
</ol>
<h3
id="莱布尼茨公式前面系数与二次项系数类似">莱布尼茨公式(前面系数与二次项系数类似)</h3>
<p><span
class="math inline">$\begin{align}&amp;(f\small(x)·g(x)\big)^{(n)} =
C^0_nf·g^{(n)} + C^1_nf'·g^{(n-1)} + … +
C^0_nf{(n)}·g\\\\&amp;可以分解假分式后利用莱布尼茨公式展开真分式\end{align}$</span></p>
<h3 id="题型隐函数的求导">[题型]隐函数的求导</h3>
<p>两边同时对x求导再整理即可</p>
<h3 id="题型参数方程求导">[题型]参数方程求导</h3>
<p><span class="math inline">$\begin{align}&amp;y' = \frac{dy}{dx} =
\frac{\frac{dy}{dt}}{\frac{dx}{dt}}\\&amp; y'' = \frac{d}{dx}(y') =
\frac{d}{dt}(y')·\frac{1}{\frac{dx}{dt}}\
即先对t求导,再乘上x对t求导的倒数\end{align}$</span></p>
<h3 id="题型相关变化率">[题型]相关变化率</h3>
<ol type="1">
<li>先找所给量间的关系</li>
<li>两边函数的导数如果都是和某个变量相关的不同函数，则两边同时求导</li>
</ol>
<h3 id="题型求曲率">[题型]求曲率</h3>
<p><span class="math display">$$
\begin{align}&amp;K=\frac{\Delta\Theta}{\Delta
s}=\frac{y''}{(1+(y')^2)^\frac{3}{2}}\\&amp;
\Delta s=\sqrt{1+(y')^2}dx=\sqrt{dy^2+dx^2}\\&amp;
R=\frac{1}{K}\end{align}
$$</span></p>
<h3 id="注意泰勒公式">[注意]泰勒公式</h3>
<p><span class="math display">$$
常用拉格朗日公式：\\\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-……\\
\cos x=1-\frac{x^2}{2}+\frac{x^4}{4!}-……\\
\ln x=x-\frac{x^2}{2}+\frac{x^3}{3}-……\\
e^x=1+x+\frac{x^2}{2}+\frac{x^3}{3!}+……\\
(1+x)^\alpha=1+\alpha x+\frac{\alpha(\alpha-1)x^2}{2!}+……\\
$$</span></p>
]]></content>
      <categories>
        <category>SE Courses</category>
        <category>Calculus</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>C: 基本语法</title>
    <url>/blogs/2023/10/09/c-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<h1 id="c">C</h1>
<h2 id="预处理">预处理</h2>
<h3 id="介绍">介绍</h3>
<p>在编译一个.c文件时，最开始的操作便是预处理，它会将包含的文件展开，把使用过宏的地方替换为宏定义的语句，删除注释等等…</p>
<p>可以用<code>gcc</code>生成一个预处理后的文件(后缀为.i)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-E选项表示在预处理后停止，-C表示保留库函数里的注释，-o表示自定义输出文件的名称</span></span><br><span class="line">gcc -E -C file.c -o file.i</span><br></pre></td></tr></table></figure>
<h3 id="宏">宏</h3>
<p>宏，如其名，它将一串命令序列转换为简短的语句，用短短几个单词即可以实现强大复杂的功能</p>
<p>预处理器对宏实际的操作是把参数作为<strong>字符串</strong>来替换并把这条替换后的语句<strong>插入</strong>程序控制流里</p>
<h3 id="运算符">运算符</h3>
<h4 id="宏延续">\(宏延续)</h4>
<p>它用于<strong>隔开</strong>两个语句，当宏太长时，可用<code>'\'</code>分隔为多行</p>
<h4 id="字符串常量化">#(字符串常量化)</h4>
<p>它可以将宏参数<strong>转换</strong>为字符串，字符串的内容是宏参数的名称，如要在字符串中转换需要再加上一层双引号</p>
<h4 id="标记粘贴">##(标记粘贴)</h4>
<p>它可以将两边的标记合并成一个标记</p>
<h4 id="defined已定义">defined(已定义)</h4>
<p>它接受一个标识符，若这个标识符已定义，返回<code>true</code>，否则返回<code>false</code></p>
<h3 id="处理目标">处理目标</h3>
<h4 id="include">#include</h4>
<p>各种语言都有官方的函数库，这些库包含了许多优化度极高或十分方便的宏，想要使用它，我们需要声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>上述语句包含了一个名为<code>stdio.h</code>的文件，如果使用<code>gcc</code>生成一个预处理后的文件(后缀为.i)，我们会发现这一文件条目很多，正是展开这一文件的效果</p>
<p>我们也可以用<strong>双引号</strong>包含，这时预处理器会<strong>先从当前目录</strong>而不是从库函数目录里寻找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myStd.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>在我们可以编写自己的头文件时，需要用这种包含方式包含</p>
<h4 id="define">#define</h4>
<p>这是定义一个常量，或是一个简易函数等的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COL 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(n) printf(<span class="string">&quot;&quot;</span>#n<span class="string">&quot;是%d&quot;</span>, n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTMORE(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GIVE_NEW(n) aNum##n</span></span><br></pre></td></tr></table></figure>
<p>上述语句的第一条定义了一个名为<code>COL</code>，大小为<code>50</code>的常量</p>
<p>第二条语句定义了一个<code>PRINT</code>宏函数，传入<code>(int)n</code>，打印<code>"(n的名称)是(n的数值)"</code></p>
<p>双引号括住#+宏参数名可以解析它为它的名称</p>
<p>第三条语句的宏参数为<code>"..."</code>，它可以<strong>接受多个</strong>参数，并把这些参数传给<code>__VA_ARGS__</code></p>
<p>第四条语句被用于<strong>批量创建变量</strong>，##即黏合剂，将两边记号黏着</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GIVE_NEW</span><span class="params">(<span class="number">3</span>)</span>= <span class="number">5</span>; <span class="comment">// 创建一个名为&quot;aNum3&quot;,值为5的int型变量</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，当函数含参时，需要加上()括住，原因是传参时它将表达式参数当作字符串处理，加上括号才可以达到想要的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POWT1(n) ((n)*(n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POWT2(n) (n*n)</span></span><br><span class="line">POWT1(<span class="number">5</span>+<span class="number">4</span>)==(<span class="number">5</span>+<span class="number">4</span>)*(<span class="number">5</span>+<span class="number">4</span>)==<span class="number">81</span>;</span><br><span class="line">POWT2(<span class="number">5</span>+<span class="number">4</span>)==<span class="number">5</span>+<span class="number">4</span>*<span class="number">5</span>+<span class="number">4</span>==<span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景">使用场景</h4>
<p>宏是内联函数，即在预处理阶段时会把相应语句直接<strong>插入</strong>到程序中</p>
<p>与一般函数不同，它不需要跳转，跳出，而只需要牺牲一定的空间；而一般函数会被保存为副本，每次调用都必须跳到入口进，从出口返回，这将<strong>增大时间成本</strong></p>
<p>因此，在一个函数十分<strong>简单</strong>时，可以将它写成一个宏，牺牲空间，换取时间</p>
<h4 id="todo编写简单的头文件">todo:编写简单的头文件</h4>
<p>接下来，将通过编写一个简单的头文件来帮助熟悉<code>#ifdef,#undef,inline</code>等语句和关键字</p>
<h2 id="编译">编译</h2>
<h3 id="介绍-1">介绍</h3>
<p><code>C</code>语言的编译过程即将高级语言转换为汇编语言的过程，它会将所有语句转换为汇编指令，并且会优化源代码</p>
<p>可以用<code>gcc</code>生成一个编译后的文件(后缀为.s)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S file.i -o file.s</span><br></pre></td></tr></table></figure>
<p>可以发现生成后的文件已经是汇编代码了</p>
<h3 id="c语言语法">C语言语法</h3>
<p>在这个阶段，开始涉及<code>C</code>语言的各种语法</p>
<h4 id="数据类型">数据类型</h4>
<p><code>C</code>语言有许多关键字，其中不少是用于声明变量的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="comment">// 占用字节  16位  32位  64位</span></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 字符型     1  1  1</span></span><br><span class="line"><span class="type">short</span> sn = <span class="number">1</span>;  <span class="comment">// 短整型     2  2  2</span></span><br><span class="line"><span class="type">int</span> dn = <span class="number">1</span>;   <span class="comment">// 整型     2   4   4</span></span><br><span class="line"><span class="type">long</span> ln = <span class="number">1</span>;  <span class="comment">// 长整型     4  4  8 (尽量不使用,因为可能导致不兼容)</span></span><br><span class="line"><span class="type">float</span> fn = <span class="number">1.1</span>;  <span class="comment">// 单精度浮点型  4    4    4</span></span><br><span class="line"><span class="type">double</span> lfn=<span class="number">1.1</span>;  <span class="comment">// 双精度浮点型  8    8    8</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lln=<span class="number">1</span>; <span class="comment">// 长长整型        8     8</span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ldn=<span class="number">1</span>; <span class="comment">//        12    16</span></span><br><span class="line">     <span class="comment">// 所有指针类型  2     4    8</span></span><br><span class="line"><span class="comment">// unsigned:表示无符号，并不会改变位数</span></span><br></pre></td></tr></table></figure>
<p>4位字节如<code>int</code>范围为<code>-2147483648~2147483647</code>，<code>unsigned int</code>范围为<code>0~4294967295</code>(20~43亿)(<span
class="math inline">2<sup>32</sup></span>)</p>
<p>8位字节如<code>long long</code>范围为<code>-9223372036854775808~-9223372036854775807</code></p>
<p>​
<code>unsigned long long</code>范围为<code>0~18446744073709551615</code>(<span
class="math inline">2<sup>64</sup></span>)</p>
<p>除了基本的数据类型，还可以声明<strong>结构体</strong>来储存多个类型的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STRUCT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给结构体变量的分配空间遵循<strong>对齐</strong>原则</p>
<ol type="1">
<li>从第一个成员开始往下分配空间，默认从地址0开始存放</li>
<li>每个成员的<strong>偏移量</strong>必须是<strong>该成员</strong>基本数据类型的整数倍</li>
<li>总大小是<strong>最大</strong>成员基本数据类型的整数倍</li>
</ol>
<p>例如，<code>char</code>占1个字节，那么它可以放在0,1,2,3,…地址上；<code>int</code>占4个字节，那么它可以放在0,4,8,12,…地址上</p>
<p>指针类型占8个字节，那么它可以放在0,8,16,…地址上；数组也同理，将它看作许多个基本类型成员的集合计算</p>
<h4 id="数据间的转换">数据间的转换</h4>
<p><code>C</code>语言的<code>char</code>型比较特殊，它被转换为<code>int</code>数据存储，并用<code>ASCII</code>编码，可以和<code>int</code>类型数据相加减</p>
<p><a href="https://c.biancheng.net/c/ascii/">ASCII码表</a></p>
<p>它可以用”%d”转换符输出，但并非是一个整型数据!</p>
<p>一般数据类型的转换如图所示，在<strong>赋值</strong>运算中可以进行自动类型转换将<strong>右值转换为左值</strong>的类型，在<strong>表达式</strong>运算中可以<strong>从低到高</strong>进行自动类型转换，例如整数相除的结果会被去掉小数部分
<span
class="math display"><em>c</em><em>h</em><em>a</em><em>r</em> → <em>i</em><em>n</em><em>t</em> → <em>u</em><em>n</em><em>s</em><em>i</em><em>g</em><em>n</em><em>e</em><em>d</em> → <em>l</em><em>o</em><em>n</em><em>g</em> → <em>d</em><em>o</em><em>u</em><em>b</em><em>l</em><em>e</em> ← <em>f</em><em>l</em><em>o</em><em>a</em><em>t</em></span>
指针类型十分严格，如果类型不同，则不能进行互相转换</p>
<p><code>void*</code>无类型指针是特例，可以强制转换为任意类型的一级指针，它是<strong>抽象</strong>的，并不具有一般指针类型变量的加减或给其他变量赋值的操作，它只能是左值</p>
<h4 id="数据的前缀">数据的前缀</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">011</span>  <span class="comment">// 表示八进制</span></span><br><span class="line"><span class="number">0x11</span> <span class="comment">// 表示十六进制</span></span><br><span class="line"><span class="number">0b11</span> <span class="comment">// 表示二进制</span></span><br><span class="line"><span class="string">&#x27;\072&#x27;</span> <span class="comment">// 表示转义为一个072对应的字符,实际占一个字符的空间</span></span><br></pre></td></tr></table></figure>
<h4 id="数据的后缀">数据的后缀</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浮点数的指数表达法,后面的数字必须是整数[1.0或表达式(5+4)也是错误的],e或E均可</span></span><br><span class="line"><span class="comment">// e的前面数字只能是(0,10)间的数据</span></span><br><span class="line"><span class="number">1.1e2</span> <span class="comment">// 表示1.1*pow(10,2)</span></span><br><span class="line"><span class="number">-2.3e-4</span> <span class="comment">// 表示2.3*pow(10,-4)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 其它后缀</span></span><br><span class="line"><span class="number">1u</span>(或U)  <span class="comment">// 表示是一个无符号数据,可以后加l或L表示无符号长整型</span></span><br><span class="line"><span class="number">1.1f</span>(或F) <span class="comment">// 表示是一个float类型数据,若无后缀则表示double类型</span></span><br><span class="line"><span class="number">2.2L</span>(或l) <span class="comment">// 表示是一个long double类型数据</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符-1">运算符</h4>
<table border="2">
<tr>
<td>
运算符
</td>
<td>
优先级
</td>
<td>
运算顺序
</td>
</tr>
<tr>
<td>
[]
</td>
<td rowspan="4" style="display:table-cell; vertical-align:middle">
1
</td>
<td rowspan="4" style="display:table-cell; vertical-align:middle">
从左到右
</td>
</tr>
<tr>
<td>
()
</td>
</tr>
<tr>
<td>
对象成员.
</td>
</tr>
<tr>
<td>
指针成员-&gt;
</td>
</tr>
<tr>
<td>
单目-
</td>
<td rowspan="8" style="display:table-cell; vertical-align:middle">
2
</td>
<td rowspan="8" style="display:table-cell; vertical-align:middle">
从右到左
</td>
</tr>
<tr>
<td>
取反~
</td>
</tr>
<tr>
<td>
自增++/自减–(包括前后缀)
</td>
</tr>
<tr>
<td>
解引用*
</td>
</tr>
<tr>
<td>
取地址&amp;
</td>
</tr>
<tr>
<td>
!
</td>
</tr>
<tr>
<td>
强制类型转换(type)
</td>
</tr>
<tr>
<td>
sizeof
</td>
</tr>
<tr>
<td>
/
</td>
<td rowspan="3" style="display:table-cell; vertical-align:middle">
3
</td>
<td rowspan="19" style="display:table-cell; vertical-align:middle">
从左到右
</td>
</tr>
<tr>
<td>
乘法*
</td>
</tr>
<tr>
<td>
%
</td>
</tr>
<tr>
<td>
+
</td>
<td rowspan="2" style="display:table-cell; vertical-align:middle">
4
</td>
</tr>
<tr>
<td>
-
</td>
</tr>
<tr>
<td>
&lt;&lt;
</td>
<td rowspan="2" style="display:table-cell; vertical-align:middle">
5
</td>
</tr>
<tr>
<td>
<blockquote>
<blockquote>
</td>
</tr>
<tr>
<td>
<blockquote>
</td>
<td rowspan="4" style="display:table-cell; vertical-align:middle">
6
</td>
</tr>
<tr>
<td>
<blockquote>
=
</td>
</tr>
<tr>
<td>
&lt;
</td>
</tr>
<tr>
<td>
&lt;=
</td>
</tr>
<tr>
<td>
==
</td>
<td rowspan="2" style="display:table-cell; vertical-align:middle">
7
</td>
</tr>
<tr>
<td>
!=
</td>
</tr>
<tr>
<td>
&lt;=
</td>
</tr>
<tr>
<td>
按位&amp;
</td>
<td rowspan="1" style="display:table-cell; vertical-align:middle">
8
</td>
</tr>
<tr>
<td>
按位^
</td>
<td rowspan="1" style="display:table-cell; vertical-align:middle">
9
</td>
</tr>
<tr>
<td>
按位|
</td>
<td rowspan="1" style="display:table-cell; vertical-align:middle">
10
</td>
</tr>
<tr>
<td>
&amp;&amp;
</td>
<td rowspan="1" style="display:table-cell; vertical-align:middle">
11
</td>
</tr>
<tr>
<td>
||
</td>
<td rowspan="1" style="display:table-cell; vertical-align:middle">
12
</td>
</tr>
<tr>
<td>
?:
</td>
<td rowspan="1" style="display:table-cell; vertical-align:middle">
13
</td>
<td rowspan="2" style="display:table-cell; vertical-align:middle">
从右到左
</td>
</tr>
<tr>
<td>
赋值符
</td>
<td rowspan="1" style="display:table-cell; vertical-align:middle">
14
</td>
</tr>
</table>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>基于优先级以及结合顺序，在这里讨论一些容易混淆的语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ++与*优先级相等,而它们是从右到左结合的</span></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">(*p)++;  <span class="comment">// 括号优先级最高,语句意义为先取p指向的值,然后让p指向的值自增</span></span><br><span class="line">*p++;  <span class="comment">// 先取p指向的值,然后让p自增</span></span><br><span class="line">++*p;  <span class="comment">// 先让p指向的值自增,然后取p指向的值</span></span><br><span class="line">++(*p);  <span class="comment">// 与第三条语句等价</span></span><br></pre></td></tr></table></figure>
<p>赋值运算符优先级极低，且赋值表达式的结果就是右值的结果</p>
<h3 id="数组">数组</h3>
<p>数组将多个相同类型的数据连在一起，方便进行访问和管理，许多数据类型的结构都可以由数组实现</p>
<h4 id="二维数组">二维数组</h4>
<p>初始化二维数组时，它的<strong>列</strong>不能为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一层循环遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M * N; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i / N][i % N]);</span><br></pre></td></tr></table></figure>
<h4 id="vla变长数组">VLA(变长数组)</h4>
<p><code>VLA</code>是一个概念，有许多种方法可以实现它，其中肯定需要用到的是<code>&lt;stdlib.h&gt;</code>里的<code>malloc()或calloc()和free()</code>函数(在C++中可用<code>new和delete</code>关键字)</p>
<p>引入指针后，<code>VLA</code>的实现便很容易理解了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* pa = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 接受一个参数:元素个数*单个元素空间</span></span><br><span class="line"><span class="type">int</span>* pa0 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 会进行初始化,效率比malloc低</span></span><br><span class="line"><span class="built_in">free</span>(pa); <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p><code>C</code>语言是一门面向过程的编程语言，函数对于它十分重要，它能把程序划分为多块，分别实现不同的功能</p>
<h4 id="接口与返回值">接口与返回值</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">function</span><span class="params">(paras)</span>&#123;statements&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子里，<code>paras</code>表示参数，它是进入这个函数的入口时由上一进程传入的数据，<code>type</code>规定了<code>function()</code>的返回值的类型，如果不显式声明则<strong>默认</strong>为<code>int</code></p>
<h4 id="形参">形参</h4>
<p>在函数中改变形参值无法改变上一进程中传进来的值，如要改变，可以传指针进行修改</p>
<h4 id="递归">递归</h4>
<p>递归很适合用于处理需要<strong>逆向</strong>思考的问题，例如一包数据的倒序存储等；但递归也容易造成<strong>栈溢出</strong>，递归的层级越大，风险便越大</p>
<p>涉及递归函数时，首先需要找到<strong>递归出口</strong>，即<strong>递归基础</strong>，每进行一次递归，数据应越来越靠近这一出口</p>
<p>其次是<strong>递归步骤</strong>，需要找到每次递归的数据间的联系与规律</p>
<h3 id="指针">指针</h3>
<p><code>C</code>语言的指针强大，灵活</p>
<h4 id="指针基本类型">指针基本类型</h4>
<table border="2">
<tr>
<td>
数据类型
</td>
<td>
名称
</td>
<td>
意义
</td>
</tr>
<tr>
<td>
type*
</td>
<td>
一级指针
</td>
<td>
指向一般数据类型的指针
</td>
</tr>
<tr>
<td>
type**
</td>
<td>
二级指针
</td>
<td>
指向指针的指针
</td>
</tr>
<tr>
<td>
type<a href="n">*</a>
</td>
<td>
数组指针(行指针)
</td>
<td>
指向数组的指针
</td>
</tr>
</table>
<h4 id="数组名的类型以及易混淆的声明">数组名的类型以及易混淆的声明</h4>
<p>数组名的类型很好记，只要知道该数组装载着的<strong>最高维数据的类型</strong>，就知道数组名的类型是<strong>指向这一类型的指针</strong></p>
<table border="2">
<tr>
<td>
声明方式
</td>
<td>
数据类型
</td>
<td>
意义
</td>
</tr>
<tr>
<td>
type a[n]
</td>
<td>
type*
</td>
<td>
本身是一个一维数组，a是指向一般数据的常量指针
</td>
</tr>
<tr>
<td>
type a[m][n]
</td>
<td>
type<a href="n">*</a>
</td>
<td>
本身是一个二维数组，a是指向含n个元素的数组的常量指针
</td>
</tr>
<tr>
<td>
type *a[n]
</td>
<td>
type**
</td>
<td>
本身是一个指针数组，a是指向指针的常量指针
</td>
</tr>
<tr>
<td>
type<a href="n">*a</a>t
</td>
<td>
type<a href="n">*</a>
</td>
<td>
指向一维数组的指针，a[i]是未定义的
</td>
</tr>
</table>
<h4 id="函数中的指针参数">函数中的指针参数</h4>
<h5 id="向函数传递指针">向函数传递指针</h5>
<p>地址或数组名向函数传递时，都会<strong>退化</strong>为指针，而且建立一个形参指针变量</p>
<p>函数内的<a
href="#形参">形参</a>指针拥有一般指针变量的性质：例如可以进行加减(就算传入数组名，也会新建一个形参指针)</p>
<h5 id="由函数返回地址">由函数返回地址</h5>
<p>返回形参或静态量的地址有意义</p>
<p>返回<strong>局部</strong>变量的地址无意义：局部变量离开函数时<strong>被销毁</strong>，故访问该地址没有意义</p>
<h4 id="关于赋值">关于赋值</h4>
<p>指针类型限定很<strong>严格</strong>，只能用<strong>相同类型</strong>的值赋值给指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//几个赋值的例子：</span></span><br><span class="line"><span class="type">int</span>* p; </span><br><span class="line"><span class="type">int</span>** pp;</span><br><span class="line"><span class="type">int</span> arr[n];</span><br><span class="line"><span class="type">int</span> arr2[m][n];</span><br><span class="line"><span class="type">int</span> *parr[n];</span><br><span class="line"><span class="type">int</span>(*pa)[n];</span><br><span class="line"></span><br><span class="line">p = arr; <span class="comment">// √</span></span><br><span class="line">pp = parr;    <span class="comment">// √</span></span><br><span class="line">pa = arr2; <span class="comment">// √</span></span><br><span class="line">pa[?] = ??? <span class="comment">// ×</span></span><br><span class="line"><span class="type">void</span> (*pfunc)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 声明函数指针</span></span><br><span class="line">(*pfunc)(a, b); <span class="comment">// 调用函数指针</span></span><br></pre></td></tr></table></figure>
<h3 id="位运算">位运算</h3>
<h2 id="汇编">汇编</h2>
<h3 id="介绍-2">介绍</h3>
<p>汇编即把汇编代码转换为机器语言(二进制机器码)的过程</p>
<p>可以用<code>gcc</code>生成一个汇编后的文件(后缀为.o)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c file.s -o file.o</span><br></pre></td></tr></table></figure>
<h3 id="汇编语言">汇编语言</h3>
<h4 id="介绍-3">介绍</h4>
<p>汇编语言(<code>assemble language,即asm</code>)<strong>面向机器</strong>，将许多长串的二进制码编写为一套<strong>短小精炼</strong>的命令语句，它帮助我们在寄存器、IO出口和存贮器间传递数据；将命令变为二进制码让机器听懂等。如果读者常使用IDA，则对汇编语言会有所了解</p>
<p>每一种处理器都有它们的一套汇编指令，它是软件开发者和机器直接进行交互的桥梁，对理解硬件之间的联系很有帮助</p>
<p>高级语言中提供的十六进制与八进制，正是因为汇编语言的数据会以2的幂来存储</p>
<h4 id="数据间的转换-1">数据间的转换</h4>
<p>二进制数据每进四个位对应的十六进制数将进一位，每进三个位对应的八进制数将进一位</p>
<p><span
class="math inline">2<sup><em>n</em></sup></span>进制数拥有的这种特性让计算变得规律易懂</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111-1011-1110-0101  ---&gt; 0xF-B-E-5</span><br><span class="line">0xBA93     ---&gt; 1011-1010-1001-0011</span><br></pre></td></tr></table></figure>
<h4 id="负数的表示二进制补码">负数的表示:二进制补码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-num == ~num + 1</span><br><span class="line"># 即先取反,再加1</span><br></pre></td></tr></table></figure>
<p>数据相减即让减数取反加1后进行加法运算，因为最后一位会因进位而丢失，所以可以正确表示两数相减</p>
<p>如果规定为无符号数据，则最后一位参加，最大值变为两倍(即<span
class="math inline">2<sup>8</sup></span>)，否则为<span
class="math inline"> − 2<sup>7</sup> ∼ 2<sup>7</sup> − 1</span></p>
<h4 id="数据寻址">数据寻址</h4>
<p>处理器一次可以访问多个字节的内存，它先从内存<strong>获取指令</strong>，然后<strong>解码</strong>，最后<strong>执行</strong>；存储数据时，从低位开始压入栈，即会将低位字节存储于低地址上；当它取出数据时，会从高位开始取，这就像先入后出的栈一样</p>
<p>通过这种方式，处理器搭建了一座<strong>内存和寄存器间</strong>的桥梁</p>
<h4 id="nasm">NASM</h4>
<p><code>NASM</code>全称<code>The Netwide Assembler</code>，可以在<code>Windows</code>和<code>Linux</code>下使用</p>
<p>我们在<code>Linux</code>环境下配置<code>NASM</code>，输入<code>sudo apt install nasm</code>即可</p>
<h4 id="汇编语法">汇编语法</h4>
<p>汇编分为三部分:<code>data, bss, text</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section.data</span><br><span class="line">section.bss</span><br><span class="line">section.text</span><br><span class="line"> global _start ;entre</span><br><span class="line">_start:</span><br><span class="line">;explain</span><br></pre></td></tr></table></figure>
<p><code>data</code>: 初始化数据或常量</p>
<p><code>bss</code>: 声明变量</p>
<p><code>text</code>:
保存实际代码，必须以<strong><code>global _start</code></strong>开头，它规定了执行的开始位置</p>
<p><code>;</code>: 注释，以英文<code>';'</code>开头</p>
<p>内存段分为数据段、代码段和堆栈段，数据段由<code>.data和.bss</code>表示、代码段由<code>.text</code>表示</p>
<h4 id="汇编语句">汇编语句</h4>
<p>汇编有三种类型的语句，且汇编语言<strong>不区分大小写</strong></p>
<ol type="1">
<li>可执行指令</li>
<li>汇编器指令(伪指令)</li>
<li>宏指令</li>
</ol>
<p>第一种语句告诉处理器要做什么，每一条语句汇编后都是一组二进制数，可<strong>被CPU执行</strong>；第二种语句不会变成机器语言，它们不可执行，但为汇编程序<strong>提供汇编信息</strong>(如数据和指令的区分，或数据的<strong>字长</strong>，或数据地址等)，<strong>辅助</strong>源程序的汇编；宏即一种文本替换机制，用于提高编程效率</p>
<p>每行只有一条语句，每条语句遵循下面的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[label]      mnemonic  [operands]   [;conment]</span><br><span class="line">[名字]           指令助记符  [操作数]    [注释]</span><br><span class="line">0~9,a~z,A~Z,_,?,@,$   实际可执行指令  数据或数据所在地址</span><br><span class="line">方括号内是可选项</span><br></pre></td></tr></table></figure>
<h4 id="数据项">数据项</h4>
<p><strong>常量</strong>：直接编码于指令中，不额外分配主存空间，也不存储在存贮器里</p>
<table border="2">
<tr>
<td>
进制
</td>
<td>
后缀
</td>
</tr>
<tr>
<td>
十进制
</td>
<td>
d/D(可省略)
</td>
</tr>
<tr>
<td>
十六进制
</td>
<td>
h/H,以A-F开头时需在最高位加0
</td>
</tr>
<tr>
<td>
二进制
</td>
<td>
b/B
</td>
</tr>
</table>
<p><strong>变量</strong>：保存在可读可写的主存空间，声明一个变量的指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name DB n dup(2,dup(4)) ;dup为复制操作符,它会将括号内数据复制n遍,例如本例n=2: 2,4,4,2,4,4</span><br><span class="line">name DW 20 dup(?)  ;?表示随机数,常用于预留存储空间</span><br><span class="line">name DW 22h,11h   ;从左到右压入堆栈,即地址22h低于11h</span><br><span class="line">;每个数据遵循小端存储,即高位数据存入高地址</span><br></pre></td></tr></table></figure>
<p>定义变量的伪指令如下图</p>
<table border="2">
<tr>
<td>
助记符
</td>
<td>
变量类型
</td>
<td>
所占位
</td>
</tr>
<tr>
<td>
byte(DB)
</td>
<td>
字节
</td>
<td>
8
</td>
</tr>
<tr>
<td>
word(DW)
</td>
<td>
字
</td>
<td>
16
</td>
</tr>
<tr>
<td>
dword(DD)
</td>
<td>
双字
</td>
<td>
32
</td>
</tr>
<tr>
<td>
qword(DQ)
</td>
<td>
四字
</td>
<td>
64
</td>
</tr>
<tr>
<td>
tword(DT)
</td>
<td>
十字
</td>
<td>
160
</td>
</tr>
</table>
<p><strong>表达式</strong>：</p>
<table border="2">
<tr>
<td>
运算符类型
</td>
<td>
运算符
</td>
</tr>
<tr>
<td rowspan="5" style="display:table-cell; vertical-align:middle">
算术运算符
</td>
<td>
+
</td>
</tr>
<tr>
<td>
-
</td>
</tr>
<tr>
<td>
*
</td>
</tr>
<tr>
<td>
/
</td>
</tr>
<tr>
<td>
mod
</td>
</tr>
<tr>
<td rowspan="4" style="display:table-cell; vertical-align:middle">
逻辑运算符(只能对数值进行的按位运算)
</td>
<td>
and
</td>
</tr>
<tr>
<td>
or
</td>
</tr>
<tr>
<td>
not
</td>
</tr>
<tr>
<td>
xor
</td>
</tr>
<tr>
<td rowspan="6" style="display:table-cell; vertical-align:middle">
关系运算符(只能对数值的操作)成立返回0FFFFh(-1),否则返回0000h
</td>
<td>
eq(=)
</td>
</tr>
<tr>
<td>
le(&lt;=)
</td>
</tr>
<tr>
<td>
ge(&gt;=)
</td>
</tr>
<tr>
<td>
lt(&lt;)
</td>
</tr>
<tr>
<td>
gt(&gt;)
</td>
</tr>
<tr>
<td>
ne(!=)
</td>
</tr>
<tr>
<td rowspan="5" style="display:table-cell; vertical-align:middle">
取值运算符
</td>
<td>
seg(获取段地址)
</td>
</tr>
<tr>
<td>
offset(获取段内偏移地址)
</td>
</tr>
<tr>
<td>
type(获取类型属性,返回该类型的值)
</td>
</tr>
<tr>
<td>
length(返回变量中元素个数)
</td>
</tr>
<tr>
<td>
size(返回所占数据区的字节总数)
</td>
</tr>
</table>
<h2 id="链接">链接</h2>
<h3 id="介绍-4">介绍</h3>
<p>之前提到预处理将展开库函数，事实上，这个过程导入的只有原型，真正的实现在链接库里</p>
<p>而链接即把机器码和其它文件，库文件，启动文件链接起来的过程，将会生成一个可执行文件</p>
<p>可以用<code>gcc</code>生成一个链接后的文件，已经到最后步骤了，需要做的事情很少</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc file.o -o file.out</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Programming</category>
        <category>C/Cpp</category>
      </categories>
      <tags>
        <tag>beginner</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown: 简单易学的笔记语言</title>
    <url>/blogs/2023/10/03/markdown-beginner/</url>
    <content><![CDATA[<!-- placeholder -->
<span id="more"></span>
<p><a id="HOME"></a></p>
<h1 id="markdown"><code>Markdown</code></h1>
<h2 id="md软件"><code>MD</code>软件</h2>
<ul>
<li><code>Typora</code>：<code>Typora</code>有“<strong>所见即所得</strong>”的特点，即你所看见的就是文件导出后的样子，付费</li>
<li><code>Obsidian</code>：<code>Obsidian</code>的插件市场丰富，且支持笔记之间的链接功能，个人版免费</li>
<li><code>VS Code</code>+<code>Markdown All in One</code>插件：左边编辑、右边预览，支持所见即所得，该插件提供了最基本的渲染以及快捷键配置，其它插件可查看<a
href="./1_VS%20Code.md"><code>Markdown</code>插件</a></li>
</ul>
<h2 id="常用记号">常用记号</h2>
<ul>
<li><p><code>'\'</code>：<strong>转义记号</strong>，类似<code>C</code>语言里的<code>'\n'</code>等，它可以将内嵌的命令转义</p></li>
<li><p><code>'#'</code>：<strong>标题记号</strong>，它可以将一行文字快捷地变为一级标题
格式为：# title，井号越多，标题等级越低
具有该功能的快捷键是<code>ctrl+$d</code>(<code>$d</code>表示标题等级)</p></li>
<li><p><code>'*'</code>或<code>'_'</code>：<strong>斜体记号</strong>，两个<code>*</code>组成一队，可以将中间的文本变为<em>斜体</em>
例如*abcd*的效果为：<em>abcd</em>
具有该功能的快捷键是<code>ctrl+I</code></p></li>
<li><p><code>'**'</code>或<code>'__'</code>：<strong>加粗记号</strong>，两组<code>**</code>组成一对，可以将中间的文本<strong>加粗</strong>，且可以和斜体记号一起使用
例如***abcd***的效果为：<strong><em>abcd</em></strong>
具有该功能的快捷键是<code>ctrl+B</code></p></li>
<li><p>‘`’(英文反引号)：<strong>行内代码记号</strong>，两个`组成一对，可以将中间的文本变为<code>代码字体</code>，注意代码块内的记号会失效，例如使用’\’将其转义时有时会产生混乱，<strong><code>行内代码可以加粗</code></strong>
例如`#include`的效果是：<code>#include</code>
具有该功能的快捷键是<code>shift+ctrl+</code>`</p></li>
<li><p><code>'```'</code>：<strong>代码块记号</strong>，三个反引号两组组成一对，可以在其中输入代码语言与相应代码等，例如：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>'$$'</code>：<strong>块级数学公式记号</strong>，两组<code>$$</code>组成一对，可以在其中用<code>LaTeX</code>语法写入数学公式。使用时只需键入’$$’后按下回车即可。例如：</p>
<p><span
class="math display"><em>a</em><sup><em>φ</em>(<em>x</em>)</sup>% <em>n</em> = 1 (<em>a</em><em>与</em><em>n</em><em>互</em><em>素</em>)</span></p>
<p>具体该如何写数学公式将在<a href="6_LaTeX.md">这里</a>讲述</p></li>
<li><p><code>'$'</code>：<strong>行内数学公式记号</strong>符，两个<code>$</code>组成一对，可以在其中用<code>LaTeX</code>语法写入数学公式。
例如：<span
class="math inline">$\begin{align}\int_0^{\Large\frac{\pi}{2}}f(\sin
x)dx=\int_0^{\Large\frac{\pi}{2}}f(\cos x)dx\end{align}$</span></p></li>
<li><p><code>'[]()'</code>：<strong>链接记号</strong>，在’[]‘内输入文本，在’()’内输入链接，这个链接可以是<strong>网址</strong>、<strong>本地文件</strong>或<strong>文章内锚点</strong>，文件支持使用相对路径或绝对路径，建议使用相对路径
例如：<a href="https://markdown.com.cn/basic-syntax/">Markdown</a>，<a
href="./markdown.md">aFile</a>，<a href="#HOME">aFlag</a>
<code>'crtl+左键'</code>点击可跳转至该链接
若链接中存在空格，建议使用<code>%20</code>代替
<code>()</code>最后允许包含用<code>""</code>或<code>()</code>或<code>''</code>包围的提示，鼠标悬停时会指出预设的文字</p></li>
<li><p><code>'[][]'</code>：引用表示的链接，由第二个<code>[]</code>作为中介传递链接，例如：</p>
<p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">文字</span>][<span class="symbol">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://markdown.com.cn/basic-syntax/ (悬停提示)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>'![]()'</code>：<strong>图像记号</strong>，与链接记号类似，但只能输入图片文件的路径，且会解析图片
例如：<img src="image_example.png%20(a)" />
图像与链接一样，支持引用表示与悬停提示</p></li>
<li><p><code>'[toc]'</code>：<strong>目录记号</strong>，可以用它生成自带锚点的目录，例如开头所示的索引</p></li>
<li><p><code>'---'</code>：<strong>分割线记号</strong>，可以用它生成一条直线，例如：</p>
<hr /></li>
</ul>
<h2 id="内嵌html">内嵌<code>HTML</code></h2>
<h3 id="表格">表格</h3>
<p><code>Typora</code>支持内嵌<code>HTML</code>，常见用法为写表格，例如：</p>
<table border="2">
<tr>
<td>
title
</td>
<td>
body
</td>
</tr>
<tr>
<td>
exp1
</td>
<td>
111
</td>
</tr>
<tr>
<td>
exp2
</td>
<td rowspan="4" style="display:table-cell; vertical-align:middle">
11
</td>
</tr>
<tr>
<td>
exp3
</td>
</tr>
</table>
<p>如图，使用<code>html</code>语法，写出一个四行两列的、边界值为2的、内容<code>'11'</code>被设置为占据四行且居中的表格</p>
<h3 id="图片">图片</h3>
通过<code>&lt;img /&gt;</code>标签可以定义并放缩图片：
<style>.tvqwvbtbltbr{zoom:33%;}</style>
<img src="/blogs/2023/10/03/markdown-beginner/image_example.png" class="tvqwvbtbltbr">
<p>图片可以缩放，即在前方的<code>html</code>标签内加上<code>style="zoom:num%"</code>，<code>num</code>为缩放比例</p>
<h3 id="链接">链接</h3>
<p><code>&lt;a id="111"&gt;&lt;/a&gt;</code>：这条元素定义了一个<code>id</code>为<code>'111'</code>的锚点，在文章内部可以通过<code>[点击](#111)</code>链接跳转到这个锚点，例如本文在目录处设定了一个<code>'HOME'</code>锚点，您可以<a
href="#HOME">点击我</a>来跳转
<code>&lt;a href="https://www.baidu.com"&gt;Baidu&lt;/a&gt;</code>：这条元素定义了一个链接为百度域名，显示内容为<code>'Baidu'</code>的链接，<a href="https://www.baidu.com">Baidu</a></p>
<h3 id="强制分页">强制分页</h3>
<p><code>&lt;div style="page-break-after: always;"&gt;&lt;/div&gt;</code>
在导出时，这条元素将强制新建一页</p>
<h3 id="透明字体及右对齐">透明字体及右对齐</h3>
<code>&lt;p style="color: rgba(400, 0, 400, 0.2)" align="right"&gt;ishiooo&lt;/p&gt;</code>
<code>style</code>属性中，前三个数字为<code>rgb</code>值，第四个数字为透明度
这条元素定义了一个透明度为0.2，内容为<code>'ishiooo'</code>，右对齐的段落：
<p style="color: rgba(400, 0, 400, 0.2)" align="right">
ishiooo
</p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Markup Languages</category>
      </categories>
      <tags>
        <tag>beginner</tag>
      </tags>
  </entry>
</search>
