<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=consolas:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ishi-o.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"github","dark":"github-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="Cpp: Effective Modern C++阅读笔记">
<meta property="og:url" content="https://ishi-o.github.io/2024/07/15/cpp-effective-moderncpp-reaction/index.html">
<meta property="og:site_name" content="Ishio">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-07-15T00:00:00.000Z">
<meta property="article:modified_time" content="2025-12-06T11:40:07.515Z">
<meta property="article:author" content="ishio">
<meta property="article:tag" content="reaction">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ishi-o.github.io/2024/07/15/cpp-effective-moderncpp-reaction/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://ishi-o.github.io/2024/07/15/cpp-effective-moderncpp-reaction/","path":"2024/07/15/cpp-effective-moderncpp-reaction/","title":"Cpp: Effective Modern C++阅读笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Cpp: Effective Modern C++阅读笔记 | Ishio</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.7.0/mermaid.min.js","integrity":"sha256-4+IKDqhZ/sXjc8Wtl2/MsxI4e0s1KpEVdbEP7V/Lz8U="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ishio</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#effective-modern-c"><span class="nav-number">1.</span> <span class="nav-text">Effective Modern C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">关于类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">成员函数的引用限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%AE%B9%E5%99%A8%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%9D%9E%E6%88%90%E5%91%98%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">对于容器优先使用常量迭代器和非成员迭代器函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%99%9A%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.4.</span> <span class="nav-text">构造函数、析构函数、虚函数、赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.</span> <span class="nav-text">优先考虑的关键字与场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8nullptr%E8%80%8C%E4%B8%8D%E6%98%AF0%E6%88%96null"><span class="nav-number">1.2.1.</span> <span class="nav-text">优先使用nullptr而不是0或NULL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8using%E8%80%8C%E4%B8%8D%E6%98%AFtypedef%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%91%BD%E5%90%8D"><span class="nav-number">1.2.2.</span> <span class="nav-text">优先使用using而不是typedef进行重命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91auto%E8%80%8C%E4%B8%8D%E6%98%AF%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">优先考虑auto而不是显式声明类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8delete%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%A7%81%E6%9C%89%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">优先使用delete而不是未定义的私有函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8noexcept%E5%8F%AA%E8%A6%81%E5%87%BD%E6%95%B0%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">1.2.5.</span> <span class="nav-text">优先使用noexcept只要函数不抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8constexpr"><span class="nav-number">1.2.6.</span> <span class="nav-text">尽可能使用constexpr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%BB%86%E5%88%99"><span class="nav-number">1.3.</span> <span class="nav-text">类型推导细则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.3.1.</span> <span class="nav-text">模板类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.3.2.</span> <span class="nav-text">auto类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype"><span class="nav-number">1.3.3.</span> <span class="nav-text">decltype</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ishio</p>
  <div class="site-description" itemprop="description">Just for fun!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">89</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ishi-o" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ishi-o" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
        <div class="sidebar-inner sidebar-post-related">
          <div class="animated">
              <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    Related Posts
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2025/03/06/java-oop/" rel="bookmark">
        <time class="popular-posts-time">2025-03-06</time>
        <br>
      Java: 面向对象编程
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2024/11/26/algo-trick-offline-query/" rel="bookmark">
        <time class="popular-posts-time">2024-11-26</time>
        <br>
      算法竞赛: 离线查询
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2025/07/11/java-bean-validation/" rel="bookmark">
        <time class="popular-posts-time">2025-07-11</time>
        <br>
      Java EE: Bean Validation
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2024/03/14/cpp-string/" rel="bookmark">
        <time class="popular-posts-time">2024-03-14</time>
        <br>
      Cpp STL: std::string
      </a>
    </li>
  </ul>

          </div>
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ishi-o.github.io/2024/07/15/cpp-effective-moderncpp-reaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ishio">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ishio">
      <meta itemprop="description" content="Just for fun!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Cpp: Effective Modern C++阅读笔记 | Ishio">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp: Effective Modern C++阅读笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-07-15T00:00:00+00:00">2024-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-06 11:40:07" itemprop="dateModified" datetime="2025-12-06T11:40:07+00:00">2025-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/C-Cpp/" itemprop="url" rel="index"><span itemprop="name">C/Cpp</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>19 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- placeholder -->
<span id="more"></span>
<h1 id="effective-modern-c"><code>Effective Modern C++</code></h1>
<h2 id="关于类">关于类</h2>
<h3 id="初始化">初始化</h3>
<p><code>C++</code>丰富的语法中提供了三种对象的初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>一般来说，对数组的初始化通常只用花括号，忽略等号</p>
<p>这样的初始化会带来对类类型的疑惑，这里复习一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class a = ClassObj;	<span class="comment">// 调用复制构造函数.</span></span><br><span class="line">a = ClassObj;		<span class="comment">// 调用重载赋值运算符.</span></span><br></pre></td></tr></table></figure>
<p><code>C++</code>通过花括号来实现统一初始化，只有花括号能在任何地点使用，既不会被看作函数声明，也可用在不可拷贝类上，你也可以自定义初始化列表构造函数，编译器会优先调用它而不是其它构造函数，只有在这种情况下，可以考虑使用圆括号调用其它构造函数，但如果需要自定义，一定需要三思，因为用户可能因这个自定义而疑惑</p>
<p>一种边缘情况是，在一个类既有默认<code>ctor</code>又有自定义初始化列表<code>ctor</code>的时候，传递空花括号时编译器会选择默认<code>ctor</code></p>
<p>使用花括号唯一的限制是不能对内部表达式进行变窄转换(而其它两种因向下兼容问题不会检查这种转换)</p>
<p>总而言之，无论是作为库开发者还是库使用者，应该注意是否含有初始化列表<code>ctor</code>，事实上<code>()</code>与<code>{}</code>各有优劣，但后者使用更广</p>
<h3 id="成员函数的引用限定符">成员函数的引用限定符</h3>
<p>在<code>C++11</code>中，增加了两种限制调用成员函数的情况，即调用左/右值的成员函数，与<code>const</code>一样，可以作为签名区分两个重名函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">// 这两个限定符要放在const后.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;	<span class="comment">// 左值限定符,只有左值能够调用它.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member</span><span class="params">()</span> <span class="type">const</span> &amp;&amp;</span>;	<span class="comment">// 右值限定符,只有右值能够调用它.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3
id="对于容器优先使用常量迭代器和非成员迭代器函数">对于容器优先使用常量迭代器和非成员迭代器函数</h3>
<p>优先考虑常量迭代器不难理解，优先使用非成员迭代器函数的原因是：</p>
<ul>
<li>原生<code>C</code>数组不能使用成员函数，可能还有更多情况</li>
<li>自由函数拥有更大的通用性，因为可以随时添加对某个特定容器的特例化版本，而不用对这个数据结构进行改动</li>
</ul>
<h3
id="构造函数析构函数虚函数赋值运算符">构造函数、析构函数、虚函数、赋值运算符</h3>
<ul>
<li><p>多态性决定了，可以通过用基类指针来使用子类方法，对于这种基类，应将析构函数声明为虚拟的；因为使用的是子类的数据，就应该使用子类的析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Son</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* Obj = <span class="keyword">new</span> Son;	<span class="comment">// 应该调用Son的析构函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不在构造、析构函数中使用虚函数，原因很简单，编译器会先构造父类，再构造子类，而一旦在构造父类对象时调用虚函数，那么就会调用一个尚未构造的子类对象的成员函数，这是危险的；析构函数同理，先析构子类对象再析构父类对象，在调用虚函数时子类对象早已销毁了</p></li>
<li><p>永不从析构函数中抛出异常，就算需要抛出异常，也应由析构函数捕获并终止程序</p></li>
<li><p>在实现使用堆内存类的赋值运算符重载时，需要考虑自我赋值的情况，一般不能先释放自身内存再拷贝右值资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  Class&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Class&amp; rhs) &#123;</span><br><span class="line">      <span class="comment">// delete data;	// 错误!万一rhs是自己呢?</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (rhs == <span class="keyword">this</span>) &#123;<span class="keyword">return</span> *<span class="keyword">this</span>; &#125;	<span class="comment">// 正确做法一:检查,但会使代码量增加.</span></span><br><span class="line">      </span><br><span class="line">      Class* tmp &#123;data&#125;;	<span class="comment">// 正确做法二:先记住原先data,不会增加代码,但有暂时空间开销.</span></span><br><span class="line">      data = <span class="keyword">new</span> <span class="built_in">type</span>(rhs.data);	<span class="comment">// 复制,这里已经创建新副本.</span></span><br><span class="line">      <span class="keyword">delete</span> tmp;		<span class="comment">// 删除原先data.</span></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 保证常成员函数的线程安全</span><br><span class="line"></span><br><span class="line">线程安全是指，需要在并发环境下，保证获取、改变资源的安全：</span><br><span class="line"></span><br><span class="line">- 一般来说，同时调用多个**只有读操作**的常成员函数不会造成线程安全问题</span><br><span class="line">- 当多线程同时工作时，如果含有写线程，则可能引起**数据竞争**，即有不同线程同时修改共享数据，这破坏了线程安全，例如：</span><br><span class="line">- 多窗口同时售票情景，需要保证已取走的共享资源不会被其它线程访问</span><br><span class="line">- `C+<span class="number">+11</span>`引入`<span class="keyword">mutable</span>`，它只能修饰成员变量，表示数据一直可变(**即使在`<span class="type">const</span>`成员函数中**)。例如，它可用于缓存已计算的值，这使得`<span class="type">const</span>`成员函数只需要计算第一次，而在之后都访问这个结果。由于它能在常成员函数中被改变，所以即使是`<span class="type">const</span>`成员函数，也引发了线程安全问题</span><br><span class="line"></span><br><span class="line">有以下几种方式保证线程安全：</span><br><span class="line"></span><br><span class="line">- 使用`std::mutex`，即互斥量：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">          <span class="function">lock_guard&lt;mutex&gt; <span class="title">lg</span><span class="params">(m)</span></span>;	<span class="comment">// 锁住互斥量m,使其它线程无法访问.</span></span><br><span class="line">          <span class="keyword">if</span> (!Value) &#123;	<span class="comment">// 如果没有记录.</span></span><br><span class="line">              Compute;	<span class="comment">// 计算并记录.</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Value;	<span class="comment">// 返回结果.</span></span><br><span class="line">      &#125;	<span class="comment">// 解锁m.</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">mutable</span> mutex m;	<span class="comment">// 由于lock_guard调用非常成员函数,所以要声明multable.</span></span><br><span class="line">      <span class="keyword">mutable</span> Type Value;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用互斥量开销较大，可使用<code>std::atomic</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">mutable</span> atomic&lt;<span class="type">unsigned</span>&gt; cnt;	<span class="comment">// 只是用于记录调用次数.</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">当然，如果能保证一个常成员函数不会发生在并发环境或者不会发生写操作，那么它的线程安全是无关紧要的</span><br><span class="line"></span><br><span class="line">### 为类型信息添加类型萃取类`type_traits`</span><br><span class="line"></span><br><span class="line">假设需要统一不同类的接口，而这些类的一些类型在实现上有区别，最好使用类型萃取来管理这些类型信息</span><br><span class="line"></span><br><span class="line">例如，`C++ STL`的迭代器类型就依靠这种技术：</span><br><span class="line"></span><br><span class="line">- 链表与数组的迭代器是不同的，前者是一个具体类，而后者只是原生指针</span><br><span class="line">- 使用部分模板特化，对类型信息进行萃取，并使算法端通过这个萃取类来访问迭代器</span><br><span class="line">- 萃取类尝试获取容器的迭代器类，如果没有，则返回原生指针</span><br><span class="line">- 这样就分开了算法与容器，使得算法不用考虑迭代器的实现，而总是获取到想要的迭代器</span><br><span class="line"></span><br><span class="line">使不同的类型包括自定义类、基础数据类型等有统一的类型名，实现统一的接口，这就是类型萃取的任务</span><br><span class="line"></span><br><span class="line">## 智能指针</span><br><span class="line"></span><br><span class="line">使用智能指针需要包含头文件`&lt;memory&gt;`</span><br><span class="line"></span><br><span class="line">### `std::unique_ptr`管理独占资源</span><br><span class="line"></span><br><span class="line">在以前的`C++`版本中，智能指针由`std::auto_ptr`担任，但`auto_ptr`是在`C+<span class="number">+11</span>`之后被废弃的，它有如下问题：</span><br><span class="line"></span><br><span class="line">- 智能指针是类，设计原意为拥有原生指针的功能，并且能避开原生指针的坑，例如使用的是栈空间还是堆空间？如果使用堆空间，那么它是单个对象还是数组(决定使用`<span class="keyword">delete</span>`还是`<span class="keyword">delete</span>[]`)？</span><br><span class="line">- 用拷贝方法来实现资源转移，但为了保证资源所有权唯一，**原本的副本会被赋值`<span class="literal">nullptr</span>`**，对于其它指向这块副本的智能指针来说是危险的；在语义上，给人<span class="string">&quot;拷贝&quot;</span>的错觉，但其实并非拷贝</span><br><span class="line">- 仍然需要手动`<span class="keyword">delete</span>`</span><br><span class="line"></span><br><span class="line">而`unique_ptr`拥有如下优势：</span><br><span class="line"></span><br><span class="line">- 用移动方法来实现资源转移，不允许拷贝，这在语义上是很清晰的</span><br><span class="line">- 与智能指针的初衷一样，每个`unique_ptr`拥有唯一的资源(除非它是`<span class="literal">nullptr</span>`)，每份资源对应唯一的`unique_ptr`，不会导致多次`<span class="keyword">delete</span>`</span><br><span class="line">- 非`<span class="literal">nullptr</span>`指针析构时自动释放指向的资源，能安全地`<span class="keyword">delete</span>`</span><br><span class="line"></span><br><span class="line">所以对于独占资源，最好使用`unique_ptr`来管理，如果使用原生指针，则很有可能因多次`<span class="keyword">delete</span>`而出错</span><br><span class="line"></span><br><span class="line">### `std::shared_ptr`管理共享资源</span><br><span class="line"></span><br><span class="line">通过`shared_ptr`，`C++`拥有一套自动垃圾回收，且可预测回收时机的系统。它使用的垃圾回收策略是**引用计数**，事实上很多语言并不使用这套策略，因为它有一些问题：</span><br><span class="line"></span><br><span class="line">- 只有在最后一个引用对象析构时，`shared_ptr`会`<span class="keyword">delete</span>`掉这部分资源，但对循环引用的资源无效</span><br><span class="line">- 性能上的问题：它需要同时维护一个引用计数，而且这个引用计数是动态分配的</span><br><span class="line">- 每个`shared_ptr`只对应一个控制块，即一份资源，但每个`shared_ptr`控制块互相不关联，这导致下面这个问题：</span><br><span class="line">  - 通过原始指针创建一个`shared_ptr`，将同时**创建一个控制块**，接下来正常应该只通过它来管理，但如果再次用**同一原始指针**创建新的`shared_ptr`，**尽管它们指向的内存相同**，它依旧会创建一个**新的控制块**，这将导致重复`<span class="keyword">delete</span>`</span><br><span class="line">- 用`shared_ptr`管理的资源应该在堆上，因为它总想使用`<span class="keyword">delete</span>`来释放这份资源</span><br><span class="line"></span><br><span class="line">尽量养成以下习惯：</span><br><span class="line"></span><br><span class="line">- 使用`make_shared`来创建控制块而不是传递一个原始指针，它保证在堆上创建新对象，而这个新对象肯定不会与其它控制块关联</span><br><span class="line">- 通过传递`shared_ptr`或`weak_ptr`来创建新引用，这样不会创建新的控制块</span><br><span class="line">- 由于有额外开销，尽量只在共享资源上使用它</span><br><span class="line">- 使用`weak_ptr`辅助可能悬空的`shared_ptr`</span><br><span class="line">  - ``weak_ptr`是`shared_ptr`的升级，当它悬空时，`expired`函数返回`<span class="number">1</span>`，但是，它无法解引用，通常来说，`weak_ptr`用于观测一份资源，或用在循环引用中打破循环的引用计数</span><br><span class="line">- 不混用智能指针和原始指针</span><br><span class="line"></span><br><span class="line">### 使用`make`函数而不是`<span class="keyword">new</span>`</span><br><span class="line"></span><br><span class="line">常用的`make`函数有`make_unique`(`C+<span class="number">+14</span>`)和`make_shared`(`C+<span class="number">+11</span>`)，这有以下好处：</span><br><span class="line"></span><br><span class="line">- 两种方式的区别：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">  <span class="keyword">auto</span> upObj&#123;std::<span class="built_in">make_unique</span>&lt;Class&gt;()&#125;;	<span class="comment">// 调用函数申请一份Class资源.</span></span><br><span class="line">  std::unique_ptr&lt;Class&gt; upObj &#123;<span class="keyword">new</span> Class&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>光是这样看似乎没有区别，但后者隐含了<strong>异常安全</strong>问题，因为在调用<code>new</code>和调用<code>unique_ptr</code>构造函数间有一层空隙，如果在这时出现异常，那么已<code>new</code>的资源无法被<code>unique_ptr</code>管理，造成<strong>内存泄漏</strong>；而前者安全性更高</p></li>
<li><p>但是，<code>make</code>函数不支持自定义删除器和花括号初始化，在这些情况下<code>make</code>函数不好用</p></li>
</ul>
<h2 id="优先考虑的关键字与场景">优先考虑的关键字与场景</h2>
<h3
id="优先使用nullptr而不是0或null">优先使用<code>nullptr</code>而不是<code>0</code>或<code>NULL</code></h3>
<ul>
<li><code>NULL</code>是<code>0LL</code>的宏定义，与<code>0</code>都被看作数值，只有在必须转换成指针时才会转换，这样的优先度使得当遇到重载的数值参数函数和指针参数函数时，调用<code>func(NULL)</code>可能不是你想要的</li>
<li><code>nullptr</code>增加了类型安全的保险，它只能隐式转换成任意的指针类型，编译器不会将它视为数值</li>
<li><code>nullptr</code>是向后兼容的，可以完美替换掉老代码中的<code>NULL</code></li>
<li><code>nullptr</code>可以直接使用，那么应该是某种类型的实例化，标准定义为<code>decltype(nullptr)=std::nullptr_t</code></li>
</ul>
<h3
id="优先使用using而不是typedef进行重命名">优先使用<code>using</code>而不是<code>typedef</code>进行重命名</h3>
<ul>
<li><p><code>typedef TypeName OtherName</code>与<code>using OtherName = TypeName</code>都是将<code>TypeName</code>重命名为<code>OtherName</code>，某些情况下<code>using</code>可读性更高，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*OtherName)</span><span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;	<span class="comment">// 将这个函数指针类型重命名为OtherName.</span></span><br><span class="line"><span class="keyword">using</span> OtherName = <span class="built_in">void</span> (*)<span class="built_in">func</span>(<span class="type">int</span>);<span class="comment">// 效果相同.</span></span><br></pre></td></tr></table></figure></li>
<li><p>在模板类型的重命名上，<code>using</code>更简洁实用，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">basic_List</span>&lt;T, Alloc&lt;T&gt;&gt; &#123;&#125;;</span><br><span class="line">  <span class="comment">// 为了让用户声明List&lt;T&gt;时就像声明basic_List&lt;T, Alloc&lt;T&gt;&gt;时一样.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	<span class="comment">// typedef是做不到的,最多只能嵌套在结构体内.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListType</span> &#123;</span><br><span class="line">      <span class="keyword">typedef</span> basic_List&lt;T, Alloc&lt;T&gt;&gt; type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 并且由于这个类依赖于T, 在其它模板类使用时需要在前面加typename让编译器将它视为类型.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">UseList</span> &#123;</span><br><span class="line">  	<span class="keyword">typename</span> ListType&lt;T&gt;::type _M_List;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 而using则简单很多.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">using</span> List = basic_List&lt;T, Alloc&lt;T&gt;&gt;;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">UseList</span> &#123;</span><br><span class="line">  	List&lt;T&gt; _M_List;	<span class="comment">// 正常使用,达成目的.</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">### 优先使用限域`<span class="keyword">enum</span>`而不是非限域</span><br><span class="line"></span><br><span class="line">非限域`<span class="keyword">enum</span>`指，一个枚举类型的所有内含名在这个`<span class="keyword">enum</span>`所在的作用域都不可再使用，如果没有限定在命名空间里或限域，这些内含名就会泄露到整个文件中</span><br><span class="line"></span><br><span class="line">限域指`C+<span class="number">+11</span>`的一个新特性：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ENUM</span> &#123; A, B, C &#125;;<span class="comment">// 在枚举类型前加class,将枚举名限定在花括号内,且总可以前置声明.</span></span><br><span class="line"><span class="keyword">auto</span> a = ENUM::A;	<span class="comment">// 通过枚举类型访问枚举名.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优先考虑auto而不是显式声明类型"><a
href="#auto">优先考虑<code>auto</code>而不是显式声明类型</a></h3>
<h3
id="优先使用delete而不是未定义的私有函数">优先使用<code>delete</code>而不是未定义的私有函数</h3>
<p>当不希望用户使用一个类的构造函数，而编译器又会偷偷提供时，以前的做法是在私有域内声明，且不定义它们，但这样会使友元或成员函数有潜在的使用风险，道理很简单，应该使用<code>delete</code>关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>delete</code>不止可用于成员函数，它能用于任何函数以处理隐式转换的弊端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">// 如果希望只接受int,而不是char,bool,double,就删除它们.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;	<span class="comment">// float会先转换成double,所以这条同时删除了float.</span></span><br></pre></td></tr></table></figure>
<p>它也能用于删除特化模板的实例化</p>
<h3
id="优先使用noexcept只要函数不抛出异常">优先使用<code>noexcept</code>只要函数不抛出异常</h3>
<p><code>C++11</code>引入的<code>noexcept</code>在以前是<code>throw()</code>，但拥有更多的优化灵活</p>
<p>对于一个绝对不会抛出异常的函数来说，可以在后面添加<code>noexcept</code>来承诺，允许编译器<strong>极尽所能优化</strong>生成的代码</p>
<p>而且，<code>noexcept</code>可视条件优化，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>;</span><br></pre></td></tr></table></figure>
<p>即只要提供不抛异常的<code>swap(*,*)</code>，那么<code>swap(&amp;,&amp;)</code>就是不抛异常的</p>
<p>使用<code>except</code>需要考虑改动，因为只要承诺了，就要考虑用户的使用，未来一旦改动，那么向下的代码都有可能出现问题，一般而言，<strong>移动、交换、内存释放</strong>等相关函数能靠<code>noexcept</code>得到相当大的优化</p>
<h3 id="尽可能使用constexpr">尽可能使用<code>constexpr</code></h3>
<p><code>constexpr</code>是<code>C++11</code>引入的关键字，从文字上来看，是<code>const</code>与<code>expr</code>的组合，即常量表达式：</p>
<ul>
<li>对于<code>constexpr</code>对象而言，与<code>const</code>对象不同的是它需要在编译期就决定，即编译期常量</li>
<li>对于<code>constexpr</code>函数而言，如果传递<code>constexpr</code>对象，函数会返回一个编译期常量，否则将在运行时计算；注意这不表示函数返回一个<code>const</code>值，而是”如果传递编译期常量参数，则返回值可作为编译期常量”</li>
<li>注意在<code>C++11</code>中，只能用<code>1</code>条<code>return</code>语句，而在<code>C++14</code>中限制减小了</li>
<li>注意<code>constexpr</code>与<code>const</code>、<code>noexcept</code>同为接口的一部分，如果未来可能修改，那么最好不要使用它们</li>
</ul>
<h2 id="类型推导细则">类型推导细则</h2>
<h3 id="模板类型推导">模板类型推导</h3>
<p>通常通过定义模板类或模板函数来减少代码量，使用模板所要求的是，每个使用过它的<code>.cpp</code>都能直接看见它的定义，即声明与定义应该放在同一份头文件内</p>
<p>因为不同参数类型的模板作为头文件在展开时需要实例化，而展开过程在预处理期，所以当声明与定义分开时，将因头文件找不到定义而展开失败，导致无法编译</p>
<p>而一般头文件的展开只是复制粘贴而已，不影响编译，那么整个过程就不会出错</p>
<p>放在一起时编译器会丢弃重复的实例化，最后随机保留一份；事实上<code>inline</code>、<code>module</code>等新特性正在致力于将所有定义放进头文件内或直接不使用头文件</p>
<p>通常来说，对于一个模板，编译器会对<code>T</code>与<code>ParamType</code>推导类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(ParamType Param)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>ParamType</code>可以有一些修饰符，但终究<code>ParamT</code>会被推导为非引用非指针类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; Param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里函数签名内的<code>T</code>会推导成模板参数<code>T</code>，这是最简单的情形：当传入的<code>ParamType</code>是一个指针或一个非通用引用时(只能作为左值或右值之一的引用)，<code>T</code>就会是非引用非指针类型</p>
<p>如果<code>ParamType</code>为通用引用(既可能是左值，也可能是右值)，在作为右值时当然与上述情况相符，但作为左值时，考虑以下模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; Param)</span></span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">func</span>(x);	<span class="comment">// 此时Param为左值,推导出不正常的T = int&amp;.</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>);	<span class="comment">// 此时Param为右值,推导出T为正常的T = int, ParamType为int&amp;&amp;.</span></span><br></pre></td></tr></table></figure>
<p>只有在引入了右值引用的<code>C++11</code>中才出现通用引用，在类型推导时会区分引用的左值与右值</p>
<h3 id="auto类型推导"><code>auto</code>类型推导<a id="auto"></a></h3>
<p>一般进行<code>auto</code>的情况有例如申请迭代器等场合，事实上除了推导花括号的初始化外，其它情况均与模板推导相同，而对于内部元素类型相同的花括号，<code>auto</code>能够成功推出它是一个初始化列表，以及它的模板参数</p>
<p><code>auto</code>声明变量一定要求初始化，这在很多情况下比不用<code>auto</code>要<strong>安全</strong>；除此之外，使用它也可以解决某些<strong>移植性问题</strong></p>
<p><code>auto</code>也可用于函数返回类型的自动推导，但单独使用<code>auto</code>推导返回类型比较少用，由于与模板推导是及其类似的，推出的类型大部分情况下是<strong>非引用非指针</strong>类型的，这在很多情况下会造成麻烦</p>
<p>使用<code>auto</code>时需注意一些特殊情况，例如隐藏的代理类调用：</p>
<p>例如对一个<code>vector</code>容器，它在实现<code>bool</code>时<strong>采取<code>1</code>位存储</strong>，由于<code>C++</code>不允许对位的引用，导致<code>vector&lt;bool&gt;</code>的<code>operator[]</code>只能返回一个代理类<code>vector&lt;bool&gt;::reference</code>对象来模仿引用的行为，这时使用<code>auto</code>推导出的对象是实实在在会改变容器的(而不像其它类型返回的是值)</p>
<p>在上述情况下，可以考虑使用显式类型转换器，这能保证既进行了初始化，又进行了类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> value = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(vec[<span class="number">0</span>]);	<span class="comment">// 结果为bool.</span></span><br><span class="line"><span class="keyword">auto</span> reference = vec[<span class="number">0</span>];	<span class="comment">// 结果为vector&lt;bool&gt;::reference.</span></span><br></pre></td></tr></table></figure>
<p>当然，一般的<code>bool</code>空间是八位，一个字节，可以用<code>bool&amp;</code></p>
<h3 id="decltype"><code>decltype</code></h3>
<p><code>decltype</code>是<code>C++11</code>新增的关键字，用于在编译期推导出表达式内的类型，并用这个类型作为后面变量的类型</p>
<p>它与<code>auto</code>强制要求初始化不同，它只是帮你推导出你提供的表达式最终的类型而已，而且它与模板类型推导规则是不同的，对非直接变量名进行<code>decltype</code>，通常<strong>返回它的引用</strong></p>
<p><code>decltype</code>通常与尾置返回类型相匹配使用，尾置返回类型这个<code>C++11</code>引入的新特性在声明复杂函数时有奇效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义返回一个一维数组类型的函数.</span></span><br><span class="line"><span class="built_in">int</span> (* <span class="built_in">func</span>(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n) )[<span class="number">3</span>];	<span class="comment">// 一般声明.</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[3]</span>;	<span class="comment">// 尾置返回类型声明.</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>auto</code>不代表让编译器自动推导类型，而是告诉编译器使用尾置类型</p>
<p>但当函数复杂度极高时，例如定义一个返回上述<code>func()</code>的指针的函数时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ptf</span><span class="params">()</span> -&gt; <span class="title">int</span> <span class="params">(*func(<span class="type">int</span>[][<span class="number">3</span>],<span class="type">int</span>))</span>[3]</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ptf</span><span class="params">()</span> -&gt; <span class="title">decltype</span><span class="params">(func)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这并没有快捷多少，所以<code>decltype</code>就派上用场了</p>
<p>还有一个场景，设想一个<code>operator[]</code>函数，我们需要它返回元素的引用：</p>
<ul>
<li><code>auto</code>会去除引用</li>
<li><code>decltype</code>将推导出引用类型</li>
</ul>
<p>那么组合起来，就像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> -&gt; <span class="title">decltype</span><span class="params">(arr[n])</span></span>;</span><br><span class="line"><span class="comment">// 或:</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>decltype(auto)</code>是指，让编译器自动推导类型，并且使用<code>decltype</code>的规则</p>
<p>将数组推广为容器，那么通常传的是它的引用，这意味着只能传左值引用，事实上，虽然传入临时对象返回它的元素的引用是未定义的，但极限情况是有用的，如果需要支持它，可以使用通用引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">func</span><span class="params">(Container&amp;&amp; c, Index i)</span></span>;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="sidebar-inner sidebar-post-related">
            <div class="animated">
                <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    Related Posts
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2025/03/06/java-oop/" rel="bookmark">
        <time class="popular-posts-time">2025-03-06</time>
        <br>
      Java: 面向对象编程
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2024/11/26/algo-trick-offline-query/" rel="bookmark">
        <time class="popular-posts-time">2024-11-26</time>
        <br>
      算法竞赛: 离线查询
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2025/07/11/java-bean-validation/" rel="bookmark">
        <time class="popular-posts-time">2025-07-11</time>
        <br>
      Java EE: Bean Validation
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2024/03/14/cpp-string/" rel="bookmark">
        <time class="popular-posts-time">2024-03-14</time>
        <br>
      Cpp STL: std::string
      </a>
    </li>
  </ul>

            </div>
          </div>

          <div class="post-tags">
              <a href="/tags/reaction/" rel="tag"># reaction</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/30/cpp-qt-database/" rel="prev" title="Qt: 数据库连接">
                  <i class="fa fa-angle-left"></i> Qt: 数据库连接
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/08/04/html-beginner/" rel="next" title="HTML: 基本语法">
                  HTML: 基本语法 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ishio</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">241k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">14:38</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script>
(function() {
    if (document.readyState !== 'loading') {
        initCategoryCollapse();
    } else {
        document.addEventListener('DOMContentLoaded', initCategoryCollapse);
    }

    function initCategoryCollapse() {
        var categoryItems = document.querySelectorAll('.category-all-page .category-list-item');
        
        categoryItems.forEach(function(item) {
            var childList = item.querySelector('.category-list-child');
            
            if (childList) {
                var titleLink = item.querySelector('.category-list-link');
                if (!titleLink) return;
                
                item.classList.add('has-child');
                
                var toggleIcon = document.createElement('span');
                toggleIcon.className = 'collapse-icon';
                toggleIcon.innerHTML = ' ▸';
                titleLink.parentNode.insertBefore(toggleIcon, titleLink.nextSibling);
                
                childList.style.display = 'none';
                item.classList.add('collapsed');
                
                titleLink.style.cursor = 'pointer';
                titleLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    item.classList.toggle('collapsed');
                    if (item.classList.contains('collapsed')) {
                        childList.style.display = 'none';
                        toggleIcon.innerHTML = ' ▸';
                    } else {
                        childList.style.display = 'block';
                        toggleIcon.innerHTML = ' ▾';
                    }
                });
                
                toggleIcon.style.cursor = 'pointer';
                toggleIcon.addEventListener('click', function(e) {
                    e.stopPropagation();
                    titleLink.click();
                });
            }
        });
    }
})();
</script>

</body>
</html>
